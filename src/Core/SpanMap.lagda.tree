\title{Maps between span diagrams}
\author{samueltoth}
\date{2025-11-21}
\taxon{Module}

\import{stt-macros}

%```agda
\agda{
{-#Â OPTIONS --allow-unsolved-metas #-}
module Core.SpanMap where

open import Foundations.Prelude
open import ufAxioms

open import Ergonomics.Marker

open import Core.Arrow
open import Core.ArrowEquiv
}
%```


\subtree[stt-008M]{
\date{2025-08-03}
\title{Maps of spans}
\taxon{Theorem}

\p{A map between spans #{S} and #{S'} is a diagram as follows where
all the squares commute:}

\quiver{
\begin{tikzcd}
	A && S && B \\
	\\
	{A'} && {S'} && {B'}
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=1-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=3-5]
	\arrow[from=3-3, to=3-1]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}


%```agda
\agda{
record Span-map {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                {ğ“¤' ğ“¥' ğ“¦'} (S' : Span ğ“¤' ğ“¥' ğ“¦')
                : Type (ğ“¤ âŠ” ğ“¤' âŠ” ğ“¥ âŠ” ğ“¥' âŠ” ğ“¦ âŠ” ğ“¦') where
   constructor mk-span-map
   module S = Span S
   module S' = Span S'
   field
     hâ‚ : S.Left â†’ S'.Left
     hâ‚‚ : S.Centre â†’ S'.Centre
     hâ‚ƒ : S.Right â†’ S'.Right
     H  : hâ‚ âˆ˜ S.left ~ S'.left âˆ˜ hâ‚‚
     K  : hâ‚ƒ âˆ˜ S.right ~ S'.right âˆ˜ hâ‚‚

   amap-lâ†“ : Arrow-map S.left S'.left
   amap-lâ†“ = mk-amap hâ‚‚ hâ‚ H

   amap-l : Arrow-map hâ‚‚ hâ‚
   amap-l = mk-amap S.left S'.left (H ~â»Â¹)

   amap-râ†“ : Arrow-map S.right S'.right
   amap-râ†“ = mk-amap hâ‚‚ hâ‚ƒ K

   amap-r : Arrow-map hâ‚‚ hâ‚ƒ
   amap-r = mk-amap S.right S'.right (K ~â»Â¹)
}
%```

\p{Equivalently, a span map is a pair of arrow maps between the
left and right maps of each span, together with a homotopy between
the two maps between the centre of the spans.}

%```agda
\agda{
Arrow-mapsâ†Span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S'
    â†’ let module S = Span S ; module S' = Span S'
    in Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top)
Arrow-mapsâ†Span-map S = (amap-lâ†“ , amap-râ†“ , ~refl) where open Span-map S

Span-mapâ†Arrow-maps
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S ; module S' = Span S'
    in Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top)
    â†’ Span-map S S'
Span-mapâ†Arrow-maps (F , G , H)
  = funext-rec (Î» _ â†’ Span-map _ _) (Î» where
      refl â†’ mk-span-map F.bot G.top G.bot F.comm G.comm) H where
  module F = Arrow-map F
  module G = Arrow-map G

Span-mapâ‰ƒArrow-maps
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S ; module S' = Span S'
    in (Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top))
    â‰ƒ Span-map S S'
Span-mapâ‰ƒArrow-maps = mkâ‰ƒ Span-mapâ†Arrow-maps (is-equivâ†qiso qiso) where
  qiso : quasi-iso Span-mapâ†Arrow-maps
  qiso .fst = Arrow-mapsâ†Span-map
  qiso .snd .fst x@(F , G , HH)
    = funext-rec
        (Î» HH'
          â†’ Arrow-mapsâ†Span-mapÂ (Span-mapâ†Arrow-maps (F , G , HH')) ï¼ (F , G , HH'))
        lem
        HH where
    open Span-map
    lem : (p : (Arrow-map.top F) ï¼ (Arrow-map.top G)) â†’
           Arrow-mapsâ†Span-map (Span-mapâ†Arrow-maps (F , G , happly p)) ï¼
           (F , G , happly p)
    lem refl =
      (Arrow-mapsâ†Span-map âˆ˜ Span-mapâ†Arrow-maps) (F , G , ~refl) ï¼âŸ¨âŸ©
      (mk-amap (Arrow-map.top G) _ _
      , mk-amap (Arrow-map.top G) (Arrow-map.bot G) (Arrow-map.comm G)
      , ~refl) ï¼âŸ¨âŸ©
      (F , G , ~refl) âˆ where open Span-map
  qiso .snd .snd = ~refl

span-map-pathPâ†’
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {S'' : Span ğ“¤' ğ“¥' ğ“¦'}
      {f : Span-map S' S} {g : Span-map S'' S}
    â†’ let module S = Span S
          module S' = Span S'
          module S'' = Span S''
          module f = Span-map f
          module g = Span-map g
    in (p : S'.Centre ï¼ S''.Centre)
    â†’ (q : S'.Left ï¼ S''.Left)
    â†’ (r : S'.Right ï¼ S''.Right)
    â†’ (h : coe r âˆ˜ S'.right ï¼ S''.right âˆ˜ coe p)
    â†’ (k : coe q âˆ˜ S'.left ï¼ S''.left âˆ˜ coe p)
    â†’ (Q : f.hâ‚ ï¼ g.hâ‚ âˆ˜ coe q)
    â†’ (P : f.hâ‚‚ ï¼ g.hâ‚‚ âˆ˜ coe p)
    â†’ (R : f.hâ‚ƒ ï¼ g.hâ‚ƒ âˆ˜ coe r)
    â†’ (H : f.H ï¼   (happly Q â–¸ S'.left) ~âˆ™ (g.hâ‚ â—‚ happly k)
                  ~âˆ™ (g.H â–¸ coe p) ~âˆ™ (S.left â—‚ happly (sym P)))
    â†’ (K : f.K ï¼ (happly R â–¸ S'.right) ~âˆ™ (g.hâ‚ƒ â—‚ happly h)
                 ~âˆ™ (g.K â–¸ coe p) ~âˆ™ S.right â—‚ (happly (sym P)))
    â†’ IdP (ap (Î» P â†’ Span-map P S) (Span-pathâ†’ p q r h k)) f g
span-map-pathPâ†’ refl refl refl refl refl refl refl refl refl refl
  = apâ‚‚ (Î» P Q â†’ mk-span-map _ _ _ P Q)
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))



is-Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S' â†’ Type (ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦' âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
is-Span-equiv F = is-equiv hâ‚
                    Ã— is-equiv hâ‚‚
                    Ã— is-equiv hâ‚ƒ where
  open Span-map F

l-is-arrow-equivâ†is-span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ is-Arrow-equiv (Span-map.amap-lâ†“ F)
l-is-arrow-equivâ†is-span-equiv F eq
  = (eq .snd .fst , eq .fst)

r-is-arrow-equivâ†is-span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ is-Arrow-equiv (Span-map.amap-râ†“ F)
r-is-arrow-equivâ†is-span-equiv F eq
  = (eq .snd .fst , eq .snd .snd)

Spanâ»Â¹â†Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ Span-map S' S
Spanâ»Â¹â†Span-equiv F (e1 , e2 , e3)
  = mk-span-map Fâ‚.bwd Fâ‚‚.bwd Fâ‚ƒ.bwd H1 H2 module Span-inv where
  module F = Span-map F
  module S = F.S
  module S' = F.S'
  module Fâ‚ = is-equiv e1
  module Fâ‚‚ = is-equiv e2
  module Fâ‚ƒ = is-equiv e3


  K1 : F.hâ‚ âˆ˜ Fâ‚.bwd âˆ˜ S'.left âˆ˜ F.hâ‚‚ ~ F.hâ‚ âˆ˜ S.left âˆ˜ Fâ‚‚.bwd âˆ˜ F.hâ‚‚
  K1 = (Fâ‚.Îµ â–¸ S'.left â–¸ F.hâ‚‚ ~âˆ™ (F.H ~â»Â¹) ~âˆ™ (F.hâ‚ â—‚ (S.left â—‚ Fâ‚‚.Î·) ~â»Â¹))

  H1 : Fâ‚.bwd âˆ˜ S'.left ~ S.left âˆ˜ Fâ‚‚.bwd
  H1 = e1 â—‚eqv K1 â–¸eqv e2

  K2 : F.hâ‚ƒ âˆ˜ Fâ‚ƒ.bwd âˆ˜ S'.right âˆ˜ F.hâ‚‚ ~ F.hâ‚ƒ âˆ˜ S.right âˆ˜ Fâ‚‚.bwd âˆ˜ F.hâ‚‚
  K2 = (Fâ‚ƒ.Îµ â–¸ S'.right â–¸ F.hâ‚‚) ~âˆ™ (F.K ~â»Â¹) ~âˆ™ (F.hâ‚ƒ â—‚ (S.right â—‚ Fâ‚‚.Î·) ~â»Â¹)

  H2 : Fâ‚ƒ.bwd âˆ˜ S'.right ~ S.right âˆ˜ Fâ‚‚.bwd
  H2 = e3 â—‚eqv K2 â–¸eqv e2

}
%```
}

\subtree[stt-00AJ]{
\title{Span map composition}
\taxon{Construction}
\date{2025-11-21}

%```agda
\agda{
compose-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' ğ“¤'' ğ“¥'' ğ“¦''}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'} {S'' : Span ğ“¤'' ğ“¥'' ğ“¦''}
    â†’ Span-map S' S'' â†’ Span-map S S'
    â†’ Span-map S S''
compose-span-map F G = map where
  module F = Span-map F
  module G = Span-map G

  map : Span-map _ _
  map .Span-map.hâ‚ = F.hâ‚ âˆ˜ G.hâ‚
  map .Span-map.hâ‚‚ = F.hâ‚‚ âˆ˜ G.hâ‚‚
  map .Span-map.hâ‚ƒ = F.hâ‚ƒ âˆ˜ G.hâ‚ƒ
  map .Span-map.H = (F.hâ‚ â—‚ G.H) ~âˆ™ (F.H â–¸ G.hâ‚‚)
  map .Span-map.K = F.hâ‚ƒ â—‚ G.K ~âˆ™ F.K â–¸ G.hâ‚‚

id-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
  â†’ Span-map S S
id-span-map = mk-span-map id id id ~refl ~refl
}
%```
}


\subtree[stt-00AL]{
\title{Homotopy of span maps}
\taxon{Definition}

%```agda
\agda{
Span-map-homotopy
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F G : Span-map S S') â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
Span-map-homotopy F G
  = Î£[ Hâ‚ âˆ¶ F.hâ‚ ~ G.hâ‚ ] Î£[ Hâ‚‚ âˆ¶ F.hâ‚‚ ~ G.hâ‚‚ ] Î£[ Hâ‚ƒ âˆ¶ F.hâ‚ƒ ~ G.hâ‚ƒ ]
       ( F.H ~ Hâ‚ â–¸ F.S.left ~âˆ™ G.H ~âˆ™ F.S'.left â—‚ (Hâ‚‚ ~â»Â¹)
       Ã—  F.K ~ Hâ‚ƒ â–¸ F.S.right ~âˆ™ G.K ~âˆ™ F.S'.right â—‚ (Hâ‚‚ ~â»Â¹)) where
  module F = Span-map F
  module G = Span-map G


Span-map-funextâ†’
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {F G : Span-map S S'} â†’ Span-map-homotopy F G â†’ F ï¼ G
Span-map-funextâ†’ {S = S} {S'} {F} {G} (p , q , r , s , t)
  = span-map-pathPâ†’ refl refl refl refl refl
     (funextâ†’ p) (funextâ†’ q) (funextâ†’ r)
     (funextâ†’ (Î» a â†’ s a âˆ™ ap ((p (S.left a) âˆ™_) âˆ˜ (G.H a âˆ™_))
                  (ap (ap G.S'.left) (sym (happly (happly-sym (funextâ†’ q) a) a)))))
     (funextâ†’ (Î» a â†’ t a âˆ™ ap ((r (S.right a) âˆ™_) âˆ˜ (G.K a âˆ™_))
                  (ap (ap S'.right) (sym (happly (happly-sym (funextâ†’ q) a) a))))) where
   module S = Span S
   module S' = Span S'
   module G = Span-map G

}
%```
}

\subtree[stt-00AM]{
\title{Equivalences of spans}
\taxon{definition}

%```agda
\agda{

Span-equiv-ret
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
  â†’ (F : Span-map S S') (Fe : is-Span-equiv F)
  â†’ Span-map-homotopy id-span-map
                      (compose-span-map (Spanâ»Â¹â†Span-equiv F Fe) F)
Span-equiv-ret {S = S} F Fe@(e1 , e2 , e3) = hom where
  module Fâ‚ = is-equiv e1
  module Fâ‚‚ = is-equiv e2
  module Fâ‚ƒ = is-equiv e3
  module F = Span-map F
  Fâ»Â¹ = Spanâ»Â¹â†Span-equiv F Fe
  module Fâ»Â¹ = Span-map Fâ»Â¹

  opaque
    unfolding Arrowâ»Â¹.H

    HH : (Fâ‚.Î· ~â»Â¹) â–¸ Span.left S ~âˆ™
         Span-map.H (compose-span-map (Spanâ»Â¹â†Span-equiv F Fe) F) ~âˆ™
         Span.left S â—‚ ((Fâ‚‚.Î· ~â»Â¹) ~â»Â¹)
         ~ ~refl
    HH = ((Fâ‚.Î· ~â»Â¹) â–¸ Span.left S ~âˆ™
         Span-map.H (compose-span-map (Spanâ»Â¹â†Span-equiv F Fe) F) ~âˆ™
         Span.left S â—‚ ((Fâ‚‚.Î· ~â»Â¹) ~â»Â¹)) ~âŸ¨âŸ©

         ((Fâ‚.Î· ~â»Â¹) â–¸ Span.left S ~âˆ™
         ((Fâ»Â¹.hâ‚ â—‚ F.H) ~âˆ™ (Fâ»Â¹.H â–¸ F.hâ‚‚)) ~âˆ™
         Span.left S â—‚ ((Fâ‚‚.Î· ~â»Â¹) ~â»Â¹)) ~âŸ¨âŸ©

         ((Fâ‚.Î· ~â»Â¹) â–¸ Span.left S ~âˆ™
         ((Fâ»Â¹.hâ‚ â—‚ F.H) ~âˆ™ ((e1 â—‚eqv Span-inv.K1 F e1 e2 e3 â–¸eqv e2) â–¸ F.hâ‚‚)) ~âˆ™
         Span.left S â—‚ ((Fâ‚‚.Î· ~â»Â¹) ~â»Â¹)) ~âŸ¨ {!!} âŸ©

         {!!} ~âˆ

    hom : Span-map-homotopy
           id-span-map
           (compose-span-map (Spanâ»Â¹â†Span-equiv F Fe) F)
    hom =
       Fâ‚.Î· ~â»Â¹
     , Fâ‚‚.Î· ~â»Â¹
     , Fâ‚ƒ.Î· ~â»Â¹
     , HH ~â»Â¹
     , {!KK!}


Span-equiv-sec
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
  â†’ (F : Span-map S S') (Fe : is-Span-equiv F)
  â†’ Span-map-homotopy (compose-span-map F (Spanâ»Â¹â†Span-equiv F Fe))
                       id-span-map
Span-equiv-sec = {!!}
}
%```
}
