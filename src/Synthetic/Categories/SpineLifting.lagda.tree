\title{Spine lifting}
\taxon{Module}
\date{2026-01-24}
\author{samueltoth}

\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.SpineLifting
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Algebra.Lattice.Instances.Free.Inductive Î”Â¹ I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Separated
open import Modalities.Instances.Truncation

open import Data.Bool

open import Core.CanonicalPushouts
open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.CosliceOrthogonality
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.PushoutProduct
open import Core.CoSlice
open import Core.Slice
open import Core.Cube
open import Core.ArrowEquiv
open import Core.ArrowRetract
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.WedgeSum

open import Ergonomics.Notations.Orthogonality
open Core.Orthogonal.notation
open import Ergonomics.Extensionality
open import Ergonomics.Representation
open import Ergonomics.Auto

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
}
%```


\subtree[tot-0000]{
\title{Bi-pointed wedge sum}
\taxon{Definition}

\p{We extend the definition of [Wedge sum](tot-0009) to the case of maps out of
the boundary of #{\Delta^1}. Given a type #{A}, equipped with
maps from #{\partial \Delta^1}, we call the source and target points #{A_s} and
#{A_t} repetitively. Given a pair of such types #{A} and #{B}, we say that their
wedge sum is the wedge sum #{A_t \vee B_s}, glueing the target of the first to
the source of the second. This is itself a bi-pointed type with src #{A_s} and
target #{B_t}.}

\p{We also remark that #{-\vee-} determines a bifunctor
##{\Type_{\partial\Delta^1 /} \times \Type_{\partial \Delta^1 /}
\to \Type_{\partial \Delta^1 /}}
}

%```agda
\agda{
âˆ‚Î”Â¹-Wedge : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
              (a : Î´Î”Â¹ â†’ A) (b : Î´Î”Â¹ â†’ B)
            â†’ Î£[ X âˆ¶ Type (ğ“¤ âŠ” ğ“¥) ] (Î´Î”Â¹ â†’ X)
âˆ‚Î”Â¹-Wedge {A = A} {B} a b .fst = Pushout {A = ğŸ™} (Î» _ â†’ a Î´Î”Â¹-1) (Î» _ â†’ b Î´Î”Â¹-0)
âˆ‚Î”Â¹-Wedge {A = A} {B} a b .snd = Î´Î”Â¹-UPâ†’ (Î¹â‚ (a Î´Î”Â¹-0) , Î¹â‚‚ (b Î´Î”Â¹-1))

âˆ‚Î”Â¹-Wedge-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {A' : Type ğ“¦} {B' : Type ğ“œ}
      (a : Î´Î”Â¹ â†’ A) (b : Î´Î”Â¹ â†’ B) (a' : Î´Î”Â¹ â†’ A') (b' : Î´Î”Â¹ â†’ B')
    â†’ Coslice-map a a' â†’ Coslice-map b b'
    â†’ Coslice-map (âˆ‚Î”Â¹-Wedge a b .snd) (âˆ‚Î”Â¹-Wedge a' b' .snd)
âˆ‚Î”Â¹-Wedge-map a b a' b' F G .fst
  = Pushoutâ‚
      (mk-span-map
        (F .fst) id (G .fst)
        (Î» _ â†’ F .snd Î´Î”Â¹-1)
        (Î» _ â†’ G .snd Î´Î”Â¹-0))
âˆ‚Î”Â¹-Wedge-map a b a' b' F G .snd (mk-lift true)
  = ap Î¹â‚‚ (G .snd Î´Î”Â¹-1)
âˆ‚Î”Â¹-Wedge-map a b a' b' F G .snd (mk-lift false)
  = ap Î¹â‚ (F .snd Î´Î”Â¹-0)
}
%```

\p{Finally, we remark that this functor preserves inner anodyne maps.}

%```agda
\agda{
wedge-map-is-inner-anodyne
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {A' : Type ğ“¦} {B' : Type ğ“œ}
      (a : Î´Î”Â¹ â†’ A) (b : Î´Î”Â¹ â†’ B) (a' : Î´Î”Â¹ â†’ A') (b' : Î´Î”Â¹ â†’ B')
      (F : Coslice-map a a') (G : Coslice-map b b')
    â†’ is-inner-anodyne (F .fst) â†’ is-inner-anodyne (G .fst)
    â†’ is-inner-anodyne (âˆ‚Î”Â¹-Wedge-map _ _ _ _ F G .fst)
wedge-map-is-inner-anodyne a b a' b' F G fia gia {U = U} {V} k ik
  = left-orthogonal-pushoutâ‚
      (extend-coslice-map _ _ (const _ _ Î´Î”Â¹-1) F )
      (extend-coslice-map _ _ (const _ _ Î´Î”Â¹-0) G)
      k
      (fia  k ik)
      (gia k ik)
}
%```
}

\subtree[tot-0004]{
\title{Spines}
\taxon{Definition}

\p{We construct the #{n}-spine, written #{\II_n}, as the result of gluing
#{n} copies of the interval end-to-end. By convention, #{\II_0} is the unit type,
and #{\II_1} is #{\Delta^1}. We also remark that the 2-spine #{\II_2} is
definitionally equal to the bespoke definition we already gave in the form
of the [inner horn](stt-00AD).}

%```agda
\agda{
Spine-coslice : â„• â†’ Î£[ X âˆ¶ Type ğ“˜ ] (Î´Î”Â¹ â†’ X)
Spine-coslice zero = (ULift ğ“˜ ğŸ™ , mk-lift âˆ˜ !)
Spine-coslice (suc zero) = (Î”Â¹ , Î´Î”Â¹-incl)
Spine-coslice (suc (suc n)) = âˆ‚Î”Â¹-Wedge (Spine-coslice (suc n) .snd) Î´Î”Â¹-incl

Spine : â„• â†’ Type ğ“˜
Spine = fst âˆ˜ Spine-coslice

spine-agrees-[2,1]-horn : Spine-coslice 2 .snd ~ Î´Î›[2,1]-incl
spine-agrees-[2,1]-horn = Î´Î”Â¹-UPâ†’ (refl , refl)
}
%```

\p{We show that there is an inclusion of the spine into the #{n}-cube, and
that this inclusion factors through #{\Delta^n}}

%```agda
\agda{
Spine-is-set : âˆ€ {n} â†’ is-truncated 2 (Spine n)
Spine-is-set {zero} = trunc!
Spine-is-set {suc zero} = trunc!
Spine-is-set {suc (suc n)} = Wedge-is-set (Spine-is-set {suc n}) trunc!

Spine-incl-â–¡ : âˆ€ {n} â†’ Spine n â†’ â–¡^ n
Spine-incl-â–¡ {zero} = id
Spine-incl-â–¡ {suc zero} = id
Spine-incl-â–¡ {suc (suc n)} = (Spine-incl-â–¡ âŠ—1 Î”Â¹) âˆ˜ Wedge-embed

Spine-incl : âˆ€ {n} â†’ Spine n â†’ Î”^ n
Spine-top : âˆ€ {n} â†’ Î”-path (Spine-incl (Spine-coslice n .snd Î´Î”Â¹-1)) (Î”-1 {n})

Spine-incl {zero} s = Â·
Spine-incl {suc zero} i = (Â· :â‰¥: i)
Spine-incl {suc (suc n)} = cogap
  (mk-cocone
    (Î» s â†’ Spine-incl s :â‰¥: i0)
    (Î» i â†’ Î”-1 :â‰¥: i)
    Î» _ â†’ Î”-ext (Spine-top :â‰¥: refl))

Spine-top {zero} = Â·
Spine-top {suc zero} = Â· :â‰¥: refl
Spine-top {suc (suc n)} = Î”-refl :â‰¥: refl :â‰¥: refl

Spine-bot : âˆ€ {n} â†’ Î”-path (Spine-incl (Spine-coslice n .snd Î´Î”Â¹-0)) (Î”-0 {n})
Spine-bot {zero} = Â·
Spine-bot {suc zero} = Â· :â‰¥: refl
Spine-bot {suc (suc zero)} = Â· :â‰¥: refl :â‰¥: refl
Spine-bot {suc (suc (suc n))} = Spine-bot :â‰¥: refl :â‰¥: refl

âˆ‚Î”^_ : âˆ€ n â†’ Î´Î”Â¹ â†’ Î”^ n
(âˆ‚Î”^ n) (mk-lift true) = Î”-1
(âˆ‚Î”^ n) (mk-lift false) = Î”-0

âˆ‚Î”Â¹-Spine-incl : âˆ€ n â†’ Coslice-map (Spine-coslice n .snd) (âˆ‚Î”^ n)
âˆ‚Î”Â¹-Spine-incl n .fst = Spine-incl
âˆ‚Î”Â¹-Spine-incl n .snd (mk-lift true ) = Î”-ext Spine-top
âˆ‚Î”Â¹-Spine-incl n .snd (mk-lift false) = Î”-ext Spine-bot

â–¡â†Î” : âˆ€ {n} â†’ Î”^ n â†’ â–¡^ n
â–¡â†Î” Â· = _
â–¡â†Î” (Â· :â‰¥: j) = j
â–¡â†Î” (x :â‰¥: i :â‰¥: j) = â–¡â†Î” (x :â‰¥: i) , j
}
%```
}


\subtree[tot-0005]{
\taxon{Lemma}
\p{#{\Delta^{n + 2}} is a retract of #{\square^n \times \Delta^2}}

\p{We extend the obvious embedding #{\Delta^n \to \square^n}, to the map that
just forgets the first #{n} inequalities and preserves the latter two. The
retraction is defined as follows:
##{(\bar{i}, j \geq k) : \square^n \times \Delta^2 \mapsto
((\bigvee_{n} i_n \vee j) â‰¥ ... \ge (i_n \vee j) \ge j \ge k)}
It is a retraction since if #{i_n} were ordered in the first place, then taking
these successive joins would have no effect.
}

%```agda
\agda{
mutual
  Î”â†â–¡ : âˆ€ {n} â†’ â–¡^ n â†’ Î”Â¹ â†’ Î”^ n
  Î”â†â–¡-â‰¤ : âˆ€ {n} (x : â–¡^ n) i â†’ i â‰¤ last-Î” (Î”â†â–¡ x i)

  Î”â†â–¡ {zero} x j = Â·
  Î”â†â–¡ {suc zero} x j = Â· :â‰¥: x âˆ¨ j
  Î”â†â–¡ {suc (suc n)} (x , i) j = (Î”â†â–¡ x (i âˆ¨ j) :â‰¥: i âˆ¨ j) â¦ƒ Î”â†â–¡-â‰¤ x (i âˆ¨ j) â¦„

  Î”â†â–¡-â‰¤ {zero} x i = auto!
  Î”â†â–¡-â‰¤ {suc zero} x i = âˆ¨-â‰¤-intror auto!
  Î”â†â–¡-â‰¤ {suc (suc n)} x i = âˆ¨-â‰¤-intror auto!

Î”â†â–¡-1 : âˆ€ {n} (x : â–¡^ n) {i} â†’ (i ï¼ i1) â†’ Î”-path (Î”â†â–¡ x i) Î”-1
Î”â†â–¡-1 {zero} x _ = Â·
Î”â†â–¡-1 {suc zero} x refl = Â· :â‰¥: (â‰¤-max auto!)
Î”â†â–¡-1 {suc (suc n)} (x , i) refl
  = Î”â†â–¡-1 {suc n} x (â‰¤-max auto!) :â‰¥: (â‰¤-max auto!)

include-Î”-n+2 : âˆ€ {n} â†’ Î”^ (n + 2) â†’ â–¡^ n Ã— Î”Â²
include-Î”-n+2 (x :â‰¥: i :â‰¥: j) = â–¡â†Î” x , (i , j)

ret-Î”-n+2 : âˆ€ {n} â†’ â–¡^ n Ã— Î”Â² â†’ Î”^ (n + 2)
ret-Î”-n+2 (x , (i , j)) = ((Î”â†â–¡ x i :â‰¥: i) â¦ƒ Î”â†â–¡-â‰¤ x i â¦„ :â‰¥: j)

â–¡â†Î”-ret : âˆ€ {n} (p : Î”^ n) i â¦ƒ k : i â‰¤ last-Î” p â¦„ â†’ Î”-path (Î”â†â–¡ (â–¡â†Î” p) i) p
â–¡â†Î”-ret Â· i = Â·
â–¡â†Î”-ret (Â· :â‰¥: j) i = Â· :â‰¥: âˆ¨-comm âˆ™ â‰¤-max auto!
â–¡â†Î”-ret (p :â‰¥: i :â‰¥: j) k
  = â–¡â†Î”-ret (p :â‰¥: i) (j âˆ¨ k) â¦ƒ âˆ¨-UP (auto! , (â‰¤-trans {b = j}auto! auto!)) â¦„
  :â‰¥: (âˆ¨-comm âˆ™ â‰¤-max auto!)

is-ret-Î”-â–¡ : âˆ€ {n} â†’ ret-Î”-n+2 {n} âˆ˜ include-Î”-n+2 ~ id
is-ret-Î”-â–¡ (p :â‰¥: i :â‰¥: j) = Î”-ext (â–¡â†Î”-ret p i :â‰¥: refl :â‰¥: refl)

Î”â†Î”Â² : Î”Â² â†’ Î”^ 2
Î”â†Î”Â² (i , j) = (Â· :â‰¥: i :â‰¥: j)

Î”â†Î”Â²-is-equiv : is-equiv Î”â†Î”Â²
Î”â†Î”Â²-is-equiv = is-equivâ†qiso
  ( (Î» { (Â· :â‰¥: i :â‰¥: j) â†’ (i , j) })
  , (Î» { (i , j) â†’ refl})
  , Î» { (Â· :â‰¥: i :â‰¥: j) â†’ Î”-ext (Â· :â‰¥: refl :â‰¥: refl)})
}
%```
}

\subtree[tot-0006]{
\taxon{Theorem}
\title{Spine lifting}
\date{2026-02-04}

\p{For all #{n \ge 2}, the inclusion #{\II_n \hookrightarrow \Delta^n} is inner
anodyne.}

\proof{
We proceed by induction on #{n}. The base case is trivial, so we need to show
that the map #{\II_{n + 1} \to \Delta^{n + 1}} is inner anodyne. Firstly,
we note that we can factorise this map as follows:

##{\II_{n} \vee \Delta^1 \to \Delta^n \vee \Delta^1 \to \Delta^{n+1}}

By the induction hypothesis and [closure properties of left orthogonal
maps](tot-0007), we have the first map is inner anodyne. To show the second
map is inner anodyne, we show it is a retraction of
#{\square^{n-1} \times \Lambda^2_1 \to \square^{n-1} \times \Delta^2}, which is
trivially left anodyne by closure of orthogonal maps under products. The
retraction is a pair of squares as follows:

\quiver{
\begin{tikzcd}
	{\Delta^n\vee\Delta^1} && {\square^{n-1}\times\Lambda^2_1} && {\Delta^n\vee\Delta^1} \\
	\\
	{\Delta^{n+1}} && {\square^{n-1}\times\Delta^2} && {\Delta^{n+1}}
	\arrow[hook, from=1-1, to=1-3]
	\arrow[hook, from=1-1, to=3-1]
	\arrow[two heads, from=1-3, to=1-5]
	\arrow[hook, from=1-3, to=3-3]
	\arrow[hook, from=1-5, to=3-5]
	\arrow[hook, from=3-1, to=3-3]
	\arrow[two heads, from=3-3, to=3-5]
\end{tikzcd}
}

\p{\ref{tot-0005} gives the bottom maps. It is clear that this retraction should
restrict to the appropriate subtypes.}

}

%```agda
\agda{
spine-incl-factor-1 : âˆ€ n â†’ âˆ‚Î”Â¹-Wedge (âˆ‚Î”^ n) Î´Î”Â¹-incl .fst â†’ Î”^ (suc n)
spine-incl-factor-1 n
  = cogap (mk-cocone (Î» x â†’ x :â‰¥: i0) (Î» i â†’ (Î”-1 :â‰¥: i)â¦ƒ Î”-1-â‰¤ {n = n} â¦„)
           Î» a â†’ Î”-ext (Î”-refl :â‰¥: refl))

spine-incl-factor-2 : âˆ€ n â†’ Spine (suc n) â†’ âˆ‚Î”Â¹-Wedge (âˆ‚Î”^ n) Î´Î”Â¹-incl .fst
spine-incl-factor-2 zero i = Î¹â‚‚ i
spine-incl-factor-2 (suc n) = âˆ‚Î”Â¹-Wedge-map
                        (Spine-coslice (suc n) .snd) Î´Î”Â¹-incl
                        (âˆ‚Î”^ (suc n)) Î´Î”Â¹-incl
                        (Spine-incl ,
                        (Î» {
                          (mk-lift true ) â†’ Î”-ext Spine-top
                        ; (mk-lift false) â†’ Î”-ext Spine-bot}))
                        (id , ~refl) .fst

private
  factorisation
    : âˆ€ n â†’ spine-incl-factor-1 n âˆ˜ spine-incl-factor-2 n ~ Spine-incl {suc n}
  factorisation zero = ~refl
  factorisation (suc n) = pushout-rec-unique _ _
    ~refl ~refl Î» _ â†’ prop!

opaque
  fat-spine-lifts
    : âˆ€ {n} â†’ is-inner-anodyne (spine-incl-factor-1 (suc n))
  fat-spine-lifts {n} f finn
    = left-orthogonal-retract
        (spine-incl-factor-1 (suc n)) _
        (amap2 n) (amap2-ret n)
        f (incl-mid-inner-anodyne f finn) where
    incl-mid : âˆ€ n â†’ â–¡^ n Ã— Î›[2,1] â†’ â–¡^ n Ã— Î”Â²
    incl-mid n = (â–¡^ n) 1âŠ— Î›[2,1]-incl

    incl-mid-inner-anodyne : âˆ€ {n} â†’ is-inner-anodyne (incl-mid n)
    incl-mid-inner-anodyne k = left-orthogonal-Ã— id Î›[2,1]-incl k (idâŠ¥ k)

    amap2 : âˆ€ n â†’ Arrow-map (spine-incl-factor-1 (suc n)) (incl-mid n)
    amap2 n .Arrow-map.top = cogap
      (mk-cocone
        (Î» { (x :â‰¥: i) â†’ (â–¡â†Î” x , Î¹â‚ i)})
        (Î» i â†’ â–¡â†Î” Î”-1 , Î¹â‚‚ i)
        Î» a â†’ Ã—-pathâ†’ (refl , glue tt))
    amap2 n .Arrow-map.bot = include-Î”-n+2
    amap2 n .Arrow-map.comm = pushout-ind _
      (mk-coconeD
        (Î» { (x :â‰¥: j) â†’ refl})
        ~refl
        Î» _ â†’ is-setâ†is-truncated
                (Trunc.Ã—âˆˆS (â–¡-is-set trunc!) Î”Â²-is-set)
                _ _ _ _)

    amap2-ret : âˆ€ n â†’ retract-arrow-map (amap2 n)
    amap2-ret n .fst .Arrow-map.top = uncurry (Î» x â†’ cogap
      (mk-cocone
        (Î» i â†’ Î¹â‚ ((Î”â†â–¡ x i :â‰¥: i) â¦ƒ Î”â†â–¡-â‰¤ x i â¦„))
        (Î» i â†’ Î¹â‚‚ i)
        Î» _ â†’ ap Î¹â‚ (Î”-ext (Î”â†â–¡-1 x refl :â‰¥: refl)) âˆ™ glue tt))
    amap2-ret n .fst .Arrow-map.bot = ret-Î”-n+2
    amap2-ret n .fst .Arrow-map.comm = uncurry (Î» x â†’ pushout-ind _
      (mk-coconeD
        ~refl
        (Î» i â†’ Î”-ext (Î”â†â–¡-1 x refl :â‰¥: refl :â‰¥: refl))
        Î» _ â†’ prop!))
    amap2-ret n .snd .fst = pushout-ind _
      (mk-coconeD
        (Î» { (l :â‰¥: j) â†’ ap Î¹â‚ (Î”-ext (â–¡â†Î”-ret l j :â‰¥: refl))})
        ~refl
        Î» _ â†’ prop!)
    amap2-ret n .snd .snd .fst = is-ret-Î”-â–¡
    amap2-ret n .snd .snd .snd x = prop!

opaque
  Spine-lifting : âˆ€ n â†’ is-inner-anodyne (Spine-incl {suc (suc n)})
  Spine-lifting zero k ko
    = left-orthogonal-equiv
       Î›[2,1]-incl Spine-incl
       (mk-amap id (Î» where (i , j) â†’ Â· :â‰¥: i :â‰¥: j)
       (pushout-ind _
         (mk-coconeD ~refl ~refl
           (Î» _ â†’ prop!))))
       (id-is-equiv , Î”â†Î”Â²-is-equiv)
       k ko
  Spine-lifting (suc n)
    = is-anodyne-homotopy
        {f = spine-incl-factor-1 (n + 2) âˆ˜ spine-incl-factor-2 (n + 2)}
        {g = Spine-incl}
        Î›[2,1]-incl
        (factorisation (n + 2))
        (is-anodyne-âˆ˜
          {f = spine-incl-factor-1 (n + 2)}
          {g = spine-incl-factor-2 (n + 2)}
          Î›[2,1]-incl
          fat-spine-lifts
          (wedge-map-is-inner-anodyne
            (Spine-coslice (suc (suc n)) .snd) Î´Î”Â¹-incl
            (âˆ‚Î”^ (n + 2)) Î´Î”Â¹-incl
            (âˆ‚Î”Â¹-Spine-incl (n + 2))
            (id , ~refl)
            (Spine-lifting n)
            Î» k _ â†’ idâŠ¥ k))
}
%```
}
