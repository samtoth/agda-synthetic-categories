\title{An inductive definition of free lattice algebras}
\taxon{Module}
\author{samueltoth}
\date{2026-02-05}
\import{stt-macros}


%```agda
\agda{
open import Foundations.Prelude
open import ufAxioms

open import Algebra.Lattice

module Algebra.Lattice.Instances.Free.Inductive
       {ğ“˜} (I : Type ğ“˜) (L : Lattice I) where

open import Algebra.Poset
open import Modalities.Instances.Truncation
open import Modalities.Separated

open import Ergonomics.Auto
open import Ergonomics.Extensionality

open import Data.Bool

open Lattice L renaming (0l to i0; 1l to i1)
}
%```

\subtree[tot-0001]{
\title{General simplices}
\taxon{Definition}

\p{Just as in the case of the [1-variable free algebra](stt-009X), we give a
geometrically suggestive name to the underlying type of the free algebra on
#{n}-generators.}

\remark{
\p{We give an indexed-inductive-recursive definition for the type of n-simplices,
which, if you aren't a type theorist - may scare you, and if you are, might
worry you. In both cases, these worries may be assuaged by observing that the
definition is trivially equivalent to your favorite other definition of a
descending sequence of #{n}-elements. We hope to formalise this equivalence at
some point.}
}

%```agda
\agda{
data Î”^_ : (n : â„•) â†’ Type ğ“˜
last-Î” : âˆ€ {n} â†’ Î”^ n â†’ I

data Î”^_ where
  Â· : Î”^ 0
  _â‰¥,_ : âˆ€ {n} â†’ (i : Î”^ n) â†’ (j : I) â†’ â¦ƒ j â‰¤ last-Î” i â¦„ â†’ Î”^ (suc n)

infixl 5 _â‰¥,_

last-Î” Â· = i1
last-Î” (x â‰¥, j) = j

Î”-suc : âˆ€ {n} â†’ (Î”^ suc n) â‰… (Î£[ x âˆ¶ (Î”^ n)] Î£[ y âˆ¶ I ] (y â‰¤ last-Î” x))
Î”-suc ._â‰…_.fwd (x â‰¥, j) = (x , j , auto!)
Î”-suc ._â‰…_.fwd-iso .fst (x , j , p) = (x â‰¥, j) â¦ƒ p â¦„
Î”-suc ._â‰…_.fwd-iso .snd .fst (x â‰¥, j) = refl
Î”-suc ._â‰…_.fwd-iso .snd .snd = ~refl

Î”-1 : âˆ€ {n} â†’ Î”^ n
Î”-1-â‰¤ : âˆ€ {i n} â†’ i â‰¤ last-Î” {n} (Î”-1)

Î”-1 {zero} = Â·
Î”-1 {suc n} = (Î”-1 â‰¥, i1) â¦ƒ Î”-1-â‰¤ {i1} {n} â¦„

Î”-1-â‰¤ {i} {zero} = auto!
Î”-1-â‰¤ {i} {suc n} = auto!

Î”-0 : âˆ€ {n} â†’ Î”^ n
Î”-0 {zero} = Â·
Î”-0 {suc n} = (Î”-0 â‰¥, i0)
}
%```
}


\subtree[tot-0002]{
\title{Paths in #{n}-simplices}
\taxon{Definition}

\p{We also inductively define the type of paths in the standard #{n}-simplex.
It is clear that since #{\Delta^1} is a set, then so is #{\Delta^n}.}

%```agda
\agda{
data Î”-path : {n : â„•} â†’ Î”^ n â†’ Î”^ n â†’ Type ğ“˜ where
  Â· : Î”-path Â· Â·
  _â‰¥,_ : âˆ€ {n} {x x' : Î”^ n} {i i' : I} {p : i â‰¤ last-Î” x}
           { q : i' â‰¤ last-Î” x' } â†’ Î”-path x x' â†’ i ï¼ i'
         â†’ Î”-path ((x â‰¥, i) â¦ƒ p â¦„) ((x' â‰¥, i') â¦ƒ q â¦„)

Î”-refl : âˆ€ {n} {p : Î”^ n} â†’ Î”-path p p
Î”-refl {p = Â·} = Â·
Î”-refl {p = p â‰¥, j} = Î”-refl â‰¥, refl

Î”-path-suc
  : âˆ€ {n} {a b : Î”^ n} {i j : I} â¦ƒ p : i â‰¤ last-Î” a â¦„ â¦ƒ q : j â‰¤ last-Î” b â¦„
    â†’ Î”-path (a â‰¥, i) (b â‰¥, j) â‰… (Î”-path a b Ã— (i ï¼ j))
Î”-path-suc ._â‰…_.fwd (x â‰¥, p) = (x , p)
Î”-path-suc ._â‰…_.fwd-iso .fst (x , p) = (x â‰¥, p)
Î”-path-suc ._â‰…_.fwd-iso .snd .fst (x â‰¥, p) = refl
Î”-path-suc ._â‰…_.fwd-iso .snd .snd = ~refl

opaque
  Î”-path-is-torsorial
    : âˆ€ {n} (a : Î”^ n) â†’ is-singleton (Î£ (Î”^ n) (Î”-path a))
  Î”-path-is-torsorial Â· = mk-singl (Â· , Â·) (Î» { (Â· , Â·) â†’ refl})
  Î”-path-is-torsorial {suc n} (a â‰¥, j)
    = is-singleâ†equiv-to-single
        (  (Î£-ap-â‰ƒ (Î» where (x â‰¥, i) â†’ equivâ†qiso Î”-path-suc)
        âˆ™â‰ƒ Î£-ap-â‰ƒ-fst (equivâ†qiso (Î”-suc {n}))) eâ»Â¹)
        (is-singleton-structureâ†parts
          (Î”-path-is-torsorial a)
          (a , Î”-refl)
          (is-singleâ†equiv-to-single
            (remove-singleton-structure
              Sing-is-singleton
              (j , refl) eâ»Â¹)
            (mk-singl auto! (â‰¤-is-prop auto!))))

instance
  Î”-IdS : âˆ€ {n} â†’ Identity-system (Î”^ n) ğ“˜
  Î”-IdS .Identity-system.IdS = Î”-path
  Î”-IdS .Identity-system.IdSâ†Id refl = Î”-refl
  Î”-IdS .Identity-system.has-is-ids a
    = fundamental-Id _ (Î”-path-is-torsorial a) _

Î”-ext : âˆ€ {n} {p q : Î”^ n} â†’ Î”-path p q â†’ p ï¼ q
Î”-ext = ext!

Î”-path-is-prop : âˆ€ {n} {a b : Î”^ n} â†’ is-prop (Î”-path a b)
Î”-path-is-prop Â· Â· = refl
Î”-path-is-prop (p â‰¥, q) (r â‰¥, s)
  = apâ‚‚ _â‰¥,_ (Î”-path-is-prop p r) (is-propâ†is-truncated trunc! _ _)

opaque
  unfolding is-n-separated
  Î”-is-set : âˆ€ {n} â†’ is-truncated 2 (Î”^ n)
  Î”-is-set {n} _ _ = Trunc.is-truncatedâ†equiv
                       (ext!â‰ƒ â¦ƒ Î”-IdS â¦„ eâ»Â¹)
                       (is-truncatedâ†is-prop (Î”-path-is-prop))

instance
  Î”-Is-set : âˆ€ {n k} â†’ Is-truncated (k + 2) (Î”^ n)
  Î”-Is-set = truncation-instance 2 Î”-is-set
}
%```
}

\subtree[tot-0003]{
\title{There is a lattice structure on the #{n}-simplex}
\taxon{Lemma}

\p{This should correspond to the free lattice algebra on #{n}-generators. But
this remains to be formalised.}
}
