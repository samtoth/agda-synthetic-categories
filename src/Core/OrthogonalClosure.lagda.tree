\title{Closure properties of orthogonal maps}
\taxon{Module}
\date{2025-12}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.OrthogonalClosure where

open import Foundations.Prelude

open import ufAxioms

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.ArrowRetract
open import Core.Orthogonal
open import Core.Cube
open import Core.PullbackPower
open import Core.Postwhisker
open import Core.CocartesianSquare
open import Core.PushoutProduct

open notation
open import Ergonomics.Notations.Orthogonality
}
%```


\subtree[stt-00BU]{
\title{Being right orthogonal is preserved under pullback}
\taxon{Lemma}
\date{2025-11-26}

\p{Given a [cartesian square](stt-003V) between maps #{g} and #{h}, then if
#{f \perp h}, #{f \perp g}.}


\proof{
\p{Consider the following [cube](stt-00B2):}

\quiver{
\begin{tikzcd}[cramped]
	& {C^Y} && {C^X} \\
	{A^Y} && {A^X} \\
	& {D^Y} && {D^X} \\
	{B^Y} && {B^X}
	\arrow[from=1-2, to=1-4]
	\arrow["{h_*}"'{pos=0.6}, from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow["{g_*}"', from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow["{f^*}"{pos=0.3}, from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow["{f^*}"', from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

\p{The left and right faces are cartesian since [precomposing a cartesian square
gives a cartesian square](stt-003R), then by our assumption the back square is
cartesian, [so the front square is cartesian](stt-00B3).}
}

%```agda
\agda{
orthogonalâ†pullback
  : âˆ€ {ğ“¤ ğ“¥ ğ“ ğ“‘ ğ“’ ğ““} {X : Type ğ“¤} {Y : Type ğ“¥} (f : X â†’ Y)
      {A : Type ğ“} {B : Type ğ“‘} {C : Type ğ“’} {D : Type ğ““}
      {g : A â†’ B} {h : C â†’ D}
    â†’ (F : Arrow-map g h) â†’ is-cartesian F
    â†’ are-orthogonal f h â†’ are-orthogonal f g
orthogonalâ†pullback {X = X} {Y} f {A} {g = g}{h} F cart orth
  = orthogonalâ†is-cartesian
     (front-cartesianâ†cartesian-cube
       (power-hom f g) (power-hom f h)
       the-cube
       (precomp-cartesian F cart)
       (precomp-cartesian F cart)
       (is-cartesianâ†orthogonal orth)) where
  module F = Arrow-map F

  the-cube : Cube (power-hom f g) (power-hom f h)
  the-cube .Cube.left = precomp-square F Y
  the-cube .Cube.right = precomp-square F X
  the-cube .Cube.comm .fst = ~refl
  the-cube .Cube.comm .snd .fst = ~refl
  the-cube .Cube.comm .snd .snd a
    = âˆ™-reflr _ âˆ™ âˆ™-reflr _ âˆ™ sym (commutes-postwhisker-funext _)
}
%```
}

\subtree[stt-00BW]{
\title{Right orthogonal maps are left cancellative}
\taxon{Lemma}

%```agda
\agda{
right-orthogonal-âˆ˜
  : âˆ€ {ğ“§ ğ“¨ ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“§} {Y : Type ğ“¨} (f : X â†’ Y)
      {A : Type ğ“¤}{B : Type ğ“¥} {C : Type ğ“¦}
      {g : B â†’ C} {h : A â†’ B}
    â†’ f âŠ¥ g â†’ f âŠ¥ h â†’ f âŠ¥ g âˆ˜ h
right-orthogonal-âˆ˜ h fg fh
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian _
        (compose-cartesian
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fg))
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fh))))

right-orthogonal-left-cancel
  : âˆ€ {ğ“§ ğ“¨ ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“§} {Y : Type ğ“¨} (f : X â†’ Y)
      {A : Type ğ“¤}{B : Type ğ“¥} {C : Type ğ“¦}
      {g : B â†’ C} {h : A â†’ B}
    â†’ f âŠ¥ g â†’ f âŠ¥ g âˆ˜ h â†’ f âŠ¥ h
right-orthogonal-left-cancel f fg fgh
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian _
        (3-for-2-cartesian
          Arrow-map-path-refl
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fgh))
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fg))))
}
%```
}

\subtree[stt-00BV]{
\title{Closure properties of left orthogonal maps}
\taxon{Theorem}

\subtree[stt-00C0]{
\p{In general, left orthogonal maps are closed under 'colimit' like operations.
Suppose any map labeled with an #{f} is left orthogonal to #{h}, then:}

\ol{
\li{#{f \times f' \perp h}}
\li{#{g \circ f \perp h} iff #{g \perp h}}
\li{#{\Sigma_{i}f_i \perp h}}
\li{If there is a cocartesian square #{f \to g}, then #{g \perp h}}
\li{If #{g} is a retract of #{f}, then #{g \perp h}}
\li{For \strong{any} #{g}, the pushout product #{f \hat{\otimes} g \perp h}}
}
}

%```agda
\agda{
left-orthogonal-retract
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (f' : X â†’ Y)
      (F : Arrow-map f f') (R : retract-arrow-map F)
      {C : Type ğ“} {D : Type ğ“›} (g : C â†’ D)
      â†’ (f' âŠ¥ g) â†’ (f âŠ¥ g)
left-orthogonal-retract {A = A}{B} f f' F ret {C}{D} h f'h
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian _
        (retract-is-cartesian cube cube-ret
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal f'h)))) where
  cube : Cube (rotate-square (power-hom f h)) (rotate-square (power-hom f' h))
  cube .Cube.left = postcomp-square (ret .fst) C
  cube .Cube.right = postcomp-square (ret .fst) D
  cube .Cube.comm .fst = ~refl
  cube .Cube.comm .snd .fst = ~refl
  cube .Cube.comm .snd .snd k = âˆ™-reflr _ âˆ™ âˆ™-reflr _
                              âˆ™ sym (commutes-prewhisker-funext {h = h} _)
                              âˆ™ ap funextâ†’ (funextâ†’ (â—‚âˆ˜ h k _ ~â»Â¹))

  cube' : Cube (rotate-square (power-hom f' h)) (rotate-square (power-hom f h))
  cube' .Cube.left = postcomp-square F C
  cube' .Cube.right = postcomp-square F D
  cube' .Cube.comm .fst = ~refl
  cube' .Cube.comm .snd .fst = ~refl
  cube' .Cube.comm .snd .snd k = âˆ™-reflr _ âˆ™ âˆ™-reflr _
                               âˆ™ sym (commutes-prewhisker-funext {h = h} _)
                               âˆ™ ap funextâ†’ (funextâ†’ (â—‚âˆ˜ h k _ ~â»Â¹))

  cube-ret : 1-coherent-retract-cube cube
  cube-ret .fst = cube'
  cube-ret .snd .fst x = funextâ†’ (x â—‚ ret .snd .snd .fst)
  cube-ret .snd .snd
    = (ret-left .snd .fst
    ,  ret-right .snd .fst
    ,  ret-right .fst
    ,  (Î» f â†’ sym (ap-âˆ˜  (h âˆ˜_) (f âˆ˜_) (funextâ†’ (ret .snd .fst))))
    ,  Î» a â†’ sym
              (âˆ™-assoc
                (ap (_âˆ˜ Arrow-map.top F) (funextâ†’ (a â—‚ _)))
                (funextâ†’ ( a âˆ˜ Arrow-map.bot (ret .fst) â—‚ (Arrow-map.comm F ~â»Â¹)))
                ((postcomp D f â—‚ ret-right .fst) a))
              âˆ™ ret-right .snd .snd a âˆ™ âˆ™-reflr _) where
    ret-left : Arrow-map-path
                (paste-squares (postcomp-retract-square F ret .fst)
                               (postcomp-square (ret .fst) C))
                id-square
    ret-left = retract-arrow-map-is-retract
                         (postcomp-square (ret .fst) C)
                         (postcomp-retract-square F ret)


    ret-right : Arrow-map-path
                (paste-squares (postcomp-retract-square F ret .fst)
                               (postcomp-square (ret .fst) D))
                id-square
    ret-right = retract-arrow-map-is-retract
                         (postcomp-square (ret .fst) D)
                         (postcomp-retract-square F ret)


left-orthogonal-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“} {B : Type ğ“¤} {C : Type ğ“¥} (f : B â†’ C)
      {A : Type ğ“¦} (g : A â†’ B)
      {X : Type ğ“œ} {Y : Type ğ“} (h : X â†’ Y)
    â†’ (f âŠ¥ h) â†’ (g âŠ¥ h) â†’ (f âˆ˜ g) âŠ¥ h
left-orthogonal-âˆ˜ f g h fh gh
  = orthogonalâ†is-cartesian
      (compose-cartesian
        (is-cartesianâ†orthogonal gh)
        (is-cartesianâ†orthogonal fh))

left-orthogonal-right-cancel
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“} {B : Type ğ“¤} {C : Type ğ“¥} {f : B â†’ C}
      {A : Type ğ“¦} {g : A â†’ B}
      {X : Type ğ“œ} {Y : Type ğ“} {h : X â†’ Y}
    â†’ (g âŠ¥ h) â†’ (f âˆ˜ g) âŠ¥ h â†’ (f âŠ¥ h)
left-orthogonal-right-cancel gh fgh
  = orthogonalâ†is-cartesian
      (3-for-2-cartesian
         Arrow-map-path-refl
         (is-cartesianâ†orthogonal fgh)
         (is-cartesianâ†orthogonal gh))

left-orthogonal-homotopy
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B}
      {X : Type ğ“œ} {Y : Type ğ“} (h : X â†’ Y)
      (H : f ~ g)
    â†’ (f âŠ¥ h) â†’ (g âŠ¥ h)
left-orthogonal-homotopy h = funext-rec _ Î» where refl â†’ id

left-orthogonal-Î£
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“} {A : Type ğ“¤}
      {B : A â†’ Type ğ“¥} {C : A â†’ Type ğ“¦} (f : âˆ€ a â†’ B a â†’ C a)
      {X : Type ğ“œ} {Y : Type ğ“} (g : X â†’ Y)
      â†’ (âˆ€ a â†’ f a âŠ¥ g) â†’ (total-map f) âŠ¥ g
left-orthogonal-Î£ {A = A} {B} {C} f {Y = Y} g fg
  = orthogonalâ†is-cartesian
      (front-cartesianâ†equiv-cube
        cube
        cube-is-equiv
        (Î -square-is-cartesian _ (is-cartesianâ†orthogonal âˆ˜ fg))) where
  cube : Cube (power-hom (total-map f) g) (Î -square (Î» i â†’ power-hom (f i) g))
  cube .Cube.left .Arrow-map.top = curry
  cube .Cube.left .Arrow-map.bot = curry
  cube .Cube.left .Arrow-map.comm = ~refl
  cube .Cube.right .Arrow-map.top = curry
  cube .Cube.right .Arrow-map.bot = curry
  cube .Cube.right .Arrow-map.comm = ~refl
  cube .Cube.comm .fst = ~refl
  cube .Cube.comm .snd .fst = ~refl
  cube .Cube.comm .snd .snd a = âˆ™-reflr _ âˆ™ funext-refl

  cube-is-equiv : is-Cube-equiv cube
  cube-is-equiv .fst .fst = curry-is-equiv
  cube-is-equiv .fst .snd = curry-is-equiv
  cube-is-equiv .snd .fst = curry-is-equiv
  cube-is-equiv .snd .snd = curry-is-equiv


left-orthogonal-Ã—
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (f' : X â†’ Y)
      {C : Type ğ“} {D : Type ğ“›} (g : C â†’ D)
      â†’ (f âŠ¥ g) â†’ (f' âŠ¥ g) â†’ (f âŠ— f') âŠ¥ g
left-orthogonal-Ã— {ğ“¤} {ğ“¥}{ğ“¦}{ğ“œ}{ğ“}{ğ“›}{A} {B} f {X} {Y} g h fh gh
  = left-orthogonal-âˆ˜ (f âŠ— id) (id âŠ— g) h
      (left-orthogonal-retract (f âŠ— id) (id âŠ— f)
        (mk-amap (Ã—-swap ._â‰ƒ_.fwd) (Ã—-swap ._â‰ƒ_.fwd) ~refl)
        ( mk-amap (Ã—-swap ._â‰ƒ_.fwd) (Ã—-swap ._â‰ƒ_.fwd) ~refl
        , ~refl
        , ~refl
        , ~refl)
        h
        (left-orthogonal-Î£ (Î» _ â†’ f) h (Î» _ â†’ fh)))
      (left-orthogonal-Î£ (Î» _ â†’ g) h Î» _ â†’ gh )

idâŠ¥_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (f : B â†’ C)
       â†’ id{A = A} âŠ¥ f
idâŠ¥ f = orthogonalâ†postcomp-Î  (Î» _ â†’ id-is-equiv)

left-orthogonal-pushout
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-cocartesianÏ‰ F
    â†’ {C : Type ğ“} {D : Type ğ“›} (h : C â†’ D)
    â†’ (f âŠ¥ h) â†’ (g âŠ¥ h)
left-orthogonal-pushout {f = f} {g = g} F cocart h fh
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian
        _
        (front-cartesianâ†cartesian-cube
        _ _ the-cube
        (cocart _)
        (cocart _)
        (rotate-is-cartesian _ (is-cartesianâ†orthogonal fh)))) where

  the-cube : Cube (rotate-square (power-hom g h)) (rotate-square (power-hom f h))
  the-cube .Cube.left = postcomp-square F _
  the-cube .Cube.right = postcomp-square F _
  the-cube .Cube.comm .fst = ~refl
  the-cube .Cube.comm .snd .fst = ~refl
  the-cube .Cube.comm .snd .snd k
    = âˆ™-reflr _ âˆ™ âˆ™-reflr _
    âˆ™ sym (commutes-prewhisker-funext {h = h} (ap k âˆ˜ sym âˆ˜ Arrow-map.comm F))
    âˆ™ ap funextâ†’ (funextâ†’ (Î» a â†’ sym (ap-âˆ˜ h k _)))

left-orthogonal-pushout-product
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦Â ğ“œ ğ“ ğ“›}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“} {Y : Type ğ“›} (h : X â†’ Y)
  â†’ f âŠ¥ h
  â†’ {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
  â†’ pushout-product f g âŠ¥ h
left-orthogonal-pushout-product f h fh g
  = left-orthogonal-right-cancel
      (left-orthogonal-pushout _
        (Pushout-square-is-cocartesian (mk-span _ (f âŠ—1 _) (_ 1âŠ— g)))
        h (left-orthogonal-Ã— f id h fh (idâŠ¥ h)))
        (left-orthogonal-Ã— f id h fh (idâŠ¥ h))
}
%```
}
