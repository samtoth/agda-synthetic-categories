\title{Hom families}
\taxon{Module}
\author{samueltoth}
\date{2025-12-09}

\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.HomFamilies
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Data.Bool

open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.CosliceOrthogonality
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CoSlice
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection
open import Core.CanonicalPushouts

open import Core.FunctorialPushout
open import Core.SpanMap

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open import Ergonomics.Auto
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.JoinSlice Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Homotopies Î”Â¹ I I-distr
}
%```



\subtree[stt-00D6]{
\title{Unstraightening hom families}
\taxon{Remark}

\p{The unstraightening of the family #{\Hom(x,-)} is #{X_{x/} \to X}. Thus
representable families are covariant iff #{X_{x/} \to X} are all left fibrations.}


%```agda
\agda{
hom-fam-is-covâ‡”is-left-fibration
  : âˆ€ {ğ“¤} {X : Type ğ“¤} x
  â†’ is-covariant (Î» a â†’ Hom X x a)
  â‡” is-left-fibration {A = Coslice X (Î» (_ : ğŸ™) â†’ x)} fst
hom-fam-is-covâ‡”is-left-fibration x
  = is-covariantâ‡”is-left-fibration (Î» a â†’ Hom _ x a)
  âˆ™â‡” right-orthogonal-iffâ†equiv (Î» _ â†’ i0) amap amap-eq where
  amap : Arrow-map (fst {B = Î» c â†’ (i : ğŸ™) â†’ Hom _ x c})
                   (fst {B = Î» a â†’ Hom _ x a})
  amap .Arrow-map.top = total-map (Î» a â†’ ev tt)
  amap .Arrow-map.bot = id
  amap .Arrow-map.comm = ~refl

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = is-total-equivâ†is-fibrewise-equiv (Î» a â†’ unit-ev-is-equiv)
  amap-eq .snd = id-is-equiv
}
%```
}

\subtree[stt-00DA]{
\taxon{Definition}
\title{Strongly (left) Segal types}

\p{We call a type \em{strongly} (left) Segal if it is local with respect to the
map #{\Lambda^2_1 \to 1 \rtimes \Delta^1}.
}

%```agda
\agda{
weird-horn-inclusion : Î›[2,1] â†’ ğŸ™ â‹‰ Î”Â¹
weird-horn-inclusion = cogap (mk-cocone (â†‘-hom (tt , i0) .HomP.hom) â†‘-Î¹â‚‚
                             Î» a â†’ glue (Î´Î”Â¹-1 , tt , i0))

weird-horn-inclusionâˆ™ : Coslice-map (Î» (_ : ğŸ™) â†’ Î¹â‚ i0) Î» _ â†’ â†‘-Î¹â‚ tt
weird-horn-inclusionâˆ™ = (weird-horn-inclusion , Î» _ â†’ glue (Î´Î”Â¹-0 , tt , i0))

is-strongly-segal : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-strongly-segal A = is-local (Î» (_ : ğŸ™) â†’ weird-horn-inclusion) A
}
%```
}

\subtree[stt-00DB]{
\title{Strongly Segal types are Segal}
\taxon{Lemma}

\p{Any [strongly Segal](stt-00DA) type is [Segal](stt-00AI).}

\proof{
\p{We give a splitting of #{\Delta^2 \hookrightarrow 1 \rtimes \Delta^1},
   which furthermore preserves the inner horn inclusion.
   (Note the split embedding #{\Delta^2 \hookrightarrow \square^2} in
   \ref{stt-00C7} factors through this map.)}
}

%```agda
\agda{
retract-weird : ğŸ™ â‹‰ Î”Â¹ â†’ Î”Â²
retract-weird
  = cogap (mk-cocone
            (Î» {(i , tt , j) â†’ (i , i âˆ§ j) â¦ƒ âˆ§-â‰¤-eliml auto! â¦„})
            âŠ[ (Î» _ â†’ (i0 , i0)) , (i1 ,_) ]
            Î» { (mk-lift true  , tt , b) â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ 1-top)
              ; (mk-lift false , tt , b) â†’ Î”Â²-ext (refl , 0-init) })

retract-weird-resp-horn
  : retract-weird âˆ˜ weird-horn-inclusion ~ Î›[2,1]-incl
retract-weird-resp-horn = pushout-ind _
  (mk-coconeD
    (Î» l â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ 0-init))
    (Î» r â†’ refl)
    (Î» _ â†’ is-setâ†is-truncated Î”Â²-is-set _ _ _ _))

section-weird : Î”Â² â†’ ğŸ™ â‹‰ Î”Â¹
section-weird a = Î¹â‚ (Poly.Î”Â².s a , tt , Poly.Î”Â².t a)

section-weird-resp-horn
  : section-weird âˆ˜ Î›[2,1]-incl ~ weird-horn-inclusion
section-weird-resp-horn = pushout-rec-unique _ _
  ~refl
  (Î» a â†’ glue (Î´Î”Â¹-1 , tt , a))
  Î» a â†’ ap (_âˆ™ glue (Î´Î”Â¹-1 , tt , i0))
         ( ap-âˆ˜ section-weird Î›[2,1]-incl (glue a)
         âˆ™ ap (ap section-weird) (pushout-rec-apÎ² _)
         âˆ™ lem) where
  lem : ap (section-weird) Î”Â²-refl ï¼ refl
  lem = ap-âˆ˜ Î¹â‚ (Î» where (i , j) â†’ (i , tt , j)) Î”Â²-refl
      âˆ™ ap (ap Î¹â‚) (is-setâ†is-truncated
                     (Trunc.Ã—âˆˆS car-is-set (Trunc.Ã—âˆˆS Trunc.ğŸ™âˆˆS car-is-set))
                     _ _ _ _)

sec-weird-is-sec : retract-weird âˆ˜ section-weird ~ id
sec-weird-is-sec (a , b) = Î”Â²-ext (refl , (âˆ§-comm âˆ™ auto!))

is-segalâ†is-strongly-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (weird-horn-inclusion âŠ¥ A)
    â†’ is-segal A
is-segalâ†is-strongly-segal orth tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-retract Î›[2,1]-incl weird-horn-inclusion
        (mk-amap id section-weird section-weird-resp-horn)
        ((mk-amap id retract-weird retract-weird-resp-horn) ,
          (~refl , ((Î» (i , j) â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ auto!))
          , Î» _ â†’ is-setâ†is-truncated Î”Â²-is-set _ _ _ _)))
        !
        (is-orthogonalâ‡”orthogonal-! .snd orth))
}
%```
}


\subtree[stt-00D9]{
\taxon{Therem}
\title{Covariance of representable families}

\p{We show that a type #{A} is [strongly Segal](stt-00DA) iff the family
#{\Hom(x,-)} is covariant for each #{x}.}

\proof{
We will show that every #{A_{x/} \to A} is a left fibration iff A is right
orthogonal to the map #{\Lambda^2_1 \to 1 \rtimes \Delta^1}.

\p{First we give an equivalence of arrows:}

\quiver{
\begin{tikzcd}
	{1\rtimes \Delta^1 \to_\bullet A} && {{A_{x/}}^{\Delta^1}} \\
	\\
	{\Lambda^2_1 \to_\bullet A} && {A^{\Delta^1} \times_A A_{x/}}
	\arrow["\sim", from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow["\sim"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{The top equivalence is given by the [join-coslice adjunction](stt-00D5), and
the bottom via the universal property of the horn.}


\p{Now we use \ref{stt-00DC} to finish the proof.}
}

\closedScope{
\subtree[stt-00DD]{
\title{The bottom equivalence}
%```agda
\agda{
char-coslice-lift : âˆ€ {ğ“¤} {A : Type ğ“¤} x
      â†’ Arrow-map (Î» (_ : ğŸ™) â†’ i0) {C = Coslice A (Î» (_ : ğŸ™) â†’ x)} (fst)
      â†’ Coslice-map {X = Î›[2,1]} (Î» _ â†’ Î¹â‚ i0) (Î» (_ : ğŸ™) â†’ x)
char-coslice-lift x (mk-amap top bot comm)
  = cogap (mk-cocone (top tt .snd tt .HomP.hom)
                     bot
                     (Î» c â†’ top tt .snd tt .HomP.hom1 âˆ™ sym (comm c)))
  , Î» _ â†’ HomP.hom0 (top tt .snd tt)

opaque
  char-coslice-lift-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} x
    â†’ is-equiv (char-coslice-lift {A = A} x)
  char-coslice-lift-is-equiv x = is-equivâ†qiso qiso where
    qiso : quasi-iso (char-coslice-lift x)
    qiso .fst (a , b) = mk-amap (Î» _ â†’ _ , (Î» _ â†’ mk-hom (a âˆ˜ Î¹â‚) (b tt) refl))
                                (a âˆ˜ Î¹â‚‚)
                                (ap a âˆ˜ sym âˆ˜ glue)
    qiso .snd .fst (mk-amap top bot comm)
      = let pth = ( top tt .snd tt .HomP.hom1
                  , Î» i â†’ ( ~refl
                          , Square-degen-vert _ _ refl
                          , Square-flatten-hor refl))
        in Arrow-map-pathâ†’
          ( (Î» a â†’ Coslice-pathâ†’ pth)
          , (~refl
          , Î» _ â†’ ap (_âˆ™ ap fst (Coslice-pathâ†’ pth))
                    (ap-sym _ (glue tt) âˆ™ ap sym (pushout-rec-apÎ² tt))
                âˆ™ ap (sym (HomP.hom1 (top tt .snd tt) âˆ™ sym (comm tt)) âˆ™_)
                     (Coslice-path-ap-fst pth)
                âˆ™ ap (_âˆ™ top tt .snd tt .HomP.hom1) (âˆ™-symsym _ (sym (comm tt)))
                âˆ™ âˆ™.cancell _  (âˆ™-sym' (HomP.hom1 (top tt .snd tt)))
                               {f = sym (sym (comm tt))}
                âˆ™ sym-sym ))
    qiso .snd .snd (a , p)
      = ext! ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
                      (Î» _ â†’ âˆ™-reflr _ âˆ™ sym (ap sym (ap-sym a _) âˆ™ sym-sym))
             , ~refl)
}
%```
}
}

%```agda
\agda{
coslice-is-leftâ‡”strongly-inner-coslice
  : âˆ€ {ğ“¤} {A : Type ğ“¤} x
  â†’ is-left-fibration {A = Coslice A (Î» (_ : ğŸ™) â†’ x)} fst
  â‡” (is-equiv (Coslice-map-postcompose (Î» (_ : ğŸ™) â†’ x) weird-horn-inclusionâˆ™))
coslice-is-leftâ‡”strongly-inner-coslice x
  = (orthogonalâ‡”pb-power-is-equiv â‡”â»Â¹)
  âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv amap amap-eq where
  amap : Arrow-map (pullback-power (Î» _ â†’ i0) (Î» r â†’ fst r))
                   (Coslice-map-postcompose (Î» _ â†’ x) weird-horn-inclusionâˆ™)
  amap .Arrow-map.top = joinâ†coslice-map (Î» _ â†’ x)
  amap .Arrow-map.bot = char-coslice-lift x
  amap .Arrow-map.comm f = ext!
    ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
          (Î» a â†’ ap (_âˆ™ refl) ( ap-âˆ˜ _ _ (glue a)
                              âˆ™ ap (ap (pushout-rec _)) (pushout-rec-apÎ² a)
                              âˆ™ pushout-rec-apÎ² _))
    , Î» _ â†’ âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _)

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = joinâ†coslice-map-is-equiv (Î» _ â†’ x)
  amap-eq .snd = char-coslice-lift-is-equiv x


hom-fam-is-covâ‡”is-strongly-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (âˆ€ x â†’ is-covariant (Î» a â†’ Hom A x a))
    â‡” is-strongly-segal A
hom-fam-is-covâ‡”is-strongly-segal {ğ“¤}{A}
  =  precomp-Î -â‡” (Î»
       x â†’  hom-fam-is-covâ‡”is-left-fibration x
         âˆ™â‡” coslice-is-leftâ‡”strongly-inner-coslice x)
  âˆ™â‡” logicalâ†equiv (postcomp-Î -â‰ƒ _ unit-UPâ‰ƒ)
  âˆ™â‡” (coslice-orthogonality (weird-horn-inclusionâˆ™) â‡”â»Â¹)
  âˆ™â‡” logicalâ†equiv {ğ“¥ = ğ“˜ âŠ” ğ“¤} (unit-UPâ‰ƒ eâ»Â¹)
}
%```
}

\subtree[stt-00DI]{
\taxon{Lemma}

\p{The map #{\Delta^2 \to â§…+^{\Delta^1} 1} is a Segal equivalence.}

\proof{
\p{By associativity of pushouts, #{â§… +^{\Delta^1} 1} is equivalently
#{X = \Delta^2 +^{\Delta^1} (\Delta^2 +^{\Delta^1} 1)}, where we call the
right hand component #{\Delta^2 +^{\Delta^1} 1} [the walking homotopy](stt-00DK).
By the universal property of pushouts, then #{A^X} is equivalently the pullback
of #{A^{\Delta^2}} with #{A^{\Delta_{\sim}}} along the diagonal. But since
#{A} is Segal, homotopies form an identity system over morphisms, and we
can contract away singletons to get an equivalence to the pullback of
#{A^{\Delta^2}} with the source of the homotopy. So we can contract away
singletons once more to get that the map #{A^{\Delta^2} \toeq A^X} which
picks out the lower right simplex is an equivalence.
}
}

%```agda
\agda{
â§…-degen-top : Type ğ“˜
â§…-degen-top = Pushout {A = Î”Â¹} {B = â§…} (Î¹â‚‚ âˆ˜ (_, i0)) !

â§…-degen' : Pushout Î”Â²-diagonal src-Î”~ â†’ â§…-degen-top
â§…-degen' = Pushout-assocâ†’ Î”Â²-diagonal Î”Â²-diagonal (_, i0) !

â§…-degenâ†Î”Â² : Î”Â² â†’ â§…-degen-top
â§…-degenâ†Î”Â² = Î¹â‚ âˆ˜ Î¹â‚

_ : âˆ€ {ğ“¤} {A : Type ğ“¤}
     â†’ postcomp A â§…-degenâ†Î”Â²
       ~ fst âˆ˜ _â‰…_.fwd cocone-reprâ‰… âˆ˜ cocone-map _ pushout âˆ˜ postcomp A â§…-degen'
_ = ~refl

opaque
  â§…-degenâ†Î”Â²-is-segal-equiv : is-segal-equiv â§…-degenâ†Î”Â²
  â§…-degenâ†Î”Â²-is-segal-equiv {Q = Q} qpc
    = is-equiv-âˆ˜
        {f = fst}
        {_â‰…_.fwd cocone-reprâ‰… âˆ˜ cocone-map _ pushout âˆ˜ postcomp Q â§…-degen'}
        (singleton-fst-is-equiv
          (Î» a â†’
            is-singleâ†equiv-to-single
              ( (Î£-ap-â‰ƒ-fst {B = Î» f â†’ a âˆ˜ Î”Â²-diagonal ~ f}
                          (mkâ‰ƒ _ (src-is-segal-equiv qpc))
                           eâ»Â¹) )
              (SingS-is-single _)))
        (is-equiv-âˆ˜
          (_â‰ƒ_.has-is-eqv cocone-reprâ‰ƒ)
          (is-equiv-âˆ˜
            Pushout-is-pushoutÏ‰
            (postcomp-equiv
              (is-equivâ†qiso
                (Pushout-assoc-is-equiv Î”Â²-diagonal Î”Â²-diagonal (_, i0) !)))))

}
%```
}

\subtree[stt-00DG]{
\taxon{Lemma}
\title{Precategories are strongly Segal}

\p{A [simplicial type](stt-00AC) is [Segal](stt-00AI) iff it
is [strongly Segal](stt-00DA).}

\proof{

\p{We factorise the defining map for strongly Segal types as follows:}

\quiver{
\begin{tikzcd}
	{\Lambda^2_1} && {\Delta^2} \\
	\\
	\\
	{1 \ltimes \Delta^1 \simeq \square +^{\Delta^1}1} && {\ttt +^{\Delta^1}1}
	\arrow["{\sim_{\textit{Segal}}}", from=1-1, to=1-3]
	\arrow[from=1-1, to=4-1]
	\arrow["{\sim_{\textit{Segal}}}", from=1-3, to=4-3]
	\arrow["{\sim_{\textit{simp}}}", from=4-3, to=4-1]
\end{tikzcd}
}

\p{The top map is a Segal equivalence by definition. Likewise the bottom map
is a simplicial equivalence, which follows from \ref{stt-00DC}. Finally,
\ref{stt-00DI} gives the right most map as a Segal equivalence.}


}

%```agda
\agda{
1â‹‰Î”Â¹â†cone : Pushout {B = â–¡^ 2} (_, i0) (! {A = Î”Â¹}) â†’ ğŸ™ â‹‰ Î”Â¹
1â‹‰Î”Â¹â†cone = Pushoutâ‚
  (mk-span-map
    (Î» (a , b) â†’ b , tt , a)
    (Î» i â†’ Î´Î”Â¹-0 , tt , i)
    inl
    ~refl
    ~refl)

1â‹‰Î”Â¹-is-cone : quasi-iso 1â‹‰Î”Â¹â†cone
1â‹‰Î”Â¹-is-cone .fst = â†‘-rec (mk-right-cocone Î¹â‚‚ (Î¹â‚ âˆ˜ (_, i1))
                           Î» where (_ , i) â†’ mk-hom (Î¹â‚ âˆ˜ (i ,_))
                                                    (glue i)
                                                    refl)
1â‹‰Î”Â¹-is-cone .snd .fst = pushout-ind _
  (mk-coconeD ~refl ~refl
    (Î» i â†’ IdP-funcâ†Square
               {f = (1â‹‰Î”Â¹-is-cone .fst âˆ˜ 1â‹‰Î”Â¹â†cone)} {id} (glue i) refl refl
               (Square-degen-hor _ _
                 (ap-âˆ˜ (1â‹‰Î”Â¹-is-cone .fst) 1â‹‰Î”Â¹â†cone (glue i)
                 âˆ™ ap (ap (1â‹‰Î”Â¹-is-cone .fst)) (pushout-rec-apÎ² _ âˆ™ âˆ™-reflr _)
                 âˆ™ pushout-rec-apÎ² _ âˆ™ sym (ap-id (glue i))))))
1â‹‰Î”Â¹-is-cone .snd .snd = pushout-ind _
  (mk-coconeD ~refl (âŠ-ind (~refl , (Î» i â†’ glue (Î´Î”Â¹-1 , tt , i))))
    Î» { (mk-lift true , _ , i)
           â†’ IdP-funcâ†Square (glue (Î´Î”Â¹-1 , tt , i)) refl (glue (Î´Î”Â¹-1 , tt , i))
               (coe
                 (Square-functorial-bot (sym (ap-id (glue (Î´Î”Â¹-1 , _ , i)))))
                 (Square-flatten-vert
                   (sym (ap-âˆ˜ 1â‹‰Î”Â¹â†cone (1â‹‰Î”Â¹-is-cone .fst) (glue _)
                   âˆ™ ap (ap 1â‹‰Î”Â¹â†cone) (pushout-rec-apÎ² _)))))
      ; (mk-lift false , _ , i)
           â†’ IdP-funcâ†Square (glue (Î´Î”Â¹-0 , tt , i)) refl refl
               (Square-degen-hor _ _
                 (ap-âˆ˜ 1â‹‰Î”Â¹â†cone (1â‹‰Î”Â¹-is-cone .fst) (glue (Î´Î”Â¹-0 , tt , i))
                 âˆ™ ap (ap 1â‹‰Î”Â¹â†cone) (pushout-rec-apÎ² _) âˆ™ pushout-rec-apÎ² _
                 âˆ™ âˆ™-reflr _ âˆ™ sym (ap-id (glue _)))) })

â§…-â–¡-degen-incl
  : Pushout {B = â§…} (Î¹â‚‚ âˆ˜ (_, i0)) ! â†’ Pushout {B = â–¡^ 2} (_, i0) !
â§…-â–¡-degen-incl
  = Pushoutâ‚ (mk-span-map â§…-incl id id ~refl ~refl)

strong-segal-factorisation
  : 1â‹‰Î”Â¹â†cone âˆ˜ â§…-â–¡-degen-incl âˆ˜ â§…-degenâ†Î”Â² âˆ˜ Î›[2,1]-incl ~ weird-horn-inclusion
strong-segal-factorisation
  = pushout-rec-unique _ _
      ~refl
      (Î» i â†’ glue (Î´Î”Â¹-1 , tt , i))
      Î» _ â†’ ap (_âˆ™ glue (Î´Î”Â¹-1 , tt , i0))
              ( ap-âˆ˜ (1â‹‰Î”Â¹â†cone âˆ˜ â§…-â–¡-degen-incl âˆ˜ â§…-degenâ†Î”Â²)
                     Î›[2,1]-incl (glue tt)
              âˆ™ ap (ap (1â‹‰Î”Â¹â†cone âˆ˜ â§…-â–¡-degen-incl âˆ˜ â§…-degenâ†Î”Â²))
                   (pushout-rec-apÎ² tt)
              âˆ™ ap-âˆ˜ Î¹â‚ _ Î”Â²-refl
              âˆ™ ap (ap Î¹â‚) (is-setâ†is-truncated
                    (Trunc.Ã—âˆˆS car-is-set (Trunc.Ã—âˆˆS Trunc.ğŸ™âˆˆS car-is-set))
                     _ _ _ refl))

is-based-triangulated
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’  â§…-incl âŠ¥ A â†’ â§…-â–¡-degen-incl âŠ¥ A
is-based-triangulated {A = A} ttA
  = left-orthogonal-pushoutâ‚ map .snd (lem âˆ˜ ev tt)  where
  -- A map colim(â§… â† Î”Â¹ â†’ ğŸ™) â†’ colim(â–¡ â† Î”Â¹ â†’ ğŸ™)
  -- is equivalently a map in the coslice under Î”Â¹ from â§… â†’ â–¡
  map : Coslice-map {A = Î”Â¹} (Î¹â‚‚ âˆ˜ (_, i0)) (_, i0)
  map .fst = â§…-incl
  map .snd = ~refl

  lem : âˆ€ x â†’ map âŠ¥ (Î» _ â†’ x)
  lem x = coslice-orthogonality map .fst ttA (Î» _ â†’ x)

is-strongly-segalâ†is-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-simplicial A â†’ is-segal A
    â†’ is-strongly-segal A
is-strongly-segalâ†is-segal {A = A} asimp apc tt
  = is-equiv~âˆ˜ (Î» h â†’ funextâ†’ Î» a â†’ ap h (sym (strong-segal-factorisation a)))
      (is-equiv-âˆ˜
        (apc tt)
        (â§…-degenâ†Î”Â²-is-segal-equiv apc))
      (is-equiv-âˆ˜
        (is-based-triangulated (simp-is-triangulated asimp tt))
        (postcomp-equiv (is-equivâ†qiso 1â‹‰Î”Â¹-is-cone)))
}
%```
}
