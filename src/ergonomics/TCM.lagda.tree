\taxon{module}
\date{2025-04-18}
\title{Meta programming primitives}
\meta{module}{\startverb ergonomics.TCM \stopverb}

\import{stt-macros}

% ```agda
\agda{
module ergonomics.TCM where

open import foundations.Prelude
open import ergonomics.Builtins

open import ergonomics.Term public
open import ergonomics.Name public
open import ergonomics.Meta public

-- Error messages can contain embedded names and terms.
data ErrorPart : Set where
  strErr  : String ‚Üí ErrorPart
  termErr : Term ‚Üí ErrorPart
  pattErr : Pattern ‚Üí ErrorPart
  nameErr : Name ‚Üí ErrorPart

{-# BUILTIN AGDAERRORPART       ErrorPart #-}
{-# BUILTIN AGDAERRORPARTSTRING strErr    #-}
{-# BUILTIN AGDAERRORPARTTERM   termErr   #-}
{-# BUILTIN AGDAERRORPARTNAME   nameErr   #-}


postulate
  TC       : ‚àÄ {ùì§} ‚Üí Type ùì§ ‚Üí Type ùì§
  returnTC : ‚àÄ {ùì§} {A : Type ùì§} ‚Üí A ‚Üí TC A
  bindTC   : ‚àÄ {ùì§ ùì•} {A : Type ùì§} {B : Type ùì•} ‚Üí TC A ‚Üí (A ‚Üí TC B) ‚Üí TC B

{-# BUILTIN AGDATCM       TC       #-}
{-# BUILTIN AGDATCMRETURN returnTC #-}
{-# BUILTIN AGDATCMBIND   bindTC   #-}

module DoTC where
  _>>=_ : ‚àÄ {ùì§ ùì•} {A : Type ùì§} {B : Type ùì•} ‚Üí TC A ‚Üí (A ‚Üí TC B) ‚Üí TC B
  _>>=_ = bindTC

  _=<<_ :  ‚àÄ {ùì§ ùì•} {A : Type ùì§} {B : Type ùì•} ‚Üí (A ‚Üí TC B) ‚Üí TC A ‚Üí TC B
  f =<< x = x >>= f

  _>>_ : ‚àÄ {ùì§ ùì•} {A : Type ùì§} {B : Type ùì•} ‚Üí TC A ‚Üí TC B ‚Üí TC B
  x >> y = x >>= Œª _ ‚Üí y


postulate
  -- Unify two terms, potentially solving metavariables in the process.
  unify : Term ‚Üí Term ‚Üí TC ùüô

  -- Throw a type error. Can be caught by catchTC.
  typeError : ‚àÄ {ùì§} {A : Type ùì§} ‚Üí List ErrorPart ‚Üí TC A

  -- Block a type checking computation on a blocker. This will abort
  -- the computation and restart it (from the beginning) when the
  -- blocker has been solved.
  blockTC : ‚àÄ {a} {A : Set a} ‚Üí Blocker ‚Üí TC A

  -- Prevent current solutions of metavariables from being rolled back in
  -- case 'blockOnMeta' is called.
  commitTC : TC ùüô

  -- Backtrack and try the second argument if the first argument throws a
  -- type error.
  catchTC : ‚àÄ {a} {A : Set a} ‚Üí TC A ‚Üí TC A ‚Üí TC A

  -- Infer the type of a given term
  inferType : Term ‚Üí TC Term

  -- Check a term against a given type. This may resolve implicit arguments
  -- in the term, so a new refined term is returned. Can be used to create
  -- new metavariables: newMeta t = checkType unknown t
  checkType : Term ‚Üí Term ‚Üí TC Term

  -- Compute the normal form of a term.
  normalise : Term ‚Üí TC Term

  -- Compute the weak head normal form of a term.
  reduce : Term ‚Üí TC Term

  -- Get the current context. Returns the context in reverse order, so that
  -- it is indexable by deBruijn index. Note that the types in the context are
  -- valid in the rest of the context. To use in the current context they need
  -- to be weakened by 1 + their position in the list.
  getContext : TC Telescope

  -- Extend the current context with a variable of the given type and its name.
  extendContext : ‚àÄ {a} {A : Set a} ‚Üí String ‚Üí Arg Term ‚Üí TC A ‚Üí TC A

  -- Set the current context relative to the context the TC computation
  -- is invoked from.  Takes a context telescope entries in reverse
  -- order, as given by `getContext`. Each type should be valid in the
  -- context formed by the remaining elements in the list.
  inContext : ‚àÄ {a} {A : Set a} ‚Üí Telescope ‚Üí TC A ‚Üí TC A

  -- Quote a value, returning the corresponding Term.
  quoteTC : ‚àÄ {a} {A : Set a} ‚Üí A ‚Üí TC Term

  -- Unquote a Term, returning the corresponding value.
  unquoteTC : ‚àÄ {a} {A : Set a} ‚Üí Term ‚Üí TC A

  -- Quote a value in Setœâ, returning the corresponding Term
  quoteœâTC : ‚àÄ {A : Typeœâ} ‚Üí A ‚Üí TC Term

  -- Create a fresh name.
  freshName : String ‚Üí TC Name

  -- Declare a new function of the given type. The function must be defined
  -- later using 'defineFun'. Takes an Arg Name to allow declaring instances
  -- and irrelevant functions. The Visibility of the Arg must not be hidden.
  declareDef : Arg Name ‚Üí Term ‚Üí TC ùüô

  -- Declare a new postulate of the given type. The Visibility of the Arg
  -- must not be hidden. It fails when executed from command-line with --safe
  -- option.
  declarePostulate : Arg Name ‚Üí Term ‚Üí TC ùüô

  -- Declare a new datatype. The second argument is the number of parameters.
  -- The third argument is the type of the datatype, i.e. its parameters and
  -- indices. The datatype must be defined later using 'defineData'.
  declareData      : Name ‚Üí ‚Ñï ‚Üí Term ‚Üí TC ùüô

  -- Define a declared datatype. The datatype must have been declared using
  -- 'declareData`. The second argument is a list of triples in which each triple
  -- is the name of a constructor, its erasure status and its type.
  defineData       : Name ‚Üí List (Œ£ Name (Œª _ ‚Üí Œ£ Quantity (Œª _ ‚Üí Term))) ‚Üí TC ùüô

  -- Define a declared function. The function may have been declared using
  -- 'declareDef' or with an explicit type signature in the program.
  defineFun : Name ‚Üí List Clause ‚Üí TC ùüô

  -- Get the type of a defined name relative to the current
  -- module. Replaces 'primNameType'.
  getType : Name ‚Üí TC Term 

  -- Get the definition of a defined name relative to the current
  -- module. Replaces 'primNameDefinition'.
  getDefinition : Name ‚Üí TC Definition

  -- Check if a name refers to a macro
  isMacro : Name ‚Üí TC Bool

  -- Generate FOREIGN pragma with specified backend and top-level backend-dependent text.
  pragmaForeign : String ‚Üí String ‚Üí TC ùüô

  -- Generate COMPILE pragma with specified backend, associated name and backend-dependent text.
  pragmaCompile : String ‚Üí Name ‚Üí String ‚Üí TC ùüô

  -- Change the behaviour of inferType, checkType, quoteTC, getContext
  -- to normalise (or not) their results. The default behaviour is no
  -- normalisation.
  withNormalisation : ‚àÄ {a} {A : Set a} ‚Üí Bool ‚Üí TC A ‚Üí TC A
  askNormalisation  : TC Bool

  -- If 'true', makes the following primitives to reconstruct hidden arguments:
  -- getDefinition, normalise, reduce, inferType, checkType and getContext
  withReconstructed : ‚àÄ {a} {A : Set a} ‚Üí Bool ‚Üí TC A ‚Üí TC A
  askReconstructed  : TC Bool

  -- Whether implicit arguments at the end should be turned into metavariables
  withExpandLast : ‚àÄ {a} {A : Set a} ‚Üí Bool ‚Üí TC A ‚Üí TC A
  askExpandLast  : TC Bool

  -- White/blacklist specific definitions for reduction while executing the TC computation
  -- 'true' for whitelist, 'false' for blacklist
  withReduceDefs : ‚àÄ {a} {A : Set a} ‚Üí (Œ£ Bool Œª _ ‚Üí List Name) ‚Üí TC A ‚Üí TC A
  askReduceDefs  : TC (Œ£ Bool Œª _ ‚Üí List Name)

  -- Parse and type check the given string against the given type, returning
  -- the resulting term (when successful).
  checkFromStringTC : String ‚Üí Type ‚Üí TC Term

  -- Prints the third argument to the debug buffer in Emacs
  -- if the verbosity level (set by the -v flag to Agda)
  -- is higher than the second argument. Note that Level 0 and 1 are printed
  -- to the info buffer instead. For instance, giving -v a.b.c:10 enables
  -- printing from debugPrint "a.b.c.d" 10 msg.
  debugPrint : String ‚Üí ‚Ñï ‚Üí List ErrorPart ‚Üí TC ùüô

  -- Return the formatted string of the argument using the internal pretty printer.
  formatErrorParts : List ErrorPart ‚Üí TC String

  -- Fail if the given computation gives rise to new, unsolved
  -- "blocking" constraints.
  noConstraints : ‚àÄ {a} {A : Set a} ‚Üí TC A ‚Üí TC A

  -- Run the given computation at the type level, allowing use of erased things.
  workOnTypes : ‚àÄ {a} {A : Set a} ‚Üí TC A ‚Üí TC A

  -- Run the given TC action and return the first component. Resets to
  -- the old TC state if the second component is 'false', or keep the
  -- new TC state if it is 'true'.
  runSpeculative : ‚àÄ {a} {A : Set a} ‚Üí TC (Œ£ A Œª _ ‚Üí Bool) ‚Üí TC A

  -- Get a list of all possible instance candidates for the given meta
  -- variable (it does not have to be an instance meta).
  getInstances : Meta ‚Üí TC (List Term)

  -- Try to solve open instance constraints. When wrapped in `noConstraints`,
  -- fails if there are unsolved instance constraints left over that originate
  -- from the current macro invokation. Outside constraints are still attempted,
  -- but failure to solve them are ignored by `noConstraints`.
  solveInstanceConstraints : TC ùüô

{-# BUILTIN AGDATCMUNIFY                      unify                      #-}
{-# BUILTIN AGDATCMTYPEERROR                  typeError                  #-}
{-# BUILTIN AGDATCMBLOCK                      blockTC                    #-}
{-# BUILTIN AGDATCMCATCHERROR                 catchTC                    #-}
{-# BUILTIN AGDATCMINFERTYPE                  inferType                  #-}
{-# BUILTIN AGDATCMCHECKTYPE                  checkType                  #-}
{-# BUILTIN AGDATCMNORMALISE                  normalise                  #-}
{-# BUILTIN AGDATCMREDUCE                     reduce                     #-}
{-# BUILTIN AGDATCMGETCONTEXT                 getContext                 #-}
{-# BUILTIN AGDATCMEXTENDCONTEXT              extendContext              #-}
{-# BUILTIN AGDATCMINCONTEXT                  inContext                  #-}
{-# BUILTIN AGDATCMQUOTETERM                  quoteTC                    #-}
{-# BUILTIN AGDATCMUNQUOTETERM                unquoteTC                  #-}
{-# BUILTIN AGDATCMQUOTEOMEGATERM             quoteœâTC                   #-}
{-# BUILTIN AGDATCMFRESHNAME                  freshName                  #-}
{-# BUILTIN AGDATCMDECLAREDEF                 declareDef                 #-}
{-# BUILTIN AGDATCMDECLAREPOSTULATE           declarePostulate           #-}
{-# BUILTIN AGDATCMDECLAREDATA                declareData                #-}
{-# BUILTIN AGDATCMDEFINEDATA                 defineData                 #-}
{-# BUILTIN AGDATCMDEFINEFUN                  defineFun                  #-}
{-# BUILTIN AGDATCMGETTYPE                    getType                    #-}
{-# BUILTIN AGDATCMGETDEFINITION              getDefinition              #-}
{-# BUILTIN AGDATCMCOMMIT                     commitTC                   #-}
{-# BUILTIN AGDATCMISMACRO                    isMacro                    #-}
{-# BUILTIN AGDATCMPRAGMAFOREIGN              pragmaForeign              #-}
{-# BUILTIN AGDATCMPRAGMACOMPILE              pragmaCompile              #-}
{-# BUILTIN AGDATCMWITHNORMALISATION          withNormalisation          #-}
{-# BUILTIN AGDATCMWITHRECONSTRUCTED          withReconstructed          #-}
{-# BUILTIN AGDATCMWITHEXPANDLAST             withExpandLast             #-}
{-# BUILTIN AGDATCMWITHREDUCEDEFS             withReduceDefs             #-}
{-# BUILTIN AGDATCMASKNORMALISATION           askNormalisation           #-}
{-# BUILTIN AGDATCMASKRECONSTRUCTED           askReconstructed           #-}
{-# BUILTIN AGDATCMASKEXPANDLAST              askExpandLast              #-}
{-# BUILTIN AGDATCMASKREDUCEDEFS              askReduceDefs              #-}
{-# BUILTIN AGDATCMDEBUGPRINT                 debugPrint                 #-}
{-# BUILTIN AGDATCMNOCONSTRAINTS              noConstraints              #-}
{-# BUILTIN AGDATCMWORKONTYPES                workOnTypes                #-}
{-# BUILTIN AGDATCMRUNSPECULATIVE             runSpeculative             #-}
{-# BUILTIN AGDATCMGETINSTANCES               getInstances               #-}
{-# BUILTIN AGDATCMSOLVEINSTANCES             solveInstanceConstraints   #-}


pattern _v‚à∑_ t xs = arg (arginfo visible (modality relevant quantity-œâ)) t ‚à∑ xs
pattern _h‚à∑_ t xs = arg (arginfo hidden (modality relevant quantity-œâ)) t ‚à∑ xs
pattern _hm‚à∑_ t xs = arg (arginfo hidden (modality relevant _)) t ‚à∑ xs
infixr 20 _v‚à∑_ _h‚à∑_ _hm‚à∑_

all-metas-in : Term ‚Üí List Blocker
all-metas-in tm = go tm [] where
  go  : Term ‚Üí List Blocker ‚Üí List Blocker
  go* : List (Arg Term) ‚Üí List Blocker ‚Üí List Blocker

  go (var _ args)             acc = go* args acc
  go (con _ args)             acc = go* args acc
  go (def _ args)             acc = go* args acc
  go (lam _ (abs _ t))        acc = go t acc
  go (pat-lam cs args)        acc = acc
  go (pi (arg _ a) (abs _ b)) acc = go a (go b acc)
  go (agda-sort s)            acc = acc
  go (lit l)                  acc = acc
  go (meta x args)            acc = go* args (blocker-meta x ‚à∑ acc)
  go unknown                  acc = acc

  go* []             acc = acc
  go* (arg _ x ‚à∑ xs) acc = go x (go* xs acc)

wait-for-type : Term ‚Üí TC Term
wait-for-type tm with all-metas-in tm
... | [] = returnTC tm
... | it = blockTC (blocker-all it)
}
% ```
