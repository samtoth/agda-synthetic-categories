\date{2026-02-09}
\title{Disjunctive types}
\author{fredrikbakke}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Disjunctive
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)

private
  Î”Â² = Poly.Î”Â² I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation

open import Core.Join
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CanonicalPushouts
open import Core.Orthogonal
open import Core.OrthogonalClosure

open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
  using (is-simplicial; fam-is-simplicial)
}
%```


\subtree[stt-00DY]{
\taxon{Definition}
\title{Disjunctive types}

\p{
The generic interval is not necessarily \em{disjunctive}, in the sense that
for all #{i} and #{j} such that #{(i âˆ¨ j) = 1} we would have #{i = 1} or
#{j = 1}. Instead, we can speak of particular types which \em{'see'} the
interval as being disjunctive. This can be made precise by asking for types
which are [null](stt-005G) with respect to the family of propositions
#{(i = 1) âˆ¨ (j = 1)} for all #{i} and #{j} such that #{(i âˆ¨ j) = 1}. Let #{âˆ¨Â²}
be the type of elements #{i} and #{j} such that #{(i âˆ¨ j) = 1}.
}

%```agda
\agda{
âˆ¨Â² : Type ğ“˜
âˆ¨Â² = Î£ (Î”Â¹ Ã— Î”Â¹) (Î» (i , j) â†’ (i âˆ¨ j ï¼ i1))

fam-disjunctive : Î”Â¹ Ã— Î”Â¹ â†’ Type ğ“˜
fam-disjunctive (i , j) = (i ï¼ i1) * (j ï¼ i1)

fam-is-disjunctive : âˆ¨Â² â†’ Type ğ“˜
fam-is-disjunctive = fam-disjunctive âˆ˜ fst

is-disjunctive : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
is-disjunctive = is-null fam-is-disjunctive
}
%```

\p{
By virtue of being defined in terms of nullification at a proposition, we
know that disjunctive types form a lex [#{\Sigma}-closed](stt-006E)
[reflective subuniverse](stt-0065).
}

%```agda
\agda{
Disjunctive-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Disjunctive-SubU = Null-SubU fam-is-disjunctive _

Disjunctive-GSU : GSU (_âŠ” ğ“˜)
Disjunctive-GSU = Null-GSU fam-is-disjunctive

Disjunctive-is-globally-reflective
  : is-globally-reflective Disjunctive-GSU
Disjunctive-is-globally-reflective = Null-globally-reflective

module Disj where
  open GRSUInduction Disjunctive-is-globally-reflective
                     Null-globally-Î£-closed
      public

  open GSU Disjunctive-GSU public renaming (S-equiv to is-disjunctiveâ†equiv)

  open is-globally-reflective Disjunctive-is-globally-reflective
  Î£-is-disjunctive = Null-globally-Î£-closed

Î›[2,2]-âˆ¨-rec : âˆ€ {ğ“¤} {A : Type ğ“¤} {i j} â†’ (i âˆ¨ j ï¼ i1) â†’ is-disjunctive A
          â†’ (l : i ï¼ i1 â†’ A) â†’ (r : j ï¼ i1 â†’ A)
          â†’ ((pi : i ï¼ i1) (pj : j ï¼ i1) â†’ l pi ï¼ r pj) â†’ A
Î›[2,2]-âˆ¨-rec {i = i} {j} p disj-A l r eq
  = is-equiv.bwd
  (disj-A ((i , j) , p))
  (cogap (mk-cocone l r (Î» (p , q) â†’ eq p q)))

Î›[2,2]-âˆ¨-rec' : âˆ€ {ğ“¤} {A : Type ğ“¤} {i j} â†’ (p : i âˆ¨ j ï¼ i1)
              â†’ is-disjunctive A
              â†’ (l : i ï¼ i1 â†’ A) â†’ (r : j ï¼ i1 â†’ A)
              â†’ ((q : i ï¼ j) â†’ l (=âˆ¨â†= q âˆ™ p) ï¼ r ((=âˆ¨'â†= (sym q)) âˆ™ p)) â†’ A
Î›[2,2]-âˆ¨-rec' {i = i} {j} p disj-A l r eq
  = Î›[2,2]-âˆ¨-rec p disj-A l r (Î» pi pj
    â†’ ap l (is-prop-separated _ _ _ _)
    âˆ™ eq (pi âˆ™ sym pj)
    âˆ™ ap r (is-prop-separated _ _ _ _))

Î›[2,2]-âˆ¨-rec! : âˆ€ {ğ“¤} {A : Type ğ“¤} i j â†’ â¦ƒ p : i âˆ¨ j ï¼ i1 â¦„
              â†’ is-disjunctive A
              â†’ (l : â¦ƒ  i ï¼ i1 â¦„ â†’ A) â†’ (r : â¦ƒ j ï¼ i1 â¦„ â†’ A)
              â†’ ((pi : i ï¼ i1) (pj : j ï¼ i1) â†’ l â¦ƒ pi â¦„ ï¼ r â¦ƒ pj â¦„)
              â†’ A
Î›[2,2]-âˆ¨-rec! i j â¦ƒ p â¦„ disj-A l r
  = Î›[2,2]-âˆ¨-rec p disj-A (Î» p â†’ l â¦ƒ p â¦„) (Î» q â†’ r â¦ƒ q â¦„)
}
%```
}


\subtree[stt-00DT]{
\taxon{Definition}
\title{The outer horn #{Î›[2,2]}}

\p{
We give a slightly nonstandard definition of the outer horn #{Î›[2,2]} as the
subtype of the square consisting of elements #{(i,j)} such that
#{(i = 1) * (j = 1)}. Normally, it is defined as the subtype such that
#{(i = 1) * (i = j)}.
}

\p{
We show that #{Î›[2,2]} is a subtype of #{âˆ¨Â²} by showing that
#{(i = 1) âˆ¨ (j = 1)} implies #{(i âˆ¨ j) = 1}, and hence #{Î›[2,2]} is
equivalent to the type #{Î£_{(i\,j:Î”Â¹)}((i âˆ¨ j = 1) âˆ§ ((i = 1) âˆ¨ (j = 1)))}.
}

%```agda
\agda{
âˆ¨=1â†fam-disjunctive : âˆ€ {i j} â†’ fam-disjunctive (i , j) â†’ (i âˆ¨ j ï¼ i1)
âˆ¨=1â†fam-disjunctive {i = i} {j}
  = *-prop-rec
      (is-prop-separated _ _)
      (Î» pi â†’ ap (_âˆ¨ j) pi âˆ™ âˆ¨-comm âˆ™ 1-coinit)
      (Î» pj â†’ ap (i âˆ¨_) pj âˆ™ 1-coinit)

Î›[2,2]' : Type ğ“˜
Î›[2,2]' = Î£ âˆ¨Â² fam-is-disjunctive

Î›[2,2] : Type ğ“˜
Î›[2,2] = Î£ (Î”Â¹ Ã— Î”Â¹) fam-disjunctive

drop-join-proof
  : (ij : Î”Â¹ Ã— Î”Â¹)
  â†’ ((fst ij âˆ¨ snd ij ï¼ i1) Ã— (fam-disjunctive ij))
  â†’ fam-disjunctive ij
drop-join-proof _ = snd

drop-join-proof-is-equiv
  : (ij : Î”Â¹ Ã— Î”Â¹) â†’ is-equiv (drop-join-proof ij)
drop-join-proof-is-equiv (i , j)
  = is-equivâ†inverse
      (is-prop-Î£
        (is-prop-separated _ _)
        (Î» _ â†’ *-is-prop (is-prop-separated _ _) (is-prop-separated _ _)))
      (*-is-prop (is-prop-separated _ _) (is-prop-separated _ _))
      (Î» d â†’ âˆ¨=1â†fam-disjunctive d , d)

Î›[2,2]â†Î›[2,2]' : Î›[2,2]' â†’ Î›[2,2]
Î›[2,2]â†Î›[2,2]' = total-map drop-join-proof âˆ˜ _â‰ƒ_.fwd Î£-assoc

Î›[2,2]â†Î›[2,2]'-is-equiv : is-equiv Î›[2,2]â†Î›[2,2]'
Î›[2,2]â†Î›[2,2]'-is-equiv
  = is-equiv-âˆ˜
      (is-total-equivâ†is-fibrewise-equiv drop-join-proof-is-equiv)
      (_â‰ƒ_.has-is-eqv Î£-assoc)

Î›[2,2]'â‰ƒÎ›[2,2] : Î›[2,2]' â‰ƒ Î›[2,2]
Î›[2,2]'â‰ƒÎ›[2,2] = mkâ‰ƒ Î›[2,2]â†Î›[2,2]' Î›[2,2]â†Î›[2,2]'-is-equiv

Î›[2,2]'â†Î›[2,2] : Î›[2,2] â†’ Î›[2,2]'
Î›[2,2]'â†Î›[2,2] = _â‰ƒ_.bwd Î›[2,2]'â‰ƒÎ›[2,2]

Î›[2,2]-incl : Î›[2,2] â†’ âˆ¨Â²
Î›[2,2]-incl ((i , j) , d) = ((i , j) , âˆ¨=1â†fam-disjunctive d)
}
%```
}


\subtree[stt-00DU]{
\taxon{Definition}
\title{Upper located types}

\p{
We might say a type is \em{upper located} if it is local at the inclusion of
#{Î£_{(i\,j:Î”Â¹)}((i = 1) âˆ¨ (j = 1))} into
#{Î£_{(i\,j:Î”Â¹)}(i âˆ¨ j = 1)}. In other words, it sees the outer horn #{Î›[2,2]}
as identical to the subset of the square whose join is #{1}.
}

%```agda
\agda{
is-upper-located : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
is-upper-located = is-local (Î» (_ : ğŸ™) â†’ Î›[2,2]-incl)
}
%```
}


\subtree[stt-00DV]{
\title{Disjunctive types are upper located}
\taxon{Lemma}

\proof{
\p{
By sum-closure, disjunctive types are local at the inclusion of
#{Î£_{(i\,j:Î”Â¹)}((i âˆ¨ j ï¼ 1) âˆ§ ((i = 1) âˆ¨ (j ï¼ 1)))} into
#{Î£_{(i\,j:Î”Â¹)}(i âˆ¨ j ï¼ 1)}, which is equivalent to the inclusion of #{Î›[2,2]}
into #{âˆ¨Â²}.
}
}

%```agda
\agda{
disj-is-upper-located : âˆ€ {ğ“¤} {A : Type ğ“¤}
                      â†’ is-disjunctive A â†’ is-upper-located A
disj-is-upper-located {_}{A} disj tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-equiv _ _ amap amap-is-eqv !
        (left-orthogonal-Î£ _ !
          (is-orthogonalâ‡”orthogonal-! .snd
          âˆ˜ (is-localâ†is-null disj)))) where

  amap : Arrow-map (total-map (Î» _ â†’ !)) Î›[2,2]-incl
  amap .Arrow-map.top = Î›[2,2]â†Î›[2,2]'
  amap .Arrow-map.bot = fst
  amap .Arrow-map.comm (((i , j) , p) , d)
    = Î£-pathâ†’ (refl , is-prop-separated _ _ _ _)

  amap-is-eqv : is-Arrow-equiv amap
  amap-is-eqv .fst = Î›[2,2]â†Î›[2,2]'-is-equiv
  amap-is-eqv .snd = singleton-fst-is-equiv (Î» _ â†’ ğŸ™-is-singleton)
}
%```
}


\subtree[stt-00DW]{
\title{Simplicial types are disjunctive}
\taxon{Lemma}

\p{
We call a type [simplicial](stt-00AB) if it is null at #{((i â‰¤ j) * (j â‰¤ i))}
for all #{i\,j:Î”Â¹}. We show that every simplicial type is disjunctive.
}

\proof{
\p{
If #{P} implies #{Q} then #{P}-null types are #{Q}-null, so it suffices to show
that #{((i â‰¤ j) * (j â‰¤ i))} implies #{i = 1} or #{j = 1} for all #{i} and #{j}
such that #{(i âˆ¨ j) = 1}.
}
}

%```agda
\agda{
disjâ†simp-over-âˆ¨Â² : (x : âˆ¨Â²)
                  â†’ fam-is-simplicial (fst x) â†’ fam-is-disjunctive x
disjâ†simp-over-âˆ¨Â² ((i , j) , p)
  = *-prop-rec
      (*-is-prop (is-prop-separated _ _) (is-prop-separated _ _))
      (Î» ij â†’ Î¹â‚‚ (sym (â‰¤-max ij) âˆ™ p))
      (Î» ji â†’ Î¹â‚ (sym (â‰¤-max ji) âˆ™ sym âˆ¨-comm âˆ™ p))

disjâ†’simp-over-âˆ¨Â² : (x : âˆ¨Â²)
                  â†’ fam-is-disjunctive x â†’ fam-is-simplicial (fst x)
disjâ†’simp-over-âˆ¨Â² ((i , j) , _)
  = *-prop-rec
      (*-is-prop â‰¤-is-prop â‰¤-is-prop)
      (Î» pi â†’ Î¹â‚‚ (tr (j â‰¤_) (sym pi) â‰¤-top))
      (Î» pj â†’ Î¹â‚ (tr (i â‰¤_) (sym pj) â‰¤-top))

disjâ†simp-over-âˆ¨Â²-is-equiv
  : (x : âˆ¨Â²) â†’ is-equiv (disjâ†simp-over-âˆ¨Â² x)
disjâ†simp-over-âˆ¨Â²-is-equiv x@((i , j) , _)
  = is-equivâ†inverse
      (*-is-prop â‰¤-is-prop â‰¤-is-prop)
      (*-is-prop (is-prop-separated _ _) (is-prop-separated _ _))
      (disjâ†’simp-over-âˆ¨Â² x)

simp-is-disjunctive : âˆ€ {ğ“¤} {A : Type ğ“¤}
                    â†’ is-simplicial A â†’ is-disjunctive A
simp-is-disjunctive {_}{A} simp
  = is-nullâ†is-local
      (is-local-equiv amap amap-is-eqv
        (is-localâ†is-null simp-over-âˆ¨Â²)) where

  simp-over-âˆ¨Â² : is-null (fam-is-simplicial âˆ˜ fst) A
  simp-over-âˆ¨Â² x = simp (fst x)

  amap : (x : âˆ¨Â²)
       â†’ Arrow-map (! {A = fam-is-simplicial (fst x)})
                   (! {A = fam-is-disjunctive x})
  amap x .Arrow-map.top = disjâ†simp-over-âˆ¨Â² x
  amap x .Arrow-map.bot = id
  amap x .Arrow-map.comm = ~refl

  amap-is-eqv : âˆ€ x â†’ is-Arrow-equiv (amap x)
  amap-is-eqv x .fst = disjâ†simp-over-âˆ¨Â²-is-equiv x
  amap-is-eqv x .snd = id-is-equiv
}
%```
}


\subtree[stt-00DX]{
\title{Simplicial types are upper located}
\taxon{Corollary}

%```agda
\agda{
simp-is-upper-located : âˆ€ {ğ“¤} {A : Type ğ“¤}
                      â†’ is-simplicial A â†’ is-upper-located A
simp-is-upper-located = disj-is-upper-located âˆ˜ simp-is-disjunctive
}
%```
}
