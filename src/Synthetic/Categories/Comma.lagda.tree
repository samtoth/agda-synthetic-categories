\title{Comma types}
\taxon{Module}
\author{samueltoth}
\date{2025-12-09}

\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Comma
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Core.Orthogonal
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection
open import Core.FunctorialPullback
open import Core.Slice

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.NaturalTransformation Î”Â¹ I I-distr
}
%```

\subtree[stt-00C1]{
\title{Right cones over a cospan}
\taxon{Definition}

\p{Given a [cospan diagram](stt-0039) #{S}, we consider the right cones over #{S}.
This is analogous to the type of [cones over #{S}](stt-003A) but with the filler now
being a morphism, not a path.}

%```agda
\agda{
record Right-cone {ğ“¤ ğ“¥ ğ“¦} (S : Cospan ğ“¤ ğ“¥ ğ“¦) {ğ“›} (Carrier : Type ğ“›)
  : Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›) where
  constructor mk-right-cone
  open Cospan S
  field
    p : Carrier â†’ Left
    q : Carrier â†’ Right
    filler : âˆ€ (a : Carrier) â†’ Hom Centre (left (p a)) (right (q a))
}
%```
}


\subtree[stt-00C2]{
\title{Comma cones}
\taxon{Definition}

\p{Again analogously to undirected pullbacks, for any lax cone #{C} over a cospan
#{S}, we can define a canonical map #{(Q \to C) \to \mathrm{Cone}_S(Q)}.
We call #{C} a (right) comma cone when this map is an equivalence.}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {S : Cospan ğ“¤ ğ“¥ ğ“¦} {ğ“›} {Carrier : Type ğ“›} where
  right-cone-map : Right-cone S Carrier
               â†’ âˆ€ {ğ“ } {Q : Type ğ“ } â†’ (Q â†’ Carrier) â†’ Right-cone S Q
  right-cone-map cone f = mk-right-cone (p âˆ˜ f) (q âˆ˜ f) (filler âˆ˜ f) where
    open Right-cone cone

  is-comma-cone : Right-cone S Carrier â†’ TypeÏ‰
  is-comma-cone cone
    = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-equiv (right-cone-map cone {ğ“ }{Q})
}
%```
}

\subtree[stt-00C3]{
\title{Canonical comma types}
\taxon{Construction}

\p{The comma type of a [cospan diagram](stt-0039) is written
#{f \downarrow g}. It can be constructed as the type:}

##{\Sigma_{a : A} \Sigma_{c : C} \Hom_B(f(a), g(c))}


%```agda
\agda{
_â†“_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : A â†’ B) (g : C â†’ B) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
f â†“ g = Î£[ a âˆ¶ _ ] Î£[ c âˆ¶ _ ] Hom _ (f a) (g c)

â†“-cone : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : A â†’ B) (g : C â†’ B) â†’ Right-cone (mk-cospan _ f g) (f â†“ g)
â†“-cone f g = mk-right-cone fst (fst âˆ˜ snd) (snd âˆ˜ snd)

â†“-is-comma-cone
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {f : A â†’ B} {g : C â†’ B}
    â†’ is-comma-cone (â†“-cone f g)
â†“-is-comma-cone = is-equivâ†qiso qiso where
  open Right-cone
  qiso : quasi-iso (right-cone-map (â†“-cone _ _))
  qiso .fst cone x = (cone .p x , cone .q x , cone .filler x)
  qiso .snd .fst = ~refl
  qiso .snd .snd = ~refl
}
%```
}

\subtree[stt-00C4]{
\title{Slice and coslice categories as lax pullbacks}
\taxon{Example}

\p{A common example of a comma category is a slice category. Given a type
#{C} and #{c}, an object of #{C}, we consider the category #{C/c} of which
the objects consists of pairs of objects of #{C} together with maps into #{c}.
}

\p{We generalise this notation slightly, to consider any diagram
#{F : \mathcal{I}\to C}, which gives rise to the slice category #{C/F} for which
the objects consists of pairs of objects of #{c}, now with a natural transformation
#{\Delta_c \to F}. This type #{C/F} is the lax pullback of the following diagram:}

\quiver{
\begin{tikzcd}[cramped]
	{C/F} && C \\
	\\
	1 && {C^I}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=3-3]
	\arrow["\Delta", from=1-3, to=3-3]
	\arrow["F"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{We retain the original notion of slice category by taking the slice of an
object #{c} considered as a function #{1 \to C}.}

%```agda
\agda{
Slice : âˆ€ {ğ“¤ ğ“¥} (C : Type ğ“¤) {I : Type ğ“¥} (F : I â†’ C) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
Slice C f = Î£[ c âˆ¶ C ] âˆ€ i â†’ Hom _ c (f i)

Slice-cone : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥}
           (F : I â†’ C) â†’ Right-cone (mk-cospan _ (const C I) (const _ ğŸ™ F)) (Slice _ F)
Slice-cone F .Right-cone.p (c , _) = c
Slice-cone F .Right-cone.q (c , g) = tt
Slice-cone F .Right-cone.filler (_ , f) = Homâ†NT f

Slice-is-comma : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} (F : I â†’ C)
                    â†’ is-comma-cone (Slice-cone F)
Slice-is-comma F = is-equivâ†qiso qiso where
  qiso : quasi-iso (right-cone-map (Slice-cone F))
  qiso .fst cone x = (cone .Right-cone.p x , NTâ†Hom (cone .Right-cone.filler x))
  qiso .snd .fst f = funextâ†’ (Î» q â†’ Î£-pathâ†’ (refl , _â‰ƒ_.Îµ NTâ‰ƒHom (f q .snd)))
  qiso .snd .snd c = ap (mk-right-cone (Right-cone.p c) (Î» _ â†’ tt))
                        (funextâ†’ (_â‰ƒ_.Î· NTâ‰ƒHom âˆ˜ Right-cone.filler c))


Coslice : âˆ€ {ğ“¤ ğ“¥} (C : Type ğ“¤) {I : Type ğ“¥} (F : I â†’ C) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
Coslice C f = Î£[ c âˆ¶ C ] âˆ€ i â†’ Hom _ (f i) c

Coslice-cone
  : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥}
      (F : I â†’ C)
    â†’ Right-cone (mk-cospan _ (const _ ğŸ™ F) (const C I)) (Coslice C F)
Coslice-cone F .Right-cone.p = !
Coslice-cone F .Right-cone.q (c , _) = c
Coslice-cone F .Right-cone.filler (_ , Î±) = Homâ†NT Î±

Coslice-is-comma : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} (F : I â†’ C)
                    â†’ is-comma-cone (Coslice-cone F)
Coslice-is-comma F = is-equivâ†qiso qiso where
  qiso : quasi-iso (right-cone-map (Coslice-cone F))
  qiso .fst cone x = (cone .Right-cone.q x , NTâ†Hom (cone .Right-cone.filler x))
  qiso .snd .fst f =  funextâ†’ (Î» q â†’ Î£-pathâ†’ (refl , _â‰ƒ_.Îµ NTâ‰ƒHom (f q .snd)))
  qiso .snd .snd c =  ap (mk-right-cone _ (Right-cone.q c))
                        (funextâ†’ (_â‰ƒ_.Î· NTâ‰ƒHom âˆ˜ Right-cone.filler c))


Slice-path
  : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
  â†’ Slice C F â†’ Slice C F â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
Slice-path a b
  = Î£[ p âˆ¶ (a .fst ï¼ b .fst) ]
       (âˆ€ i â†’ Hom-pathP p refl (a .snd i) (b .snd i))

Slice-path-refl
  : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
    â†’ (F : Slice C F) â†’ Slice-path F F
Slice-path-refl F
  = (refl , Î» i â†’ Hom-pathP-refl)

opaque
  Slice-path-is-torsorial
    : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
      â†’ (F : Slice C F) â†’ is-singleton (Î£ _ (Slice-path F))
  Slice-path-is-torsorial F
    = is-singleton-structureâ†parts
        Sing-is-singleton
        (_ , refl)
        (SingS-is-single â¦ƒ IdS-Î  â¦ƒ Hom-IdSP â¦„ â¦„ _)

instance
  Slice-IdS
    : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
      â†’ Identity-system (Slice C F) (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
  Slice-IdS .Identity-system.IdS = Slice-path
  Slice-IdS .Identity-system.IdSâ†Id refl = Slice-path-refl _
  Slice-IdS .Identity-system.has-is-ids a
    = fundamental-Id _ (Slice-path-is-torsorial _) _

Coslice-path
  : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
  â†’ Coslice C F â†’ Coslice C F â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
Coslice-path a b
  = Î£[ p âˆ¶ (a .fst ï¼ b .fst) ]
       (âˆ€ i â†’ Hom-pathP refl p (a .snd i) (b .snd i))

Coslice-path-refl
  : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
  â†’ (p : Coslice C F) â†’ Coslice-path p p
Coslice-path-refl a = (refl , Î» _ â†’ Hom-pathP-refl)

opaque
  Coslice-path-is-torsorial
    : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
      â†’ (F : Coslice C F) â†’ is-singleton (Î£ _ (Coslice-path F))
  Coslice-path-is-torsorial F
    = is-singleton-structureâ†parts
        Sing-is-singleton
        (_ , refl)
        (SingS-is-single â¦ƒ IdS-Î  â¦ƒ Hom-IdSP â¦„ â¦„ _)

instance
  Coslice-IdS
    : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
      â†’ Identity-system (Coslice C F) (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
  Coslice-IdS .Identity-system.IdS = Coslice-path
  Coslice-IdS .Identity-system.IdSâ†Id refl = Coslice-path-refl _
  Coslice-IdS .Identity-system.has-is-ids a
    = fundamental-Id _ (Coslice-path-is-torsorial a) _

opaque
  Coslice-pathâ†’
    : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C}
    â†’ {x y : Coslice C F}
    â†’ Coslice-path x y â†’ x ï¼ y
  Coslice-pathâ†’ = Idâ†IdS â¦ƒ Coslice-IdS â¦„

  Coslice-path-ap-fst
    : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} {F : I â†’ C} {a b : Coslice C F}
      â†’ (p : Coslice-path a b) â†’ ap fst (Coslice-pathâ†’ p) ï¼ fst p
  Coslice-path-ap-fst
    = IdSJ â¦ƒ Coslice-IdS â¦„ (Î» x â†’ ap fst (Idâ†IdS (x .snd)) ï¼ fst (x .snd))
           (ap (ap fst) (Idâ†IdSâ†Id refl))
}
%```
}

\subtree[stt-00CG]{
\title{Paths in comma types}

%```agda
\agda{
Comma-path
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {a : Type ğ“¤} {b : Type ğ“¥} {c : Type ğ“¦}
      {f : a â†’ b} {g : c â†’ b}
    â†’ (x y : f â†“ g) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“˜)
Comma-path {f = F} {g = G} (a , b , f) (a' , b' , f')
  = Î£[ p âˆ¶ a ï¼ a' ] Î£[ q âˆ¶ b ï¼ b' ] Hom-pathP (ap F p) (ap G q) f f'

Comma-path-refl
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {a : Type ğ“¤} {b : Type ğ“¥} {c : Type ğ“¦}
      {f : a â†’ b} {g : c â†’ b}
    â†’ {x : f â†“ g} â†’ Comma-path x x
Comma-path-refl = (refl , refl , Hom-pathP-refl)

opaque
  Comma-path-is-torsorial
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {a : Type ğ“¤} {b : Type ğ“¥} {c : Type ğ“¦}
        {f : a â†’ b} {g : c â†’ b}
      â†’ {x : f â†“ g} â†’ is-singleton (Î£ (f â†“ g) (Comma-path x))
  Comma-path-is-torsorial
    = is-singleton-structureâ†parts
        Sing-is-singleton
        (_ , refl)
        (is-singleton-structureâ†parts
          Sing-is-singleton
          (_ , refl)
          Hom-pathP-is-torsorial)

instance
  IdS-Comma
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {a : Type ğ“¤} {b : Type ğ“¥} {c : Type ğ“¦}
        {F : a â†’ b} {G : c â†’ b} â†’ Identity-system (F â†“ G) (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
  IdS-Comma .Identity-system.IdS = Comma-path
  IdS-Comma .Identity-system.IdSâ†Id refl = Comma-path-refl
  IdS-Comma .Identity-system.has-is-ids x
    = fundamental-Id _ Comma-path-is-torsorial _
}
%```
}

\subtree[stt-00CF]{
\title{Comma types are functorial in their cospan}
\taxon{Construction}


%```agda
\agda{
Commaâ‚€ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} â†’ Cospan ğ“¤ ğ“¥ ğ“¦ â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“˜)
Commaâ‚€ C = left â†“ right where open Cospan C

Commaâ‚ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
           {S : Cospan ğ“¤ ğ“¥ ğ“¦} {T : Cospan ğ“¤' ğ“¥' ğ“¦'}
         â†’ Cospan-map S T â†’ Commaâ‚€ S â†’ Commaâ‚€ T
Commaâ‚ F (x , y , h)
  = (hâ‚ x , hâ‚ƒ y , adjust-hom (H x) (K y) (ap-hom hâ‚‚ h))
  where open Cospan-map F

Comma-id
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Cospan ğ“¤ ğ“¥ ğ“¦}
    â†’ Commaâ‚ (id-cospan-map {S = S}) ~ id
Comma-id (x , y , f) = ext!
  (refl , refl
  , (~refl
    , Square-degen-vert _ _ (âˆ™-reflr _ âˆ™ ap-id _)
    , Square-degen-vert _ _ (âˆ™-reflr _ âˆ™ ap-id _)))

Comma-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' ğ“¤'' ğ“¥'' ğ“¦''}
      {A : Cospan ğ“¤ ğ“¥ ğ“¦} {B : Cospan ğ“¤' ğ“¥' ğ“¦'} {C : Cospan ğ“¤'' ğ“¥'' ğ“¦''}
      (F : Cospan-map B C) (G : Cospan-map A B)
    â†’ Commaâ‚ (cospan-map-compose F G) ~ Commaâ‚ F âˆ˜ Commaâ‚ G
Comma-âˆ˜ F G (x , y , f) = ext!
  (refl , refl
  , ( ~refl
    , (Square-degen-vert _ _
        (âˆ™.pullr _
          {a = ap (F .hâ‚‚) (G .H x)}
          {b = ap (F .hâ‚‚ âˆ˜ G .hâ‚‚) (f .hom0)}
          {c = ap (F .hâ‚‚) _}
          (ap (_âˆ™ ap (F .hâ‚‚) (G .H x)) (ap-âˆ˜ (F .hâ‚‚) (G .hâ‚‚) (f .hom0))
          âˆ™ sym (ap-âˆ™ (F .hâ‚‚) _ (G .H x)))))
    , Square-degen-vert _ _
        (âˆ™.pullr _
          {a = ap (hâ‚‚ F) (G .K y)}
          {b = ap (F .hâ‚‚ âˆ˜ G .hâ‚‚) (f .hom1)}
          {c = ap (F .hâ‚‚) (ap (G .hâ‚‚) _ âˆ™ G .K y)}
          ((ap (_âˆ™ ap (F .hâ‚‚) (G .K y)) (ap-âˆ˜ (F .hâ‚‚) (G .hâ‚‚) (f .hom1))
          âˆ™ sym (ap-âˆ™ (F .hâ‚‚) _ (G .K y)))))))
  where
  open Cospan-map
  open HomP
}
%```
}

\subtree[stt-00CJ]{
\title{Functoriality of the slice construction}
\taxon{Corollary}

\p{The functoriality of somewhat of the (co)slice construction is somewhat
more subtle to express. The operation #{-_{/-}} can be considered a functor
#{\Sigma_{A : \UU}((\UU_{/A})^{op}) \to \UU}. In the first argument, we can express
functoriality as follows: given a map #{f : A \to B}, there is a function
#{f_{/p} : A_{/p} \to B_{/fp}}. In the second argument, we fix a type #{A},
and consider a pair of arrows into #{A}, #{p} and #{q}. Now a
[map in the slice](Core.Slice) #{t : p \to q} determines a function #{A_{/q} \to A_{/p}}
(note the contravariance). We also provide a bespoke function for the trivial
slice map, for any #{t : K \to L}, we have #{(pt \xrightarrow{t} p) \mapsto
#{A_{/p} \to A_{/pt}}}, we also
refer to this as (co)slice postcomposition.}

%```agda
\agda{
postcompose-slice
  : âˆ€ {ğ“¤ ğ“¥ ğ“š} {A : Type ğ“¤} {K : Type ğ“š} (p : K â†’ A)
      {B : Type ğ“¥} (f : A â†’ B)
    â†’ Slice A p â†’ Slice B (f âˆ˜ p)
postcompose-slice p f (a , h) = (f a , ap-hom f âˆ˜ h)

postcompose-coslice
  : âˆ€ {ğ“¤ ğ“¥ ğ“š} {A : Type ğ“¤} {K : Type ğ“š} (p : K â†’ A)
      {B : Type ğ“¥} (f : A â†’ B)
    â†’ Coslice A p â†’ Coslice B (f âˆ˜ p)
postcompose-coslice p f (a , h) = (f a , ap-hom f âˆ˜ h)

slice-map-slice
  : âˆ€ {ğ“¤ ğ“š ğ“š'} {A : Type ğ“¤}
      {K : Type ğ“š} (p : K â†’ A)
      {K' : Type ğ“š'} (q : K' â†’ A)
      (t : Slice-map p q)
    â†’ Slice A q â†’ Slice A p
slice-map-slice p q (t , H) (a , h) = (a , adjust-hom refl (H _) âˆ˜ h âˆ˜ t)

precompose-slice
  : âˆ€ {ğ“¤ ğ“š ğ“š'} {A : Type ğ“¤}
      {K : Type ğ“š} (p : K â†’ A)
      {K' : Type ğ“š'} (t : K' â†’ K)
    â†’ Slice A p â†’ Slice A (p âˆ˜ t)
precompose-slice p t (a , h) = (a , h âˆ˜ t)

coslice-map-slice
  : âˆ€ {ğ“¤ ğ“š ğ“š'} {A : Type ğ“¤}
      {K : Type ğ“š} (p : K â†’ A)
      {K' : Type ğ“š'} (q : K' â†’ A)
      (t : Slice-map q p)
    â†’ Coslice A p â†’ Coslice A q
coslice-map-slice p q (t , H) (a , h) = (a , adjust-hom (H _) refl âˆ˜ h âˆ˜ t)

precompose-coslice
  : âˆ€ {ğ“¤ ğ“š ğ“š'} {A : Type ğ“¤}
      {K : Type ğ“š} (p : K â†’ A)
      {K' : Type ğ“š'} (t : K' â†’ K)
    â†’ Coslice A p â†’ Coslice A (p âˆ˜ t)
precompose-coslice p t (a , h) = (a , h âˆ˜ t)
}
%```
}
