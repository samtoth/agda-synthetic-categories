\date{2025-07-30}
\title{Coequalisers}
\taxon{module}
\meta{module}{Core.Coequalisers}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
module Core.Coequalisers where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Postwhisker
open import Core.PushoutEquiv
open import Ergonomics.Representation

Fork : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
       → (f g : A → B) → (C : Type 𝓦) → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦)
Fork {B = B} f g C = Σ[ p ∶ (B → C) ] (p ∘ f ~ p ∘ g)

fork-map : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
         → {f g : A → B} → {C : Type 𝓦}
         → Fork f g C → ∀ {𝓠} {Q : Type 𝓠}
         → (C → Q) → Fork f g Q
fork-map (p , H) f = (f ∘ p , f ◂ H)

is-coeq : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
            {f g : A → B} {C : Type 𝓦}
          → Fork f g C → Typeω
is-coeq f = ∀ {𝓠} {Q : Type 𝓠} → is-equiv (fork-map f {𝓠} {Q})


Coeq : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
       → (f g : A → B) → Type (𝓤 ⊔ 𝓥)
Coeq {_} {_} {A} {B} f g
  = Pushout l r  module Coeq where
  l : B ⊎ A → B
  l (inl x) = x
  l (inr x) = f x

  r : B ⊎ A → B
  r (inl x) = x
  r (inr x) = g x

  span : Span _ _ _
  span = mk-span _ l r

{-# DISPLAY Pushout (Coeq.l f g) (Coeq.r f g) = Coeq f g #-}

coeq : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
       → (f g : A → B) → Fork f g (Coeq f g)
coeq f g = (ι₂ , λ x → sym (glue (inl (f x))) ∙ glue (inr x))

ι-coeq : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
         → {f g : A → B}
         → B → Coeq f g
ι-coeq = coeq _ _ .fst

glue-coeq : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
            → {f g : A → B}
            → ι-coeq ∘ f ~ ι-coeq ∘ g
glue-coeq = coeq _ _ .snd


cocone←fork : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                {f g : A → B} {C : Type 𝓦}
              → Fork f g C → Cocone (Coeq.span f g) C
cocone←fork {f = f} {g} (p , H) = mk-cocone p p (⊎-ind (~refl , H))

fork←cocone : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                {f g : A → B} {C : Type 𝓦}
              → Cocone (Coeq.span f g) C → Fork f g C
fork←cocone {f = f} {g} (mk-cocone p q filler)
  = p , λ a → filler (inr a) ∙ sym (filler (inl (g a)))

cocone≃fork : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                {f g : A → B} {C : Type 𝓦}
              → Fork f g C ≃ Cocone (Coeq.span f g) C
cocone≃fork {B = B} {f} {g}{C}
  = Fork f g C
      ≃⟨⟩
    (Σ[ p ∶ (B → C)] (p ∘ f ~ p ∘ g))
      ≃⟨ Σ-ap-≃ (λ _ → Σ-＝singl') e⁻¹ ⟩
    (Σ[ p ∶ (B → C)] Σ[ q ∶ (B → C)] ((p ＝ q) × (p ∘ f ~ q ∘ g)))
      ≃⟨ Σ-ap-≃ (λ p → Σ-ap-≃ (λ q → Σ-ap-≃-fst funext≃)) ⟩
    (Σ[ p ∶ (B → C)] Σ[ q ∶ (B → C)] ((p ~ q) × (p ∘ f ~ q ∘ g)))
      ≃⟨ Σ-ap-≃ (λ p → Σ-ap-≃ (λ q → ⊎-UP≃ global-funext)) ⟩
    (Σ[ p ∶ (B → C)] Σ[ q ∶ (B → C)] (p ∘ Coeq.l f g ~ q ∘ Coeq.r f g))
      ≃⟨ cocone-repr≃ e⁻¹ ⟩
    Cocone (Coeq.span f g) C ≃∎

cocone←fork-is-equiv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                {f g : A → B} {C : Type 𝓦}
                → is-equiv (cocone←fork {f = f} {g} {C})
cocone←fork-is-equiv = cocone≃fork ._≃_.has-is-eqv

coeq-is-coeq : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
                 {f g : A → B} → is-coeq (coeq f g)
coeq-is-coeq {f = f} {g} {Q = Q}
  = 3-for-2~ (H ~⁻¹)
             (cocone≃fork ._≃_.has-is-eqv)
             (Pushout-is-pushoutω) where
  H : cocone←fork ∘ fork-map (coeq f g) {Q = Q}
    ~ cocone-map (Coeq.span f g) pushout
  H f = Cocone-path→ _ _ (funext→ (f ◂ (glue ~⁻¹) ▸ inl)) refl λ where
    (inl x) → sym ( ap (_∙ ap f (glue (inl x))) (ap-sym f (glue (inl x)))
                   ∙ ∙-sym' (ap f (glue _)))
    (inr x) → ∙-reflr _ ∙ ap-∙ f (sym (glue _)) (glue (inr x))


coeq-rec : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
             {f g : A → B} {C : Type 𝓦}
           → Fork f g C
           → Coeq f g → C
coeq-rec = is-equiv.bwd coeq-is-coeq

coeq-rec-is-equiv
  : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
      {f g : A → B} {C : Type 𝓦}
    → is-equiv (coeq-rec {f = f}{g}{C})
coeq-rec-is-equiv
  = is-equiv-∘ pushout-rec-is-equiv cocone←fork-is-equiv


module _ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {f g : A → B}
         {C : Type 𝓦} (cf : Fork f g C) where
  private
    H : ∀ {𝓠}{Q : Type 𝓠}
      → cocone-map (Coeq.span f g) (cocone←fork cf) {Q}
      ~ cocone←fork ∘ fork-map cf
    H f = Cocone-path→ _ _ refl refl (⊎-ind (~refl , (~∙-reflr _)))

  is-coeq←is-pushout : is-pushoutω (Coeq.span f g) (cocone←fork cf)
                       → is-coeq cf
  is-coeq←is-pushout po = 3-for-2~ H (cocone≃fork ._≃_.has-is-eqv) po

  is-pushout←is-coeq : is-coeq cf
                     → is-pushoutω (Coeq.span f g) (cocone←fork cf)
  is-pushout←is-coeq coe
    = is-equiv~∘ H (cocone≃fork ._≃_.has-is-eqv) coe

cogap-is-equiv←is-coeq
  : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {f g : A → B} {C : Type 𝓦}
      {cf : Fork f g C} → is-coeq cf → is-equiv (coeq-rec cf)
cogap-is-equiv←is-coeq {cf = cf} ce
  = cogap-is-equiv←is-pushout (cocone←fork cf)
                              (is-pushout←is-coeq cf ce)

is-coeq←cogap-is-equiv
  : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {f g : A → B} {C : Type 𝓦}
      {cf : Fork f g C} → is-equiv (coeq-rec cf) → is-coeq cf
is-coeq←cogap-is-equiv {cf = cf} ce
  = is-coeq←is-pushout cf (is-pushout←cogap _ ce)
}
%```

%```agda
\agda{
ForkP : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
          (f g : A → B) (C : Coeq f g → Type 𝓦)
        → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦)
ForkP {A = A} {B} f g C
  =  Σ[ p ∶ ((b : B) →  C (ι₂ b))]
      (∀ a → IdP (ap C (coeq f g .snd a)) (p (f a)) (p (g a)))

cocone←forkP : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                {f g : A → B} {C : Coeq f g → Type 𝓦}
              → ForkP f g C
              → CoconeD (Coeq.span f g) (cocone←fork (coeq f g)) C
cocone←forkP {f = f} {g} (p , H)
  = mk-coconeD p p (⊎-ind (~refl , H))

unquoteDecl coconeD-repr≅ coconeD-repr≃
  = make-record-repr coconeD-repr≅ coconeD-repr≃ (quote CoconeD)

cocone≃forkP : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                {f g : A → B} {C : Coeq f g → Type 𝓦}
              → ForkP f g C ≃ CoconeD (Coeq.span f g) (cocone←fork (coeq f g)) C
cocone≃forkP {B = B} {f} {g}{C}
  = ForkP f g C
      ≃⟨⟩
    (Σ[ p ∶ (Π B (C ∘ ι₂))] (p ∘ f ~[ (C ◂ (coeq f g .snd)) ] p ∘ g))
      ≃⟨  Σ-ap-≃ (λ p → Σ-＝singl') e⁻¹ ⟩
    (Σ[ p ∶ (Π B (C ∘ ι₂))] Σ[ q ∶ Π B (C ∘ ι₂)] ((p ＝ q) × (p ∘ f ~[ C ◂ (coeq f g .snd) ] q ∘ g)))
      ≃⟨  Σ-ap-≃ (λ p → Σ-ap-≃ (λ q → Σ-ap-≃-fst funext≃))  ⟩
    (Σ[ p ∶ Π B (C ∘ ι₂)] Σ[ q ∶ Π B (C ∘ ι₂)] ((p ~ q) × (p ∘ f ~[ C ◂ (coeq f g .snd) ] q ∘ g)))
      ≃⟨  Σ-ap-≃ (λ p → Σ-ap-≃ (λ q → ⊎-UP≃ global-funext)) ⟩
    (Σ[ p ∶ Π B (C ∘ ι₂)] Σ[ q ∶ Π B (C ∘ ι₂)] (p ∘ Coeq.l f g ~[ (C ◂ ⊎-ind (~refl , coeq f g .snd)) ] q ∘ Coeq.r f g))
      ≃⟨ coconeD-repr≃ e⁻¹ ⟩
    CoconeD (Coeq.span f g) _ C ≃∎

cocone←forkP-is-equiv
  : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
      {f g : A → B} {C : Coeq f g → Type 𝓦}
    → is-equiv (cocone←forkP {f = f} {g} {C})
cocone←forkP-is-equiv = cocone≃forkP ._≃_.has-is-eqv

forkP-map : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
              {f g : A → B} {C : Coeq f g → Type 𝓦}
            → Π _ C → ForkP f g C
forkP-map {C = C} f = (f ∘ ι₂ , f ◂ᵈ coeq _ _ .snd)

is-coeqᵈ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
             {f g : A → B} {C : Coeq f g → Type 𝓦}
           → is-equiv (forkP-map {C = C})
is-coeqᵈ {f = f}{g}{Q} = 3-for-2~ (H ~⁻¹) cocone←forkP-is-equiv coeq-is-po where
  H : cocone←forkP ∘ forkP-map {C = Q}
    ~ coconeᵈ-map (Coeq.span f g) (cocone←fork (coeq f g))  {Q = Q}
  H f = from-coconeᵈ-path (record {
      p＝ = refl
    ; q＝ = refl
    ; filler＝ = funext→ (⊎-ind (~refl , ~refl)) })

  lem : cocone←fork (coeq f g) ＝ pushout
  lem = Cocone-path→ _ _ (funext→ (λ b → sym (glue (inl b)))) refl
          (⊎-ind ((λ b → sym (∙-sym' (glue (inl b)))) , λ a → ∙-reflr _))

  coeq-is-po : is-pushoutωᵈ (Coeq.span f g) (cocone←fork (coeq f g))
  coeq-is-po {𝓜} = tr (λ x → ∀ {Q : Coeq f g → Type 𝓜} → is-equiv (coconeᵈ-map (Coeq.span f g) x {Q}))
                       (sym lem) Pushout-is-pushoutωᵈ

coeq-ind : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
             {f g : A → B} {C : Coeq f g → Type 𝓦}
           → ForkP f g C
           → (x : Coeq f g) → C x
coeq-ind = is-equiv.bwd is-coeqᵈ

{-# DISPLAY is-equiv.bwd is-coeqᵈ x = coeq-ind x #-}
}
%```

\subtree[stt-009D]{
\title{Adjusting equalizers by equivalences}

\p{We mirror the results in \ref{stt-0093} about pushouts.

Given a pair of maps #{f g : A \to B} and an equivalence #{e : A' \to A},
we show that a cofork coequalises of #{(f,g)} iff it coequalises
#{(fe,ge)}.}

%```agda
\agda{

precomp-cofork : ∀ {𝓤 𝓥 𝓦 𝓛} {A' : Type 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                   (f g : A → B)
                   (h : A' → A) {D : Type 𝓛}
                 → Fork f g D
                 → Fork (f ∘ h) (g ∘ h) D
precomp-cofork _ _ h = total-map λ f → _▸ h


precomp-cofork-is-equiv
  : ∀ {𝓤 𝓥 𝓦 𝓛} {A' : Type 𝓦} {A : Type 𝓤} {B : Type 𝓥}
      (f g : A → B) {h : A' → A} → is-equiv h
    → {D : Type 𝓛} → is-equiv (precomp-cofork f g h {D})
precomp-cofork-is-equiv f g heq {D}
  = is-total-equiv←is-fibrewise-equiv λ a → postwhisker-equiv-is-equiv heq

precomp-cofork-is-coeq
 : ∀ {𝓤 𝓥 𝓦 𝓛} {A' : Type 𝓦} {A : Type 𝓤} {B : Type 𝓥}
     {f g : A → B}
     {h : A' → A} → is-equiv h
   → {D : Type 𝓛}
   → {cf : Fork f g D}
   → is-coeq cf
   → is-coeq (precomp-cofork _ _ h cf)
precomp-cofork-is-coeq {f = f}{g}{h} heq {D} {cf} coeq
  = is-equiv-∘ (precomp-cofork-is-equiv _ _ heq) coeq


precomp-coeq≃ : ∀ {𝓤 𝓥 𝓦} {A' : Type 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                  {f g : A → B} {h : A' → A} → is-equiv h
                → Coeq (f ∘ h) (g ∘ h) ≃ Coeq f g
precomp-coeq≃ {f = f}{g}{h} heq
  = mk≃ map (cogap-is-equiv←is-coeq
              (precomp-cofork-is-coeq heq coeq-is-coeq)) where
  map : Coeq (f ∘ h) (g ∘ h) → Coeq f g
  map = coeq-rec (precomp-cofork f g h (coeq _ _))
}
%```

%```agda
\agda{
postcomp-cofork : ∀ {𝓤 𝓥 𝓦 𝓛} {A : Type 𝓤} {B : Type 𝓥} {B' : Type 𝓦}
                   (f g : A → B)
                   (h : B → B') {D : Type 𝓛}
                 → Fork (h ∘ f) (h ∘ g) D
                 → Fork f g D
postcomp-cofork f g h = total-map-fst (_∘ h)

postcomp-cofork-is-equiv
  : ∀ {𝓤 𝓥 𝓦 𝓛} {A : Type 𝓤} {B : Type 𝓥} {B' : Type 𝓦}
      (f g : A → B) {h : B → B'} → (heq : is-equiv h)
    → {D : Type 𝓛} → is-equiv (postcomp-cofork f g h {D})
postcomp-cofork-is-equiv f g {h} heq {D}
  = total-is-equiv←fst-is-equiv (postcomp-equiv heq)

postcomp-cofork-is-coeq
 : ∀ {𝓤 𝓥 𝓦 𝓛} {A : Type 𝓤} {B : Type 𝓥} {B' : Type 𝓦}
     {f g : A → B} {h : B → B'} → is-equiv h
   → {D : Type 𝓛}
   → {cf : Fork (h ∘ f) (h ∘ g) D}
   → is-coeq cf
   → is-coeq (postcomp-cofork _ _ h cf)
postcomp-cofork-is-coeq {f = f}{g}{h} heq {D} {cf} coeq
  = is-equiv-∘ (postcomp-cofork-is-equiv _ _ heq) coeq

postcomp-coeq≃ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {B' : Type 𝓦}
                  {f g : A → B} {h : B → B'} → is-equiv h
                → Coeq f g ≃ Coeq (h ∘ f) (h ∘ g)
postcomp-coeq≃ {f = f}{g}{h} heq
  = mk≃ map (cogap-is-equiv←is-coeq
              (postcomp-cofork-is-coeq heq coeq-is-coeq)) where
  map : Coeq f g → Coeq (h ∘ f) (h ∘ g)
  map = coeq-rec (postcomp-cofork f g h (coeq _ _))
}
%```
}

\subtree[stt-009J]{
\title{Coequalisers of homotopic maps}
\taxon{lemma}

%```agda
\agda{
module _ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f g h k : A → B}
         (H : f ~ h) (K : g ~ k) where
  Coeq≃←homotopy : Coeq h k ≃ Coeq f g
  Coeq≃←homotopy = Pushout≃←homotopy (⊎-ind (~refl , H))
                                     (⊎-ind (~refl , K))

precomp-coeq≃~ : ∀ {𝓤 𝓥 𝓦} {A' : Type 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                  {f g : A → B} {h : A' → A} (heq : is-equiv h)
                  {f' g' : A' → B} (H : f ∘ h ~ f') (K : g ∘ h ~ g')
                → Coeq f' g' ≃ Coeq f g
precomp-coeq≃~ {f = f}{g}{h} heq {f'}{g'} H K
  = Coeq f' g'           ≃⟨ Coeq≃←homotopy H K ⟩
    Coeq (f ∘ h) (g ∘ h) ≃⟨ precomp-coeq≃ heq ⟩
    Coeq f g ≃∎

postcomp-coeq≃~ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {B' : Type 𝓦}
                  {f g : A → B} {h : B → B'} (heq : is-equiv h)
                  {f' g' : A → B'} (H : f' ~ h ∘ f) (K : g' ~ h ∘ g)
                → Coeq f g ≃ Coeq f' g'
postcomp-coeq≃~ {f = f}{g}{h} heq {f'}{g'} H K
  = Coeq f g             ≃⟨ postcomp-coeq≃ heq ⟩
    Coeq (h ∘ f) (h ∘ g) ≃⟨ Coeq≃←homotopy H K ⟩
    Coeq f' g' ≃∎
}
%```
}
