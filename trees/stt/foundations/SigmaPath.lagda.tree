\date{2025-02-24}
\title{Characterising the Path Space of Sigma Types}

\import{stt-macros}

% ```agda
\agda{
module foundations.SigmaPath where

open import foundations.universe
open import foundations.Sigma
open import foundations.Identity
open import foundations.DependentIdentity
open import foundations.Functions
open import foundations.Homotopy
open import foundations.FunctionInverses
open import foundations.CoherentIsomorphism
open import foundations.QuasiIsomorphism
}
% ```


\subtree{
\taxon{theorem}

\p{Given two terms #{(x_1 , x_2) , (y_1 , y_2) : \Sigma_{(a:A)}B(a)}, we have #{(x_1,x_2) = (y_1,y_2) \simeq
\Sigma_{(p : x_1 = y_1)}(x_2 =_B^p y_2)}  }

}

% ```agda
\agda{
Î£-path : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {x y : Î£ A B} â†’ (Î£ (x .fst ï¼ y .fst) Î» p â†’ IdP B (x .snd) p (y .snd)) â‰ƒ (x ï¼ y)
Î£-path {x = x1 , x2} {y1 , y2} = qisoâ†’equiv (mk-iso to-path (from-path , ret , sec)) module Î£-path where
  to-path : Î£ (x1 ï¼ y1) (Î» p â†’ IdP _ x2 p y2) â†’ (x1 , x2) ï¼ (y1 , y2)
  to-path (refl , refl) = refl

  from-path : (x1 , x2) ï¼ (y1 , y2) â†’
            Î£ (x1 ï¼ y1) (Î» p â†’ IdP _ x2 p y2)
  from-path refl = refl , refl

  sec : section-witness to-path from-path
  sec refl = refl

  ret : retract-witness to-path from-path
  ret (refl , refl) = refl

Î£-pathâ†’ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {x y : Î£ A B} â†’ (Î£ (x .fst ï¼ y .fst) Î» p â†’ IdP B (x .snd) p (y .snd)) â†’ (x ï¼ y)
Î£-pathâ†’ = Î£-path ._â‰ƒ_.fwd

{-# DISPLAY Î£-path.to-path = Î£-pathâ†’ #-}

Î£-path-fst : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {x y : Î£ A B}
             â†’ x ï¼ y â†’ x .fst ï¼ y .fst
Î£-path-fst refl = refl             

Î£-path-snd : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {x y : Î£ A B}
           â†’ (p : x ï¼ y) â†’ IdP B (x .snd) (Î£-path-fst p) (y .snd)
Î£-path-snd refl = refl           

is-fibrewise-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {B' : A â†’ Type ğ“¦} â†’ (âˆ€ a â†’ B a â†’ B' a) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
is-fibrewise-equiv f = âˆ€ a â†’ is-equiv (f a) 

totalisation : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {B' : A â†’ Type ğ“¦}
               â†’ (f : âˆ€ a â†’ B a â†’ B' a) â†’ Î£ A B â†’ Î£ A B'
totalisation f (a , b) = (a , f a b)

is-fibrewise-equivâ†’is-total-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {B' : A â†’ Type ğ“¦} â†’ {f : âˆ€ a â†’ B a â†’ B' a}
                                  â†’ is-fibrewise-equiv f â†’ is-equiv (totalisation f)
is-fibrewise-equivâ†’is-total-equiv {f = f} feq = is-equivâ†qiso iso where
  module A x = is-equiv (feq x)
  open A

  iso : quasi-iso (totalisation f)
  iso .fst (a , b) = a , bwd a b
  iso .snd .fst (a , b) = Î£-pathâ†’ (refl , retract-fwd a .snd b)
  iso .snd .snd (a , b) = Î£-pathâ†’ (refl , section-fwd a .snd b)


Î£-ap-â‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {B' : A â†’ Type ğ“¦} â†’ ((a : A) â†’ B a â‰ƒ B' a) â†’  Î£ A B â‰ƒ Î£ A B'
Î£-ap-â‰ƒ eq = totalisation (_â‰ƒ_.fwd âˆ˜ eq) , is-fibrewise-equivâ†’is-total-equiv (_â‰ƒ_.has-is-eqv âˆ˜ eq)

Î£-ap-â‰ƒ-fst : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¥} {B : A â†’ Type ğ“¦} â†’ ((f , _) : A' â‰ƒ A) â†’ Î£ A' (B âˆ˜ f) â‰ƒ Î£ A B
Î£-ap-â‰ƒ-fst {A = A} {A'} {B} eq = func , is-equivâ†qiso the-iso where
  open _â‰ƒ_ eq

  func : Î£ _ (B âˆ˜ fwd) â†’ Î£ _ B
  func (a , b) = fwd a , b

  lem : {a : A'} {b : (B âˆ˜ fwd) a} â†’ 
      tr (B âˆ˜ fwd) (Î· a) (tr B (sym (Îµ (fwd a))) b) ï¼ b
  lem {a} {b} = tr (B âˆ˜ fwd) (Î· a) _                    ï¼âŸ¨ trâˆ˜ B fwd (Î· a) âŸ©
                tr B (ap fwd (Î· a)) _                   ï¼âŸ¨ ap (Î» p â†’ tr B p (tr B (sym (Îµ (fwd a))) b)) (coherent a) âŸ©
                tr B (Îµ (fwd a)) _                      ï¼âŸ¨ trâˆ™tr-sym' (Îµ (fwd a)) b âŸ©
                b âˆ
  
  the-iso : quasi-iso func
  the-iso .fst (a , b) = (bwd a , tr B (sym (Îµ a)) b)
  the-iso .snd .fst (a , b) = Î£-pathâ†’ (Î· a ,  lem) 
  the-iso .snd .snd (a , b) = Î£-pathâ†’ (Îµ a ,  trâˆ™tr-sym' (Îµ a) b)



Î£-assoc : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {C : (a : A) â†’ B a â†’ Type ğ“¦}
          â†’ Î£ (Î£ A B) (Î» x â†’ C (fst x) (snd x)) â‰ƒ Î£ A Î» a â†’ Î£ (B a) Î» b â†’ C a b
Î£-assoc {A = A} {B} {C} = qisoâ†’equiv iso where
  fwd : Î£ (Î£ A B) (Î» x â†’ C (fst x) (snd x)) â†’ Î£ A (Î» a â†’ Î£ (B a) (C a))
  fwd ((a , b) , c) = a , (b , c)

  iso : Î£ (Î£ A B) (Î» x â†’ C (fst x) (snd x)) â‰… Î£ A (Î» a â†’ Î£ (B a) (C a))
  iso ._â‰…_.fwd = fwd
  iso ._â‰…_.fwd-iso .fst (x , y , z) = (x , y) , z
  iso ._â‰…_.fwd-iso .snd .fst a = refl
  iso ._â‰…_.fwd-iso .snd .snd a = refl


Î£-singl : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a' : A} {B : (a : A) â†’ a ï¼ a' â†’ Type ğ“¥}
        â†’ Î£ A (Î» a â†’ Î£ (a ï¼ a') Î» p â†’ B a p) â‰ƒ B a' refl
Î£-singl {A = A} {a'} {B} = qisoâ†’equiv iso where
  iso : Î£ A (Î» a â†’ Î£ (a ï¼ a') (B a)) â‰… B a' refl
  iso ._â‰…_.fwd (.a' , refl , ba) = ba
  iso ._â‰…_.fwd-iso .fst ba = a' , refl , ba
  iso ._â‰…_.fwd-iso .snd .fst (.a' , refl , ba) = refl
  iso ._â‰…_.fwd-iso .snd .snd _ = refl


Î£-comm : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : A â†’ B â†’ Type ğ“¦}
         â†’ (Î£ A Î» a â†’ Î£ B (C a)) â‰ƒ (Î£ B Î» b â†’ Î£ A Î» a â†’ C a b)
Î£-comm {A = A} {B} {C} = f , is-equivâ†qiso iso where
  f : Î£ A (Î» a â†’ Î£ B (C a)) â†’ Î£ B (Î» b â†’ Î£ A (Î» a â†’ C a b))
  f (a , b , c) = b , a , c

  iso : quasi-iso f
  iso .fst (b , a , c) = a , b , c
  iso .snd .fst _ = refl
  iso .snd .snd _ = refl
}
% ```
