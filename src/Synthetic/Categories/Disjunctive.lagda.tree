\date{2026-02-09}
\title{Disjunctive types}
\author{fredrikbakke}
\taxon{Module}
\import{stt-macros}

\subtree[fre-0000]{
\taxon{Remark}
\p{This module, as almost all in \code{Synthetic.Categories}, assumes a
type #{\Delta^1} with a distributive lattice structure, we
call this type the generic interval.}
}


%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Disjunctive
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I
  âˆ¨Â² = Î£ (Î”Â¹ Ã— Î”Â¹) (Î» (i , j) â†’ (i âˆ¨ j ï¼ i1))

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Core.Join
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CanonicalPushouts
open import Core.PushoutEquiv
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.FlatteningPushouts

open import Ergonomics.Extensionality
open import Ergonomics.Auto

open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
  using (is-simplicial; fam-is-simplicial)
}
%```


\subtree[fre-0001]{
\taxon{Definition}
\title{Disjunctive types}

\p{
The generic interval is not necessarily \em{disjunctive}, in the sense that 
for all #{i} and #{j} such that #{i âˆ¨ j = 1} we have #{i = 1} or #{j = 1}. 
Instead, we can speak of particular types which \em{'see'} the interval as being 
disjunctive. This can be made precise by asking for types which are 
[null](stt-005G) with respect to the family of propositions
#{(i = 1) \lor (j = 1)} for all #{i} and #{j} such that #{i âˆ¨ j = 1}. Let #{âˆ¨Â²} 
be the type of elements #{i} and #{j} such that #{i âˆ¨ j = 1}.
}

%```agda
\agda{
fam-disjunctive : Î”Â¹ Ã— Î”Â¹ â†’ Type ğ“˜
fam-disjunctive (i , j) = (i ï¼ i1) * (j ï¼ i1)

fam-is-disjunctive : âˆ¨Â² â†’ Type ğ“˜
fam-is-disjunctive = fam-disjunctive âˆ˜ fst

is-disjunctive : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
is-disjunctive = is-null fam-is-disjunctive
}

\p{
By virtue of being defined in terms of nullification at a proposition, we
know that disjunctive types form a lex [#{\Sigma}-closed](stt-006E)
[reflective subuniverse](stt-0065).
}

\agda{
Disjunctive-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Disjunctive-SubU = Null-SubU fam-is-disjunctive _

Disjunctive-GSU : GSU (_âŠ” ğ“˜)
Disjunctive-GSU = Null-GSU fam-is-disjunctive

Disjunctive-is-globally-reflective
  : is-globally-reflective Disjunctive-GSU
Disjunctive-is-globally-reflective = Null-globally-reflective

module Disj where
  open GRSUInduction Disjunctive-is-globally-reflective
                     Null-globally-Î£-closed 
      public

  open GSU Disjunctive-GSU public renaming (S-equiv to is-disjunctiveâ†equiv)

  open is-globally-reflective Disjunctive-is-globally-reflective

  Î£-is-disjunctive = Null-globally-Î£-closed

Î›Â²â‚‚-âˆ¨-rec : âˆ€ {ğ“¤} {A : Type ğ“¤} {i j} â†’ (i âˆ¨ j ï¼ i1) â†’ is-disjunctive A
          â†’ (l : i ï¼ i1 â†’ A) â†’ (r : j ï¼ i1 â†’ A) 
          â†’ ((pi : i ï¼ i1) (pj : j ï¼ i1) â†’ l pi ï¼ r pj) â†’ A
Î›Â²â‚‚-âˆ¨-rec {i = i} {j} p disj-A l r eq
  = is-equiv.bwd 
  (disj-A ((i , j) , p)) 
  (cogap (mk-cocone l r (Î» (p , q) â†’ eq p q)))

Î›Â²â‚‚-âˆ¨-rec' : âˆ€ {ğ“¤} {A : Type ğ“¤} {i j} â†’ (p : i âˆ¨ j ï¼ i1) â†’ is-disjunctive A
          â†’ (l : i ï¼ i1 â†’ A) â†’ (r : j ï¼ i1 â†’ A) 
          â†’ ((q : i ï¼ j) â†’ l (=âˆ¨â†= q âˆ™ p) ï¼ r ((=âˆ¨'â†= (sym q)) âˆ™ p)) â†’ A
Î›Â²â‚‚-âˆ¨-rec' {i = i} {j} p disj-A l r eq
  = Î›Â²â‚‚-âˆ¨-rec p disj-A l r (Î» pi pj 
    â†’ ap l (is-prop-separated _ _ _ _) 
    âˆ™ eq (pi âˆ™ sym pj) 
    âˆ™ ap r (is-prop-separated _ _ _ _))

Î›Â²â‚‚-âˆ¨-rec! : âˆ€ {ğ“¤} {A : Type ğ“¤} i j â†’ â¦ƒ p : i âˆ¨ j ï¼ i1 â¦„ â†’ is-disjunctive A
            â†’ (l : â¦ƒ  i ï¼ i1 â¦„ â†’ A) â†’ (r : â¦ƒ j ï¼ i1 â¦„ â†’ A)
            â†’ ((pi : i ï¼ i1) (pj : j ï¼ i1) â†’ l â¦ƒ pi â¦„ ï¼ r â¦ƒ pj â¦„)
            â†’ A
Î›Â²â‚‚-âˆ¨-rec! i j â¦ƒ p â¦„ disj-A l r = Î›Â²â‚‚-âˆ¨-rec p disj-A (Î» p â†’ l â¦ƒ p â¦„) (Î» q â†’ r â¦ƒ q â¦„)
}
%```
}


\subtree[fre-0002]{
\taxon{Lemma}
\title{The outer horn #{Î›Â²â‚‚}}

\p{
We give a slightly nonstandard definition of the outer horn #{Î›Â²â‚‚} as the 
subtype of the square consisting of elements #{(i,j)} such that 
#{(i = 1) * (j = 1)}. Normally, it is defined as the subtype such that 
#{(i = 1) * (i = j)}.
}

%```agda
\agda{
âˆ¨=1â†fam-disjunctive : âˆ€ {i j} â†’ fam-disjunctive (i , j) â†’ (i âˆ¨ j ï¼ i1)
âˆ¨=1â†fam-disjunctive {i = i} {j}
  = *-prop-rec
      (is-prop-separated _ _)
      (Î» pi â†’ ap (_âˆ¨ j) pi âˆ™ âˆ¨-comm âˆ™ 1-coinit)
      (Î» pj â†’ ap (i âˆ¨_) pj âˆ™ 1-coinit)

Î›Â²â‚‚' : Type ğ“˜
Î›Â²â‚‚' = Î£ âˆ¨Â² fam-is-disjunctive

Î›Â²â‚‚ : Type ğ“˜
Î›Â²â‚‚ = Î£ (Î”Â¹ Ã— Î”Â¹) fam-disjunctive

drop-join-proof
  : (ij : Î”Â¹ Ã— Î”Â¹)
  â†’ (Î£[ p âˆ¶ (fst ij âˆ¨ snd ij ï¼ i1) ] fam-disjunctive ij)
  â†’ fam-disjunctive ij
drop-join-proof _ = snd

drop-join-proof-is-equiv
  : (ij : Î”Â¹ Ã— Î”Â¹) â†’ is-equiv (drop-join-proof ij)
drop-join-proof-is-equiv (i , j)
  = is-equivâ†inverse
      (is-prop-Î£
        (is-prop-separated _ _)
        (Î» _ â†’ *-is-prop (is-prop-separated _ _) (is-prop-separated _ _)))
      (*-is-prop (is-prop-separated _ _) (is-prop-separated _ _))
      (Î» d â†’ âˆ¨=1â†fam-disjunctive d , d)

Î›Â²â‚‚â†Î›Â²â‚‚' : Î›Â²â‚‚' â†’ Î›Â²â‚‚
Î›Â²â‚‚â†Î›Â²â‚‚' = total-map drop-join-proof âˆ˜ _â‰ƒ_.fwd Î£-assoc

Î›Â²â‚‚â†Î›Â²â‚‚'-is-equiv : is-equiv Î›Â²â‚‚â†Î›Â²â‚‚'
Î›Â²â‚‚â†Î›Â²â‚‚'-is-equiv
  = is-equiv-âˆ˜
      (is-total-equivâ†is-fibrewise-equiv drop-join-proof-is-equiv)
      (_â‰ƒ_.has-is-eqv Î£-assoc)

Î›Â²â‚‚'â‰ƒÎ›Â²â‚‚ : Î›Â²â‚‚' â‰ƒ Î›Â²â‚‚
Î›Â²â‚‚'â‰ƒÎ›Â²â‚‚ = mkâ‰ƒ Î›Â²â‚‚â†Î›Â²â‚‚' Î›Â²â‚‚â†Î›Â²â‚‚'-is-equiv

Î›Â²â‚‚'â†Î›Â²â‚‚ : Î›Â²â‚‚ â†’ Î›Â²â‚‚'
Î›Â²â‚‚'â†Î›Â²â‚‚ = _â‰ƒ_.bwd Î›Â²â‚‚'â‰ƒÎ›Â²â‚‚

Î›Â²â‚‚-incl : Î›Â²â‚‚ â†’ âˆ¨Â²
Î›Â²â‚‚-incl ((i , j) , d) = ((i , j) , âˆ¨=1â†fam-disjunctive d)
}
%```
}


\subtree[fre-0003]{
\taxon{Definition}
\title{Upper located types}

\p{
We might say a type is \em{upper located} if it is local at the inclusion of 
#{Î£_{(i\,j:ğ•€)((i = 1) âˆ¨ (j ï¼ 1))}} into 
#{Î£_{(i\,j:ğ•€)(i âˆ¨ j ï¼ 1)}}. In other words, it sees the outer horn #{Î›Â²â‚‚} as 
identical to the subset of the square whose join is #{1}.
}

%```agda
\agda{
is-upper-located : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
is-upper-located A = is-local (Î» (_ : ğŸ™) â†’ Î›Â²â‚‚-incl) A
}
%```
}


\subtree[fre-0004]{
\title{Disjunctive types are upper located}
\taxon{Lemma}

%```agda
\agda{
disj-is-upper-located : âˆ€ {ğ“¤} {A : Type ğ“¤}
                      â†’ is-disjunctive A â†’ is-upper-located A
disj-is-upper-located {_}{A} disj tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-equiv _ _ amap amap-is-eqv !
        (left-orthogonal-Î£ _ !
          (is-orthogonalâ‡”orthogonal-! .snd
          âˆ˜ (is-localâ†is-null disj)))) where

  amap : Arrow-map (total-map (Î» _ â†’ !)) Î›Â²â‚‚-incl
  amap .Arrow-map.top = Î›Â²â‚‚â†Î›Â²â‚‚'
  amap .Arrow-map.bot = fst
  amap .Arrow-map.comm (((i , j) , p) , d)
    = Î£-pathâ†’ (refl , is-prop-separated _ _ _ _)

  amap-is-eqv : is-Arrow-equiv amap
  amap-is-eqv .fst = Î›Â²â‚‚â†Î›Â²â‚‚'-is-equiv
  amap-is-eqv .snd = singleton-fst-is-equiv (Î» _ â†’ ğŸ™-is-singleton)
}
%```
}


\subtree[fre-0005]{
\title{Simplicial types are disjunctive}
\taxon{Lemma}

\p{
We call a type [simplicial](stt-00AB) if it is null at #{((i â‰¤ j) * (j â‰¤ i))} 
for all #{(i, j) : â–¡}. We show that every simplicial type is disjunctive.
}

\proof{
\p{
If #{P} implies #{Q} then #{P}-null types are #{Q}-null, so it suffices to show 
that #{((i â‰¤ j) * (j â‰¤ i))} implies #{i = 1} or #{j = 1} for all #{i} and #{j} 
such that #{(i âˆ¨ j) = 1}.
}

%```agda
\agda{
simp-over-âˆ¨Â²â†’disj : (x : âˆ¨Â²)
                  â†’ fam-is-simplicial (fst x) â†’ fam-is-disjunctive x
simp-over-âˆ¨Â²â†’disj ((i , j) , p)
  = *-prop-rec
      (*-is-prop (is-prop-separated _ _) (is-prop-separated _ _))
      (Î» ij â†’ Î¹â‚‚ (sym (â‰¤-max ij) âˆ™ p))
      (Î» ji â†’ Î¹â‚ (sym (â‰¤-max ji) âˆ™ sym âˆ¨-comm âˆ™ p))

disjâ†’simp-over-âˆ¨Â² : (x : âˆ¨Â²)
                  â†’ fam-is-disjunctive x â†’ fam-is-simplicial (fst x)
disjâ†’simp-over-âˆ¨Â² ((i , j) , _)
  = *-prop-rec
      (*-is-prop â‰¤-is-prop â‰¤-is-prop)
      (Î» pi â†’ Î¹â‚‚ (tr (j â‰¤_) (sym pi) â‰¤-top))
      (Î» pj â†’ Î¹â‚ (tr (i â‰¤_) (sym pj) â‰¤-top))

simp-over-âˆ¨Â²â†’disj-is-equiv
  : (x : âˆ¨Â²) â†’ is-equiv (simp-over-âˆ¨Â²â†’disj x)
simp-over-âˆ¨Â²â†’disj-is-equiv x@((i , j) , _)
  = is-equivâ†inverse
      (*-is-prop â‰¤-is-prop â‰¤-is-prop)
      (*-is-prop (is-prop-separated _ _) (is-prop-separated _ _))
      (disjâ†’simp-over-âˆ¨Â² x)

simp-is-disjunctive : âˆ€ {ğ“¤} {A : Type ğ“¤}
                    â†’ is-simplicial A â†’ is-disjunctive A
simp-is-disjunctive {_}{A} simp
  = is-nullâ†is-local
      (is-local-equiv amap amap-is-eqv
        (is-localâ†is-null simp-over-âˆ¨Â²)) where

  simp-over-âˆ¨Â² : is-null (fam-is-simplicial âˆ˜ fst) A
  simp-over-âˆ¨Â² x = simp (fst x)

  amap : (x : âˆ¨Â²)
       â†’ Arrow-map (! {A = fam-is-simplicial (fst x)})
                   (! {A = fam-is-disjunctive x})
  amap x .Arrow-map.top = simp-over-âˆ¨Â²â†’disj x
  amap x .Arrow-map.bot = id
  amap x .Arrow-map.comm = ~refl

  amap-is-eqv : âˆ€ x â†’ is-Arrow-equiv (amap x)
  amap-is-eqv x .fst = simp-over-âˆ¨Â²â†’disj-is-equiv x
  amap-is-eqv x .snd = id-is-equiv
}
%```
}



\subtree[fre-0006]{
\title{Simplicial types are upper located}
\taxon{Corollary}

\agda{
simp-is-upper-located : âˆ€ {ğ“¤} {A : Type ğ“¤}
                      â†’ is-simplicial A â†’ is-upper-located A
simp-is-upper-located = disj-is-upper-located âˆ˜ simp-is-disjunctive
}
}
