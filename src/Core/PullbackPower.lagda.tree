\date{2025-05-18}
\author{samueltoth}
\date{2026-02-23}
\author{fredrikbakke}
\taxon{Module}
\import{stt-macros}

\title{The pullback power}

%```agda
\agda{
module Core.PullbackPower where

open import Foundations.Prelude
open import Foundations.TypeFamily
open import Core.PullbackPowerFamilies
open import ufAxioms
open import Foundations.NullHomotopy global-funext

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Lifts
open import Ergonomics.Extensionality
}
%```

\subtree[fre-0010]{
\taxon{Construction}
\title{Dependent pullback power}

\p{
Given an [arrow](fre-0001) #{f : A â†’ B} and a dependent arrow over it
#{g : (b : B) â†’ X\,b â†’ Y\,b}, then we may form the \em{dependent pullback power}
#{\hat\Pi_f g} as the gap map in the square

\quiver{
\begin{tikzcd}
	((b : B) \to X\,b) && ((b : B) \to Y\,b) \\
	& \Hom^\mathrm{d}(f, g) \\
	((a : A) \to X(f\,a)) && ((a : A) \to Y(f\,a))
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=2-2, to=1-3]
	\arrow[from=2-2, to=3-1]
	\arrow[from=3-1, to=3-3]
	\arrow[dashed, from=1-1, to=2-2, "{\hat\Pi_f g}"]
	\arrow[phantom, from=2-2, to=3-3, "\lrcorner" very near start]
\end{tikzcd}
}

where #{\Hom^\mathrm{d}(f, g)} is the type of
[dependent morphisms of arrows](fre-0002).
}

%```agda
\agda{
module _ {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4}
         {A : Type ğ“¤1} {B : Type ğ“¤2} (f : A â†’ B)
         {X : B â†’ Type ğ“¤3} {Y : B â†’ Type ğ“¤4} (g : (b : B) â†’ X b â†’ Y b) where

  Î Ì‚ : ((b : B) â†’ X b) â†’ Arr-dmap f g
  Î Ì‚ l = mk-amap (postcomp-Î  X f l) (precomp-Î  g l) ~refl
}
%```
}

\subtree[stt-004D]{
\title{Pullback power}
\taxon{Construction}

\quiver{
\begin{tikzcd}
	A && C \\
	\\
	B && D
	\arrow[dashed, from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["l"{description}, from=3-1, to=1-3]
	\arrow[dashed, from=3-1, to=3-3]
\end{tikzcd}
}

\p{Given a pair of arrows as above, any diagonal map
gives rise to a square for which it is trivially a lifting.}
\p{This is the nondependent case of the [dependent pullback power](fre-0010).}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
         {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
         {C : Type ğ“¦} {D : Type ğ“œ} (f' : C â†’ D) where

  pullback-power : (B â†’ C) â†’ Arrow-map f f'
  pullback-power = Î Ì‚ f (Î» _ â†’ f')

  infixl 40 âŸ¨_,_âŸ©
  âŸ¨_,_âŸ© = pullback-power

  pullback-power-lifts : (l : B â†’ C) â†’ Lift (pullback-power l)
  pullback-power-lifts l .Lift.lift = l
  pullback-power-lifts l .Lift.K = ~refl
  pullback-power-lifts l .Lift.L = ~refl
  pullback-power-lifts l .Lift.pastes = ~refl
}
%```

\p{The pullback power of #{f} with #{g} is sometimes written #{f \hat\pitchfork g}.}
}

\subtree[stt-004C]{
\title{Pullback power is a gap map}
\taxon{Theorem}

\p{The name pullback power comes from the fact that for any pair
of maps, we can define a square as follows:}

\quiver{
\begin{tikzcd}
	{C^B} && {C^A} \\
	\\
	{D^B} && {D^A}
	\arrow["{- \circ f}", from=1-1, to=1-3]
	\arrow["{g \circ -}"', from=1-1, to=3-1]
	\arrow["{g \circ -}", from=1-3, to=3-3]
	\arrow["{- \circ f}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{Then the gap map of this square is the [pullback power](stt-004D) in the
sense that the following triangle commutes.}

\quiver{
\begin{tikzcd}
	& {B \to C} \\
	\\
	{\Hom(f,g)} && {D^B\times_{D^A}C^A}
	\arrow["{f\hat\pitchfork g}"', from=1-2, to=3-1]
	\arrow["gap", from=1-2, to=3-3]
	\arrow["\sim"', from=3-1, to=3-3]
\end{tikzcd}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
         {C : Type ğ“¦} {D : Type ğ“œ} (f : A â†’ B)
         (g : C â†’ D)  where

  power-hom : Arrow-map (postcomp B g) (postcomp A g)
  power-hom .Arrow-map.top = precomp _ f
  power-hom .Arrow-map.bot = precomp _ f
  power-hom .Arrow-map.comm = ~refl

  pb-power-cone : Cone (mk-cospan (A â†’ D) (precomp _ f) (postcomp _ g)) (B â†’ C)
  pb-power-cone = snd (Coneâ†Arrow-map power-hom)

  pullback-gap~pullback-power :
    gap pb-power-cone ~ pullbackâ†arrow' âˆ˜ pullback-power f g
  pullback-gap~pullback-power f = ext! (~refl , ~refl , sym funext-refl)
}
%```
}

\subtree[stt-004L]{
% \title{The pullback power is an equiv  is a pullback}
\taxon{Corollary}

\p{For a pair of maps #{f} and #{g}, the following are equivalent:}
\ol{
\li{The [pullback power](stt-004D) of #{f} with #{g} is an equivalence}
\li{The square of \ref{stt-004C} is cartesian}
\li{The cone given by the pullback power is a pullback cone}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
         {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
         {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D) where

  power-pbâ†pb-power-is-equiv : is-equiv (pullback-power f g)
                             â†’ is-pullbackÏ‰ _ (pb-power-cone f g)
  power-pbâ†pb-power-is-equiv pb-eq = is-pullbackâ†gap (pb-power-cone f g)
    (homotopy-is-equiv (pullback-gap~pullback-power f g ~â»Â¹)
                       (is-equiv-âˆ˜ (Arrow-mapâ‰ƒpullback' ._â‰ƒ_.has-is-eqv)
                                   pb-eq))

  pb-power-is-equivâ†power-pb : is-pullbackÏ‰ _ (pb-power-cone f g)
                             â†’ is-equiv (pullback-power f g)
  pb-power-is-equivâ†power-pb pb = 3-for-2~ (pullback-gap~pullback-power f g)
                                           (Arrow-mapâ‰ƒpullback' ._â‰ƒ_.has-is-eqv)
                                           (gap-is-equivâ†is-pullback _ pb)

  power-hom-cartesianâ†pullback-power : is-equiv (pullback-power f g)
                                     â†’ is-cartesian (power-hom f g)
  power-hom-cartesianâ†pullback-power ppeq
    = is-cartesianâ†is-pullback (power-hom f g) lem where
    lem : is-pullbackÏ‰ _ (pb-power-cone f g)
    lem = power-pbâ†pb-power-is-equiv ppeq

  pullback-powerâ†power-hom-cartesian : is-cartesian (power-hom f g)
                                     â†’ is-equiv (pullback-power f g)
  pullback-powerâ†power-hom-cartesian pb = 3-for-2~ {f = pullbackâ†arrow'}
                                     (pullback-gap~pullback-power f g)
                                     (Arrow-mapâ‰ƒpullback' ._â‰ƒ_.has-is-eqv)
                                     gap-is-equiv where
    gap-is-equiv : is-equiv (gap (pb-power-cone f g))
    gap-is-equiv = gap-is-equivâ†is-pullback _ (is-pullbackâ†is-cartesian _ pb)
}
%```
}

\subtree[stt-004K]{
\taxon{Theorem}
\title{Characterising fibres of the pullback map}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
         {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
         {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
  where

  pb-power-fibreâ‰ƒlifts
    : (G : Arrow-map f g) â†’ fibre (pullback-power f g) G â‰ƒ Lift G
  pb-power-fibreâ‰ƒlifts G
    = Î£-ap-â‰ƒ (Î» l â†’ Arrow-map-pathâ‰ƒ (pullback-power f g l) G) âˆ™â‰ƒ Lift-reprâ‰ƒ G eâ»Â¹
}
%```
}

\subtree{
\taxon{Subsection}
\title{Equivalence between the pullback powers of families and arrows}

\subtree[fre-0012]{
\taxon{Theorem}
\title{The equivalence of unstraightened pullback powers}

\p{
Given #{f : A â†’ B} and #{g : (b : B) â†’ X\,b â†’ Y\,b}, the dependent pullback power
is equivalent, as an arrow, to the unstraightening of the fibrewise pullback power.

##{Î Ì‚\,f\,g â‰ƒ Î Ì‚^{\mathrm f}_{\text{unstraight}}\,f\,g}
}

%```agda
\agda{

module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4}
  {A : Type ğ“¤1} {B : Type ğ“¤2} (f : A â†’ B)
  {X : B â†’ Type ğ“¤3} {Y : B â†’ Type ğ“¤4} (g : (b : B) â†’ X b â†’ Y b) where

  Î Ì‚á¶ -unstraight-fibre-fam
    : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
          (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î Ì‚á¶ -unstraight-fibre-fam = Î Ì‚á¶  (fibre-fam f) (fibre-depfam g)

  Î Ì‚-unstraight-cod : Type (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î Ì‚-unstraight-cod = fst Î Ì‚á¶ -unstraight-fibre-fam

  Î Ì‚á¶ -unstraight-bundle : Bundle Î Ì‚-unstraight-cod
  Î Ì‚á¶ -unstraight-bundle = unstraighten (snd Î Ì‚á¶ -unstraight-fibre-fam)

  Î Ì‚-unstraight-dom : Type (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î Ì‚-unstraight-dom = fst Î Ì‚á¶ -unstraight-bundle

  Î Ì‚á¶ -unstraight : Î Ì‚-unstraight-dom â†’ Î Ì‚-unstraight-cod
  Î Ì‚á¶ -unstraight = snd Î Ì‚á¶ -unstraight-bundle

  straighten-Î Ì‚á¶ -unstraight-bundle
    : straighten Î Ì‚á¶ -unstraight-bundle ï¼ snd Î Ì‚á¶ -unstraight-fibre-fam
  straighten-Î Ì‚á¶ -unstraight-bundle
    = straighten-qiso .snd .snd (snd Î Ì‚á¶ -unstraight-fibre-fam)

module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4}
  {A : Type ğ“¤1} {B : Type ğ“¤2} (f : A â†’ B)
  {X : B â†’ Type ğ“¤3} {Y : B â†’ Type ğ“¤4} (g : (b : B) â†’ X b â†’ Y b) where

  Î Ì‚-unstraight-codâ†pullback
    : Pullback (postcomp-Î  Y f) (precomp-Î  (Î» a â†’ g (f a)))
    â†’ Î Ì‚-unstraight-cod f g
  Î Ì‚-unstraight-codâ†pullback (i , j , p)
    = i
    , Î» where b (a , refl) â†’ j a , sym (happly p a)

  Î Ì‚-unstraight-cod-cone
    : Cone (mk-cospan ((a : A) â†’ Y (f a))
                      (postcomp-Î  Y f)
                      (precomp-Î  (Î» a â†’ g (f a))))
           (Î Ì‚-unstraight-cod f g)
  Î Ì‚-unstraight-cod-cone .Cone.i (i , k)
    = i
  Î Ì‚-unstraight-cod-cone .Cone.j (i , k) a
    = fst (k (f a) (a , refl))
  Î Ì‚-unstraight-cod-cone .Cone.filler (i , k)
    = funextâ†’ (Î» a â†’ sym (snd (k (f a) (a , refl))))

  pullbackâ†Î Ì‚-unstraight-cod
    : Î Ì‚-unstraight-cod f g
    â†’ Pullback (postcomp-Î  Y f) (precomp-Î  (Î» a â†’ g (f a)))
  pullbackâ†Î Ì‚-unstraight-cod = gap Î Ì‚-unstraight-cod-cone

  Î Ì‚-unstraight-codâ†pullback-qiso : quasi-iso Î Ì‚-unstraight-codâ†pullback
  Î Ì‚-unstraight-codâ†pullback-qiso .fst = pullbackâ†Î Ì‚-unstraight-cod
  Î Ì‚-unstraight-codâ†pullback-qiso .snd .fst (i , j , p)
    = Î£-pathâ†’
        ( refl
        , Î£-pathâ†’
            ( refl
            , ap funextâ†’ (funextâ†’ (Î» a â†’ sym-sym {p = happly p a}))
            âˆ™ funext.Î· p))

  Î Ì‚-unstraight-codâ†pullback-qiso .snd .snd (i , k)
    = Î£-pathâ†’
        ( refl
        , funextâ†’ Î» b â†’ funextâ†’ Î» where
          (a , refl) â†’ Î£-pathâ†’
            ( refl
            , ap sym (happly (funext.Îµ (Î» a â†’ sym (snd (k (f a) (a , refl))))) a)
            âˆ™ sym-sym))

  Î Ì‚-unstraight-codâ†Arr-dmap : Arr-dmap f g â†’ Î Ì‚-unstraight-cod f g
  Î Ì‚-unstraight-codâ†Arr-dmap
    = Î Ì‚-unstraight-codâ†pullback âˆ˜ Arr-dmapâ‰ƒpullback ._â‰ƒ_.fwd

  Î Ì‚-unstraight-codâ†Arr-dmap-is-equiv : is-equiv Î Ì‚-unstraight-codâ†Arr-dmap
  Î Ì‚-unstraight-codâ†Arr-dmap-is-equiv
    = is-equiv-âˆ˜
        (is-equivâ†qiso Î Ì‚-unstraight-codâ†pullback-qiso)
        (Arr-dmapâ‰ƒpullback ._â‰ƒ_.has-is-eqv)

  Î Ì‚-unstraight-domâ†Î  : ((b : B) â†’ X b) â†’ Î Ì‚-unstraight-dom f g
  Î Ì‚-unstraight-domâ†Î  l = Î Ì‚-unstraight-codâ†Arr-dmap (Î Ì‚ f g l) , m where
    y : (b : B) â†’ fibre (g b) (precomp-Î  g l b)
    y b = l b , refl

    H : (b : B) â†’ Î Ì‚-unstraight-codâ†Arr-dmap (Î Ì‚ f g l) .snd b ~ const _ _ (y b)
    H b (a , refl) = refl

    m : (b : B) â†’ null-homotopy (Î Ì‚-unstraight-codâ†Arr-dmap (Î Ì‚ f g l) .snd b)
    m b = y b , H b

  Î â†Î Ì‚-unstraight-dom : Î Ì‚-unstraight-dom f g â†’ ((b : B) â†’ X b)
  Î â†Î Ì‚-unstraight-dom (_ , m) b = fst (fst (m b))

  Î â†Î Ì‚-unstraight-domâˆ˜Î Ì‚-unstraight-domâ†Î 
    : Î â†Î Ì‚-unstraight-dom âˆ˜ Î Ì‚-unstraight-domâ†Î  ~ id
  Î â†Î Ì‚-unstraight-domâˆ˜Î Ì‚-unstraight-domâ†Î  l = refl

  Ptáµˆ : B â†’ Type (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Ptáµˆ b = fibre-pointed-total (fibre f b) (g b)

  Î Ì‚-unstraight-domâ‰ƒptáµˆ-maps : Î Ì‚-unstraight-dom f g â‰ƒ ((b : B) â†’ Ptáµˆ b)
  Î Ì‚-unstraight-domâ‰ƒptáµˆ-maps
    = Î Ì‚-unstraight-dom f g
      â‰ƒâŸ¨ Î£-assoc âŸ©
      Î£[ i âˆ¶ ((b : B) â†’ Y b) ]
      Î£[ j âˆ¶ ((b : B) â†’ fibre f b â†’ fibre (g b) (i b)) ]
        ((b : B) â†’ null-homotopy (j b))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» i
                â†’ Î£-Î -swapâ‰ƒ (Î» b â†’ fibre f b â†’ fibre (g b) (i b))
                            (Î» b jb â†’ null-homotopy jb)
                            eâ»Â¹) âŸ©
      Î£[ i âˆ¶ ((b : B) â†’ Y b) ]
      ((b : B)
      â†’ Î£[ jb âˆ¶ (fibre f b â†’ fibre (g b) (i b)) ] null-homotopy jb)
      â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ (Î» b â†’ Y b)
                   (Î» b i â†’ Î£[ jb âˆ¶ (fibre f b â†’ fibre (g b) i) ] null-homotopy jb)
                   eâ»Â¹ âŸ©
      ((b : B) â†’ Ptáµˆ b)
      â‰ƒâˆ

  Î Ì‚-unstraight-domâ‰ƒÎ  : Î Ì‚-unstraight-dom f g â‰ƒ ((b : B) â†’ X b)
  Î Ì‚-unstraight-domâ‰ƒÎ 
    = Î Ì‚-unstraight-domâ‰ƒptáµˆ-maps
    âˆ™â‰ƒ Î -ap-â‰ƒ (Î» b â†’ fibre-pointed-totalâ‰ƒdomain (fibre f b) (g b))

  Î â†Î Ì‚-unstraight-dom-is-equiv : is-equiv Î â†Î Ì‚-unstraight-dom
  Î â†Î Ì‚-unstraight-dom-is-equiv
    = homotopy-is-equiv
        (Î» (_ , m) â†’ refl)
        (Î Ì‚-unstraight-domâ‰ƒÎ  ._â‰ƒ_.has-is-eqv)

  Î Ì‚-unstraight-domâ†Î -is-equiv : is-equiv Î Ì‚-unstraight-domâ†Î 
  Î Ì‚-unstraight-domâ†Î -is-equiv
    = 3-for-2~ (Î â†Î Ì‚-unstraight-domâˆ˜Î Ì‚-unstraight-domâ†Î  ~â»Â¹)
               Î â†Î Ì‚-unstraight-dom-is-equiv
               id-is-equiv

  Î Ì‚á¶ -unstraightâ†Î Ì‚ : Arrow-map (Î Ì‚ f g) (Î Ì‚á¶ -unstraight f g)
  Î Ì‚á¶ -unstraightâ†Î Ì‚ = mk-amap Î Ì‚-unstraight-domâ†Î  Î Ì‚-unstraight-codâ†Arr-dmap ~refl

  Î Ì‚á¶ -unstraightâ†Î Ì‚-is-Arrow-equiv : is-Arrow-equiv Î Ì‚á¶ -unstraightâ†Î Ì‚
  Î Ì‚á¶ -unstraightâ†Î Ì‚-is-Arrow-equiv
    = Î Ì‚-unstraight-domâ†Î -is-equiv , Î Ì‚-unstraight-codâ†Arr-dmap-is-equiv

  Î Ì‚-unstraighten-Arrow-equiv : Arrow-equiv (Î Ì‚ f g) (Î Ì‚á¶ -unstraight f g)
  Î Ì‚-unstraighten-Arrow-equiv
    = Î Ì‚á¶ -unstraightâ†Î Ì‚ , Î Ì‚á¶ -unstraightâ†Î Ì‚-is-Arrow-equiv

  Î Ì‚-Arrow-equivâ†â‰ƒá¶ 
    : {ğ“¤5 ğ“¤6 : Level}
      (H : Fam ğ“¤5 ğ“¤6)
    â†’ Î Ì‚á¶ -unstraight-fibre-fam f g â‰ƒá¶  H
    â†’ Arrow-equiv (Î Ì‚ f g) (arrâ†Fam H)
  Î Ì‚-Arrow-equivâ†â‰ƒá¶  H
    = concat-Arrow-equiv-â‰ƒá¶ 
        (Î Ì‚á¶ -unstraight-fibre-fam f g)
        (H)
        (Î Ì‚-unstraighten-Arrow-equiv)

  Î Ì‚-fibre-fam
    : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
          (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î Ì‚-fibre-fam
    = Arr-dmap f g
    , fibre (Î Ì‚ f g)

  Î Ì‚-unstraight-fibre-fam
    : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
          (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î Ì‚-unstraight-fibre-fam
    = Î Ì‚-unstraight-cod f g
    , fibre (Î Ì‚á¶ -unstraight f g)

  Î Ì‚-unstraightenâ‰ƒá¶ 
    : Î Ì‚-fibre-fam â‰ƒá¶  Î Ì‚-unstraight-fibre-fam
  Î Ì‚-unstraightenâ‰ƒá¶ 
    = mkâ‰ƒ Î Ì‚-unstraight-codâ†Arr-dmap Î Ì‚-unstraight-codâ†Arr-dmap-is-equiv
    , (Î» t
      â†’ mkâ‰ƒ (arrow-fibre Î Ì‚á¶ -unstraightâ†Î Ì‚ t)
            (is-cartesianâ†is-equiv Î Ì‚á¶ -unstraightâ†Î Ì‚
                                   Î Ì‚á¶ -unstraightâ†Î Ì‚-is-Arrow-equiv
                                   t))

  Î Ì‚-unstraight-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam
    : Î Ì‚-unstraight-fibre-fam â‰ƒá¶  Î Ì‚á¶ -unstraight-fibre-fam f g
  Î Ì‚-unstraight-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam
    = idequiv
    , (Î» t â†’ coeâ‰ƒ (ap (Î» P â†’ P t) (straighten-Î Ì‚á¶ -unstraight-bundle f g)))

  Î Ì‚-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam
    : Î Ì‚-fibre-fam â‰ƒá¶  Î Ì‚á¶ -unstraight-fibre-fam f g
  Î Ì‚-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam
    = concatâ‰ƒá¶ 
        (Î Ì‚-fibre-fam)
        (Î Ì‚-unstraight-fibre-fam)
        (Î Ì‚á¶ -unstraight-fibre-fam f g)
        (Î Ì‚-unstraightenâ‰ƒá¶ )
        (Î Ì‚-unstraight-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam)
}
%```
}

\subtree[fre-0015]{
\taxon{Lemma}
\title{Changing the family in the base of #{Î Ì‚á¶ }}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 : Level}
  {A : Type ğ“¤1} {B : A â†’ Type ğ“¤2} {C : A â†’ Type ğ“¤3}
  (G@(X , Y) : DepFam ğ“¤4 ğ“¤5 (A , B))
  (e : (a : A) â†’ B a â‰ƒ C a) where

  Î Ì‚á¶ -ap-base-fam-base
    : base-Î Ì‚á¶  (A , B) G â‰ƒ base-Î Ì‚á¶  (A , C) G
  Î Ì‚á¶ -ap-base-fam-base
    = Î£-ap-â‰ƒ (Î» i â†’ Î -ap-â‰ƒ (Î» a â†’ postcomp-â‰ƒ (e a) eâ»Â¹))

  Î Ì‚á¶ -ap-base-fam-family
    : (fp : base-Î Ì‚á¶  (A , B) G)
    â†’ fam-Î Ì‚á¶  (A , B) G fp
    â‰ƒ fam-Î Ì‚á¶  (A , C) G (Î Ì‚á¶ -ap-base-fam-base ._â‰ƒ_.fwd fp)
  Î Ì‚á¶ -ap-base-fam-family (i , j)
    = Î -ap-â‰ƒ (Î» a â†’ null-homotopy-postcomp-â‰ƒ (e a) (j a))

  Î Ì‚á¶ -ap-base-fam : Î Ì‚á¶  (A , B) G â‰ƒá¶  Î Ì‚á¶  (A , C) G
  Î Ì‚á¶ -ap-base-fam = Î Ì‚á¶ -ap-base-fam-base , Î Ì‚á¶ -ap-base-fam-family
}
%```
}

\subtree[fre-0016]{
\taxon{Theorem}
\title{The equivalence of straightened pullback powers}

\p{Given families #{B : A â†’ ğ“¤} and #{Y : (a : A) â†’ X a â†’ ğ“¤}, their fiberwise
dependent pullback power is equivalent, as family, to the straightening of the
dependent pullback power of total space projections.

##{Î Ì‚^{\mathrm f}\,F\,G \simeq Î Ì‚_{\text{straight}}\,F\,G}
}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4}
  (F@(A , B) : Fam ğ“¤1 ğ“¤2)
  (G@(X , Y) : DepFam ğ“¤3 ğ“¤4 F)
  (let fáµ˜ = fst {A = A} {B = B})
  (let Xáµ˜ = Î» a â†’ Î£ (X a) (Y a))
  (let Yáµ˜ = X)
  (let gáµ˜ = Î» a â†’ fst {A = X a} {B = Y a})
  (let Fáµ˜@(Aáµ˜ , Báµ˜) = fibre-fam fáµ˜)
  (let Gáµ˜ = fibre-depfam gáµ˜)
  where

  Î Ì‚-straight
    : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4) (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î Ì‚-straight = Î Ì‚-fibre-fam fáµ˜ gáµ˜

  Î Ì‚á¶ -fibre-fam-unstraight
    : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4) (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤4)
  Î Ì‚á¶ -fibre-fam-unstraight = Î Ì‚á¶  Fáµ˜ G

  Î Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ Ì‚á¶ -fibre-fam-unstraight
    : Î Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜ â‰ƒá¶  Î Ì‚á¶ -fibre-fam-unstraight
  Î Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ Ì‚á¶ -fibre-fam-unstraight
    = Î Ì‚á¶ -ap-â‰ƒáµˆá¶  Fáµ˜ Gáµ˜ G (Î» a â†’ (idequiv , fibre-straighten (Y a)))

  Î Ì‚á¶ -fibre-fam-unstraightâ‰ƒÎ Ì‚á¶ 
    : Î Ì‚á¶ -fibre-fam-unstraight â‰ƒá¶  Î Ì‚á¶  F G
  Î Ì‚á¶ -fibre-fam-unstraightâ‰ƒÎ Ì‚á¶ 
    = Î Ì‚á¶ -ap-base-fam G (fibre-straighten B)

  Î Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ Ì‚á¶ 
    : Î Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜ â‰ƒá¶  Î Ì‚á¶  F G
  Î Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ Ì‚á¶ 
    = concatâ‰ƒá¶ 
        (Î Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜)
        (Î Ì‚á¶ -fibre-fam-unstraight)
        (Î Ì‚á¶  F G)
        (Î Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ Ì‚á¶ -fibre-fam-unstraight)
        (Î Ì‚á¶ -fibre-fam-unstraightâ‰ƒÎ Ì‚á¶ )

  Î Ì‚-straightâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam : Î Ì‚-straight â‰ƒá¶  Î Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜
  Î Ì‚-straightâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam
    = concatâ‰ƒá¶ 
        (Î Ì‚-straight)
        (Î Ì‚-unstraight-fibre-fam fáµ˜ gáµ˜)
        (Î Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜)
        (Î Ì‚-unstraightenâ‰ƒá¶  fáµ˜ gáµ˜)
        (Î Ì‚-unstraight-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜)

  Î Ì‚-straightenâ‰ƒá¶  : Î Ì‚-straight â‰ƒá¶  Î Ì‚á¶  F G
  Î Ì‚-straightenâ‰ƒá¶ 
    = concatâ‰ƒá¶ 
        (Î Ì‚-straight)
        (Î Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜)
        (Î Ì‚á¶  F G)
        (Î Ì‚-straightâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam)
        (Î Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ Ì‚á¶ )
}
%```
}
}
