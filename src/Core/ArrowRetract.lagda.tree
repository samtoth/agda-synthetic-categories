\title{Retracts of maps}
\taxon{Module}
\author{samueltoth}
\date{2025-01-06}
\import{stt-macros}


%```agda
\agda{
module Core.ArrowRetract where

open import Foundations.Prelude

open import ufAxioms

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Postwhisker

open import Ergonomics.Marker
}
%```

\subtree[stt-00BJ]{
\title{Retracts of maps}
\taxon{Definition}

\p{We define both coherent and incoherent notions of retracts of maps:}


\p{Given commuting squares as follows: }

\quiver{
\begin{tikzcd}[cramped]
	A && C && A \\
	\\
	B && D && B
	\arrow[hook, from=1-1, to=1-3]
	\arrow["\id", shift left, curve={height=-12pt}, from=1-1, to=1-5]
	\arrow["f"', from=1-1, to=3-1]
	\arrow[two heads, from=1-3, to=1-5]
	\arrow["g", from=1-3, to=3-3]
	\arrow["f", from=1-5, to=3-5]
	\arrow[hook, from=3-1, to=3-3]
	\arrow["\id"', curve={height=18pt}, from=3-1, to=3-5]
	\arrow[two heads, from=3-3, to=3-5]
\end{tikzcd}
}

\p{We say #{f} is a incoherent retract of #{g}. If furthermore, the two squares
paste to make the identity square, then we say #{f} is a coherent retract (or just
retract) of #{g}. Note that despite this terminology, a map being a retract
of another is not a proposition.}

%```agda
\agda{
incoherent-retract-arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
    â†’ Arrow-map f g
    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ)
incoherent-retract-arrow-map {f = f} {g = g} F
  = Î£[ G âˆ¶ Arrow-map g f ]
     ( retract-witness (F .Arrow-map.top) (G .Arrow-map.top)
     Ã— retract-witness (F .Arrow-map.bot) (G .Arrow-map.bot))


retract-arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
    â†’ Arrow-map f g
    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ)
retract-arrow-map {f = f} {g = g} F
  = Î£[ G âˆ¶ Arrow-map g f ]
     Î£[ lr âˆ¶ retract-witness (F .Arrow-map.top) (G .Arrow-map.top) ]
      Î£[ rr âˆ¶ retract-witness (F .Arrow-map.bot) (G .Arrow-map.bot) ]
        ((bot G) â—‚ (comm F) ~âˆ™ (comm G) â–¸ (top F) ~âˆ™ f â—‚ lr
        ~ (rr â–¸ f))
  where open Arrow-map


retract-arrow-map-is-retract
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
      (F : Arrow-map f g)
      ((G , _) : retract-arrow-map F)
    â†’ Arrow-map-path (paste-squares G F) id-square
retract-arrow-map-is-retract {f = f} F (G , lr , rr , fill)
  = (lr , rr , Î» a â†’ âˆ™-assoc (ap (bot G) (comm F a)) _ (ap f (lr a))
                     âˆ™ fill a
                     âˆ™ sym (âˆ™-reflr _))
  where open Arrow-map
}
%```
}


\subtree[stt-00BL]{
\title{Postcomposition of retract squares are retracts squares}
\taxon{Lemma}

\p{Given a square #{F : f \to g}, and a square #{G : g \to f} witnessing #{f}
as a retract of #{g}, then postcomposing #{G} at any type witnesses #{f^*}
as a retract of #{g^*}.}

%```agda
\agda{
postcomp-retract-square
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
      (F : Arrow-map f g)
      ((G , _) : retract-arrow-map F)
      {ğ““} {D : Type ğ““}
     â†’ retract-arrow-map (postcomp-square G D)
postcomp-retract-square F (G , _) .fst = postcomp-square F _
postcomp-retract-square F (G , tr , br , _) .snd .fst a = ap (a âˆ˜_) (funextâ†’ br)
postcomp-retract-square F (G , tr , _) .snd .snd .fst a = ap (a âˆ˜_) (funextâ†’ tr)
postcomp-retract-square {f = f} F (G , lr , rr , coh) .snd .snd .snd j
  = ap (_âˆ˜ _) (funextâ†’ (j â—‚ (Arrow-map.comm G ~â»Â¹)))
  âˆ™ funextâ†’ (Arrow-map.top (postcomp-square G _) j  â—‚ (Arrow-map.comm F ~â»Â¹))
  âˆ™ ap (_âˆ˜ f) (ap (j âˆ˜_) (funextâ†’ rr))
      ï¼âŸ¨ apâ‚ƒ (Î» p q r â†’ p âˆ™ q âˆ™ r) (sym (commutes-postwhisker-funext _)) refl
                      (ap (ap (_âˆ˜ f)) (sym (commutes-prewhisker-funext _))
                        âˆ™ sym (commutes-postwhisker-funext _)) âŸ©
   funextâ†’ (prewhisker j _ _ ((Arrow-map.comm G ~â»Â¹) â–¸ Arrow-map.top F))
 âˆ™ funextâ†’ ((Arrow-map.top (postcomp-square G _) j  â—‚ (Arrow-map.comm F ~â»Â¹)))
 âˆ™ funextâ†’ (postwhisker f (j âˆ˜ Arrow-map.bot G âˆ˜ Arrow-map.bot F) j
             (prewhisker j (Arrow-map.bot G âˆ˜ Arrow-map.bot F) id
               rr))
     ï¼âŸ¨ sym (funext-âˆ™âˆ™ _ _ _) âŸ©
   funextâ†’ (Î» a â†’
              ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
              ap (j âˆ˜ (Arrow-map.bot G)) (sym (Arrow-map.comm F a)) âˆ™
              ap j (rr (f a)))
      ï¼âŸ¨ ap funextâ†’ (funextâ†’ p) âŸ©
   funextâ†’ (prewhisker (j âˆ˜ f) (Arrow-map.top G âˆ˜ Arrow-map.top F)
              id lr) ï¼âŸ¨ commutes-prewhisker-funext lr âŸ©
   ap ((j âˆ˜ f) âˆ˜_) (funextâ†’ lr) âˆ where

  q : âˆ€ a â†’
      sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
      âŒœ sym (ap (Arrow-map.bot G) (Arrow-map.comm F a)) âˆ™
      ap (Arrow-map.bot G) (Arrow-map.comm F a) âˆ™
      Arrow-map.comm G (Arrow-map.top F a) âˆ™ ap f (lr a) âŒ
      ï¼
      sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
      âŒœ sym (ap (Arrow-map.bot G) (Arrow-map.comm F a)) âˆ™
       ap (Arrow-map.bot G) (Arrow-map.comm F a) âˆ™
       Arrow-map.comm G (Arrow-map.top F a) âŒ
      âˆ™ ap f (lr a)
  q a = let
         X = ap f (lr a)
         Y = Arrow-map.comm G (Arrow-map.top F a)
         Z = ap (Arrow-map.bot G) (Arrow-map.comm F a)
         W = sym (ap (Arrow-map.bot G) (Arrow-map.comm F a))
       in ap!
         (sym (âˆ™.assoc-4 _ X Y Z W)
         âˆ™ ap (_âˆ™ ap f (lr a)) (âˆ™-assoc W Z Y ))


  p : âˆ€ a â†’
          ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
          ap (j âˆ˜ Arrow-map.bot G) (sym (Arrow-map.comm F a)) âˆ™
          ap j (rr (f a))
       ï¼
        ap (j âˆ˜ f) (lr a)
  p a
    = ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
       âŒœ ap (j âˆ˜ Arrow-map.bot G) (sym (Arrow-map.comm F a)) âŒ âˆ™
       ap j (rr (f a)) ï¼âŸ¨ ap! (ap-âˆ˜ j (Arrow-map.bot G) _ âˆ™ ap (ap j) (ap-sym _ _)) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
      ap j (sym (ap (Arrow-map.bot G) (Arrow-map.comm F a))) âˆ™
      ap j (rr (f a)) ï¼âŸ¨ sym (ap-âˆ™âˆ™ j (sym (Arrow-map.comm G (Arrow-map.top F a)))
                                      _ (rr (f a))) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
            sym (ap (Arrow-map.bot G) (Arrow-map.comm F a))
            âˆ™ âŒœ rr (f a) âŒ) ï¼âŸ¨ ap! (sym (coh a)) âˆ™ ap (ap j) (q a) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
            âŒœ sym (ap (Arrow-map.bot G) (Arrow-map.comm F a)) âˆ™
            ap (Arrow-map.bot G) (Arrow-map.comm F a) âˆ™
            Arrow-map.comm G (Arrow-map.top F a) âŒ âˆ™ ap f (lr a))
          ï¼âŸ¨ ap! (sym'âˆ™ (ap (Arrow-map.bot G) (Arrow-map.comm F a))
                         (Arrow-map.comm G (Arrow-map.top F a))) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
            Arrow-map.comm G (Arrow-map.top F a) âˆ™ ap f (lr a))
          ï¼âŸ¨ ap (ap j) (sym'âˆ™ (Arrow-map.comm G (Arrow-map.top F a)) (ap f (lr a))) âŸ©
      ap j (ap f (lr a)) ï¼âŸ¨ sym (ap-âˆ˜ j f (lr a)) âŸ©
      ap (j âˆ˜ f) (lr a) âˆ
}
%```
}

\subtree[stt-00BK]{
\title{Incoherent retracts of equivalences are equivalences}
\taxon{Lemma}


%```agda
\agda{
is-equivâ†retract-equiv
   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
    â†’ (F : Arrow-map f g)
    â†’ incoherent-retract-arrow-map F
    â†’ is-equiv g
    â†’ is-equiv f
is-equivâ†retract-equiv {f = f}{g = g} F (G , tr , br) feq
  = is-equivâ†qiso iso where
  open Arrow-map
  open is-equiv feq

  iso : quasi-iso f
  iso .fst = top G âˆ˜ bwd âˆ˜ bot F
  iso .snd .fst = (top G âˆ˜ bwd) â—‚ comm F ~âˆ™ top G â—‚ Î· â–¸ top F ~âˆ™ tr
  iso .snd .snd = (comm G â–¸ bwd â–¸ bot F ~â»Â¹) ~âˆ™ bot G â—‚ Îµ â–¸ bot F ~âˆ™ br
}
%```
}
