\date{2025-05-17}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\title{Orthogonal maps}

% ```agda
\agda{
module Core.Orthogonal where

open import ufAxioms
open import Foundations.Prelude

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Lifts
open import Core.PullbackPower
open import Core.Postwhisker
open import Core.Cube

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
}
% ```


\subtree[stt-0048]{
\title{Orthogonal maps}
\taxon{Definition}

\p{Given maps #{f : A \to B} and #{g : C \to D}, we say
#{f} is orthogonal to #{g} when any [square](stt-003U) has
a unqique [lifting](stt-0044).}

% ```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤}
       {B : Type ğ“¥} {C : Type ğ“¦}
       {D : Type ğ“›} where
  are-orthogonal : âˆ€ (f : A â†’ B) (g : C â†’ D) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›)
  are-orthogonal f g = âˆ€ (F : Arrow-map f g) â†’ unique-lifts F
}
% ```
}



\subtree[stt-004A]{
\title{Classification of orthogonal maps}
\taxon{Theorem}

\p{For maps #{f : A â†’ B} and #{g : C â†’ D}, we have that the following
are equivalent:}

\ol{
  \li{#{f \perp g}}
  \li{The square defined in \ref{stt-004C} is a pullback square}
  \li{The [pullback power](stt-004D) of f with g is an equivalence}
  \li{The [dependent postcomposition](stt-004M) by #{f} at the fibre of
      #{g} is an equivalence.}
}

\proof{
  \p{We have already shown (2) iff (3) as a [corollary](stt-004L) of the fact
     that the pullback power [is homotopic to the gap map](stt-004C).}

  \p{To show (1) iff (3), we note that the pullback power is an equiv
  iff for all #{(G = (t , b , H) : \Hom(f,g))},
  #{\textrm{fib}_{f \pitchfork g}(G)} is a singleton. [We have
  shown](stt-004K) the fibres of the pullback power are equivalent to the
  type of lifts of #{G}.

  \p{Finally we show (2) iff (4).  }
}


%```agda
\agda{
pb-power-is-equivâ†orthogonal
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {D : Type ğ“›}
      {f : A â†’ B} {g : C â†’ D}
    â†’ are-orthogonal f g
    â†’ is-equiv (pullback-power f g)
pb-power-is-equivâ†orthogonal {A = A}{B}{C}{D}{f}{g} orth
  = is-equivâ†is-contr-map Î» where
    G@(mk-amap t b H) â†’ is-singleâ†equiv-to-single
                        (pb-power-fibreâ‰ƒlifts f g G eâ»Â¹)
                        (orth G)


postcomp-Î â†is-cartesian : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
                             {C : Type ğ“¦} {D : Type ğ“›}
                             {f : A â†’ B} {g : C â†’ D}
                           â†’ is-cartesian (power-hom f g)
                           â†’ âˆ€ (h : B â†’ D)
                           â†’ is-equiv (postcomp-Î  (fibre g âˆ˜ h) f)
postcomp-Î â†is-cartesian {f = f} {g} pb h
  = is-equivâ†Arrow-equiv {F = amap} amap-eq (pb h) where
  amap : Arrow-map
           (arrow-fibre (power-hom f g) h)
           (postcomp-Î  (fibre g âˆ˜ h) f)
  amap .Arrow-map.top = _â‰ƒ_.fwd (fibre-precompâ‰ƒ g h)
  amap .Arrow-map.bot = _â‰ƒ_.fwd (fibre-precompâ‰ƒ g (h âˆ˜ f))
  amap .Arrow-map.comm (_ , refl) = refl

  amap-eq : is-Arrow-equiv amap
  amap-eq = ( fibre-precompâ‰ƒ g h ._â‰ƒ_.has-is-eqv
            , fibre-precompâ‰ƒ g (h âˆ˜ f) ._â‰ƒ_.has-is-eqv
            )

is-cartesianâ†postcomp-Î  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
                                {C : Type ğ“¦} {D : Type ğ“›}
                                {f : A â†’ B} {g : C â†’ D}
                              â†’ (âˆ€ h â†’ is-equiv (postcomp-Î  (fibre g âˆ˜ h) f))
                              â†’ is-cartesian (power-hom f g)
is-cartesianâ†postcomp-Î  {f = f}{g} eq h
  = is-equivâ†Arrow-equivâ»Â¹ {F = amap} amap-eq (eq h) where
  amap : Arrow-map
           (arrow-fibre (power-hom f g) h)
           (postcomp-Î  (fibre g âˆ˜ h) f)
  amap .Arrow-map.top = _â‰ƒ_.fwd (fibre-precompâ‰ƒ g h)
  amap .Arrow-map.bot = _â‰ƒ_.fwd (fibre-precompâ‰ƒ g (h âˆ˜ f))
  amap .Arrow-map.comm (_ , refl) = refl

  amap-eq : is-Arrow-equiv amap
  amap-eq = ( fibre-precompâ‰ƒ g h ._â‰ƒ_.has-is-eqv
            , fibre-precompâ‰ƒ g (h âˆ˜ f) ._â‰ƒ_.has-is-eqv
            )

orthogonalâ†postcomp-Î  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
                          {C : Type ğ“¦} {D : Type ğ“›}
                          {f : A â†’ B} {g : C â†’ D}
                       â†’ (âˆ€ (h : B â†’ D) â†’ is-equiv (postcomp-Î  (fibre g âˆ˜ h) f))
                       â†’ are-orthogonal f g
orthogonalâ†postcomp-Î  {f = f}{g} eqv F
  = is-singleâ†equiv-to-single (pb-power-fibreâ‰ƒlifts _ _ F)
     (is-contr-mapâ†is-equiv
       (pullback-powerâ†power-hom-cartesian _ _
         (is-cartesianâ†postcomp-Î  eqv))
        F)

postcomp-Î â†orthogonal : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
                          {C : Type ğ“¦} {D : Type ğ“›}
                          {f : A â†’ B} {g : C â†’ D}
                        â†’ (âˆ€ (h : B â†’ D)
                        â†’ are-orthogonal f g
                        â†’ is-equiv (postcomp-Î  (fibre g âˆ˜ h) f))
postcomp-Î â†orthogonal {f = f}{g} h orth
  = postcomp-Î â†is-cartesian
      (power-hom-cartesianâ†pullback-power f g
        (pb-power-is-equivâ†orthogonal orth)) h


orthogonalâ†is-cartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {D : Type ğ“›}
      {f : A â†’ B} {g : C â†’ D}
      â†’ is-cartesian (power-hom f g)
      â†’ are-orthogonal f g
orthogonalâ†is-cartesian cart
  = orthogonalâ†postcomp-Î  (postcomp-Î â†is-cartesian cart)

is-cartesianâ†orthogonal
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {D : Type ğ“›}
      {f : A â†’ B} {g : C â†’ D}
      â†’ are-orthogonal f g
      â†’ is-cartesian (power-hom f g)
is-cartesianâ†orthogonal orth
  = is-cartesianâ†postcomp-Î  Î» h â†’ postcomp-Î â†orthogonal h orth

orthogonalâ†pb-power-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {D : Type ğ“›}
      {f : A â†’ B} {g : C â†’ D}
    â†’ is-equiv (pullback-power f g)
    â†’ are-orthogonal f g
orthogonalâ†pb-power-is-equiv
  = orthogonalâ†is-cartesian âˆ˜ power-hom-cartesianâ†pullback-power _ _

orthogonalâ‡”pb-power-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {D : Type ğ“›}
      {f : A â†’ B} {g : C â†’ D}
    â†’ is-equiv (pullback-power f g)
    â‡” are-orthogonal f g
orthogonalâ‡”pb-power-is-equiv
  = (orthogonalâ†pb-power-is-equiv , pb-power-is-equivâ†orthogonal)
}
%```
}
}


\subtree[stt-004N]{
\date{2025-05-24}
\taxon{Remark}
\title{Orthogonality at types}
\p{We say that a type #{A} is orthogonal to a map when the unique map #{A \to 1}
   is.}
}


\subtree[stt-004O]{
\date{2025-05-24}
\taxon{Theorem}
\title{Orthogonality via composition}

\p{A type #{A} is [orthogonal](stt-004N) to a map #{X \to Y} iff postcomposition
by f is an equivalence.}

\p{We postpone this proof until later, but for now in the formalisation we
   define orthogonality to be the types satisfying the above property.}

%```agda
\agda{
orthogonal-type : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“¤} {Y : Type ğ“¥}
                    (f : X â†’ Y)
                    (A : Type ğ“¦) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
orthogonal-type f A = is-equiv (postcomp A f)
}
%```
}


\subtree[stt-004B]{
\taxon{Notation}

\p{When we have that #{f} is orthogonal to #{g}, we write
#{f \perp g}. Likewise if #{A} is a type, then we can write
  #{f \perp A} to mean #{f} is orthogonal to #{!_A}.}

% ```agda
\agda{
module notation where
  instance
    orth-maps : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤}
       {B : Type ğ“¥} {C : Type ğ“¦}
       {D : Type ğ“›} â†’ Orthogonality (A â†’ B) (C â†’ D)
    orth-maps {ğ“¤} {ğ“¥} {ğ“¦} {ğ“›} .Orthogonality.ğ“¦ = ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›
    orth-maps .Orthogonality._âŠ¥_ = are-orthogonal

  instance
    orth-map-typ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤}
       {B : Type ğ“¥} â†’ Orthogonality (A â†’ B) (Type ğ“¦)
    orth-map-typ {ğ“¤} {ğ“¥} {ğ“¦} .Orthogonality.ğ“¦ = ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦
    orth-map-typ .Orthogonality._âŠ¥_ = orthogonal-type

open notation
}
% ```
}


\subtree[stt-004Q]{
\taxon{Proof}
\title{Proof of \ref{stt-004O}}

\p{
We want to show #{A \to \bb1} is orthogonal to #{f : X \to Y}, which by
the [[stt-004A]], it surfices to show that for all #{h : Y \to 1}, the map
#{- \circ f : ((y : Y) â†’ \fibre{!}{h(y)}) \to ((x : X) â†’ \fibre{!}{h(f(x))})}
is an equivalence. But the fibre of #{A \to 1} is just A. Formally, we can
use the 3-for-2 property on the following diagram:
}

\quiver{
\begin{tikzcd}
	{\fibre{!}{-}^Y} &&& {\fibre{!}{-}^X} \\
	\\
	& {A^Y} & {A^X}
	\arrow[from=1-1, to=1-4]
	\arrow["\sim"', from=1-1, to=3-2]
	\arrow["{A^f}"', from=3-2, to=3-3]
	\arrow["\sim"', from=3-3, to=1-4]
\end{tikzcd}
}

%```agda
\agda{
is-orthogonalâ‡”orthogonal-! : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“¤} {Y : Type ğ“¥}
                 {f : X â†’ Y} {A : Type ğ“¦}
               â†’ (f âŠ¥ (! {A = A}))
               â‡” (f âŠ¥ A)
is-orthogonalâ‡”orthogonal-! {X = X}{Y}{f}{A}
  = ((Î» orth â†’ is-equivâ†Arrow-equiv {F = sq} sq-is-equiv
                                             (postcomp-Î â†orthogonal ! orth))
    , Î» orth â†’ orthogonalâ†postcomp-Î 
                 Î» _ â†’ is-equivâ†Arrow-equivâ»Â¹ {F = sq} sq-is-equiv orth) where
  fstâ»Â¹ : A â†’ fibre {A = A} ! _
  fstâ»Â¹ a = a , refl

  fst-is-equiv : is-equiv {A = fibre {A = A} ! tt} fst
  fst-is-equiv = is-equivâ†qiso (fstâ»Â¹
                               , (Î» where (a , refl) â†’ refl)
                               , ~refl)

  H :   (fst âˆ˜_) âˆ˜ postcomp-Î  (fibre ! âˆ˜ (Î» _ â†’ tt)) f
      ~ postcomp A f âˆ˜ (fst âˆ˜_)
  H f' = funextâ†’ ~refl

  sq : Arrow-map (postcomp-Î  (fibre {A = A} ! âˆ˜ !) f) (postcomp A f)
  sq .Arrow-map.top = fst âˆ˜_
  sq .Arrow-map.bot = fst âˆ˜_
  sq .Arrow-map.comm = H

  sq-is-equiv  : is-Arrow-equiv sq
  sq-is-equiv .fst = precomp-equiv fst-is-equiv
  sq-is-equiv .snd = precomp-equiv fst-is-equiv
}
%```
}

