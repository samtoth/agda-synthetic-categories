\date{2025-07-29}
\title{Cocartesian squares}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Core.CocartesianSquare where

open import ufAxioms
open import Foundations.Prelude
open import Foundations.Pushout

open import Core.Arrow
open import Core.CanonicalPushouts
}
%```


\subtree[stt-007V]{
\title{Co-cartesian squares}
\taxon{Defintion}

\p{Given a square:}

\quiver{
\begin{tikzcd}
	A && X \\
	\\
	B && Y
	\arrow["{f'}", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["{g'}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{we say that the square is cocartesian if the square [given by
postcomposition](stt-003P) is a [cartesian square](stt-003V).}

%```agda
\agda{
is-cocartesian : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
                   {X : Type ğ“¦} {Y : Type ğ“œ}
                   {f : A â†’ B} {g : X â†’ Y}
                 â†’ Arrow-map f g â†’ (ğ“  : Level)
                 â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ âŠ” lsuc ğ“ )
is-cocartesian F ğ“  = âˆ€ (Q : Type ğ“ )
                     â†’ is-cartesian (postcomp-square F Q)


is-cocartesianÏ‰ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
                    {X : Type ğ“¦} {Y : Type ğ“œ}
                    {f : A â†’ B} {g : X â†’ Y}
                  â†’ Arrow-map f g
                  â†’ TypeÏ‰
is-cocartesianÏ‰ F = âˆ€ {ğ“ } (Q : Type ğ“ )
                    â†’ is-cartesian (postcomp-square F Q)
}
%```
}

\subtree[stt-007W]{
\title{Cocartesian squares are pushouts}
\taxon{Theorem}

\proof{An easy consequence of \ref{stt-003C} and \ref{stt-007Y}}

%```agda
\agda{
is-pushoutâ†is-cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-cocartesianÏ‰ F â†’ is-pushoutÏ‰ _ (Coconeâ†Arrow-map F .snd)
is-pushoutâ†is-cocartesian {f = f} {g} F cc
  = is-pushoutâ†postcomp-pullback _
       (Î» Q â†’ is-pullbackâ†is-cartesian (postcomp-square F Q) (cc Q))

is-cocartesianâ†is-pushout
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {D : Type ğ“œ} {C : Cocone S D}
    â†’ is-pushoutÏ‰ S C â†’ is-cocartesianÏ‰ (Arrow-mapâ†Cocone C)
is-cocartesianâ†is-pushout po Q
  = is-cartesianâ†is-pullback
      (postcomp-square (Arrow-mapâ†Cocone _) Q)
      (postcomp-pullbackâ†is-pushout _ po Q)
}
%```
}


\subtree[stt-0080]{
\title{Pushouts squares of equivalences}
\taxon{Theorem}

\p{Given an equivalence #{f} and any map #{g}, together with a
square #{f \to g}, the square is cocartesian iff #{g} is an
equivalence.}

\proof{
\p{We have the following square given by postcomposition:}
\quiver{
\begin{tikzcd}
	{Q^Y} &&& {Q^B} \\
	& \bullet \\
	\\
	{Q^X} &&& {Q^A}
	\arrow["{Q^b}", from=1-1, to=1-4]
	\arrow["{\rm{gap}}", dashed, from=1-1, to=2-2]
	\arrow["{Q^g}"', from=1-1, to=4-1]
	\arrow["{Q^f}", from=1-4, to=4-4]
	\arrow[from=2-2, to=1-4]
	\arrow["\sim", from=2-2, to=4-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=2-2, to=4-4]
	\arrow["{Q^t}"', from=4-1, to=4-4]
\end{tikzcd}
}

\p{By \ref{stt-007Z}, the projection from the pullback to #{Q^X} is an
equivalence because #{Q^f} is. Then we have a triangle which, by the
[3 for 2](stt-003E) property, shows that #{Q^g} is an equivalence iff
the gap map is.}
}

%```agda
\agda{
cocartesianâ†equiv-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
      {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-equiv f
    â†’ is-equiv g
    â†’ is-cocartesianÏ‰ F
cocartesianâ†equiv-map F feq geq Q
  = is-cartesianâ†is-pullback (postcomp-square F Q)
      (is-pullbackâ†gap (Coneâ†Arrow-map (postcomp-square F Q) .snd)
        (3-for-2
           (pullback-equivâ‚ (postcomp-equiv feq))
           (postcomp-equiv geq))) where
  module F = Arrow-map F

dom-is-equivâ†cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
      {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-equiv f
    â†’ is-cocartesianÏ‰ F
    â†’ is-equiv g
dom-is-equivâ†cocartesian F feq cart = is-equivâ†postcomp _
  Î» {_} {Q} â†’  is-equiv-âˆ˜
      (pullback-equivâ‚ (postcomp-equiv feq))
      (gap-is-equivâ†is-pullback
        (Coneâ†Arrow-map (postcomp-square F Q) .snd)
        (is-pullbackâ†is-cartesian _ (cart Q)))
}
%```
}
