\date{2025-02-19}
\title{Identity types}
\import{stt-macros}


\subtree[identity-def]{
\taxon{definition}

\title{Id}

\p{
For any type #{A : \cal{U}}, and pair of terms #{a,b : A}, we can define a type #{a = b : \cal{U}} generated by the term #{\textrm{refl}_a : a = a}. If the type of the identity is not obvious from context we write #{a =_A b}.
}

% ```agda
\agda{
module foundations.Identity where

open import foundations.universe

data Id {𝓤} (A : Type 𝓤) (a : A) : A → Type 𝓤 where
  refl : Id A a a


{-# BUILTIN EQUALITY Id #-}
{-# BUILTIN REWRITE Id #-}

}
% ```
}

\subtree[identity-notation]{
\taxon{notation}

\p{We defined the identity type to be called \code{Id A a b}, but for convenience, we also define an infix notation: \code{a ＝ b}.
Note that this uses the unicode equals symbol!
}

% ```agda
\agda{
infix 6 _＝_
_＝_ : ∀ {𝓤} {A : Type 𝓤} → A → A → Type 𝓤
a ＝ b = Id _ a b
{-# DISPLAY Id _ a b = a ＝ b #-}

}
% ```
}


\subtree[stt-0005]{
\taxon{theorem}
\title{Identity induction}

\p{ Identity induction, or the J-rule, states that for a fixed value #{a}, and given a family of types #{P} over a singleton, it is enough to
give a term at #{P(a,\refl_a)} to get a term #{P(b,p)} for any #{(b,p) : \Sigma_{b : A} a = b}.}


% ```agda
\agda{
J : ∀ {𝓤 𝓥} {A : Type 𝓤} {a : A} (P : (x : A) → a ＝ x → Type 𝓥)
   → P a refl → ∀ {b} → (p : a ＝ b) → P b p
J P prfl refl = prfl

tr : ∀ {𝓤 𝓥} {A : Type 𝓤} (P : A → Type 𝓥) → ∀ {a b} → a ＝ b → P a → P b
tr P refl pa = pa

}
% ```

}

\subtree[stt-000B]{
\title{Groupoid structure of the universe}


\p{The J-rule allows us to exhibit the universe as a groupoid with the identity type as the homs}

\subtree[stt-000C]{
  \taxon{theorem}
  \title{The Identity is symmetric, transitive and reflexive}
  \ul{
    \li{Given #{x =_A y}, we can define a term of type #{y =_A x}}
    \li{Given #{x = y}, and #{y = z}, we have a term #{x = z}}
    \li{There is always a term #{x = x}}
  }
  \subtree{
    \taxon{proof}
    \p{Reflexivity comes directly from the definition of Id and proofs of the remaining are trivial applications of the identity elimination rule}
% ```agda
\agda{

sym : ∀ {𝓤} {A : Type 𝓤} {x y : A} → x ＝ y → y ＝ x
sym refl = refl

sym-sym : ∀ {𝓤} {A : Type 𝓤} {x y : A} {p : x ＝ y} → sym (sym p) ＝ p
sym-sym {p = refl} = refl

{-# REWRITE sym-sym #-}

trans : ∀ {𝓤} {A : Type 𝓤} {x y z : A} → x ＝ y → y ＝ z → x ＝ z
trans refl p = p

_∙_ = trans
infixr 20 _∙_

∙-refll : ∀ {𝓤} {A : Type 𝓤} {x y : A} → (p : x ＝ y) → refl ∙ p ＝ p
∙-refll p = refl

∙-reflr : ∀ {𝓤} {A : Type 𝓤} {x y : A} → (p : x ＝ y) → p ∙ refl ＝ p
∙-reflr refl = refl

∙-assoc : ∀ {𝓤} {A : Type 𝓤} {x y z w : A} (p : x ＝ y) (q : y ＝ z) (r : z ＝ w) → (p ∙ q) ∙ r ＝ p ∙ q ∙ r
∙-assoc refl q r = refl

∙-sym : ∀ {𝓤} {A : Type 𝓤} {x y : A} (p : x ＝ y) → p ∙ sym p ＝ refl
∙-sym refl = refl

∙-sym' : ∀ {𝓤} {A : Type 𝓤} {x y : A} (p : x ＝ y) → sym p ∙ p ＝ refl
∙-sym' refl = refl

＝⟨⟩-syntax : ∀ {𝓤} {A : Type 𝓤} (x : A) {y z} → y ＝ z → x ＝ y → x ＝ z
＝⟨⟩-syntax x q p = p ∙ q

infixr 2 ＝⟨⟩-syntax
syntax ＝⟨⟩-syntax x q p = x ＝⟨ p ⟩ q

_＝⟨⟩_ : ∀ {𝓤} {A : Type 𝓤} (x : A) {y : A} → x ＝ y → x ＝ y
x ＝⟨⟩ p = p

_∎ : ∀ {ℓ} {A : Type ℓ} (x : A) → x ＝ x
x ∎ = refl

infixr 2 _＝⟨⟩_ 
infix  3 _∎


tr∙tr : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥} → ∀ {a b c} (p : a ＝ b) (q : b ＝ c)
      (b : P a)
      → tr P q (tr P p b) ＝ tr P (p ∙ q) b
tr∙tr refl refl b = refl

tr∙tr-sym : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥} → ∀ {a b} (p : a ＝ b)
            → (b : P a)
            → tr P (sym p) (tr P p b) ＝ b
tr∙tr-sym refl b = refl            

tr∙tr-sym' : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥} → ∀ {a b} (p : a ＝ b)
            → (b : P b)
            → tr P p (tr P (sym p) b) ＝ b
tr∙tr-sym' refl b = refl            
}
% ```
  }

}
}
