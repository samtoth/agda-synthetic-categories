\title{Maps between span diagrams}
\author{samueltoth}
\date{2025-11-21}
\taxon{Module}

\import{stt-macros}

%```agda
\agda{
module Core.SpanMap where

open import Foundations.Prelude
open import ufAxioms

open import Ergonomics.Marker
open import Ergonomics.Representation
open import Ergonomics.Extensionality

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CanonicalPushouts
}
%```


\subtree[stt-008M]{
\date{2025-08-03}
\title{Maps of spans}
\taxon{Definition}

\p{A map between spans #{S} and #{S'} is a diagram as follows where
all the squares commute:}

\quiver{
\begin{tikzcd}
	A && S && B \\
	\\
	{A'} && {S'} && {B'}
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=1-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=3-5]
	\arrow[from=3-3, to=3-1]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}


%```agda
\agda{
record Span-map {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                {ğ“¤' ğ“¥' ğ“¦'} (S' : Span ğ“¤' ğ“¥' ğ“¦')
                : Type (ğ“¤ âŠ” ğ“¤' âŠ” ğ“¥ âŠ” ğ“¥' âŠ” ğ“¦ âŠ” ğ“¦') where
   constructor mk-span-map
   module S = Span S
   module S' = Span S'
   field
     hâ‚ : S.Left â†’ S'.Left
     hâ‚‚ : S.Centre â†’ S'.Centre
     hâ‚ƒ : S.Right â†’ S'.Right
     H  : hâ‚ âˆ˜ S.left ~ S'.left âˆ˜ hâ‚‚
     K  : hâ‚ƒ âˆ˜ S.right ~ S'.right âˆ˜ hâ‚‚

   amap-lâ†“ : Arrow-map S.left S'.left
   amap-lâ†“ = mk-amap hâ‚‚ hâ‚ H

   amap-l : Arrow-map hâ‚‚ hâ‚
   amap-l = mk-amap S.left S'.left (H ~â»Â¹)

   amap-râ†“ : Arrow-map S.right S'.right
   amap-râ†“ = mk-amap hâ‚‚ hâ‚ƒ K

   amap-r : Arrow-map hâ‚‚ hâ‚ƒ
   amap-r = mk-amap S.right S'.right (K ~â»Â¹)

unquoteDecl Span-map-reprâ‰… Span-map-reprâ‰ƒ
  = make-record-repr Span-map-reprâ‰… Span-map-reprâ‰ƒ (quote Span-map)
}
%```

\p{Equivalently, a span map is a pair of arrow maps between the
left and right maps of each span, together with a homotopy between
the two maps between the centre of the spans.}

%```agda
\agda{
Arrow-mapsâ†Span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S'
    â†’ let module S = Span S ; module S' = Span S'
    in Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top)
Arrow-mapsâ†Span-map S = (amap-lâ†“ , amap-râ†“ , ~refl) where open Span-map S

Span-mapâ†Arrow-maps
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S ; module S' = Span S'
    in Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top)
    â†’ Span-map S S'
Span-mapâ†Arrow-maps (F , G , H)
  = funext-rec (Î» _ â†’ Span-map _ _) at-refl H module from-arrow-map where
  module F = Arrow-map F
  module G = Arrow-map G

  at-refl : F.top ï¼ G.top â†’ Span-map _ _
  at-refl refl = mk-span-map F.bot G.top G.bot F.comm G.comm

Span-mapâ‰ƒArrow-maps
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S ; module S' = Span S'
    in (Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top))
    â‰ƒ Span-map S S'
Span-mapâ‰ƒArrow-maps = mkâ‰ƒ Span-mapâ†Arrow-maps (is-equivâ†qiso qiso) where
  qiso : quasi-iso Span-mapâ†Arrow-maps
  qiso .fst = Arrow-mapsâ†Span-map
  qiso .snd .fst x@(F , G , HH)
    = funext-rec
        (Î» HH'
          â†’ Arrow-mapsâ†Span-map (Span-mapâ†Arrow-maps (F , G , HH')) ï¼ (F , G , HH'))
        lem
        HH where
    open Span-map
    lem : (p : (Arrow-map.top F) ï¼ (Arrow-map.top G)) â†’
           Arrow-mapsâ†Span-map (Span-mapâ†Arrow-maps (F , G , happly p)) ï¼
           (F , G , happly p)
    lem refl =
      (Arrow-mapsâ†Span-map âˆ˜ Span-mapâ†Arrow-maps) (F , G , ~refl) ï¼âŸ¨âŸ©
      Arrow-mapsâ†Span-map (funext-rec (Î» _ â†’ Span-map _ _)
        (from-arrow-map.at-refl _ _ _) ~refl)
      ï¼âŸ¨ ap Arrow-mapsâ†Span-map (funext-rec-~refl _ _) âŸ©
      (F , G , ~refl) âˆ where open Span-map
  qiso .snd .snd F =  funext-rec-~refl _ _

span-map-pathPâ†’
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {S'' : Span ğ“¤' ğ“¥' ğ“¦'}
      {f : Span-map S' S} {g : Span-map S'' S}
    â†’ let module S = Span S
          module S' = Span S'
          module S'' = Span S''
          module f = Span-map f
          module g = Span-map g
    in (p : S'.Centre ï¼ S''.Centre)
    â†’ (q : S'.Left ï¼ S''.Left)
    â†’ (r : S'.Right ï¼ S''.Right)
    â†’ (h : coe r âˆ˜ S'.right ï¼ S''.right âˆ˜ coe p)
    â†’ (k : coe q âˆ˜ S'.left ï¼ S''.left âˆ˜ coe p)
    â†’ (Q : f.hâ‚ ï¼ g.hâ‚ âˆ˜ coe q)
    â†’ (P : f.hâ‚‚ ï¼ g.hâ‚‚ âˆ˜ coe p)
    â†’ (R : f.hâ‚ƒ ï¼ g.hâ‚ƒ âˆ˜ coe r)
    â†’ (H : f.H ï¼   (happly Q â–¸ S'.left) ~âˆ™ (g.hâ‚ â—‚ happly k)
                  ~âˆ™ (g.H â–¸ coe p) ~âˆ™ (S.left â—‚ happly (sym P)))
    â†’ (K : f.K ï¼ (happly R â–¸ S'.right) ~âˆ™ (g.hâ‚ƒ â—‚ happly h)
                 ~âˆ™ (g.K â–¸ coe p) ~âˆ™ S.right â—‚ (happly (sym P)))
    â†’ IdP (ap (Î» P â†’ Span-map P S) (Span-pathâ†’ p q r h k)) f g
span-map-pathPâ†’ refl refl refl refl refl refl refl refl refl refl
  = apâ‚‚ (Î» P Q â†’ mk-span-map _ _ _ P Q)
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))
}
%```
}

\subtree[stt-00B5]{
\title{Span equivalences}
\taxon{Theorem}

\p{We call a span map an equivalence if each component is an equivalence.
Span equivalences give rise to inverse span maps in the obvious way.}

%```agda
\agda{
is-Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S' â†’ Type (ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦' âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
is-Span-equiv F = is-equiv hâ‚
                    Ã— is-equiv hâ‚‚
                    Ã— is-equiv hâ‚ƒ where
  open Span-map F

l-is-arrow-equivâ†is-span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ is-Arrow-equiv (Span-map.amap-lâ†“ F)
l-is-arrow-equivâ†is-span-equiv F eq
  = (eq .snd .fst , eq .fst)

r-is-arrow-equivâ†is-span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ is-Arrow-equiv (Span-map.amap-râ†“ F)
r-is-arrow-equivâ†is-span-equiv F eq
  = (eq .snd .fst , eq .snd .snd)

Spanâ»Â¹â†Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ Span-map S' S
Spanâ»Â¹â†Span-equiv F (e1 , e2 , e3)
  = mk-span-map Fâ‚.bwd Fâ‚‚.bwd Fâ‚ƒ.bwd H1 H2 module Span-inv where
  module F = Span-map F
  module S = F.S
  module S' = F.S'
  module Fâ‚ = is-equiv e1
  module Fâ‚‚ = is-equiv e2
  module Fâ‚ƒ = is-equiv e3


  K1 : F.hâ‚ âˆ˜ Fâ‚.bwd âˆ˜ S'.left âˆ˜ F.hâ‚‚ ~ F.hâ‚ âˆ˜ S.left âˆ˜ Fâ‚‚.bwd âˆ˜ F.hâ‚‚
  K1 = (Fâ‚.Îµ â–¸ S'.left â–¸ F.hâ‚‚ ~âˆ™ (F.H ~â»Â¹) ~âˆ™ (F.hâ‚ â—‚ (S.left â—‚ Fâ‚‚.Î·) ~â»Â¹))

  H1 : Fâ‚.bwd âˆ˜ S'.left ~ S.left âˆ˜ Fâ‚‚.bwd
  H1 = e1 â—‚eqv K1 â–¸eqv e2

  K2 : F.hâ‚ƒ âˆ˜ Fâ‚ƒ.bwd âˆ˜ S'.right âˆ˜ F.hâ‚‚ ~ F.hâ‚ƒ âˆ˜ S.right âˆ˜ Fâ‚‚.bwd âˆ˜ F.hâ‚‚
  K2 = (Fâ‚ƒ.Îµ â–¸ S'.right â–¸ F.hâ‚‚) ~âˆ™ (F.K ~â»Â¹) ~âˆ™ (F.hâ‚ƒ â—‚ (S.right â—‚ Fâ‚‚.Î·) ~â»Â¹)

  H2 : Fâ‚ƒ.bwd âˆ˜ S'.right ~ S.right âˆ˜ Fâ‚‚.bwd
  H2 = e3 â—‚eqv K2 â–¸eqv e2
}
%```
}

\subtree[stt-00AJ]{
\title{Span map composition}
\taxon{Construction}
\date{2025-11-21}

%```agda
\agda{
compose-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' ğ“¤'' ğ“¥'' ğ“¦''}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'} {S'' : Span ğ“¤'' ğ“¥'' ğ“¦''}
    â†’ Span-map S' S'' â†’ Span-map S S'
    â†’ Span-map S S''
compose-span-map F G = map where
  module F = Span-map F
  module G = Span-map G

  map : Span-map _ _
  map .Span-map.hâ‚ = F.hâ‚ âˆ˜ G.hâ‚
  map .Span-map.hâ‚‚ = F.hâ‚‚ âˆ˜ G.hâ‚‚
  map .Span-map.hâ‚ƒ = F.hâ‚ƒ âˆ˜ G.hâ‚ƒ
  map .Span-map.H = (F.hâ‚ â—‚ G.H) ~âˆ™ (F.H â–¸ G.hâ‚‚)
  map .Span-map.K = F.hâ‚ƒ â—‚ G.K ~âˆ™ F.K â–¸ G.hâ‚‚

id-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
  â†’ Span-map S S
id-span-map = mk-span-map id id id ~refl ~refl

id-span-map-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
    â†’ is-Span-equiv (id-span-map {S = S})
id-span-map-is-equiv = (id-is-equiv , id-is-equiv , id-is-equiv)
}
%```
}

\subtree[stt-00AZ]{
\title{Univalence for spans}
\taxon{Theorem}

\p{Span equivalences are an identity system for spans.}

%```
\agda{
Span-equiv
  : {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' : Level}
  â†’ Span ğ“¤ ğ“¥ ğ“¦
  â†’ Span ğ“¤' ğ“¥' ğ“¦'
  â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
Span-equiv S S' = Î£[ F âˆ¶ Span-map S S' ] is-Span-equiv F

Span-equiv'
  : {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' : Level}
  â†’ Span ğ“¤ ğ“¥ ğ“¦
  â†’ Span ğ“¤' ğ“¥' ğ“¦'
  â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
Span-equiv' S S'
  = Î£[ F âˆ¶ (S .Span.Centre â‰ƒ S' .Span.Centre) ]
    Î£[ L âˆ¶ (S .Span.Left â‰ƒ S' .Span.Left) ]
    Î£[ _ âˆ¶ (L ._â‰ƒ_.fwd âˆ˜ S .Span.left ~ S' .Span.left âˆ˜ F ._â‰ƒ_.fwd) ]
    Î£[ R âˆ¶ (S .Span.Right â‰ƒ S' .Span.Right) ]
      (R ._â‰ƒ_.fwd âˆ˜ S .Span.right ~ S' .Span.right âˆ˜ F ._â‰ƒ_.fwd)

Span-equiv'â‰ƒSpan-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span  ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-equiv S S' â‰ƒ Span-equiv' S S'
Span-equiv'â‰ƒSpan-equiv {S = S} {S' = S'}
  = equivâ†qiso qiso where
  qiso : Span-equiv S S' â‰… Span-equiv' S S'
  qiso ._â‰…_.fwd (smap , (leq , ceq , req))
    =
    ( mkâ‰ƒ (smap .Span-map.hâ‚‚) ceq
    , mkâ‰ƒ (smap .Span-map.hâ‚) leq
    , smap .Span-map.H
    , mkâ‰ƒ (smap .Span-map.hâ‚ƒ) req
    , smap .Span-map.K)
  qiso ._â‰…_.fwd-iso .fst (mkâ‰ƒ c ceq , mkâ‰ƒ l leq , H , mkâ‰ƒ r req , K)
    = (mk-span-map l c r H K , leq , ceq , req)
  qiso ._â‰…_.fwd-iso .snd .fst = ~refl
  qiso ._â‰…_.fwd-iso .snd .snd = ~refl

Span-equivâ†’components
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-equiv S S' â†’ Span-equiv' S S'
Span-equivâ†’components = _â‰ƒ_.fwd Span-equiv'â‰ƒSpan-equiv

Span-equivâ†components
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-equiv' S S' â†’ Span-equiv S S'
Span-equivâ†components = _â‰ƒ_.bwd Span-equiv'â‰ƒSpan-equiv

inverse-componentsâ†Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-equiv S S'
    â†’ Span-equiv' S' S
inverse-componentsâ†Span-equiv {S = S} {S'} e
  = from-components (Span-equivâ†’components e)
  where
  from-components
    : Span-equiv' S S'
    â†’ Span-equiv' S' S
  from-components (F , L , H , R , K)
    = (F eâ»Â¹)
    , (L eâ»Â¹ , left-inv-comm , (R eâ»Â¹ , right-inv-comm))
    where
    left-inv-comm : _â‰ƒ_.bwd L âˆ˜ S' .Span.left ~ S .Span.left âˆ˜ _â‰ƒ_.bwd F
    left-inv-comm p
      = ap (_â‰ƒ_.bwd L) (ap (S' .Span.left) (sym (_â‰ƒ_.Îµ F p)))
      âˆ™ ap (_â‰ƒ_.bwd L) (sym (H (_â‰ƒ_.bwd F p)))
      âˆ™ _â‰ƒ_.Î· L (S .Span.left (_â‰ƒ_.bwd F p))

    right-inv-comm : _â‰ƒ_.bwd R âˆ˜ S' .Span.right ~ S .Span.right âˆ˜ _â‰ƒ_.bwd F
    right-inv-comm p
      = ap (_â‰ƒ_.bwd R) (ap (S' .Span.right) (sym (_â‰ƒ_.Îµ F p)))
      âˆ™ ap (_â‰ƒ_.bwd R) (sym (K (_â‰ƒ_.bwd F p)))
      âˆ™ _â‰ƒ_.Î· R (S .Span.right (_â‰ƒ_.bwd F p))

Span-equivâ†inverse-components
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-equiv' S' S
    â†’ Span-equiv S S'
Span-equivâ†inverse-components {S = S} {S'} (F , L , H , R , K)
  = Span-equivâ†components
      ( (F eâ»Â¹)
      , (L eâ»Â¹)
      , (Î» p
          â†’ sym (ap (_â‰ƒ_.bwd L) (ap (Span.left S) (_â‰ƒ_.Îµ F p)))
          âˆ™ sym (ap (_â‰ƒ_.bwd L) (H (_â‰ƒ_.bwd F p)))
          âˆ™ is-equiv.Î· (L ._â‰ƒ_.has-is-eqv) (Span.left S' (_â‰ƒ_.bwd F p)))
      , (R eâ»Â¹)
      , (Î» p
          â†’ sym (ap (_â‰ƒ_.bwd R) (ap (Span.right S) (_â‰ƒ_.Îµ F p)))
          âˆ™ sym (ap (_â‰ƒ_.bwd R) (K (_â‰ƒ_.bwd F p)))
          âˆ™ is-equiv.Î· (R ._â‰ƒ_.has-is-eqv) (Span.right S' (_â‰ƒ_.bwd F p))))

Span-equivâ†Id
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S S' : Span ğ“¤ ğ“¥ ğ“¦}
    â†’ S ï¼ S' â†’ Span-equiv S S'
Span-equivâ†Id {S = S} refl = (id-span-map , id-span-map-is-equiv {S = S})

opaque
  Span-equivâ†Id-is-equiv
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S S' : Span ğ“¤ ğ“¥ ğ“¦} â†’ is-equiv (Span-equivâ†Id {S = S}{S'})
  Span-equivâ†Id-is-equiv {S = S} {S'}
    = fundamental-Id
       (Span-equiv S)
       (is-singleâ†equiv-to-single
         ((Î£-ap-â‰ƒ-fst
            {B = Î» (C , _ , f , _ , g) â†’ Span-equiv S (mk-span C f g) }
            Span-reprâ‰ƒ âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» a â†’ Span-equiv'â‰ƒSpan-equiv)) eâ»Â¹)
         (is-singleton-structureâ†parts (SingS-is-single (Centre S))
          (S .Centre , idequiv)
          (is-singleton-structureâ†parts
           (SingS-is-single (Left S))
           (Left S , idequiv)
           (is-singleton-structureâ†parts
            (SingS-is-single (left S))
            (left S , ~refl)
            (is-singleton-structureâ†parts
              (SingS-is-single (Right S))
              (Right S , idequiv)
              (SingS-is-single (right S)))))))
       (Î» _ â†’ Span-equivâ†Id)
       S' where open Span

instance
  SpanIdS : âˆ€ {ğ“¤ ğ“¥ ğ“¦} â†’ Identity-system (Span ğ“¤ ğ“¥ ğ“¦) (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
  SpanIdS .Identity-system.IdS = Span-equiv
  SpanIdS .Identity-system.IdSâ†Id = Span-equivâ†Id
  SpanIdS .Identity-system.has-is-ids _ _ = Span-equivâ†Id-is-equiv
}
%```
}


\subtree[stt-00B0]{
\title{Homotopy of span maps}
\taxon{Definition}

%```agda
\agda{
Span-map-homotopy
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F G : Span-map S S') â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
Span-map-homotopy F G
  = Î£[ Hâ‚ âˆ¶ F.hâ‚ ~ G.hâ‚ ] Î£[ Hâ‚‚ âˆ¶ F.hâ‚‚ ~ G.hâ‚‚ ] Î£[ Hâ‚ƒ âˆ¶ F.hâ‚ƒ ~ G.hâ‚ƒ ]
       ( F.H ~ Hâ‚ â–¸ F.S.left ~âˆ™ G.H ~âˆ™ F.S'.left â—‚ (Hâ‚‚ ~â»Â¹)
       Ã—  F.K ~ Hâ‚ƒ â–¸ F.S.right ~âˆ™ G.K ~âˆ™ F.S'.right â—‚ (Hâ‚‚ ~â»Â¹)) where
  module F = Span-map F
  module G = Span-map G

Span-map-homotopy-refl
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ Span-map-homotopy F F
Span-map-homotopy-refl F = ~refl , ~refl , ~refl , ~âˆ™-reflr _ ~â»Â¹ , ~âˆ™-reflr _ ~â»Â¹

Span-map-funextâ†’
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {F G : Span-map S S'} â†’ Span-map-homotopy F G â†’ F ï¼ G
Span-map-funextâ†’ {S = S} {S'} {F} {G} (p , q , r , s , t)
  = span-map-pathPâ†’ refl refl refl refl refl
     (funextâ†’ p) (funextâ†’ q) (funextâ†’ r)
     (funextâ†’ (Î» a â†’ s a âˆ™ ap ((p (S.left a) âˆ™_) âˆ˜ (G.H a âˆ™_))
                  (ap (ap G.S'.left) (sym (happly (happly-sym (funextâ†’ q) a) a)))))
     (funextâ†’ (Î» a â†’ t a âˆ™ ap ((r (S.right a) âˆ™_) âˆ˜ (G.K a âˆ™_))
                  (ap (ap S'.right) (sym (happly (happly-sym (funextâ†’ q) a) a))))) where
   module S = Span S
   module S' = Span S'
   module G = Span-map G
}
%```
}

\subtree[stt-00AM]{
\title{Isomorphisms of spans}
\taxon{Theorem}

\p{An equivalence of spans gives rise to a quasi-isomorphism in span. I.e. we
get a pair of span maps whose composition is homotopic to the identity span map.}


\remark{This remains to be formalised.}

%```agda
\agda{
record Span-quasi-iso {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
         {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'} (F : Span-map S S')
         : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦') where
  constructor mk-span-qiso
  field
    bwd : Span-map S' S
    Îµ : Span-map-homotopy (compose-span-map F bwd) id-span-map
    Î· : Span-map-homotopy (compose-span-map bwd F) id-span-map
}
%```
}


\subtree[stt-00CN]{
\title{Spans of proposition}
\taxon{Definition}

\p{We call a span a \em{span of propositions} if each type is a proposition.}

%```agda
\agda{
is-prop-span : âˆ€ {ğ“¤ ğ“¥ ğ“¦} â†’ Span ğ“¤ ğ“¥ ğ“¦ â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
is-prop-span S = is-prop Left Ã— is-prop Centre Ã— is-prop Right
  where open Span S
}
%```

\p{We note that any span map into a propositional span is equal.}

%```agda
\agda{
Span-map-homotopyâ†dom-is-prop
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F G : Span-map S S') â†’ is-prop-span S' â†’ Span-map-homotopy F G
Span-map-homotopyâ†dom-is-prop F G prp .fst a
  = prp .fst (Span-map.hâ‚ F a) (Span-map.hâ‚ G a)
Span-map-homotopyâ†dom-is-prop F G prp .snd .fst a
  = prp .snd .fst (Span-map.hâ‚‚ F a) (Span-map.hâ‚‚ G a)
Span-map-homotopyâ†dom-is-prop F G prp .snd .snd .fst a
  = prp .snd .snd (Span-map.hâ‚ƒ F a) (Span-map.hâ‚ƒ G a)
Span-map-homotopyâ†dom-is-prop F G prp .snd .snd .snd .fst _
  = is-propâ†is-single (ï¼-singletonâ†is-prop (prp .fst) _ _) _ _
Span-map-homotopyâ†dom-is-prop F G prp .snd .snd .snd .snd _
  = is-propâ†is-single (ï¼-singletonâ†is-prop (prp .snd .snd) _ _) _ _
}
%```
}

\subtree[stt-00CO]{
\title{Logical equivalence of spans}
\taxon{Definition}

\p{Given spans #{S} and #{S'} (which are usually spans of propositions),
a logical equivalence #{S \iff S'} of spans is a logical equivalence between
each point of the spans.}

%```agda
\agda{
Span-logical-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} (S : Span ğ“¤ ğ“¥ ğ“¦) (S' : Span ğ“¤' ğ“¥' ğ“¦')
                     â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
Span-logical-equiv S S' = (S .Left â‡” S' .Left)
                        Ã— (S .Centre â‡” S' .Centre)
                        Ã— (S .Right â‡” S' .Right)
  where open Span
}
%```

\p{We show a logical equivalence of spans of propositions gives rise to an
equivalence of spans.}

%```agda
\agda{
module Span-logical-equiv {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
         {S : Span ğ“¤ ğ“¥ ğ“¦} (spr : is-prop-span S)
         {S' : Span ğ“¤' ğ“¥' ğ“¦'} (s'pr : is-prop-span S')
         (e : Span-logical-equiv S S')
         where
  fwd : Span-map S S'
  fwd .Span-map.hâ‚ = e .fst .fst
  fwd .Span-map.hâ‚‚ = e .snd .fst .fst
  fwd .Span-map.hâ‚ƒ = e .snd .snd .fst
  fwd .Span-map.H _ = s'pr .fst _ _
  fwd .Span-map.K _ = s'pr .snd .snd _ _

  bwd : Span-map S' S
  bwd .Span-map.hâ‚ = e .fst .snd
  bwd .Span-map.hâ‚‚ = e .snd .fst .snd
  bwd .Span-map.hâ‚ƒ = e .snd .snd .snd
  bwd .Span-map.H _ = spr .fst _ _
  bwd .Span-map.K _ = spr .snd .snd _ _

  fwd-is-equiv : is-Span-equiv fwd
  fwd-is-equiv .fst = is-equivâ†inverse (spr .fst) (s'pr .fst) (e .fst .snd)
  fwd-is-equiv .snd .fst
    = is-equivâ†inverse (spr .snd .fst) (s'pr .snd .fst) (e .snd .fst .snd)
  fwd-is-equiv .snd .snd
    = is-equivâ†inverse (spr .snd .snd) (s'pr .snd .snd) (e .snd .snd .snd)

  fwd-qiso : Span-quasi-iso fwd
  fwd-qiso .Span-quasi-iso.bwd = bwd
  fwd-qiso .Span-quasi-iso.Îµ = Span-map-homotopyâ†dom-is-prop _ _ s'pr
  fwd-qiso .Span-quasi-iso.Î· = Span-map-homotopyâ†dom-is-prop _ _ spr
}
%```
}
