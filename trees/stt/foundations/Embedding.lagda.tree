\date{2025-02-24}
\title{Embeddings}

\import{stt-macros}

\p{Embeddings are the homotopy coherent generalisation of injective functions}

% ```agda
\agda{
module foundations.Embedding where

open import foundations.universe
open import foundations.Functions
open import foundations.Identity
open import foundations.Homotopy
open import foundations.CoherentIsomorphism
open import foundations.QuasiIsomorphism
open import foundations.Sigma
open import foundations.FunctionInverses
open import foundations.PathReasoning
}
% ```

\subtree{
\title{embedding}
\taxon{definition}

\p{A function #{f : A \to B} is an embedding if #{f^* : x = y \to f(x) = f(y)} is an embedding}

% ```agda
\agda{

is-embedding : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-embedding f = âˆ€ {x y} â†’ is-equiv (ap {x = x} {y} f)

is-embeddingâ†’inj : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ is-embedding f â†’ âˆ€ {x y} â†’ f x ï¼ f y â†’ x ï¼ y
is-embeddingâ†’inj emb = is-equiv.bwd emb
}
% ```
}


\subtree{
\taxon{theorem}
\title{Equivalences are embeddings}

% ```agda
\agda{

is-equivâ†’is-embedding : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ is-equiv f â†’ is-embedding f 
is-equivâ†’is-embedding {f = f} eq {x} {y} = qisoâ†’is-equiv qiso' where
  open is-equiv eq renaming (bwd to finv)
}
% ```

\proof{
\p{Suppose #{f} is an equivalence, we will find a quasi-inserve to #{\textit{ap}_f}.
Given an identity #{p : f x = f y}, we obtain #{f^{-1}(f(x)) = f^{-1}(f(y))} by applying the inverse. }

% ```agda
\agda{
  inverse : f x ï¼ f y â†’ x ï¼ y
  inverse p = {- x          ï¼âŸ¨ -} sym (Îµ x) âˆ™ -- âŸ©
              {- finv (f x) ï¼âŸ¨ -} ap finv p âˆ™ -- âŸ©
              {- finv (f y) ï¼âŸ¨ -} Îµ y -- âŸ©
              {- y          âˆ -}
}
% ```

% ```agda
\agda{
  ret : retract-witness (ap f) inverse
  ret refl = inverse refl         ï¼âŸ¨âŸ©
             sym (Îµ x) âˆ™ refl âˆ™ Îµ y  ï¼âŸ¨ refl âŸ©
             sym (Îµ x) âˆ™ Îµ x         ï¼âŸ¨ âˆ™-sym' (Îµ x) âŸ©
             refl âˆ
}
% ```





% ```agda
\agda{
  sec : ap f âˆ˜ inverse ~ id
  sec p = ap f (inverse p)                    ï¼âŸ¨âŸ©
          ap f (sym (Îµ x) âˆ™ ap finv p âˆ™ Îµ y)  ï¼âŸ¨ {! !} âŸ©
          {!!} âˆ
}
% ```

% ```agda
\agda{
  qiso' : is-quasi-iso (ap f)
  qiso' .fst = inverse
  qiso' .snd .fst = sec
  qiso' .snd .snd = {!!}
}
% ```

}
}
