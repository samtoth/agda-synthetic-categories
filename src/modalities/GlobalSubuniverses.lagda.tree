\date{2025-06-14}
\title{Global subuniverses}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb modalities.GlobalSubuniverses \stopverb}
\import{stt-macros}


\p{The developments in this module follow \citet{foundations.global-subuniverses}{agda-unimath}.}

%```agda
\agda{
module modalities.GlobalSubuniverses where

open import foundations.Prelude
open import modalities.Subuniverses
open import core.Postwhisker
open import core.PiSection
open import ergonomics.Extensionality
}
%```

\subtree[stt-007A]{
\title{Global subuniverses}

\p{A global subuniverse is a subuniverse for each #{\UU}
which is closed under equivalence. (Which hold via univalence for
a particular univalent universe but not for equivalences between
of different universes).}

% ```agda
\agda{
record GSU (Î± : Level â†’ Level) : TypeÏ‰ where
  constructor mk-GSU
  field
    S : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (Î± ğ“¤)
    S-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
              â†’ A â‰ƒ B
              â†’ A âˆˆ S â†’ B âˆˆ S

SubUâ†global : âˆ€ {Î±} â†’ GSU Î± â†’  âˆ€ {ğ“¤} â†’ SubU ğ“¤ (Î± ğ“¤)
SubUâ†global (mk-GSU s _) = s
}
%```
}

\subtree[stt-007B]{
\taxon{definition}
\title{Global reflectors}

\p{For a particular type #{A : \UU},
we say that #{(\bigcirc A, \eta : A \to \bigcirc A)} is a global
reflector for #{A} when postcomposition by #{\eta} at modal types (of any universe)
is an equivalence. This equivalence gives us a recursion principal for #{\bigcirc A}.}


%```agda
\agda{
record is-global-reflector {Î±} (GS : GSU Î±)
         {ğ“¤} (A : Type ğ“¤)
         (â—‹A : Type ğ“¤) (Î· : A â†’ â—‹A) : TypeÏ‰ where
  constructor mk-grfltor
  open GSU GS
  field
    â—‹âˆˆS : â—‹A âˆˆ S
    reflects : âˆ€ {ğ“¥} {Q : Type ğ“¥}
               â†’ Q âˆˆ S â†’ is-equiv (postcomp Q Î·)

  â—‹-rec : âˆ€ {ğ“¥} {Q : Type ğ“¥} â†’ Q âˆˆ S â†’ (A â†’ Q) â†’ (â—‹A â†’ Q)
  â—‹-rec cs = is-equiv.bwd (reflects cs)

  â—‹-rec-Î² : âˆ€ {ğ“¥} {Q : Type ğ“¥} (p : Q âˆˆ S) (f : A â†’ Q)
             â†’ â—‹-rec p f âˆ˜ Î· ~ f
  â—‹-rec-Î² p f a = happly (is-equiv.Îµ (reflects p) f) a

  module âˆˆSâ–¸Î· {ğ“¦} {C : Type ğ“¦} {g h} (CâˆˆS : C âˆˆ S)
    = is-equiv (postwhisker-is-equivâ†ap-compose {A = A} {g = g}{h}
                         (is-embeddingâ†is-equiv (reflects CâˆˆS)))

is-reflectorâ†global : âˆ€ {Î±} {GS : GSU Î±} {ğ“¤}
                        {A : Type ğ“¤} {â—‹A : Type ğ“¤} {Î· : A â†’ â—‹A}
                      â†’ is-global-reflector GS A â—‹A Î·
                      â†’ let open GSU GS in is-reflector S A â—‹A Î·
is-reflectorâ†global (mk-grfltor â—‹âˆˆS reflects) = mk-is-rfltor â—‹âˆˆS reflects
}
%```

\p{A global subuniverse is said to be reflective if we have all
reflectors.}

%```agda
\agda{
record is-globally-reflective {Î±} (GS : GSU Î±) : TypeÏ‰ where
  constructor mk-gReflectors
  open GSU GS
  field
    â—‹ : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
    Î· : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ â—‹ A
    has-is-reflector : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-global-reflector GS A (â—‹ A) Î·

  module R {ğ“¤} {A} = is-global-reflector (has-is-reflector {ğ“¤} {A})
  open R public

  module â–¸Î· {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {g h}
    = is-equiv (postwhisker-is-equivâ†ap-compose {g = g}{h}
                         (is-embeddingâ†is-equiv (reflects {A = B} (â—‹âˆˆS {ğ“¤}{A}))))

  reflector : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Reflector S A
  reflector A = mk-rfltor (â—‹ A) Î· (is-reflectorâ†global has-is-reflector)


reflectiveâ†global :  âˆ€ {Î±} {GS : GSU Î±} â†’ is-globally-reflective GS
                     â†’ âˆ€ {ğ“¤} â†’ Reflective (SubUâ†global GS {ğ“¤})
reflectiveâ†global (mk-gReflectors â—‹ Î· has-is-reflector)
  = mk-reflective â—‹ Î· (is-reflectorâ†global has-is-reflector)
}
%```
}


\subtree[stt-007C]{
\taxon{definition}
\title{Sigma closed global reflective subuniverses}


%```agda
\agda{
is-globally-Î£-closed : âˆ€ {Î±} (GS : GSU Î±) â†’ TypeÏ‰
is-globally-Î£-closed (mk-GSU S _) = âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
                                    â†’ A âˆˆ S â†’ (âˆ€ a â†’ B a âˆˆ S)
                                    â†’ Î£ A B âˆˆ S


}
%```
}
\subtree[stt-007D]{
\taxon{theorem}
\title{Induction for sigma closed [GRSU](stt-007C)}

\p{When a global reflective subuniverse is closed under sigma types
we can extend the recursion principal in \ref{stt-007B} to an induction
prinicipal.}

\proof{
\p{Because #{S} is closed under #{\Sigma} types, we can use the universal property
of the reflector at #{A} to define a map
#{\bar{f} : \bigcirc A \to \Sigma_{(x : \bigcirc A)} \bigcirc P(x)} just by it's action
on #{\eta(x)} for #{x : A}. This map is given by #{\eta(x) \mapsto (\eta(x), f(x))}.}

\p{To show that #{\bar{f}} is indeed a section, we first note that
the universal property of the reflector gives us #{\pi \bar{f} \eta \sim \eta}.
Then because postcomposition by #{\eta} at a modal type is an equivalence,
[so is postwhiskering](stt-006I) by #{\eta} (assuming funext), thus we can apply the
inverse map to get a homotopy #{\pi \bar{f} \sim \id}.}
}


%```agda
\agda{
module GRSUInduction {Î±} {GS : GSU Î±}
        (Sref : is-globally-reflective GS)
        (SÎ£ : is-globally-Î£-closed GS) where
  open GSU GS
  open is-globally-reflective Sref

  ind : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥} (PâˆˆS : âˆ€ a â†’ P a âˆˆ S)
        â†’ (Î  A (P âˆ˜ Î·)) â†’ Î  (â—‹ A) P
  ind {A = A} {P} ps f = Î â†section (f' , â–¸Î·.bwd secÎ·) module ind where
    f'' : A â†’ Î£ (â—‹ A) P
    f'' a = (Î· a , f a)

    f' : â—‹ A â†’ Î£ (â—‹ A) P
    f' = â—‹-rec (SÎ£ â—‹âˆˆS ps) f''

    secÎ· : fst âˆ˜ f' âˆ˜ Î· ~ Î·
    secÎ· = fst â—‚ â—‹-rec-Î² _ _

  ind-Î² : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥} (PâˆˆS : âˆ€ a â†’ P a âˆˆ S)
        â†’ (f : Î  A (P âˆ˜ Î·)) â†’ ind PâˆˆS f âˆ˜ Î· ~ f
  ind-Î² {A = A} {P} PS f a
    = tr P (â–¸Î·.bwd secÎ· (Î· a)) (snd (f' (Î· a)))
        ï¼âŸ¨ ap (Î» p â†’ tr P p (snd (f' (Î· a)))) (happly (â–¸Î·.Îµ secÎ·) a) âŸ©
      tr P (ap fst (â—‹-rec-Î² _ f'' a)) (snd (f' (Î· a)))
        ï¼âŸ¨ ap (Î» p â†’ coe p (snd (f' (Î· a)))) (sym (ap-âˆ˜ P fst _)) âŸ©
      tr (P âˆ˜ fst) (â—‹-rec-Î² _ f'' a) (snd (f' (Î· a)))
        ï¼âŸ¨ apáµˆ snd (â—‹-rec-Î² _ f'' a) âŸ©
      snd (f'' a)
        ï¼âŸ¨âŸ©
      f a âˆ       where open ind PS f


  ind-qiso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥} (PS : âˆ€ a â†’ P a âˆˆ S)
                 â†’ quasi-iso {A = (a : A) â†’ P (Î· a)} {B = (a : â—‹ A) â†’ P a}
                            (ind PS)
  ind-qiso PS .fst = _âˆ˜ Î·
  ind-qiso PS .snd .fst f = ext! (ind-Î² _ f)
  ind-qiso {A = A} {P} PS .snd .snd f = ext!
    (ind (Î» a â†’ is-modal-ï¼ (reflectiveâ†global Sref) (PS a))
         (ind-Î² _ (f âˆ˜ Î·)))

  ind-is-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥} (PS : âˆ€ a â†’ P a âˆˆ S)
                 â†’ is-equiv {A = (a : A) â†’ P (Î· a)} {B = (a : â—‹ A) â†’ P a}
                            (ind PS)
  ind-is-equiv = is-equivâ†qiso âˆ˜ ind-qiso
}
%```
}

%```agda
\agda{
-- module GRSUInstances {Î±} (GS : GSU Î±) (Grfl : Global-reflectors GS) where
--   open GSU GS
--   open Global-reflectors Grfl

--   record IsModal {ğ“¤} (A : Type ğ“¤) : Type (Î± ğ“¤) where
--     constructor mk-is-modal
--     field
--       has-is-modal : A âˆˆ S

--   âˆˆS! : âˆ€ {ğ“¤} {A : Type ğ“¤} â¦ƒ _ : IsModal A â¦„ â†’ A âˆˆ S
--   âˆˆS! {A = _} â¦ƒ mk-is-modal m â¦„ = m

--   instance opaque
--     â—‹-Modal : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ IsModal (â—‹ A)
--     â—‹-Modal = mk-is-modal â—‹âˆˆS

--     ï¼-Modal : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ â¦ƒ IsModal A â¦„ â†’ {a b : A} â†’ IsModal (a ï¼ b)
--     ï¼-Modal â¦ƒ (mk-is-modal H) â¦„ = mk-is-modal (is-modal-ï¼ (reflectorsâ†global Grfl) H)

--     Î -Modal : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
--                 â¦ƒ _ : âˆ€ {x} â†’ IsModal (B x) â¦„
--               â†’ IsModal (âˆ€ x â†’ B x)
--     Î -Modal {A = A} {B}
--       = mk-is-modal (in-SubUâ†Î·-retract (reflector _) retr) where
--       retr : retract (Reflector.Î· (reflector ((x : A) â†’ B x)))
--       retr .fst f a = â—‹-rec âˆˆS! (ev a) f
--       retr .snd f = funextâ†’ Î» a â†’ â—‹-rec-Î² âˆˆS! (ev a) f

--   {-# INCOHERENT  ï¼-Modal #-}

--   â—‹-elim! : âˆ€ {ğ“¤} {A : Type ğ“¤} â¦ƒ _ : IsModal A â¦„
--             â†’ â—‹ A â†’ A
--   â—‹-elim! = â—‹-rec âˆˆS! id

--   private module test where
--     test : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ â—‹ (â—‹ A) â†’ â—‹ A
--     test = â—‹-elim!


--   instance
--     Universal-â—‹ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥}
--                  â†’ â¦ƒ _ : âˆ€ {a} â†’ IsModal (P a) â¦„
--                  â†’ â¦ƒ _ : Universal ((a : A) â†’ P (Î· a)) ğ“¦ â¦„
--                  â†’ Universal ((a : â—‹ A) â†’ P a) ğ“¦
--     Universal-â—‹ â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.methods = u .methods
--     Universal-â—‹ â¦ƒ mod â¦„ â¦ƒ u â¦„ .Universal.from
--       = ind (Î» _ â†’ mod .IsModal.has-is-modal) âˆ˜ u .from
--     Universal-â—‹ â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.from-is-equiv
--       = is-equiv-âˆ˜ (ind-is-equiv _) (u .from-is-equiv)




-- private
--   module test {Î±} {T : âˆ€ (n : â„•) â†’ GSU Î±}
--                      {Grf : âˆ€ {k} â†’ Global-reflectors (T k)}
--                      {GÎ£ : âˆ€ {k} â†’ is-globally-Î£-closed (T k)}
--                      {ğ“¤} {A : Type ğ“¤}
--                      â¦ƒ _ : âˆ€ {k} â†’ GRSUInstances.IsModal (T (suc k)) Grf A â¦„ where
--     module T n = GSU (T n)
--     open T
--     module R n = Global-reflectors (Grf {n})
--     open R
--     module I {n} = GRSUInstances (T n) Grf
--     open I
--     module In {n} = GlobalInduction {_} {T n} Grf GÎ£
--     open In

--     tst : A âˆˆ S 1
--     tst = âˆˆS!

--     tst2 : âˆ€ {x y : A} â†’ (x ï¼ y) âˆˆ S 1
--     tst2 = âˆˆS!

--     tst3 : (A â†’ A) âˆˆ S 1
--     tst3 = âˆˆS!

--     tst4 : âˆ€ {f g : ğŸ™ â†’ A} â†’ (f ~ g) âˆˆ S 1
--     tst4 = âˆˆS!

--     tst5 : âˆ€ {ğ“¥} {B : Type ğ“¥} â†’ (f : B â†’ A) â†’ (x : â—‹ 1 B) â†’ A
--     tst5 = â—‹-rec 1 âˆˆS!

--     tst6 : âˆ€ {ğ“¥} {B : Type ğ“¥} â†’ (f : B â†’ A) â†’ is-embedding f
--            â†’ (x y : â—‹ 1 B) â†’ tst5 f x ï¼ tst5 f y â†’ x ï¼ y
--     tst6 f emb = ind! Î» x y p â†’ ap (Î· 1)
--                    (unap emb (sym (â—‹-rec-Î² 1 âˆˆS! f x) âˆ™ p âˆ™ â—‹-rec-Î² 1 âˆˆS! f y))

--     postulate instance
--       ï¼-suc : âˆ€ {ğ“¤} {A : Type ğ“¤}
--                  {k}
--                  â¦ƒ _ : IsModal {suc k} A â¦„
--                â†’ {x y : A}
--                â†’ IsModal {k} (x ï¼ y)
--     tst7 :  âˆ€ {x y : A} â†’ (x ï¼ y) âˆˆ S 0
--     tst7 = âˆˆS!
}
%```
