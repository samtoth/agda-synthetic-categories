\date{2025-07-30}
\title{Canonical Sequential Colimits}
\taxon{module}
\meta{module}{Core.CanonicalSeqColims}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.CanonicalSeqColims where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Coequalisers
open import Core.SeqMapHomotopy

open import Ergonomics.Marker
open import Ergonomics.Extensionality
}
%```

\subtree[stt-008B]{
\title{Canonical Sequential Colimits}
\taxon{construction}

%```agda
\agda{
Seq-colimit : âˆ€ {ğ“¤} â†’ Incr-seq ğ“¤ â†’ Type ğ“¤
Seq-colimit S = Coeq id incrÎ£ where open Incr-seq S

seq-colimit : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) â†’ Cocone-seq S (Seq-colimit S)
seq-colimit S = mk-cocone-seq (Î» {n} a â†’ Î¹â‚‚ (n , a))
                              Î» {n} a â†’ sym (glue (inl (n , a)))
                                      âˆ™ glue (inr (n , a))

Î¹-seq : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) {n}
        â†’ S .Incr-seq.Point n â†’ Seq-colimit S
Î¹-seq S a = coeq _ _ .fst (_ , a)

seq-incr : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) {n}
           â†’ Î¹-seq S {n} ~ Î¹-seq S {suc n} âˆ˜ Incr-seq.incr S
seq-incr S = Cocone-seq.comm (seq-colimit S)
}
%```
}

\subtree[stt-008C]{
\title{Cocones of canonical sequential colimits}
\taxon{lemma}

\p{Cocones over the span in \ref{stt-008B} defining the canonical
sequential colimits are equivalent to [sequential cocones](stt-0088)}

\proof{
\p{By calculation:}
##{
\begin{align*}
\rm{Cocone}(\rm{Colim}(A)) \simeq&
  \Sigma_{f : Q^{\tilde{A}}} \Sigma_{g : Q^{\tilde{A}}} (f \sim g \times
    \Pi_{a : \tilde{A}} f(a) = g(\rm{suc}(a))) \\
 \simeq& \Sigma_{f : Q^{\tilde{A}}} (f \sim f\ \rm{suc}) \\
 \simeq& \rm{Cocone}_{\rm{seq}}(\rm{Colim}(A))
\end{align*}
}
}

%```agda
\agda{
seq-coconeâ‰ƒfork : âˆ€ {ğ“¤ ğ“ } {S : Incr-seq ğ“¤} {Q : Type ğ“ }
                  â†’ Fork id (Incr-seq.incrÎ£ S) Q
                  â‰ƒ Cocone-seq S Q
seq-coconeâ‰ƒfork {_} {_} {S} {Q}
  = mkâ‰ƒ map (is-equivâ†qiso map-qiso) where
    open Incr-seq S
    Ãƒ = Î£ â„• Point

    map : Fork id incrÎ£ Q â†’ Cocone-seq S Q
    map (p , H) = mk-cocone-seq (Î» a â†’ p (_ , a)) Î» a â†’ H (_ , a)

    map-qiso : quasi-iso map
    map-qiso .fst (mk-cocone-seq Î¹ comm)
      = (Î» (_ , a) â†’ Î¹ a) , (Î» (_ , a) â†’ comm a)
    map-qiso .snd .fst _ = refl
    map-qiso .snd .snd _ = refl

seq-colim-is-colim :  âˆ€ {ğ“¤} {S : Incr-seq ğ“¤}
                      â†’ is-seq-colim S (seq-colimit S)
seq-colim-is-colim Q = is-equiv-âˆ˜ (seq-coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv)
                                  coeq-is-coeq

seq-colim-rec : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {Q : Type ğ“¥}
                  â†’ Cocone-seq S Q â†’ (Seq-colimit S â†’ Q)
seq-colim-rec = is-equiv.bwd (seq-colim-is-colim _)

{-# DISPLAY is-equiv.bwd (seq-colim-is-colim _) f x = seq-colim-rec f x #-}

seq-colim-apÎ² : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {Q : Type ğ“¥}
                â†’ (CC : Cocone-seq S Q)
                â†’ âˆ€ a â†’ ap (seq-colim-rec CC) (seq-incr S (a .snd))
                ï¼ CC .Cocone-seq.comm (a .snd)
seq-colim-apÎ² CC a = let cocone = (coconeâ†fork (_â‰ƒ_.bwd seq-coconeâ‰ƒfork CC))
  in ap (seq-colim-rec CC) (sym (glue (inl a)) âˆ™ glue (inr a))
                          ï¼âŸ¨ ap-âˆ™ (seq-colim-rec CC) (sym (glue (inl a))) (glue (inr a)) âŸ©
     ap (seq-colim-rec CC) (sym (glue (inl a))) âˆ™ ap (seq-colim-rec CC) (glue (inr a))
                          ï¼âŸ¨ apâ‚‚ _âˆ™_ (ap-sym (seq-colim-rec CC) _ âˆ™ ap sym (pushout-rec-apÎ² (inl a))) (pushout-rec-apÎ² (inr a)) âŸ©
     sym (Cocone.filler cocone (inl a)) âˆ™ Cocone.filler cocone (inr a)  ï¼âŸ¨âŸ©
     CC .Cocone-seq.comm (a .snd) âˆ
}
%```
}


\subtree[stt-008Z]{
\title{Taking the sequential colimit is functorial}
\taxon{theorem}
\date{2025-08-15}

%```agda
\agda{
seq-colimit-map
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      (F : Incr-seq-map S S')
    â†’ Seq-colimit S â†’ Seq-colimit S'
seq-colimit-map {S = S} {S'} F = seq-colim-rec cc module seq-colim-map where
  open Incr-seq-map F

  cc : Cocone-seq _ (Seq-colimit _)
  cc .Cocone-seq.Î¹ = Î¹-seq S' âˆ˜ map
  cc .Cocone-seq.comm = seq-incr S' â–¸ map ~âˆ™ Î¹-seq S' â—‚ comm

ap-seq-colimit-map-seq-incr
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      (F : Incr-seq-map S S')
    â†’ âˆ€ {n} (a : Incr-seq.Point S n)
    â†’ ap (seq-colimit-map F) (seq-incr S a)
    ï¼ seq-incr S' (Incr-seq-map.map F a) âˆ™ ap (Î¹-seq S') (Incr-seq-map.comm F a)
ap-seq-colimit-map-seq-incr {S = S} {S'} F a
  = ap (seq-colim-rec (seq-colim-map.cc F)) (seq-incr _ a)
                      ï¼âŸ¨ seq-colim-apÎ² (seq-colim-map.cc F) (_ , a) âŸ©
    seq-colim-map.cc F .Cocone-seq.comm a
                                        ï¼âŸ¨âŸ©
    seq-incr S' (Incr-seq-map.map F a)
      âˆ™ ap (Î¹-seq S') (Incr-seq-map.comm F a) âˆ


seq-colimit-map~
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      {F G : Incr-seq-map S S'}
    â†’ iseq-map~ F G â†’ seq-colimit-map F ~ seq-colimit-map G
seq-colimit-map~ H = happly (ap (seq-colimit-map) (ext! H))

seq-colimit-rec~
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      {f g : Seq-colimit S â†’ Seq-colimit S'}
    â†’ seq-cocone-map (seq-colimit S) f
        ï¼â‚‘
      seq-cocone-map (seq-colimit S) g
    â†’ f ï¼ g
seq-colimit-rec~ {S = S}{S'} p
  = unap-equiv {f = seq-cocone-map (seq-colimit S)}
               (seq-colim-is-colim (Seq-colimit S'))
               (ext! p)

seq-colimit-map-id
  : âˆ€ {ğ“¤} {S : Incr-seq ğ“¤}
  â†’ seq-colimit-map (id-iseq-map {S = S}) ï¼ id
seq-colimit-map-id {S = S} = seq-colimit-rec~ H where
  open Incr-seq

  H : IdS
       (seq-cocone-map _ (seq-colimit-map (id-iseq-map)))
       (seq-cocone-map _ id)
  H .fst = ~refl
  H .snd {n}
    = {- (seq-colimit-map id-iseq-map) â—‚ (seq-incr S)
          ~âˆ™ ~refl â–¸ incr S        ~âŸ¨âŸ© -}
      (seq-colimit-map id-iseq-map) â—‚ (seq-incr S) ~âˆ™ ~refl
                          ~âŸ¨ ~âˆ™-reflr _ âŸ©
      (seq-colimit-map id-iseq-map) â—‚ (seq-incr S)
                          ~âŸ¨ ap-seq-colimit-map-seq-incr id-iseq-map âŸ©
      seq-incr S ~âˆ™ ~refl ~âŸ¨ ~âˆ™-reflr _ âŸ©
      seq-incr S          ~âŸ¨ sym âˆ˜ ap-id âˆ˜ seq-incr S âŸ©
      id â—‚ seq-incr S     ~âˆ

seq-colimit-mapâˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      {S'' : Incr-seq ğ“¦}
      (f : Incr-seq-map S S') (g : Incr-seq-map S'' S)
    â†’  seq-colimit-map f âˆ˜ seq-colimit-map g
    ï¼ seq-colimit-map (compose-iseq-map f g)
seq-colimit-mapâˆ˜ {S = S} {S'}{S''} f g = seq-colimit-rec~ H where
  open Incr-seq-map

  opaque
    lem2 : âˆ€ {n} (a : A.Point g n)
           â†’ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a)) ï¼ ap (Î¹-seq S') (ap (map f) (comm g a))
    lem2 a
      = ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
             ï¼âŸ¨ sym (ap-âˆ˜ (seq-colimit-map f) (Î¹-seq S) (comm g a)) âŸ©
        ap (seq-colimit-map f âˆ˜ Î¹-seq S) (comm g a) ï¼âŸ¨âŸ©
        ap (Î¹-seq S' âˆ˜ map f) (comm g a)
             ï¼âŸ¨ ap-âˆ˜ (Î¹-seq S') (map f) (comm g a) âŸ©
        ap (Î¹-seq S') (ap (map f) (comm g a)) âˆ

    lemma : âˆ€ {n} (a : A.Point g n)
            â†’   ap (Î¹-seq S') (comm f (map g a))
              âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
            ï¼ ap (Î¹-seq S') (comm f (map g a) âˆ™ ap (map f) (comm g a))
    lemma {n} a
      = ap (Î¹-seq S') (comm f (map g a)) âˆ™
         ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
              ï¼âŸ¨ ap (ap (Î¹-seq S') (comm f (map g a)) âˆ™_) (lem2 a) âŸ©
        ap (Î¹-seq S') (comm f (map g a)) âˆ™ ap (Î¹-seq S') (ap (map f) (comm g a))
              ï¼âŸ¨ sym (ap-âˆ™ (Î¹-seq S') (comm f (map g a)) (ap (map f) (comm g a))) âŸ©
        ap (Î¹-seq S') (comm f (map g a) âˆ™ ap (map f) (comm g a))    âˆ

  H : IdS
       (seq-cocone-map _ (seq-colimit-map f âˆ˜ seq-colimit-map g))
       (seq-cocone-map _ (seq-colimit-map (compose-iseq-map f g)))
  H .fst = ~refl
  H .snd {n = n} a
    = ap (seq-colimit-map f âˆ˜ seq-colimit-map g) (seq-incr S'' a) âˆ™ refl
               ï¼âŸ¨ âˆ™-reflr _ âŸ©
      ap (seq-colimit-map f âˆ˜ seq-colimit-map g) (seq-incr S'' a)
               ï¼âŸ¨ ap-âˆ˜ (seq-colimit-map f) (seq-colimit-map g) (seq-incr S'' a) âŸ©
      ap (seq-colimit-map f) (ap (seq-colimit-map g) (seq-incr S'' a))
               ï¼âŸ¨ ap (ap (seq-colimit-map f)) (ap-seq-colimit-map-seq-incr g a) âŸ©
      ap (seq-colimit-map f)
        (seq-incr S (map g a) âˆ™ ap (Î¹-seq S) (comm g a))
               ï¼âŸ¨ ap-âˆ™ (seq-colimit-map f) (seq-incr S (map g a)) (ap (Î¹-seq S) (comm g a)) âŸ©
      ap (seq-colimit-map f) (seq-incr S (map g a))
        âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
               ï¼âŸ¨ ap (_âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))) (ap-seq-colimit-map-seq-incr f (map g a)) âŸ©
      (seq-incr S' (map f (map g a)) âˆ™ ap (Î¹-seq S') (comm f (map g a)))
        âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a)) ï¼âŸ¨ âˆ™.pulll _ (lemma a) âŸ©
      seq-incr S' (map f (map g a)) âˆ™  ap (Î¹-seq S') (comm (compose-iseq-map f g) a)
               ï¼âŸ¨âŸ©
      Cocone-seq.comm (seq-colim-map.cc (compose-iseq-map f g)) a
               ï¼âŸ¨ sym (seq-colim-apÎ² _ (n , a)) âŸ©
      Cocone-seq.comm
        (seq-cocone-map
          (mk-cocone-seq (Î» {n = nâ‚} z â†’ Î¹â‚‚ (nâ‚ , z)) (seq-incr S''))
          (seq-colim-rec (seq-colim-map.cc (compose-iseq-map f g))))
         a
               ï¼âŸ¨âŸ©
      comm
       (seq-mapâ†cocone
        (seq-cocone-map
         (mk-cocone-seq (Î» {n} z â†’ Î¹â‚‚ (n , z))
          (seq-incr S''))
         (seq-colimit-map (compose-iseq-map f g))))
       a âˆ
}
%```
}

\subtree[stt-008Y]{
\title{Sequential colimits of equivalent sequences}
\taxon{corollary}
\date{2025-08-15}

\p{[Equivalent](stt-008X) sequences gives rise to equivalent sequential
colimits.}

\proof{
\p{This follows from the [functoriality of taking the colimit](stt-008Z)
and \ref{stt-0095}.}
}


%```agda
\agda{
module _ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
         (F : Incr-seq-map S S')  where
  open Incr-seq-map F

  seq-colimit-map-is-equiv
    : is-iseq-equiv F â†’ is-equiv (seq-colimit-map F)
  seq-colimit-map-is-equiv Feq = is-equivâ†qiso iso where
    module F {n} = is-equiv (Feq n)
    Fbwd = seq-map-invâ†equiv {F = F} Feq

    iso : quasi-iso (seq-colimit-map F)
    iso .fst = seq-colimit-map Fbwd
    iso .snd .fst =  happly (seq-colimit-mapâˆ˜ Fbwd F)
                  ~âˆ™ seq-colimit-map~ (inverse-seq-map-section Feq)
                  ~âˆ™ happly seq-colimit-map-id
    iso .snd .snd = happly (seq-colimit-mapâˆ˜ F Fbwd)
                  ~âˆ™ seq-colimit-map~ (inverse-seq-map-retraction {F = F} Feq)
                  ~âˆ™ happly seq-colimit-map-id
}
%```
}
