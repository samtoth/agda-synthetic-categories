\date{2025-07-30}
\title{Coequalisers}
\taxon{module}
\meta{module}{Core.CanonicalSeqColims}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
module Core.Coequalisers where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts

Fork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ (C : Type ğ“¦) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Fork {B = B} f g C = Î£[ p âˆ¶ (B â†’ C) ] (p âˆ˜ f ~ p âˆ˜ g)

fork-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
         â†’ {f g : A â†’ B} â†’ {C : Type ğ“¦}
         â†’ Fork f g C â†’ âˆ€ {ğ“ } {Q : Type ğ“ }
         â†’ (C â†’ Q) â†’ Fork f g Q
fork-map (p , H) f = (f âˆ˜ p , f â—‚ H)

is-coeq : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
            {f g : A â†’ B} {C : Type ğ“¦}
          â†’ Fork f g C â†’ TypeÏ‰
is-coeq f = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-equiv (fork-map f {ğ“ } {Q})


Coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
Coeq {_} {_} {A} {B} f g
  = Pushout l r  module Coeq where
  l : B âŠ A â†’ B
  l (inl x) = x
  l (inr x) = f x

  r : B âŠ A â†’ B
  r (inl x) = x
  r (inr x) = g x

  span : Span _ _ _
  span = mk-span _ l r

coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ Fork f g (Coeq f g)
coeq f g = (Î¹â‚‚ , Î» x â†’ sym (glue (inl (f x))) âˆ™ glue (inr x))


coconeâ†fork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Fork f g C â†’ Cocone (Coeq.span f g) C
coconeâ†fork {f = f} {g} (p , H) = mk-cocone p p (âŠ-ind (~refl , H))


coconeâ‰ƒfork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Fork f g C â‰ƒ Cocone (Coeq.span f g) C
coconeâ‰ƒfork {B = B} {f} {g}{C}
  = Fork f g C
      â‰ƒâŸ¨âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] (p âˆ˜ f ~ p âˆ˜ g))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» _ â†’ Î£-ï¼singl') eâ»Â¹ âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] ((p ï¼ q) Ã— (p âˆ˜ f ~ q âˆ˜ g)))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ Î£-ap-â‰ƒ-fst funextâ‰ƒ)) âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] ((p ~ q) Ã— (p âˆ˜ f ~ q âˆ˜ g)))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ âŠ-UPâ‰ƒ global-funext)) âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] (p âˆ˜ Coeq.l f g ~ q âˆ˜ Coeq.r f g))
      â‰ƒâŸ¨ cocone-reprâ‰ƒ eâ»Â¹ âŸ©
    Cocone (Coeq.span f g) C â‰ƒâˆ

forkâ†cocone-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
                â†’ is-equiv (coconeâ†fork {f = f} {g} {C})
forkâ†cocone-is-equiv = coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv

coeq-is-coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                 {f g : A â†’ B} â†’ is-coeq (coeq f g)
coeq-is-coeq {f = f} {g} {Q = Q}
  = 3-for-2~ (H ~â»Â¹)
             (coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv)
             (Pushout-is-pushoutÏ‰) where
  H : coconeâ†fork âˆ˜ fork-map (coeq f g) {Q = Q}
    ~ cocone-map (Coeq.span f g) pushout
  H f = Cocone-pathâ†’ _ _ (funextâ†’ (f â—‚ (glue ~â»Â¹) â–¸ inl)) refl Î» where
    (inl x) â†’ sym ( ap (_âˆ™ ap f (glue (inl x))) (ap-sym f (glue (inl x)))
                   âˆ™ âˆ™-sym' (ap f (glue _)))
    (inr x) â†’ âˆ™-reflr _ âˆ™ ap-âˆ™ f (sym (glue _)) (glue (inr x))
}
%```
