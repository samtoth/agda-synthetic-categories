\date{2025-07-29}
\title{Cocartesian squares}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Core.CocartesianSquare where

open import ufAxioms
open import Foundations.Prelude
open import Foundations.Pushout

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CanonicalPushouts
open import Core.Postwhisker
open import Core.Cube
}
%```


\subtree[stt-007V]{
\title{Co-cartesian squares}
\taxon{Definition}

\p{Given a square:}

\quiver{
\begin{tikzcd}
	A && X \\
	\\
	B && Y
	\arrow["{f'}", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["{g'}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{we say that the square is cocartesian if the square [given by
postcomposition](stt-003P) is a [cartesian square](stt-003V).}

%```agda
\agda{
is-cocartesian : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
                   {X : Type ğ“¦} {Y : Type ğ“œ}
                   {f : A â†’ B} {g : X â†’ Y}
                 â†’ Arrow-map f g â†’ (ğ“  : Level)
                 â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ âŠ” lsuc ğ“ )
is-cocartesian F ğ“  = âˆ€ (Q : Type ğ“ )
                     â†’ is-cartesian (postcomp-square F Q)


is-cocartesianÏ‰ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
                    {X : Type ğ“¦} {Y : Type ğ“œ}
                    {f : A â†’ B} {g : X â†’ Y}
                  â†’ Arrow-map f g
                  â†’ TypeÏ‰
is-cocartesianÏ‰ F = âˆ€ {ğ“ } (Q : Type ğ“ )
                    â†’ is-cartesian (postcomp-square F Q)
}
%```
}

\subtree[stt-007W]{
\title{Cocartesian squares are pushouts}
\taxon{Theorem}

\proof{An easy consequence of \ref{stt-003C} and \ref{stt-007Y}}

%```agda
\agda{
is-pushoutâ†is-cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-cocartesianÏ‰ F â†’ is-pushoutÏ‰ _ (Coconeâ†Arrow-map F .snd)
is-pushoutâ†is-cocartesian {f = f} {g} F cc
  = is-pushoutâ†postcomp-pullback _
       (Î» Q â†’ is-pullbackâ†is-cartesian (postcomp-square F Q) (cc Q))

is-cocartesianâ†is-pushout
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {D : Type ğ“œ} {C : Cocone S D}
    â†’ is-pushoutÏ‰ S C â†’ is-cocartesianÏ‰ (Arrow-mapâ†Cocone C)
is-cocartesianâ†is-pushout po Q
  = is-cartesianâ†is-pullback
      (postcomp-square (Arrow-mapâ†Cocone _) Q)
      (postcomp-pullbackâ†is-pushout _ po Q)
}
%```
}


\subtree[stt-00CQ]{
\title{The mirror of a cocartesian square is cocartesian}
\taxon{Lemma}

%```agda
\agda{
rotate-square-is-cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-cocartesianÏ‰ F â†’ is-cocartesianÏ‰ (rotate-square F)
rotate-square-is-cocartesian F cocart
  = is-cocartesianâ†is-pushout
     (is-pushoutâ†cogap _
      (is-equiv~âˆ˜
        {f = cogap-mapâ†square F}
        {g = pushout-flip}
        (sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
          (Î» a â†’ âˆ™-reflr _ âˆ™ ap-âˆ˜ (cogap-mapâ†square F) (pushout-flip) (glue a)
          âˆ™ ap (ap _) (pushout-rec-apÎ² a) âˆ™ ap-sym _ (glue a)
          âˆ™ ap sym (pushout-rec-apÎ² a)))
        (cogap-is-equivâ†is-pushout _ (is-pushoutâ†is-cocartesian _ cocart))
        (pushout-comm ._â‰ƒ_.has-is-eqv)))

rotate-is-idempotent-cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
      {ğ“ } (Q : Type ğ“ )
    â†’ Cube (postcomp-square (rotate-square (rotate-square F)) Q)
           (postcomp-square F Q)
rotate-is-idempotent-cube F Q .Cube.left = id-square
rotate-is-idempotent-cube F Q .Cube.right = id-square
rotate-is-idempotent-cube F Q .Cube.comm .fst = ~refl
rotate-is-idempotent-cube F Q .Cube.comm .snd .fst = ~refl
rotate-is-idempotent-cube F Q .Cube.comm .snd .snd a
  = ap (_âˆ™ refl)
       (sym (ap-id _ âˆ™ ap funextâ†’ (funextâ†’ (Î» x â†’ ap (ap a) sym-sym))))

rotate-is-idempotent
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
      {ğ“ } (Q : Type ğ“ )
    â†’ is-Cube-equiv (rotate-is-idempotent-cube F Q)
rotate-is-idempotent {f = f} {g} F Q .fst
  = id-square-is-equiv {f = postcomp Q g}
rotate-is-idempotent {f = f} {g} F Q .snd
  = id-square-is-equiv {f = postcomp Q f}

unrotate-square-is-cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-cocartesianÏ‰ (rotate-square F)
    â†’ is-cocartesianÏ‰ F
unrotate-square-is-cocartesian F rFcc Q
  = back-cartesianâ†equiv-cube
      {F = (postcomp-square (rotate-square (rotate-square F)) Q)}
      {G = postcomp-square F Q}
      (rotate-is-idempotent-cube F Q)
      (rotate-is-idempotent F Q)
      (rotate-square-is-cocartesian _ rFcc Q)
}
%```
}

\subtree[stt-00BT]{
\title{Canonical pushouts are cocartesian squares}
\taxon{Corollary}

%```agda
\agda{
Pushout-square
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) â†’ let open Span S
    in Arrow-map left {D = Pushout left right} Î¹â‚‚
Pushout-square S .Arrow-map.top = S .Span.right
Pushout-square S .Arrow-map.bot = Î¹â‚
Pushout-square S .Arrow-map.comm = glue

Pushout-square-is-cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) â†’ is-cocartesianÏ‰ (Pushout-square S)
Pushout-square-is-cocartesian S = is-cocartesianâ†is-pushout Pushout-is-pushoutÏ‰

Pushout-square'
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) â†’ let open Span S
    in Arrow-map right {D = Pushout left right} Î¹â‚
Pushout-square' S = rotate-square (Pushout-square S)

Pushout-square'-is-cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) â†’ is-cocartesianÏ‰ (Pushout-square' S)
Pushout-square'-is-cocartesian S = rotate-square-is-cocartesian _
                                     (is-cocartesianâ†is-pushout
                                       Pushout-is-pushoutÏ‰)
}
%```
}

\subtree[stt-0080]{
\title{Pushouts squares of equivalences}
\taxon{Theorem}

\p{Given an equivalence #{f} and any map #{g}, together with a
square #{f \to g}, the square is cocartesian iff #{g} is an
equivalence.}

\proof{
\p{We have the following square given by postcomposition:}
\quiver{
\begin{tikzcd}
	{Q^Y} &&& {Q^B} \\
	& \bullet \\
	\\
	{Q^X} &&& {Q^A}
	\arrow["{Q^b}", from=1-1, to=1-4]
	\arrow["{\rm{gap}}", dashed, from=1-1, to=2-2]
	\arrow["{Q^g}"', from=1-1, to=4-1]
	\arrow["{Q^f}", from=1-4, to=4-4]
	\arrow[from=2-2, to=1-4]
	\arrow["\sim", from=2-2, to=4-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=2-2, to=4-4]
	\arrow["{Q^t}"', from=4-1, to=4-4]
\end{tikzcd}
}

\p{By \ref{stt-007Z}, the projection from the pullback to #{Q^X} is an
equivalence because #{Q^f} is. Then we have a triangle which, by the
[3 for 2](stt-003E) property, shows that #{Q^g} is an equivalence iff
the gap map is.}
}

%```agda
\agda{
cocartesianâ†equiv-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
      {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-equiv f
    â†’ is-equiv g
    â†’ is-cocartesianÏ‰ F
cocartesianâ†equiv-map F feq geq Q
  = is-cartesianâ†is-pullback (postcomp-square F Q)
      (is-pullbackâ†gap (Coneâ†Arrow-map (postcomp-square F Q) .snd)
        (3-for-2
           (pullback-equivâ‚ (postcomp-equiv feq))
           (postcomp-equiv geq))) where
  module F = Arrow-map F

dom-is-equivâ†cocartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
      {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-equiv f
    â†’ is-cocartesianÏ‰ F
    â†’ is-equiv g
dom-is-equivâ†cocartesian F feq cart = is-equivâ†postcomp _
  Î» {_} {Q} â†’  is-equiv-âˆ˜
      (pullback-equivâ‚ (postcomp-equiv feq))
      (gap-is-equivâ†is-pullback
        (Coneâ†Arrow-map (postcomp-square F Q) .snd)
        (is-pullbackâ†is-cartesian _ (cart Q)))
}
%```
}

\subtree[stt-00EC]{
\title{Pasting for cocartesian squares}
\taxon{Lemma}

\p{Given a pair of squares, as follows: }

\quiver{
\begin{tikzcd}
	\bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=3-5]
	\arrow[from=3-1, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}

\p{The right square is a pushout iff the whole square is.}

\proof{
\p{Call the first square #{F} and the second #{G}. Then we first prove that
#{Q^{F \circ G} \sim Q^G \circ Q^F}. Then the result follows from the
[analogous theorem](stt-003W) for [cartesian squares](stt-003V). Note however,
that the contravariance of taking the postcomposition square means that
cartesian squares are right cancelative, so cocartesian squares must be left
cancelative.}
}

%```agda
\agda{
postcomp-square-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
      {U : Type ğ“} {V : Type ğ“›} {f : A â†’ B} {g : X â†’ Y} {h : U â†’ V}
      (F : Arrow-map g h) (G : Arrow-map f g)
      {ğ“ } (Q : Type ğ“ )
    â†’ Arrow-map-path (paste-squares (postcomp-square G Q) (postcomp-square F Q))
                     (postcomp-square (paste-squares F G) Q)
postcomp-square-âˆ˜ F G Q .fst = ~refl
postcomp-square-âˆ˜ F G Q .snd .fst = ~refl
postcomp-square-âˆ˜ {f = f} {g}{h} F G Q .snd .snd
 = comm (paste-squares (postcomp-square G Q) (postcomp-square F Q)) ~âˆ™ ~refl
       ~âŸ¨ ~âˆ™-reflr _ âŸ©
   comm (paste-squares (postcomp-square G Q) (postcomp-square F Q))
       ~âŸ¨âŸ©
    (postcomp Q (G .top) â—‚ postcomp-square F Q .comm
    ~âˆ™ postcomp-square G Q .comm â–¸ postcomp Q (F .bot))
       ~âŸ¨âŸ©
    (postcomp Q (G .top) â—‚ funextâ†’ âˆ˜ (_â—‚ (comm F ~â»Â¹))
    ~âˆ™ funextâ†’ âˆ˜ (_â—‚ (comm G ~â»Â¹)) â–¸ postcomp Q (F .bot))
       ~âŸ¨ (Î» a â†’ ap (_âˆ™ funextâ†’ _)
         (sym (commutes-postwhisker-funext (a â—‚ (comm F ~â»Â¹))))
         âˆ™ sym (funext-âˆ™ _ _) ) âŸ©
   funextâ†’ âˆ˜ (Î» a â†’ a â—‚ (sym âˆ˜ comm F âˆ˜ top G) ~âˆ™ (a âˆ˜ F .bot) â—‚ (sym âˆ˜ comm G))
       ~âŸ¨ (Î» a â†’ ap funextâ†’ (funextâ†’ Î» x
         â†’ ap (ap a (sym (comm F _)) âˆ™_)
             ( â—‚âˆ˜  a (bot F) (sym âˆ˜ comm G) x)
             âˆ™ sym (ap-âˆ™ a (sym (comm F (top G x))) (ap (bot F) _))
             âˆ™ ap (ap a) (sym (âˆ™-symsym (ap (bot F) (comm G x)) _
             âˆ™ ap (sym (comm F (top G x)) âˆ™_)
                  (sym (ap-sym (bot F) (comm G x))))))) âŸ©
   funextâ†’ âˆ˜ (Î» a â†’ a â—‚ ((F .bot â—‚ comm G ~âˆ™ comm F â–¸ G .top) ~â»Â¹))
       ~âŸ¨âŸ©
   comm (postcomp-square (paste-squares F G) Q) ~âˆ where open Arrow-map

opaque
  cocartesian-square-âˆ˜
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
        {U : Type ğ“} {V : Type ğ“›} {f : A â†’ B} {g : X â†’ Y} {h : U â†’ V}
        {F : Arrow-map g h} {G : Arrow-map f g}
      â†’ is-cocartesianÏ‰ F â†’ is-cocartesianÏ‰ G
      â†’ is-cocartesianÏ‰ (paste-squares F G)
  cocartesian-square-âˆ˜ {F = F} {G} fc gc Q
    = tr is-cartesian (Arrow-map-pathâ†’ (postcomp-square-âˆ˜ F G Q))
        (compose-cartesian (gc Q) (fc Q))

  cocartesian-square-cancel
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
        {U : Type ğ“} {V : Type ğ“›} {f : A â†’ B} {g : X â†’ Y} {h : U â†’ V}
        {F : Arrow-map g h} {G : Arrow-map f g}
      â†’ is-cocartesianÏ‰ G â†’ is-cocartesianÏ‰ (paste-squares F G)
      â†’ is-cocartesianÏ‰ F
  cocartesian-square-cancel {F = F} {G = G} Gc FGc Q
    = 3-for-2-cartesian
        {a = postcomp-square G Q}
        {b = postcomp-square F Q}
        (Arrow-map-pathâ†id (sym (Arrow-map-pathâ†’ (postcomp-square-âˆ˜ F G Q))))
        (FGc Q)
        (Gc Q)
}
%```
}
