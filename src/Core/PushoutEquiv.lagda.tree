\date{2025-07-30}
\title{Pushouts of equivalent types}
\taxon{module}
\meta{module}{Core.PushoutEquiv}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
module Core.PushoutEquiv where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Postwhisker

}
%```

\subtree[stt-0083]{
\date{2025-07-30}
\title{Adjusting Pushouts by equivalences}
\taxon{lemma}

\p{Given #{A \simeq B}, a pushout under #{C \xleftarrow{} B
\xrightarrow{} D}, gives rise to a pushout under the induced span #{C
\xleftarrow{} A \xrightarrow{} D}.}

\p{As a corollary, we also have that the canonical pushout of the span
is equivalent to the pushout of the induced span.}

%```agda
\agda{
precomp-span : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“œ} â†’ (S : Span ğ“¤ ğ“¥ ğ“¦)
               â†’ (A â†’ S .Span.Centre) â†’ Span ğ“œ ğ“¥ ğ“¦
precomp-span {A = A} S f = mk-span A (S.left âˆ˜ f) (S.right âˆ˜ f) where
  module S = Span S

precomp-cocone : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {A : Type ğ“œ}  {S : Span ğ“¤ ğ“¥ ğ“¦}
                   (f : A â†’ Span.Centre S) {D : Type ğ“›}
                 â†’ Cocone S D
                 â†’ Cocone (precomp-span S f) D
precomp-cocone f cc
  = mk-cocone p q (filler â–¸ f) where open Cocone cc

precomp-cocone-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {A : Type ğ“œ}  {S : Span ğ“¤ ğ“¥ ğ“¦}
      (f : A â†’ Span.Centre S) {D : Type ğ“›}
    â†’ is-equiv f
    â†’ is-equiv (precomp-cocone {S = S} f {D})
precomp-cocone-is-equiv {S = S} f feq = is-equivâ†qiso qiso where
  module â–¸f {ğ“ }{C : Type ğ“ }{g}{h} =
    is-equiv (postwhisker-equiv-is-equiv feq {C} {g} {h})

  qiso : quasi-iso (precomp-cocone f)
  qiso .fst (mk-cocone p q filler)
    = mk-cocone p q (â–¸f.bwd filler)
  qiso .snd .fst (mk-cocone p q filler)
    = ap (mk-cocone p q) (â–¸f.Î· filler)
  qiso .snd .snd (mk-cocone p q filler)
    = ap (mk-cocone p q) (â–¸f.Îµ filler)


precomp-cocone-is-pushout
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {A : Type ğ“œ}  {S : Span ğ“¤ ğ“¥ ğ“¦}
      (f : A â†’ Span.Centre S) {D : Type ğ“›}
      (feq : is-equiv f)
      {C : Cocone S D}
     â†’ is-pushoutÏ‰ _ C
     â†’ is-pushoutÏ‰ _ (precomp-cocone f C)
precomp-cocone-is-pushout {S = S} f feq {C = C} po
  = is-pushoutâ†cogap
      (precomp-cocone f C)
      (cogap-is-equivâ†is-pushout _
         (is-equiv-âˆ˜ (precomp-cocone-is-equiv f feq)
                     po))

Pushout-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                  {f : S â†’ B} {g : S â†’ C} {S' : Type ğ“œ}
                â†’ (e : S' â‰ƒ S)
                â†’ Pushout (f âˆ˜ e ._â‰ƒ_.fwd) (g âˆ˜ e ._â‰ƒ_.fwd)
                â‰ƒ Pushout f g
Pushout-equiv {f = f} {g} e = mkâ‰ƒ map map-is-eq where
  module e = _â‰ƒ_ e

  map : Pushout _ _ â†’ Pushout f g
  map = cogap (precomp-cocone e.fwd (pushout {f = f} {g}))

  map-is-eq : is-equiv map
  map-is-eq = cogap-is-equivâ†is-pushout _
                (precomp-cocone-is-pushout
                   e.fwd
                   e.has-is-eqv
                   Pushout-is-pushoutÏ‰)
}
%```
}
