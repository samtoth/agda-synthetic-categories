\title{Commuting cubes}
\taxon{Module}
\author{samueltoth}
\date{2025-12-01}

\import{stt-macros}

%```agda
\agda{
module Core.Cube where

open import Foundations.Prelude

open import ufAxioms

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.ArrowRetract
open import Core.Postwhisker
open import Core.FunctorialPullback

open import Ergonomics.Marker
open import Ergonomics.Representation
open import Ergonomics.Extensionality
}
%```


\subtree[stt-00B2]{
\title{Commuting cube}
\taxon{Definition}

\p{Given a pair of arrow maps #{F : f \to g} and #{G : h \to k}, we define the
type of commuting cubes, consisting of a quadruple of maps, fillers for each
of the resulting faces, and a coherence that fills in the solid area of the
cube. Alternatively, this data can be packages up as pair of arrow maps
#{L : f \to h} and #{R : g \to k} together with a homotopy of arrow maps
#{GL \sim RF}.}

\quiver{
\begin{tikzcd}[cramped]
	& X && Z \\
	A && C \\
	& Y && W \\
	B && D
	\arrow[from=1-2, to=1-4]
	\arrow[from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow[from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow[from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow[from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

%```agda
\agda{
record Cube {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
            {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
            {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
            (F : Arrow-map f g)
            {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
            {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
            (G : Arrow-map h k) : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“§ âŠ” ğ“› âŠ” ğ“œ âŠ” ğ“ âŠ” ğ“) where
  constructor mk-cube
  module F = Arrow-map F
  module G = Arrow-map G
  field
    left : Arrow-map f h
    right : Arrow-map g k
    comm : Arrow-map-path (paste-squares G left) (paste-squares right F)

  module left = Arrow-map left
  module right = Arrow-map right

  topl : A â†’ X
  topl = left .Arrow-map.top

  topr : C â†’ Z
  topr = right .Arrow-map.top

  botl : B â†’ Y
  botl = left .Arrow-map.bot

  botr : D â†’ W
  botr = right .Arrow-map.bot

  bot : G.bot âˆ˜ botl ~ botr âˆ˜ F.bot
  bot = comm .snd .fst

  top : G.top âˆ˜ topl ~ topr âˆ˜ F.top
  top = comm .fst


  top-amap : Arrow-map F.top G.top
  top-amap .Arrow-map.top = topl
  top-amap .Arrow-map.bot = topr
  top-amap .Arrow-map.comm = top ~â»Â¹

  bot-amap : Arrow-map F.bot G.bot
  bot-amap .Arrow-map.top = botl
  bot-amap .Arrow-map.bot = botr
  bot-amap .Arrow-map.comm = bot ~â»Â¹

  fill-hex
    : âˆ€ a â†’ Hexagon
              (ap G.bot (left.comm a)) (G.comm (left.top a)) (ap k (top a))
              (bot (f a)) (ap right.bot (F.comm a)) (right.comm (F.top a))
  fill-hex a .Hexagon.un-hex
    = sym (âˆ™-assoc (ap G.bot (left.comm a)) _ (ap k (top a)))
    âˆ™ comm .snd .snd a
}
%```
}


\subtree[stt-00B3]{
\title{Cartesian commuting cubes preserve pullbacks}
\taxon{Theorem}

\p{Consider a commuting cube where the left and right squares are cartesian,}
\quiver{
\begin{tikzcd}[cramped]
	& X && Z \\
	A && C \\
	& Y && W \\
	B && D
	\arrow[from=1-2, to=1-4]
	\arrow[from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow[from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow[from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow[from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

\p{then the front square is cartesian if the back square is.}

\proof{
\p{Follows from the 3 for 2 property for cartesian squares.}
}


%```agda
\agda{
front-cartesianâ†cartesian-cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      (F : Arrow-map f g)
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      (G : Arrow-map h k)
    â†’ (cube : Cube F G) â†’ let open Cube cube
    in is-cartesian left â†’ is-cartesian right
    â†’ is-cartesian G â†’ is-cartesian F
front-cartesianâ†cartesian-cube {f = f} F {k = k} G cube leftCart rightCart GCart
  = 3-for-2-cartesian
      comm
      (compose-cartesian GCart leftCart)
      rightCart where
  open Cube cube
}
%```
}

\subtree[stt-00BP]{
\title{Equivalences of squares preserve pullbacks}
\taxon{Corollary}

\p{We define square-equivalences in the obvious way, just asking both the left
and right squares to be [arrow equivalences](stt-004R). Since arrow equivalences
are in particular cartesian squares, this result follows trivially from
\ref{stt-00B3}.}

%```agda
\agda{
is-Cube-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      {F : Arrow-map f g}
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      {G : Arrow-map h k}
    â†’ Cube F G â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“§ âŠ” ğ“› âŠ” ğ“œ âŠ” ğ“ âŠ” ğ“)
is-Cube-equiv Î± = is-Arrow-equiv left Ã— is-Arrow-equiv right where
  open Cube Î±

opaque
  front-cartesianâ†equiv-cube
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
        {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
        {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
        {F : Arrow-map f g}
        {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
        {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
        {G : Arrow-map h k}
      â†’ (Î± : Cube F G)
      â†’ is-Cube-equiv Î±
      â†’ is-cartesian G
      â†’ is-cartesian F
  front-cartesianâ†equiv-cube {F = F} {G = G} Î± (le , re)
    = front-cartesianâ†cartesian-cube
        F G Î±
        (is-cartesianâ†is-equiv _ le)
        (is-cartesianâ†is-equiv _ re)
}
%```
}


\subtree[stt-00BF]{
\taxon{Construction}
\title{Gap map square from cubes}

\p{There is a forgetful functor from the category of squares to the
category of cospan maps. On objects, we have already shown that [a square
is comprised of a cospan together with a cone over it](stt-002Z), now we give
(part of) the action on morhpisms: each cube gives rise to a
[map of cospans](stt-00BG).}

%```agda
\agda{
module _ where
  open Cube
  cospan-mapâ†cube
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
        {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
        {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
        {F : Arrow-map f g}
        {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
        {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
        {G : Arrow-map h k}
      â†’ (cube : Cube F G)
      â†’ Cospan-map (Coneâ†Arrow-map F .fst) (Coneâ†Arrow-map G .fst)
  cospan-mapâ†cube Î± .Cospan-map.hâ‚ = botl Î±
  cospan-mapâ†cube Î± .Cospan-map.hâ‚‚ = botr Î±
  cospan-mapâ†cube Î± .Cospan-map.hâ‚ƒ = topr Î±
  cospan-mapâ†cube Î± .Cospan-map.H = bot Î± ~â»Â¹
  cospan-mapâ†cube Î± .Cospan-map.K = right.comm Î±
}
%```

\p{Consequently, a map of squares (a cube) also induces a map of arrows between
the respective [gap maps](stt-003L).}

%```agda
\agda{
gap-map-squareâ†cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      (F : Arrow-map f g)
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      (G : Arrow-map h k)
    â†’ (cube : Cube F G)
    â†’ Arrow-map (gap-mapâ†square F) (gap-mapâ†square G)
gap-map-squareâ†cube F G Î± .Arrow-map.top = Î± .Cube.left.top
gap-map-squareâ†cube F G Î± .Arrow-map.bot = Pullbackâ‚ (cospan-mapâ†cube Î±)
gap-map-squareâ†cube {f = f} F {k = k} G
   Î±@(mk-cube L R (lc , rc , fill)) .Arrow-map.comm a
  = pullback-pathâ†’ ( Î± .Cube.left.comm a
                   , sym (Cube.top Î± a)
                   , un-square
                       (coe
                         (ap (Î» p â†’ Square _ p _ _) (sym (ap-sym k (lc a))))
                         (Hexagon.Square-compress-left
                          (tr
                           (Î» p â†’
                             Hexagon (ap (Arrow-map.bot G) (Arrow-map.comm L a))
                                     (Arrow-map.comm G (Arrow-map.top L a))
                                     (ap k (lc a))
                                     p
                                     (ap (Arrow-map.bot R) (Arrow-map.comm F a))
                                     (Arrow-map.comm R (Arrow-map.top F a)))
                           (sym sym-sym)
                           (Cube.fill-hex Î± a)))))
}
%```

\subtree[stt-00BI]{
\taxon{Conjecture}

\p{This map is an equivalence.}
}
}

\subtree[stt-00BH]{
\taxon{Definition}
\title{Partially coherent retracts of squares}

\p{A fully coherent notion of retract for a cube #{\alpha : F \to G} involves a
lot of data:}

\ul{
\li{A cube #{\beta : G \to F}}
\li{A path of cubes #{\beta \alpha = 1} - which itself involves:
\ul{
\li{Paths #{\beta_{tl} \alpha_{tl} = 1}, for each corner of the squares}
\li{Such that the fillers of the resulting squares are also equal to #{1}}
\li{And the result of pasting the fillers of the whole cubes together results
in the filler of the identity cube.}
}
}
}

\p{Recall that a [cube induces a map of gap maps](stt-00BF). It follows that a retract
of cubes should induce a retract of [gap maps](stt-003L) (retracts are preserved by
all functors after all). In HoTT, a retract of maps contains extra coherence data,
namely that the squares paste together to form the identity; however, we also
define a notion of [incoherent retracts](stt-00BJ), which are enough for certain results
[such as the fact incoherent retracts preserve equivalence](stt-00BK). Correspondingly,
we define
a \strong{1-coherent} or \strong{partially coherent} retract of squares to be
a cube in the opposite direction, together with a retract of the top-left map
and a (fully-coherent) retract of the induced cospan map. We show that this data
induces an incoherent retract of the gap maps. Under the [above conjecture](stt-00BI),
we expect the type of 1-coherent cube retracts to be equivalent to the type
of incoherent retracts of gap maps (although this has not been formalised).}

%```agda
\agda{
1-coherent-retract-cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
    {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
    {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
    {F : Arrow-map f g}
    {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
    {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
    {G : Arrow-map h k}
  â†’ Cube F G
  â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“§ âŠ” ğ“› âŠ” ğ“œ âŠ” ğ“ âŠ” ğ“)
1-coherent-retract-cube {F = F} {G = G} Î±@(mk-cube L R p)
  = Î£[ Î² âˆ¶ Cube G F ]
     (retract-witness (Cube.topl Î±) (Cube.topl Î²)
      Ã—
     retract-witness-cospan (cospan-mapâ†cube Î±) (cospan-mapâ†cube Î²))
}
%```

\proof{
The fact that the induced gap map square is a retract follows from the
fact that [pullbacks are functorial with respect to their cospan](stt-00BN).
}

%```agda
\agda{
gap-map-square-retâ†cube-partial-ret
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      (F : Arrow-map f g)
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      (G : Arrow-map h k)
    â†’ (cube : Cube F G)
    â†’ (ret : 1-coherent-retract-cube cube)
    â†’ incoherent-retract-arrow-map (gap-map-squareâ†cube F G cube)
gap-map-square-retâ†cube-partial-ret {g = g} F G Î± (Î² , tlr , cspr)
  = (ret  , tlr ,  ret2) where
  open Cube
  ret : Arrow-map (gap-mapâ†square G) (gap-mapâ†square F)
  ret = gap-map-squareâ†cube _ _ Î²


  ret-cspn : Pullbackâ‚
            (cospan-map-compose (cospan-mapâ†cube Î²) (cospan-mapâ†cube Î±))
         ~ Pullbackâ‚ (id-cospan-map)
  ret-cspn
    = happly
        (ap Pullbackâ‚ {cospan-map-compose (cospan-mapâ†cube Î²) _} {id-cospan-map}
          (ext! (cospan-retract-is-cospan-retract (cospan-mapâ†cube Î±)
                                                  (cospan-mapâ†cube Î² , cspr))))

  ret2 : retract-witness
           (gap-map-squareâ†cube _ _ Î± .Arrow-map.bot)
           (ret .Arrow-map.bot)
  ret2 = Pullbackâ‚-âˆ˜ (cospan-mapâ†cube Î²) (cospan-mapâ†cube Î±)
       ~âˆ™ ret-cspn
       ~âˆ™ Pullbackâ‚-id
}
%```
}

\subtree[stt-00BE]{
\title{Retracts of cartesian squares are cartesian}
\taxon{Corollary}

\p{Given a [1-coherent retract of squares](stt-00BH) #{F \hookrightarrow G}, if
#{G} is cartesian, then so is #{F}.}

\proof{This follows from the fact that [1-coherent retracts of squares induce
incoherent retracts of the respective gap maps](stt-00BH), and that [retracts of
equivalences are equivalences](stt-00BK)}


%```agda
\agda{
opaque
  retract-is-cartesian
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
        {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
        {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
        {F : Arrow-map f g}
        {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
        {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
        {G : Arrow-map h k}
      â†’ (cube : Cube F G)
      â†’ 1-coherent-retract-cube cube
      â†’ is-cartesian G
      â†’ is-cartesian F
  retract-is-cartesian Î± Î² gcart
    = is-cartesianâ†gap-is-equiv _
          (is-equivâ†retract-equiv
            (gap-map-squareâ†cube _ _ Î±)
            (gap-map-square-retâ†cube-partial-ret _ _ Î± Î²)
            (gap-is-equivâ†is-pullback _
              (is-pullbackâ†is-cartesian _ gcart)))

}
%```
}
