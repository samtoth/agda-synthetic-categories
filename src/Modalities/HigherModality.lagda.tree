\date{2025-02-21}
\title{Higher Modalities}
\taxon{module}
\meta{module}{\startverb Modalities.HigherModality \stopverb}
\import{stt-macros}

% ```agda
\agda{
module Modalities.HigherModality where

open import Foundations.Prelude
open import Foundations.IdentitySystem
open import ufAxioms
open import Ergonomics.Universal
open import Ergonomics.Extensionality
}
% ```

\transclude{stt-000G}


% ```agda
\agda{
record HigherModality ğ“¤ : Type (lsuc ğ“¤) where
  field
    â—‹_    : Type ğ“¤ â†’ Type ğ“¤
    Î·   : âˆ€ {A : Type ğ“¤} â†’ A â†’ â—‹ A
    ind : âˆ€ {A : Type ğ“¤} (P : â—‹ A â†’ Type ğ“¤)
            â†’ (f : (a : A) â†’ â—‹ P (Î· a))
            â†’ (ma : â—‹ A) â†’ â—‹ (P ma)
    ind-Î²   : âˆ€ {A : Type ğ“¤} (P : â—‹ A â†’ Type ğ“¤)
            â†’ (f : (a : A) â†’ â—‹ P (Î· a))
            â†’ (a : A) â†’ ind P f (Î· a) ï¼ f a

  is-modal : Type ğ“¤ â†’ Type ğ“¤
  is-modal A = is-equiv (Î· {A = A})

  field
    ï¼-â—‹-is-modal : âˆ€ {A : Type ğ“¤} {x y : â—‹ A} â†’ is-modal (x ï¼ y)

  opaque
    rec : âˆ€ {A : Type ğ“¤} {B : Type ğ“¤} â†’ (A â†’ â—‹ B) â†’ (â—‹ A â†’ â—‹ B)
    rec = ind (Î» _ â†’ _)

    recÎ² :  âˆ€ {A : Type ğ“¤} {B : Type ğ“¤} (f : A â†’ â—‹ B) (a : A)
              â†’ rec f (Î· a) ï¼ f a
    recÎ² = ind-Î² (Î» _ â†’ _)

  unmod : âˆ€ {A : Type ğ“¤} (m : is-modal A) â†’ â—‹ A â†’ A
  unmod (mk-eqv (g , _) _) = g
}
% ```

\subtree{
\taxon{theorem}
\title{#{\bigcirc A} is modal}

% ```agda
\agda{
  elim : âˆ€ {A : Type ğ“¤} â†’ â—‹ (â—‹ A) â†’ â—‹ A
  elim = rec Î» x â†’ x

  â—‹-is-modal : âˆ€ {A : Type ğ“¤} â†’ is-modal (â—‹ A)
  â—‹-is-modal = is-equivâ†qiso the-iso where
    the-iso : quasi-iso Î·
    the-iso .fst = ind _ id
    the-iso .snd .fst = ind-Î² _ id
    the-iso .snd .snd a = unmod
                            ï¼-â—‹-is-modal
                            (ind (Î» a â†’ (Î· (ind _ id a)) ï¼ a)
                            (Î» a â†’ Î· (ap Î· (ind-Î² _ _ a))) a)
}
% ```
}

\subtree{
\taxon{lemma}
\title{Equality on modal is modal}

% ```agda
\agda{
  â‰ƒ-modal : âˆ€ {A B : Type ğ“¤} â†’ A â‰ƒ B â†’ is-modal A â†’ is-modal B
  â‰ƒ-modal e = tr is-modal (ua e)

  ï¼-is-modal : âˆ€ {A : Type ğ“¤} â†’ is-modal A  â†’ {a b : A}
                â†’ is-modal (a ï¼ b)
  ï¼-is-modal {A = A} H {a} {b} =
    â‰ƒ-modal
      (mkâ‰ƒ (ap Î·) (is-embeddingâ†is-equiv H) eâ»Â¹)
      ï¼-â—‹-is-modal
}
% ```
}

\subtree{
\taxon{definition}
\title{Modal induction}

% ```agda
\agda{
  opaque
    ind' : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤} (P-mod : âˆ€ {a} â†’ is-modal (P a))
           â†’ (f : (a : A) â†’ P (Î· a)) â†’ (ma : â—‹ A) â†’ P ma
    ind' {P = P} is-mod f = (unmod is-mod) âˆ˜ ind P (Î· âˆ˜ f)

    ind-Î²' : âˆ€  {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
         â†’ (P-mod : âˆ€ {a} â†’ is-modal (P a))
         â†’ (f : (a : A) â†’ P (Î· a)) â†’ (a : A) â†’ ind' (Î» {a'} â†’ P-mod {a'}) f (Î· a) ï¼ f a
    ind-Î²' is-mod f a = ap (unmod is-mod) (ind-Î² _ _ a) âˆ™ is-equiv.Î· is-mod (f a)

    ind'-qiso : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤} {P-mod : âˆ€ {a} â†’ is-modal (P a)}
                 â†’ quasi-iso {A = (a : A) â†’ P (Î· a)} {B = (a : â—‹ A) â†’ P a}
                             (ind' P-mod)
    ind'-qiso .fst = _âˆ˜ Î·
    ind'-qiso {P-mod = is-mod} .snd .fst f = ext! (ind-Î²' is-mod f)
    ind'-qiso {P = P} {P-mod = is-mod} .snd .snd f = ext! (ind' {P = Î» a â†’ _ ï¼ f a}
                   (Î» {a} â†’  ï¼-is-modal is-mod) (ind-Î²' is-mod (f âˆ˜ Î·)))

    ind'-is-equiv : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                     {P-mod : âˆ€ {a} â†’ is-modal (P a)}
                 â†’ is-equiv {A = (a : A) â†’ P (Î· a)} {B = (a : â—‹ A) â†’ P a}
                             (ind' P-mod)
    ind'-is-equiv {P-mod = is-mod} = is-equivâ†qiso (ind'-qiso {P-mod = is-mod})

}
% ```
}


\subtree{
\taxon{universal property}
% ```agda
\agda{
record Is-modal {ğ“¤} (M : HigherModality ğ“¤) (A : Type ğ“¤) : Type ğ“¤ where
  constructor mk-modal
  open HigherModality M
  field
    has-is-modal : is-modal A

module ModalUniversal {ğ“¤} (M : HigherModality ğ“¤) where

  open HigherModality M

  ind-qiso : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                 â†’ quasi-iso {A = (a : A) â†’ â—‹ P (Î· a)} {B = (a : â—‹ A) â†’ â—‹ (P a)}
                            (ind P)
  ind-qiso .fst = _âˆ˜ Î·
  ind-qiso .snd .fst f = ext! (ind-Î² _ f)
  ind-qiso {A = A} {P = P} .snd .snd f = ext! (ind' ï¼-â—‹-is-modal (ind-Î² _ (f âˆ˜ Î·)))

  ind-is-equiv : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                 â†’ is-equiv {A = (a : A) â†’ â—‹ P (Î· a)} {B = (a : â—‹ A) â†’ â—‹ P a}
                            (ind P)
  ind-is-equiv = is-equivâ†qiso ind-qiso


  open Universal

  instance
    Universal-â—‹ : âˆ€ {ğ“¦} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                 â†’ â¦ƒ _ : âˆ€ {a} â†’ Is-modal M (P a) â¦„
                 â†’ â¦ƒ _ : Universal ((a : A) â†’ P (Î· a)) ğ“¦ â¦„
                 â†’ Universal ((a : â—‹ A) â†’ P a) ğ“¦
    Universal-â—‹ â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.methods = u .methods
    Universal-â—‹ â¦ƒ mod â¦„ â¦ƒ u â¦„ .Universal.from
      = ind' (Î» {_} â†’ mod .Is-modal.has-is-modal) âˆ˜ u .from
    Universal-â—‹ â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.from-is-equiv
      = is-equiv-âˆ˜ ind'-is-equiv (u .from-is-equiv)
}
% ```
}

\subtree[stt-006Z]{

\title{Instance resolution for is-modal}

% ```agda
\agda{


module ModalInstances {ğ“¤} (M : HigherModality ğ“¤) where

  open HigherModality M
  open ModalUniversal M

  instance opaque
    â—‹-Modal : âˆ€ {A : Type ğ“¤} â†’ Is-modal M (â—‹ A)
    â—‹-Modal = mk-modal â—‹-is-modal

    ï¼-Modal : âˆ€ {A : Type ğ“¤} â†’ â¦ƒ Is-modal M A â¦„ â†’ {a b : A}  â†’ Is-modal M (a ï¼ b)
    ï¼-Modal â¦ƒ (mk-modal H) â¦„ = mk-modal (ï¼-is-modal H)

    Î -Modal : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤} â†’ â¦ƒ _ : âˆ€ {x} â†’ Is-modal M (B x) â¦„
              â†’ Is-modal M (âˆ€ x â†’ B x)
    Î -Modal = mk-modal (is-equivâ†qiso Î» where
                .fst â†’ Î» f a â†’ rec! (Î» f â†’ f a) f
                .snd .fst â†’ Î» f â†’ ext! (Î» a â†’ ind-Î²' _ _ _)
                .snd .snd â†’ Î» f â†’ ind! {B = Î» f â†’ Î· (Î» x â†’ ind' _ (Î» f â†’ f x) f) ï¼ f}
                                       (Î» f â†’ ap Î· (funextâ†’ (Î» a â†’ ind-Î²' _ _ _))) f)



  â—‹-elim! : âˆ€ {A : Type ğ“¤} â¦ƒ _ : Is-modal M A â¦„
            â†’ â—‹ A â†’ A
  â—‹-elim! = rec! id

  private module test where
    test : âˆ€ {A : Type ğ“¤} â†’ â—‹ â—‹ A â†’ â—‹ A
    test = â—‹-elim!
}
% ```


}

\subtree{
\taxon{theorem}
\title{Higher modalities are #{\Sigma}-closed}

% ```agda
\agda{
  â—‹-Î£-closed : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤}
            â†’ â¦ƒ _ : Is-modal M A â¦„
            â†’ â¦ƒ _ : âˆ€ {x} â†’ Is-modal M (B x) â¦„
            â†’ is-modal (Î£ A B)
  â—‹-Î£-closed {A = A} {B = B} = is-equivâ†qiso I where

    f : â—‹ Î£ A B â†’ A
    f = rec! (Î» a _ â†’ a)

    f-Î² : âˆ€ {a : A} {b : B a} â†’ f (Î· (a , b)) ï¼ a
    f-Î² = ind-Î²' _ _ _

    g : (x : â—‹ Î£ A B) â†’ B (f x)
    g = ind! (Î» a b â†’ tr B (sym f-Î²) b)

    g-Î² : âˆ€ {a : A} {b : B a} â†’ IdP (sym (ap B  f-Î²)) b (g (Î· (a , b)))
    g-Î² {a} {b} =  tr (Î» z â†’ IdP z b (g (Î· (a , b)))) (ap-sym B f-Î²) (sym (ind-Î²' _ _ _))

    I : quasi-iso Î·
    I .fst x = f x , g x
    I .snd .fst (a , b) = Î£-pathâ†’ (f-Î² ,  symP' g-Î²  )
    I .snd .snd = ind! Î» a b â†’ ap Î· (Î£-pathâ†’ (f-Î² , symP' g-Î²))


  instance opaque
    Modal-Î£ : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤}
            â†’ â¦ƒ _ : Is-modal M A â¦„
            â†’ â¦ƒ _ : âˆ€ {x} â†’ Is-modal M (B x) â¦„
            â†’ Is-modal M (Î£ A B)
    Modal-Î£ = mk-modal â—‹-Î£-closed
}
% ```
}



\subtree[stt-006U]{
\title{Do notation for Higher Modalities}
\taxon{notation}

\p{Higher (monadic) modalities are in particular, monads. As such,
we can use haskell style do notation to write terms and proof
with modal types.}

%```agda
\agda{
module Do {ğ“¤} (M : HigherModality ğ“¤) where
  open HigherModality M
  open ModalUniversal M


  _>>=_ : âˆ€ {A B : Type ğ“¤}
            â¦ƒ _ : Is-modal M B â¦„
          â†’ â—‹ A
          â†’ (A â†’ B)
          â†’ B
  x >>= f = rec! f x

  return : âˆ€ {A : Type ğ“¤} â†’ A â†’ â—‹ A
  return = Î·
}
%```
}
