\title{Hom families}
\taxon{Module}
\author{samueltoth}
\date{2025-12-09}

\import{stt-macros}


\subtree[tot-000R]{
\title{Idea}


}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.HomFamilies
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Data.Bool

open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CoSlice
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection
open import Core.CanonicalPushouts

-- For simpâ†strong-segal
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.FunctorialPullback
open import Core.Postwhisker

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open import Ergonomics.Auto
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.JoinSlice Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Homotopies Î”Â¹ I I-distr
}
%```



\subtree[tot-0002]{
\title{Unstraightening hom families}
\taxon{Remark}

\p{The unstraightening of the family #{\Hom(x,-)} is #{X_{x/} \to X}. Thus
representable families are covariant iff #{X_{x/} \to X} are all left fibrations.}


%```agda
\agda{
hom-fam-is-covâ‡”is-left-fibration
  : âˆ€ {ğ“¤} {X : Type ğ“¤} x
  â†’ is-covariant (Î» a â†’ Hom X x a)
  â‡” is-left-fibration {A = Coslice X (Î» (_ : ğŸ™) â†’ x)} fst
hom-fam-is-covâ‡”is-left-fibration x
  = is-covariantâ‡”is-left-fibration (Î» a â†’ Hom _ x a)
  âˆ™â‡” right-orthogonal-iffâ†equiv (Î» _ â†’ i0) amap amap-eq where
  amap : Arrow-map (fst {B = Î» c â†’ (i : ğŸ™) â†’ Hom _ x c})
                   (fst {B = Î» a â†’ Hom _ x a})
  amap .Arrow-map.top = total-map (Î» a â†’ ev tt)
  amap .Arrow-map.bot = id
  amap .Arrow-map.comm = ~refl

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = is-total-equivâ†is-fibrewise-equiv (Î» a â†’ unit-ev-is-equiv)
  amap-eq .snd = id-is-equiv
}
%```
}

\subtree[tot-0006]{
\taxon{Definition}

\p{We call a type \em{strongly} Segal if it is local with respect to the map
#{\Lambda^2_1 \to 1 \rtimes \Delta^1}.
}

%```agda
\agda{
weird-horn-inclusion : Î›[2,1] â†’ ğŸ™ â‹‰ Î”Â¹
weird-horn-inclusion = cogap (mk-cocone (â†‘-hom (tt , i0) .HomP.hom) â†‘-Î¹â‚‚
                             Î» a â†’ glue (Î´Î”Â¹-1 , tt , i0))

weird-horn-inclusionâˆ™ : Coslice-map (Î» (_ : ğŸ™) â†’ Î¹â‚ i0) Î» _ â†’ â†‘-Î¹â‚ tt
weird-horn-inclusionâˆ™ = (weird-horn-inclusion , Î» _ â†’ glue (Î´Î”Â¹-0 , tt , i0))

is-strongly-segal : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-strongly-segal A = is-local (Î» (_ : ğŸ™) â†’ weird-horn-inclusion) A
}
%```
}

\subtree[tot-0007]{
\title{Strongly Segal types are Segal}
\taxon{Lemma}

\p{Any [strongly Segal](tot-0006) type is [Segal](stt-00AI).}

\proof{
\p{We give a retraction #{\Delta^2 \hookrightarrow 1 \rtimes \Delta^1},
   which furthermore preserves the inner horn inclusion.
   (Note the retraction #{\Delta^2 \hookrightarrow \square^2} in \ref{stt-00C7}
   factors through this map.)}
}

%```agda
\agda{
retract-weird : ğŸ™ â‹‰ Î”Â¹ â†’ Î”Â²
retract-weird
  = cogap (mk-cocone
            (Î» {(i , tt , j) â†’ (i , i âˆ§ j) â¦ƒ âˆ§-â‰¤-eliml auto! â¦„})
            âŠ[ (Î» _ â†’ (i0 , i0)) , (i1 ,_) ]
            Î» { (mk-lift true  , tt , b) â†’ Î”Â²-ext (refl , âˆ§-commÂ âˆ™ 1-top)
              ; (mk-lift false , tt , b) â†’ Î”Â²-ext (refl , 0-init) })

retract-weird-resp-horn
  : retract-weird âˆ˜ weird-horn-inclusion ~ Î›[2,1]-incl
retract-weird-resp-horn = pushout-ind _
  (mk-coconeD
    (Î» l â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ 0-init))
    (Î» r â†’ refl)
    (Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _))

section-weird : Î”Â² â†’ ğŸ™ â‹‰ Î”Â¹
section-weird a = Î¹â‚ (Poly.Î”Â².s a , tt , Poly.Î”Â².t a)

section-weird-resp-horn
  : section-weird âˆ˜ Î›[2,1]-incl ~ weird-horn-inclusion
section-weird-resp-horn = pushout-rec-unique _ _
  ~refl
  (Î» a â†’ glue (Î´Î”Â¹-1 , tt , a))
  Î» a â†’ ap (_âˆ™ glue (Î´Î”Â¹-1 , tt , i0))
         ( ap-âˆ˜ section-weird Î›[2,1]-incl (glue a)
         âˆ™ ap (ap section-weird) (pushout-rec-apÎ² _)
         âˆ™ lem) where
  lem : ap (section-weird) Î”Â²-refl ï¼ refl
  lem = ap-âˆ˜ Î¹â‚ (Î» where (i , j) â†’ (i , tt , j)) Î”Â²-refl
      âˆ™ ap (ap Î¹â‚) (is-propâ†is-truncated
                     (Trunc.Ã—âˆˆS car-is-set (Trunc.Ã—âˆˆS Trunc.ğŸ™âˆˆS car-is-set) _ _)
                     _ _)

sec-weird-is-sec : retract-weird âˆ˜ section-weird ~ id
sec-weird-is-sec (a , b) = Î”Â²-ext (refl , (âˆ§-comm âˆ™ auto!))

strongly-segal-type-is-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (weird-horn-inclusion âŠ¥ A)
    â†’ is-precategory A
strongly-segal-type-is-segal orth tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-retract Î›[2,1]-incl weird-horn-inclusion
        (mk-amap id section-weird section-weird-resp-horn)
        ((mk-amap id retract-weird retract-weird-resp-horn) ,
          (~refl , ((Î» (i , j) â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ auto!))
          , Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)))
        !
        (is-orthogonalâ‡”orthogonal-! .snd orth))
}
%```
}

\subtree[tot-0008]{
\title{Orthogonality from equivalence of postcomposition maps}
\taxon{Lemma}

\p{Given a map #{f} in the [coslice](stt-0062) #{p \to_X q}, postcomposition
at every map #{X \to Y} is an equivalence iff #{f} is left orthogonal to #{Y}.
}

%```agda
\agda{
coslice-orth-lemma
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
      {p : X â†’ A} {q : X â†’ B} (f : Coslice-map p q)
    â†’ (f .fst âŠ¥ Y)
    â‡” (âˆ€ (x : X â†’ Y) â†’ is-equiv (Coslice-map-postcompose x f))
coslice-orth-lemma {A = A}{B}{X}{Y}{p}{q} (f , H)
  = topâ‡”bot-is-equivâ†Arrow-equiv (amap (funextâ†’ H)) eq âˆ™â‡” fibrewiseâ‡”total-is-equiv where

  add-singleton : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q) (g : Q â†’ Y)
                  â†’ Î£[ x âˆ¶ (X â†’ Y) ] Î£[ f' âˆ¶ (Q â†’ Y) ] (f' âˆ˜ p ~ x)
  add-singleton f g = (g âˆ˜ f , g , ~refl)

  add-singleton-eq : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q)
                     â†’ quasi-iso (add-singleton p)
  add-singleton-eq p .fst (a , f , H) = f
  add-singleton-eq p .snd .fst x = refl
  add-singleton-eq p .snd .snd (a , f , H)
    = funext-rec
        (Î» H â†’ ((f âˆ˜ p) , (f , ~refl)) ï¼ (a , (f , H)))
        (Î» where refl â†’ refl)
        H

  amap : âˆ€ (H : f âˆ˜ p ï¼ q)
         â†’ Arrow-map (postcomp Y f)
                     (total-map (Î» a â†’ Coslice-map-postcompose a (f , happly H)))
  amap H .Arrow-map.top = add-singleton q
  amap H .Arrow-map.bot = add-singleton p
  amap refl .Arrow-map.comm x = refl

  eq : is-Arrow-equiv (amap (funextâ†’ H))
  eq .fst = is-equivâ†qiso (add-singleton-eq q)
  eq .snd = is-equivâ†qiso (add-singleton-eq p)

}
%```
}

\subtree[tot-0005]{
\taxon{Therem}
\title{Covariance of representable families}

\p{We show that a type #{A} is [strongly Segal](tot-0006) iff the family
#{\Hom(-,x)} is covariant for each #{x}.}

\proof{
We will show that every #{A_{/x} \to A} is a left fibration iff A is right
orthogonal to the map #{\Lambda^2_1 \to 1 \rtimes \Delta^1}.

\p{First we give an equivalence of arrows:}

\quiver{
\begin{tikzcd}
	{1\rtimes \Delta^1 \to_\bullet A} && {{A_{x/}}^{\Delta^1}} \\
	\\
	{\Lambda^2_1 \to_\bullet A} && {A^{\Delta^1} \times_A A_{x/}}
	\arrow["\sim", from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow["\sim"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{The top equivalence is given by the [join-coslice adjunction](tot-0001), and
the bottom via the universal property of the horn.}


\p{Now we use \ref{tot-0008} to finish the proof.}
}

\closedScope{
\subtree[tot-000A]{
\title{The bottom equivalence}
%```agda
\agda{
char-coslice-lift : âˆ€ {ğ“¤} {A : Type ğ“¤} x
      â†’ Arrow-map (Î» (_ : ğŸ™) â†’ i0) {C = Coslice A (Î» (_ : ğŸ™) â†’ x)} (fst) â†’
      Coslice-map {X = Î›[2,1]} (Î» _ â†’ Î¹â‚ i0) (Î» (_ : ğŸ™) â†’ x)
char-coslice-lift x (mk-amap top bot comm)
  = cogap (mk-cocone (top tt .snd tt .HomP.hom)
                     bot
                     (Î» c â†’ top tt .snd tt .HomP.hom1 âˆ™ sym (comm c)))
  , Î» _ â†’ HomP.hom0 (top tt .snd tt)

opaque
  char-coslice-lift-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} x
    â†’ is-equiv (char-coslice-lift {A = A} x)
  char-coslice-lift-is-equiv x = is-equivâ†qiso qiso where
    qiso : quasi-iso (char-coslice-lift x)
    qiso .fst (a , b) = mk-amap (Î» _ â†’ _ , (Î» _ â†’ mk-hom (a âˆ˜ Î¹â‚) (b tt) refl))
                                (a âˆ˜ Î¹â‚‚)
                                (ap a âˆ˜ sym âˆ˜ glue)
    qiso .snd .fst (mk-amap top bot comm)
      = let pth = ( top tt .snd tt .HomP.hom1
                  , Î» i â†’ ~refl , ((Square-degen-vert _ _ refl) , (Square-flatten-hor refl)))
        in Arrow-map-pathâ†’
          ( (Î» a â†’ Coslice-pathâ†’ pth)
          , (~refl , Î» _ â†’ ap (_âˆ™ ap fst (Coslice-pathâ†’ pth)) (ap-sym _ (glue tt) âˆ™ ap sym (pushout-rec-apÎ² tt))
                         âˆ™ ap (sym (HomP.hom1 (top tt .snd tt) âˆ™ sym (comm tt)) âˆ™_)
                              (Coslice-path-ap-fst pth)
                         âˆ™ ap (_âˆ™ top tt .snd tt .HomP.hom1) (âˆ™-symsym _ (sym (comm tt)))
                         âˆ™ âˆ™.cancell _  (âˆ™-sym' (HomP.hom1 (top tt .snd tt)))
                                        {f = sym (sym (comm tt))}
                         âˆ™ sym-sym ))
    qiso .snd .snd (a , p)
      = ext! ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
                      (Î» _ â†’ âˆ™-reflr _ âˆ™ sym (ap sym (ap-sym a _) âˆ™ sym-sym))
             , ~refl)
}
%```
}
}

%```agda
\agda{
coslice-is-leftâ‡”strongly-inner-coslice
  : âˆ€ {ğ“¤} {A : Type ğ“¤} x
  â†’ is-left-fibration {A = Coslice A (Î» (_ : ğŸ™) â†’ x)} fst
  â‡” (is-equiv (Coslice-map-postcompose (Î» (_ : ğŸ™) â†’ x) weird-horn-inclusionâˆ™))
coslice-is-leftâ‡”strongly-inner-coslice x
  = (orthogonalâ‡”pb-power-is-equiv â‡”â»Â¹)
  âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv amap amap-eq where
  amap : Arrow-map (pullback-power (Î» _ â†’ i0) (Î» r â†’ fst r))
                   (Coslice-map-postcompose (Î» _ â†’ x) weird-horn-inclusionâˆ™)
  amap .Arrow-map.top = joinâ†coslice-map (Î» _ â†’ x)
  amap .Arrow-map.bot = char-coslice-lift x
  amap .Arrow-map.comm f = ext!
    ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
          (Î» a â†’ ap (_âˆ™ refl) ( ap-âˆ˜ _ _ (glue a)
                              âˆ™ ap (ap (pushout-rec _)) (pushout-rec-apÎ² a)
                              âˆ™ pushout-rec-apÎ² _))
    , Î» _ â†’ âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _)

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = joinâ†coslice-map-is-equiv (Î» _ â†’ x)
  amap-eq .snd = char-coslice-lift-is-equiv x


hom-fam-is-covâ‡”is-strongly-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (âˆ€ x â†’ is-covariant (Î» a â†’ Hom A x a))
    â‡” is-strongly-segal A
hom-fam-is-covâ‡”is-strongly-segal {ğ“¤}{A}
  =  precomp-Î -â‡” (Î»
       x â†’  hom-fam-is-covâ‡”is-left-fibration x
         âˆ™â‡” coslice-is-leftâ‡”strongly-inner-coslice x)
  âˆ™â‡” logicalâ†equiv (postcomp-Î -â‰ƒ _ unit-UPâ‰ƒ)
  âˆ™â‡” (coslice-orth-lemma (weird-horn-inclusionâˆ™) â‡”â»Â¹)
  âˆ™â‡” logicalâ†equiv {ğ“¥ = ğ“˜ âŠ” ğ“¤} (unit-UPâ‰ƒ eâ»Â¹)
}
%```
}

\subtree[tot-000H]{
\taxon{Lemma}

\p{The map #{\Delta^2 \to â§…+^{\Delta^1} 1} is a Segal equivalence.}

\proof{
\p{By associativity of pushouts, #{â§… +^{\Delta^1} 1} is equivalently
#{X = \Delta^2 +^{\Delta^1} (\Delta^2 +^{\Delta^1} 1)}, where we call the
right hand component #{\Delta^2 +^{\Delta^1} 1} the walking homotopy. Then by the
universal property of pushouts, #{A^X} is equivalently
#{\Sigma_{f : A^{\Delta^2}} \Sigma_{g : A^{\Delta^\sim}} f\Delta \sim g\Delta}.

 [Homotopies are identity systems for morphisms in
Segal types](stt-00CI), so we can contract away one of these edges and the homotopy.
Finally we can contract the data of the other edge together with the proof
it is equal to the diagonal of the first simplex. What remains is exactly the
type #{A^{\Delta^2}}.}
}

%```agda
\agda{
â§…-degen-top : Type ğ“˜
â§…-degen-top = Pushout {A = Î”Â¹} {B = â§…} (Î¹â‚‚ âˆ˜ (_, i0)) !

â§…-degen' : Pushout Î”Â²-diagonal src-Î”~ â†’ â§…-degen-top
â§…-degen' = Pushout-assocâ†’ Î”Â²-diagonal Î”Â²-diagonal (_, i0) !

â§…-degenâ†Î”Â² : Î”Â² â†’ â§…-degen-top
â§…-degenâ†Î”Â² = Î¹â‚ âˆ˜ Î¹â‚

test : âˆ€ {ğ“¤} {A : Type ğ“¤}
     â†’ postcomp A â§…-degenâ†Î”Â²
       ~ fst âˆ˜ _â‰…_.fwd cocone-reprâ‰… âˆ˜ cocone-map _ pushout âˆ˜ postcomp A â§…-degen'
test h = refl

opaque
  â§…-degenâ†Î”Â²-is-segal-equiv : is-segal-equiv â§…-degenâ†Î”Â²
  â§…-degenâ†Î”Â²-is-segal-equiv {Q = Q} qpc
    = is-equiv-âˆ˜
        {f = fst}
        {_â‰…_.fwd cocone-reprâ‰… âˆ˜ cocone-map _ pushout âˆ˜ postcomp Q â§…-degen'}
        (singleton-fst-is-equiv
          (Î» a â†’
            is-singleâ†equiv-to-single
              ( (Î£-ap-â‰ƒ-fst {B = Î» f â†’ a âˆ˜ Î”Â²-diagonal ~ f}
                          (mkâ‰ƒ _ (src-is-segal-equiv qpc))
                           eâ»Â¹) )
              (SingS-is-single _)))
        (is-equiv-âˆ˜
          (_â‰ƒ_.has-is-eqv cocone-reprâ‰ƒ)
          (is-equiv-âˆ˜
            Pushout-is-pushoutÏ‰
            (postcomp-equiv
              (is-equivâ†qiso
                (Pushout-assoc-is-equiv Î”Â²-diagonal Î”Â²-diagonal (_, i0) !)))))

}
%```
}

\subtree[tot-000F]{
\taxon{Lemma}
\title{Precategories are strongly Segal}

\p{A [simplicial type]() is [segal]() iff it is [strongly Segal]().}

\proof{

\p{We factorise the defining map for strongly Segal types as follows:}

\quiver{
\begin{tikzcd}
	{\Lambda^2_1} && {\Delta^2} \\
	\\
	\\
	{1 \ltimes \Delta^1 \simeq \square +^{\Delta^1}1} && {\ttt +^{\Delta^1}1}
	\arrow["{\sim_{\textit{Segal}}}", from=1-1, to=1-3]
	\arrow[from=1-1, to=4-1]
	\arrow["{\sim_{\textit{Segal}}}", from=1-3, to=4-3]
	\arrow["{\sim_{\textit{simp}}}", from=4-3, to=4-1]
\end{tikzcd}
}

\p{The top map is a Segal equivalence by definition. Likewise the bottom map
is a simplicial equivalence, which follows from \ref{tot-0008}. It remains to
show the right most map is a Segal equivalence.}


}

%```agda
\agda{
1â‹‰Î”Â¹â†cone : Pushout {B = â–¡^ 2} (_, i0) (! {A = Î”Â¹}) â†’ ğŸ™ â‹‰ Î”Â¹
1â‹‰Î”Â¹â†cone = Pushoutâ‚
  (mk-span-map
    (Î» (a , b) â†’ b , tt , a)
    (Î» i â†’ Î´Î”Â¹-0 , tt , i)
    inl
    ~refl
    ~refl)

1â‹‰Î”Â¹-is-cone : quasi-iso 1â‹‰Î”Â¹â†cone
1â‹‰Î”Â¹-is-cone .fst = â†‘-rec (mk-right-cocone Î¹â‚‚ (Î¹â‚ âˆ˜ (_, i1))
                           Î» where (_ , i) â†’ mk-hom (Î¹â‚ âˆ˜ (i ,_))
                                                    (glue i)
                                                    refl)
1â‹‰Î”Â¹-is-cone .snd .fst = pushout-ind _
  (mk-coconeD ~refl ~refl
    (Î» i â†’ IdP-funcâ†Square
               {f = (1â‹‰Î”Â¹-is-cone .fst âˆ˜ 1â‹‰Î”Â¹â†cone)} {id} (glue i) refl refl
               (Square-degen-hor _ _
                 (ap-âˆ˜ (1â‹‰Î”Â¹-is-cone .fst) 1â‹‰Î”Â¹â†cone (glue i)
                 âˆ™ ap (ap (1â‹‰Î”Â¹-is-cone .fst)) (pushout-rec-apÎ² _ âˆ™ âˆ™-reflr _)
                 âˆ™ pushout-rec-apÎ² _ âˆ™ sym (ap-id (glue i))))))
1â‹‰Î”Â¹-is-cone .snd .snd = pushout-ind _
  (mk-coconeD ~refl (âŠ-ind (~refl , (Î» i â†’ glue (Î´Î”Â¹-1 , tt , i))))
    Î» where (mk-lift true , _ , i)
              â†’ IdP-funcâ†Square (glue (Î´Î”Â¹-1 , tt , i)) refl (glue (Î´Î”Â¹-1 , tt , i))
                  (coe
                    (Square-functorial-bot (sym (ap-id (glue (Î´Î”Â¹-1 , _ , i)))))
                    (Square-flatten-vert (sym (ap-âˆ˜ 1â‹‰Î”Â¹â†cone (1â‹‰Î”Â¹-is-cone .fst) (glue _)
                    âˆ™ ap (ap 1â‹‰Î”Â¹â†cone) (pushout-rec-apÎ² _)))))
            (mk-lift false , _ , i)
              â†’ IdP-funcâ†Square (glue (Î´Î”Â¹-0 , tt , i)) refl refl
                  (Square-degen-hor _ _
                    (ap-âˆ˜ 1â‹‰Î”Â¹â†cone (1â‹‰Î”Â¹-is-cone .fst) (glue (Î´Î”Â¹-0 , tt , i))
                    âˆ™ ap (ap 1â‹‰Î”Â¹â†cone) (pushout-rec-apÎ² _) âˆ™ pushout-rec-apÎ² _
                    âˆ™ âˆ™-reflr _ âˆ™ sym (ap-id (glue _)))))

â§…-â–¡-degen-incl
  : Pushout {B = â§…} (Î¹â‚‚ âˆ˜ (_, i0)) ! â†’ Pushout {B = â–¡^ 2} (_, i0) !
â§…-â–¡-degen-incl
  = Pushoutâ‚ (mk-span-map â§…-incl id id ~refl ~refl)

strong-segal-factorisation
  : 1â‹‰Î”Â¹â†cone âˆ˜ â§…-â–¡-degen-incl âˆ˜ â§…-degenâ†Î”Â² âˆ˜ Î›[2,1]-incl ~ weird-horn-inclusion
strong-segal-factorisation
  = pushout-rec-unique _ _
      ~refl
      (Î» i â†’ glue (Î´Î”Â¹-1 , tt , i))
      Î» _ â†’ ap (_âˆ™ glue (Î´Î”Â¹-1 , tt , i0))
              ( ap-âˆ˜ (1â‹‰Î”Â¹â†cone âˆ˜ â§…-â–¡-degen-incl âˆ˜ â§…-degenâ†Î”Â²) Î›[2,1]-incl (glue tt)
              âˆ™ ap (ap (1â‹‰Î”Â¹â†cone âˆ˜ â§…-â–¡-degen-incl âˆ˜ â§…-degenâ†Î”Â²))
                   (pushout-rec-apÎ² tt)
              âˆ™ ap-âˆ˜ Î¹â‚ _ Î”Â²-refl
              âˆ™ ap (ap Î¹â‚) (is-propâ†is-truncated
                    (Trunc.Ã—âˆˆS car-is-set (Trunc.Ã—âˆˆS Trunc.ğŸ™âˆˆS car-is-set) _ _)
                     _ refl))
opaque
  coslice-as-pushout-lem
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“ } {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : B â†’ A) (f' : B â†’ A') (g : B â†’ C) â†’ (F : Coslice-map f f')
        {Q : Type ğ“ }
      â†’ (âˆ€ (q : C â†’ Q) â†’ is-equiv (Coslice-map-postcompose (q âˆ˜ g) F))
      â†’ is-equiv (postcomp Q (Pushoutâ‚ {S = mk-span _ f g}
                               (mk-span-map (F .fst) id id (F .snd) ~refl)))
  coslice-as-pushout-lem {A = A}{A'}{C = C} f f' g F {Q} coslice
    = is-equivâ†Arrow-equivâ»Â¹
        {F = amap}
        ( is-equiv-âˆ˜ (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv) Pushout-is-pushoutÏ‰
        , is-equiv-âˆ˜ (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv) Pushout-is-pushoutÏ‰)
        (is-total-equivâ†is-fibrewise-equiv
          Î» q â†’  is-equivâ†Arrow-equiv
                 {F = hom q}
                 ( is-total-equivâ†is-fibrewise-equiv
                     (Î» a â†’ is-equiv-âˆ˜ sym-is-equiv (is-equivâ»Â¹ global-funext))
                 , is-total-equivâ†is-fibrewise-equiv
                     (Î» a â†’ is-equiv-âˆ˜ sym-is-equiv (is-equivâ»Â¹ global-funext)))
                 (coslice q) ) where
    amap : Arrow-map (postcomp Q (Pushoutâ‚ {S = mk-span _ f g}
                               (mk-span-map (F .fst) id id (F .snd) ~refl)))
                     (Pullbackâ‚ {S = mk-cospan _  (postcomp Q g) (postcomp Q f')}
                                 {T = mk-cospan _ (postcomp Q g) (postcomp Q f)}
                       (mk-cospan-map id id (postcomp Q (F .fst))
                                      ~refl (Î» h â†’ funextâ†’ (ap h âˆ˜ sym âˆ˜ F .snd))))
    amap .Arrow-map.top = postcomp-coconeâ‰ƒpb ._â‰ƒ_.fwd âˆ˜ cocone-map _ pushout
    amap .Arrow-map.bot = postcomp-coconeâ‰ƒpb ._â‰ƒ_.fwd âˆ˜ cocone-map _ pushout
    amap .Arrow-map.comm a = pullback-pathâ†’
      ( refl
      , refl
      , sym (âˆ™-reflr _
        âˆ™ ap (funextâ†’)
          (funextâ†’ (Î» b â†’ ap sym (ap-âˆ˜ a _ (glue b)
                                 âˆ™ ap (ap a) (pushout-rec-apÎ² b
                                 âˆ™ ap (ap Î¹â‚ (F .snd b) âˆ™_) (âˆ™-reflr _)))))
          âˆ™ sym (ap (_âˆ™ funextâ†’ (ap (a âˆ˜ Î¹â‚) âˆ˜ sym âˆ˜ F .snd))
                    (ap-id (funextâ†’ (sym âˆ˜ ap a âˆ˜ glue)))
          âˆ™ sym (funext-âˆ™ (sym âˆ˜ ap a âˆ˜ glue) (ap (a âˆ˜ Î¹â‚) âˆ˜ sym âˆ˜ F .snd))
          âˆ™ ap funextâ†’ (funextâ†’ (Î» b
              â†’ ap (sym (ap a (glue b)) âˆ™_)
                   (ap-sym (a âˆ˜ Î¹â‚) (F .snd b) âˆ™ ap sym (ap-âˆ˜ a Î¹â‚ (F .snd b)))
                   âˆ™ sym (âˆ™-symsym (ap a (ap Î¹â‚ (F .snd b))) (ap a (glue b)))
                   âˆ™ ap sym (sym (ap-âˆ™ a (ap Î¹â‚ (F .snd b)) (glue b))))))))

    hom : âˆ€ (q : C â†’ Q)
          â†’ Arrow-map {A = Coslice-map f' (q âˆ˜ g)}
                      {B = Coslice-map f (q âˆ˜ g)}
                      (Coslice-map-postcompose (q âˆ˜ g) F)
                      {C = Î£[ x âˆ¶ (A' â†’ Q) ] (postcomp Q g q ï¼ postcomp Q f' x)}
                      {D = Î£[ x âˆ¶ (A â†’ Q) ] (postcomp Q g q ï¼ postcomp Q f x)}
                      (Î» G â†’
                          postcomp Q (F .fst) (G .fst)
                        , ap id (G .snd) âˆ™ funextâ†’ (ap (G .fst) âˆ˜ sym âˆ˜ F .snd))
    hom q .Arrow-map.top = total-map (Î» a â†’ sym âˆ˜ funextâ†’)
    hom q .Arrow-map.bot = total-map (Î» a â†’ sym âˆ˜ funextâ†’)
    hom q .Arrow-map.comm (x , p)
      = ext! (~refl , (sym (apâ‚‚ _âˆ™_
                             (ap-id (sym (funextâ†’ p)))
                             (ap funextâ†’ (funextâ†’ Î» b â†’ ap-sym x (F .snd b))
                               âˆ™ funext-sym _)
                      âˆ™ sym (âˆ™-symsym _ (funextâ†’ p))
                      âˆ™ ap sym (sym (funext-âˆ™ _ _)))))

is-based-triangulated
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’  â§…-incl âŠ¥ A â†’ â§…-â–¡-degen-incl âŠ¥ A
is-based-triangulated {A = A} ttA
  =  coslice-as-pushout-lem _ _ ! map (lem âˆ˜ ev tt)  where
  -- A map colim(â§… â† Î”Â¹ â†’ ğŸ™) â†’ colim(â–¡ â† Î”Â¹ â†’ ğŸ™)
  -- is equivalently a map in the coslice under Î”Â¹ from â§… â†’ â–¡
  map : Coslice-map {A = Î”Â¹} (Î¹â‚‚ âˆ˜ (_, i0)) (_, i0)
  map .fst = â§…-incl
  map .snd = ~refl

  lem : âˆ€ x â†’ is-equiv (Coslice-map-postcompose (Î» _ â†’ x) map)
  lem x = coslice-orth-lemma map .fst ttA (Î» _ â†’ x)

is-strongly-segalâ†is-precategory
  : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-simplicial A â†’ is-precategory A
    â†’ is-strongly-segal A
is-strongly-segalâ†is-precategory {A = A} asimp apc tt
  = is-equiv~âˆ˜ (Î» h â†’ funextâ†’ Î» a â†’ ap h (sym (strong-segal-factorisation a)))
      (is-equiv-âˆ˜
        (apc tt)
        (â§…-degenâ†Î”Â²-is-segal-equiv apc))
      (is-equiv-âˆ˜
        (is-based-triangulated (simp-is-triangulated asimp tt))
        (postcomp-equiv (is-equivâ†qiso 1â‹‰Î”Â¹-is-cone)))
}
%```
}
