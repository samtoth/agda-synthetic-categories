\date{2025-02-24}
\title{Characterising the Path Space of Sigma Types}

\import{stt-macros}

% ```agda
\agda{
module foundations.SigmaPath where

open import foundations.universe
open import foundations.Sigma
open import foundations.Identity
open import foundations.DependentIdentity
open import foundations.Functions
open import foundations.Homotopy
open import foundations.FunctionInverses
open import foundations.CoherentIsomorphism
open import foundations.QuasiIsomorphism
}
% ```


\subtree{
\taxon{theorem}

\p{Given two terms #{(x_1 , x_2) , (y_1 , y_2) : \Sigma_{(a:A)}B(a)}, we have #{(x_1,x_2) = (y_1,y_2) \simeq
\Sigma_{(p : x_1 = y_1)}(x_2 =_B^p y_2)}  }

}

% ```agda
\agda{
Σ-path : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥} {x y : Σ A B} → (Σ (x .fst ＝ y .fst) λ p → IdP B (x .snd) p (y .snd)) ≃ (x ＝ y)
Σ-path {x = x1 , x2} {y1 , y2} = qiso→equiv (mk-iso to-path (from-path , ret , sec)) module Σ-path where
  to-path : Σ (x1 ＝ y1) (λ p → IdP _ x2 p y2) → (x1 , x2) ＝ (y1 , y2)
  to-path (refl , refl) = refl

  from-path : (x1 , x2) ＝ (y1 , y2) →
            Σ (x1 ＝ y1) (λ p → IdP _ x2 p y2)
  from-path refl = refl , refl

  sec : section-witness to-path from-path
  sec refl = refl

  ret : retract-witness to-path from-path
  ret (refl , refl) = refl

Σ-path→ : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥} {x y : Σ A B} → (Σ (x .fst ＝ y .fst) λ p → IdP B (x .snd) p (y .snd)) → (x ＝ y)
Σ-path→ = Σ-path ._≃_.fwd

{-# DISPLAY Σ-path.to-path = Σ-path→ #-}

Σ-path-fst : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥} {x y : Σ A B}
             → x ＝ y → x .fst ＝ y .fst
Σ-path-fst refl = refl             

Σ-path-snd : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥} {x y : Σ A B}
           → (p : x ＝ y) → IdP B (x .snd) (Σ-path-fst p) (y .snd)
Σ-path-snd refl = refl           

is-fibrewise-equiv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : A → Type 𝓥} {B' : A → Type 𝓦} → (∀ a → B a → B' a) → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦)
is-fibrewise-equiv f = ∀ a → is-equiv (f a) 

totalisation : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : A → Type 𝓥} {B' : A → Type 𝓦}
               → (f : ∀ a → B a → B' a) → Σ A B → Σ A B'
totalisation f (a , b) = (a , f a b)

is-fibrewise-equiv→is-total-equiv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : A → Type 𝓥} {B' : A → Type 𝓦} → {f : ∀ a → B a → B' a}
                                  → is-fibrewise-equiv f → is-equiv (totalisation f)
is-fibrewise-equiv→is-total-equiv {f = f} feq = is-equiv←qiso iso where
  module A x = is-equiv (feq x)
  open A

  iso : quasi-iso (totalisation f)
  iso .fst (a , b) = a , bwd a b
  iso .snd .fst (a , b) = Σ-path→ (refl , retract-fwd a .snd b)
  iso .snd .snd (a , b) = Σ-path→ (refl , section-fwd a .snd b)


Σ-ap-≃ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : A → Type 𝓥} {B' : A → Type 𝓦} → ((a : A) → B a ≃ B' a) →  Σ A B ≃ Σ A B'
Σ-ap-≃ eq = totalisation (_≃_.fwd ∘ eq) , is-fibrewise-equiv→is-total-equiv (_≃_.has-is-eqv ∘ eq)

Σ-ap-≃-fst : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {A' : Type 𝓥} {B : A → Type 𝓦} → ((f , _) : A' ≃ A) → Σ A' (B ∘ f) ≃ Σ A B
Σ-ap-≃-fst {A = A} {A'} {B} eq = func , is-equiv←qiso the-iso where
  open _≃_ eq

  func : Σ _ (B ∘ fwd) → Σ _ B
  func (a , b) = fwd a , b

  lem : {a : A'} {b : (B ∘ fwd) a} → 
      tr (B ∘ fwd) (η a) (tr B (sym (ε (fwd a))) b) ＝ b
  lem {a} {b} = tr (B ∘ fwd) (η a) _                    ＝⟨ tr∘ B fwd (η a) ⟩
                tr B (ap fwd (η a)) _                   ＝⟨ ap (λ p → tr B p (tr B (sym (ε (fwd a))) b)) (coherent a) ⟩
                tr B (ε (fwd a)) _                      ＝⟨ tr∙tr-sym' (ε (fwd a)) b ⟩
                b ∎
  
  the-iso : quasi-iso func
  the-iso .fst (a , b) = (bwd a , tr B (sym (ε a)) b)
  the-iso .snd .fst (a , b) = Σ-path→ (η a ,  lem) 
  the-iso .snd .snd (a , b) = Σ-path→ (ε a ,  tr∙tr-sym' (ε a) b)



Σ-assoc : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : A → Type 𝓥} {C : (a : A) → B a → Type 𝓦}
          → Σ (Σ A B) (λ x → C (fst x) (snd x)) ≃ Σ A λ a → Σ (B a) λ b → C a b
Σ-assoc {A = A} {B} {C} = qiso→equiv iso where
  fwd : Σ (Σ A B) (λ x → C (fst x) (snd x)) → Σ A (λ a → Σ (B a) (C a))
  fwd ((a , b) , c) = a , (b , c)

  iso : Σ (Σ A B) (λ x → C (fst x) (snd x)) ≅ Σ A (λ a → Σ (B a) (C a))
  iso ._≅_.fwd = fwd
  iso ._≅_.fwd-iso .fst (x , y , z) = (x , y) , z
  iso ._≅_.fwd-iso .snd .fst a = refl
  iso ._≅_.fwd-iso .snd .snd a = refl


Σ-singl : ∀ {𝓤 𝓥} {A : Type 𝓤} {a' : A} {B : (a : A) → a ＝ a' → Type 𝓥}
        → Σ A (λ a → Σ (a ＝ a') λ p → B a p) ≃ B a' refl
Σ-singl {A = A} {a'} {B} = qiso→equiv iso where
  iso : Σ A (λ a → Σ (a ＝ a') (B a)) ≅ B a' refl
  iso ._≅_.fwd (.a' , refl , ba) = ba
  iso ._≅_.fwd-iso .fst ba = a' , refl , ba
  iso ._≅_.fwd-iso .snd .fst (.a' , refl , ba) = refl
  iso ._≅_.fwd-iso .snd .snd _ = refl


Σ-comm : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {C : A → B → Type 𝓦}
         → (Σ A λ a → Σ B (C a)) ≃ (Σ B λ b → Σ A λ a → C a b)
Σ-comm {A = A} {B} {C} = f , is-equiv←qiso iso where
  f : Σ A (λ a → Σ B (C a)) → Σ B (λ b → Σ A (λ a → C a b))
  f (a , b , c) = b , a , c

  iso : quasi-iso f
  iso .fst (b , a , c) = a , b , c
  iso .snd .fst _ = refl
  iso .snd .snd _ = refl
}
% ```
