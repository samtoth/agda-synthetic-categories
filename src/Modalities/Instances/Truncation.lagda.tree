\date{2025-06-27}
\title{Truncation modalities}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Modalities.Instances.Truncation where

open import Foundations.Prelude
open import Foundations.IdentitySystem
open import ufAxioms
open import Core.Suspensions
open import Core.Spheres
open import Modalities.Instances.Localisation
open import Modalities.Subuniverses
open import Modalities.HigherModality
open import Modalities.GlobalSubuniverses
open import Modalities.Separated
open import Ergonomics.Universal
open import Ergonomics.PushoutUniv
open import Ergonomics.Extensionality
import Modalities.ModalMaps
}
%```

\subtree[stt-006P]{
\taxon{Definition}
\title{#{n}-truncated types}

\p{A type #{X} is #{n}-truncated for #{n : \mathbb{N}} when it is
#{n}-[separated](stt-007H) with respect to being a
[singleton](stt-0006).  Equivalently, a type is #{n}-truncated if it
is [null](stt-005G) with respect to #{S^{n-1}}.  }

%```agda
\agda{
is-S-null : âˆ€ {ğ“¤}
             â†’ â„•
             â†’ Type ğ“¤ â†’ Type ğ“¤
is-S-null n = is-null {I = ğŸ™} (const _ _ (S n))

singleton-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ ğ“¤
singleton-SubU .Subtype.family = is-singleton
singleton-SubU .Subtype.has-is-subtype _ = is-single-is-prop

is-truncated : âˆ€ {ğ“¤} (n : â„•) (A : Type ğ“¤) â†’ Type ğ“¤
is-truncated = is-n-separated singleton-SubU
}
%```
}

\remark{Note that we use numbering starting from #{0}
as opposed to from #{-2} as is often used.}

\subtree[stt-006T]{
\title{Truncation-modal types are #{n}-types}
\taxon{Theorem}

\p{We show #{0}-truncated types are singletons, and #{1}-truncated
types are propositions. Furthermore, by the [general theory](stt-007F)
of separated types, we show that #{n + 1} truncated types are null
with respect to the #{n}-sphere.
}

%```agda
\agda{
opaque
  unfolding is-n-separated
  is-singletonâ†is-truncated
    : âˆ€ {ğ“¤} {A : Type ğ“¤}
      â†’ is-truncated 0 A
      â†’ is-singleton A
  is-singletonâ†is-truncated {A = A} trunc = unlift trunc

  is-truncatedâ†is-singleton
    : âˆ€ {ğ“¤} {A : Type ğ“¤}
      â†’ is-singleton A
      â†’ is-truncated 0 A
  is-truncatedâ†is-singleton {A = A} tr
    = mk-lift tr

  is-propâ†is-truncated
    : âˆ€ {ğ“¤} {A : Type ğ“¤}
      â†’ is-truncated 1 A
      â†’ is-prop A
  is-propâ†is-truncated {A = A} tr x = is-singleton.centre âˆ˜ unlift âˆ˜ tr x

  is-truncatedâ†is-prop
    : âˆ€ {ğ“¤} {A : Type ğ“¤}
      â†’ is-prop A
      â†’ is-truncated 1 A
  is-truncatedâ†is-prop {A = A} pr x y
    = mk-lift (ï¼-singletonâ†is-prop pr x y)

is-propâ†is-S0-null : âˆ€ {ğ“¤} {A : Type ğ“¤}
                     â†’ is-null (const _ ğŸ™ (S 0)) A
                     â†’ is-prop A
is-propâ†is-S0-null {A = A} null x y
  =   sym (happly (Îµ f) (Î¹â‚ tt)) âˆ™ happly (Îµ f) (Î¹â‚‚ tt) where
  open is-equiv (null tt)

  f : S 0 â†’ A
  f = rec! (mk-coconeU x y (Î» ()))

is-S0-nullâ†is-prop : âˆ€ {ğ“¤} {A : Type ğ“¤}
                     â†’ is-prop A
                     â†’ is-null (const _ ğŸ™ (S 0)) A
is-S0-nullâ†is-prop {_}{A} pr _ = is-equivâ†qiso qiso where
  qiso : quasi-iso Î» (a : A) (b : Susp âˆ…) â†’ a
  qiso .fst f = f (Î¹â‚ tt)
  qiso .snd .fst = ~refl
  qiso .snd .snd f = funextâ†’ (Î» a â†’ pr _ _)

opaque
  unfolding is-n-separated
  is-truncatedâ†null : âˆ€ {ğ“¤} n {A : Type ğ“¤}
                      â†’ is-S-null n A
                      â†’ is-truncated (suc n) A
  is-truncatedâ†null zero = is-truncatedâ†is-prop âˆ˜ is-propâ†is-S0-null
  is-truncatedâ†null (suc n) {A} null x y
    = is-truncatedâ†null n (lem x y) where
    lem : is-separated (Null-SubU (Î» (_ : ğŸ™) â†’ S n) _) A
    lem = is-separatedâ†is-Î£-null (Î» _ â†’ S n) null

  is-nullâ†truncated : âˆ€ {ğ“¤} n {A : Type ğ“¤}
                      â†’ is-truncated (suc n) A
                      â†’ is-S-null n A
  is-nullâ†truncated zero = is-S0-nullâ†is-prop âˆ˜ is-propâ†is-truncated
  is-nullâ†truncated (suc n){A} tr  = is-Î£-nullâ†is-separated _ lem  where
    lem : âˆ€ (x y : A) â†’ is-S-null n (x ï¼ y)
    lem x y = is-nullâ†truncated n (tr x y)

is-set : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
is-set A = âˆ€ (x y : A) â†’ is-prop (x ï¼ y)

opaque
  unfolding is-n-separated
  is-truncatedâ†is-set : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-set A â†’ is-truncated 2 A
  is-truncatedâ†is-set A-set = Î» x y â†’ is-truncatedâ†is-prop (A-set x y)
}
%```
}

\subtree[stt-006Q]{
\title{Truncation is a [global reflective subuniverse](stt-007A)}
\taxon{Corollary}

%```agda
\agda{
Truncation-SubU
  : âˆ€ {ğ“¤} (n : â„•)
    â†’ SubU ğ“¤ ğ“¤
Truncation-SubU = n-separated-SubU singleton-SubU

singleton-GSU : GSU id
singleton-GSU .GSU.S = singleton-SubU
singleton-GSU .GSU.S-equiv = is-singleâ†equiv-to-single

Truncation-GSU : â„• â†’ GSU id
Truncation-GSU = n-separated-GSU singleton-GSU

opaque
  unfolding is-n-separated
  Truncâ‰ƒSNull-GSU : âˆ€ {n} â†’ GSU-equiv (Null-GSU (Î» (_ : ğŸ™) â†’ S n))
                                      (Truncation-GSU (suc n))
  Truncâ‰ƒSNull-GSU A = (is-truncatedâ†null _ , is-nullâ†truncated _)

singleton-GSU-is-reflective : is-globally-reflective singleton-GSU
singleton-GSU-is-reflective .is-globally-reflective.â—‹ A = âˆ… â†’ A
singleton-GSU-is-reflective .is-globally-reflective.Î· a _ = a
singleton-GSU-is-reflective .is-globally-reflective.has-is-reflector
  {ğ“¤} {A} = gr where
  open is-global-reflector
  gr : is-global-reflector singleton-GSU A (âˆ… â†’ A) (const A âˆ…)
  gr .â—‹âˆˆS = âˆ…-UP-sing
  gr .reflects Qs = is-equivâ†single-to-prop
                     (is-singleton-Î  (Î» _ â†’ Qs))
                     (is-propâ†is-single (is-singleton-Î  (Î» _ â†’ Qs)))
                     (postcomp _ (const A âˆ…))


opaque
  unfolding is-n-separated
  Truncation-grefl : âˆ€ {n} â†’ is-globally-reflective (Truncation-GSU n)
  Truncation-grefl {zero}
    = mk-gReflectors â—‹ Î· (mk-grfltor (mk-lift â—‹âˆˆS) (reflects âˆ˜ unlift))
    where open is-globally-reflective singleton-GSU-is-reflective
  Truncation-grefl {suc n} = is-globally-reflective-subtype-equiv
                              Truncâ‰ƒSNull-GSU
                              (Nullâˆ™-global-reflectors (Î» _ â†’ S-âˆ™))

  Truncation-refl : âˆ€ {ğ“¤} n â†’ is-reflective (Truncation-SubU {ğ“¤} n)
  Truncation-refl n = is-reflectiveâ†global (Truncation-grefl)

  Truncation-Î£-closed : âˆ€ {n} â†’ is-globally-Î£-closed (Truncation-GSU n)
  Truncation-Î£-closed {zero} As Bs
    = mk-lift (Singleton-Î£ (unlift As) (unlift âˆ˜ Bs))
  Truncation-Î£-closed {suc n} {A = A} {B} As Bs
    = Truncâ‰ƒSNull-GSU (Î£ A B) .fst (Null-globally-Î£-closed
                                     (is-nullâ†truncated _ As)
                                     (is-nullâ†truncated _ âˆ˜ Bs))

module Trunc {n} where
  open GRSUInduction (Truncation-grefl {n}) Truncation-Î£-closed public

  open GSU (Truncation-GSU n) public renaming (S-equiv to is-truncatedâ†equiv)
  open GPiClosure (Truncation-grefl {n}) public
    renaming (Î âˆˆS to Î -is-truncated; ULiftâˆˆS to ULift-is-truncated)
  open is-globally-reflective (Truncation-grefl {n}) public

  Î£-is-truncated = Truncation-Î£-closed {n}

  opaque
    unfolding is-n-separated
    âˆ…-is-suc-truncated : is-truncated (suc n) âˆ…
    âˆ…-is-suc-truncated ()

  untrunc : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-truncated n A â†’ â—‹ A â†’ A
  untrunc tr = unmod (reflector _) tr

Trunc : âˆ€ {ğ“¤} n â†’ Type ğ“¤ â†’ Type ğ“¤
Trunc n = Trunc.â—‹ {n}

âˆ¥_âˆ¥ : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
âˆ¥_âˆ¥ = Trunc 1
{-# NOINLINE âˆ¥_âˆ¥ #-}

âˆ¥-âˆ¥-is-prop : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-prop âˆ¥ A âˆ¥
âˆ¥-âˆ¥-is-prop = is-propâ†is-truncated Trunc.â—‹âˆˆS

{-# DISPLAY Trunc.â—‹ {n} A = Trunc n A #-}
}
%```
}


\subtree[stt-0075]{
\title{Lifting truncation levels}
\taxon{Theorem}

\p{An #{n}-truncated type is #{n+k} truncated for any #{k : â„•}.}



\quiver{
\begin{tikzcd}
	A &&&& {A^{\Sigma S^n}} \\
	\\
	&&&& {\Sigma_{a,b}(a=b)^{S^n}}
	\arrow["{\Delta_{A}}", from=1-1, to=1-5]
	\arrow["{(a,a,\Delta_{\rm{refl}})}"', from=1-1, to=3-5]
	\arrow[from=3-5, to=1-5]
\end{tikzcd}
}

%```agda
\agda{
suc-is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥}
                {I : Type ğ“˜}
                {X : I â†’ Type ğ“¥}
                {A : Type ğ“¤}
              â†’ is-null X A
              â†’ is-null (Susp âˆ˜ X) A
suc-is-null {X = X}{A} AXnull i = eqv where opaque
  module eqv = is-equiv (AXnull i)
  Ideq : {x y : A} â†’ (x ï¼ y) â‰ƒ (X i â†’ x ï¼ y)
  Ideq {x} {y} = (mkâ‰ƒ _ (ï¼-is-null AXnull {x} {y} i))

  module Ideq x y = _â‰ƒ_ (Ideq {x} {y})

  map1 : A â†’ Î£[ a âˆ¶ A ] Î£[ b âˆ¶ A ] (X i â†’ a ï¼ b)
  map1 a = (a , a , ~refl)

  map1-eqv : A â‰ƒ (Î£[ a âˆ¶ A ] Î£[ b âˆ¶ A ] (X i â†’ a ï¼ b))
  map1-eqv
    = A                                     â‰ƒâŸ¨ Î£-singleton (Î» _ â†’ Sing-is-singleton) eâ»Â¹ âŸ©
      ((Î£[ a âˆ¶ A ] Sing A a))               â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-ap-â‰ƒ (Î» b â†’ Ideq)) âŸ©
      (Î£[ a âˆ¶ A ] Î£[ b âˆ¶ A ] (X i â†’ a ï¼ b)) â‰ƒâˆ

  map1-is-equiv : is-equiv map1
  map1-is-equiv = map1-eqv ._â‰ƒ_.has-is-eqv

  homtpy : const A (Susp (X i)) ~ Susp-UPâ†’ âˆ˜ map1
  homtpy a = funextâ†’ (pushout-ind _
                       (mk-coconeD
                         ~refl ~refl Î» x
                         â†’ IdP-funcâ†Square
                             (glue x)
                             _
                             _
                             (mk-square (âˆ™-reflr _ âˆ™ sym (pushout-rec-apÎ² x
                                              âˆ™ sym (ap-const _))))))

  eqv : is-equiv (const A (Susp (X i)))
  eqv = is-equiv~âˆ˜ homtpy
                   (_â‰ƒ_.has-is-eqv (Susp-UPâ‰ƒ eâ»Â¹))
                   map1-is-equiv

suc-is-truncated : âˆ€ {ğ“¤} {A : Type ğ“¤} n
                   â†’ is-truncated n A
                   â†’ is-truncated (suc n) A
suc-is-truncated zero
  = is-truncatedâ†is-prop
  âˆ˜ is-propâ†is-single
  âˆ˜ is-singletonâ†is-truncated
suc-is-truncated {A = A} (suc n)
  = is-truncatedâ†null (suc n)
  âˆ˜ suc-is-null
  âˆ˜ is-nullâ†truncated n

+-is-truncated : âˆ€ {ğ“¤} {A : Type ğ“¤}
                   n k
                 â†’ is-truncated n A
                 â†’ is-truncated (n + k) A
+-is-truncated n zero = id
+-is-truncated n (suc k) tr = suc-is-truncated (n + k)
                                (+-is-truncated n k tr)

opaque
  unfolding is-n-separated
  is-n-truncatedâ†is-single : âˆ€ {ğ“¤} {A : Type ğ“¤}
                          â†’ is-singleton A â†’ âˆ€ n â†’ is-truncated n A
  is-n-truncatedâ†is-single s zero = mk-lift s
  is-n-truncatedâ†is-single s (suc n) x y
    = is-n-truncatedâ†is-single
        (ï¼-singletonâ†is-prop (is-propâ†is-single s) x y) n

  is-suc-truncatedâ†is-prop
    : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-prop A â†’ âˆ€ n â†’ is-truncated (suc n) A
  is-suc-truncatedâ†is-prop ap n x y
    = is-n-truncatedâ†is-single (ï¼-singletonâ†is-prop ap _ _) n
}
%```
}

\subtree[stt-1082]{
\title{The universe of #{n}-truncated types is #{n + 1} truncated}

%```agda
\agda{
â‰ƒ-is-truncated : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} n
                 â†’ is-truncated n A â†’ is-truncated n B
                 â†’ is-truncated n (A â‰ƒ B)
â‰ƒ-is-truncated zero Atr Btr
  = is-truncatedâ†is-singleton
     (is-singleâ†equiv-to-single (â‰ƒ-rep eâ»Â¹)
       (Singleton-Î£ (is-singleton-Î  Î» _ â†’ is-singletonâ†is-truncated Btr)
       Î» a â†’ mk-singl (is-equivâ†single-to-prop (is-singletonâ†is-truncated Atr)
                         (is-propâ†is-single (is-singletonâ†is-truncated Btr)) a)
                      (is-equiv-is-prop _)))
â‰ƒ-is-truncated (suc n) Atr Btr = Trunc.is-truncatedâ†equiv (â‰ƒ-rep eâ»Â¹)
                            (Trunc.Î£-is-truncated
                              (Trunc.Î -is-truncated (Î» a â†’ Btr))
                              Î» a â†’ is-suc-truncatedâ†is-prop
                                       is-equiv-is-prop n)

Trunc-U : âˆ€ n ğ“¤ â†’ Type (lsuc ğ“¤)
Trunc-U n ğ“¤ = Î£ (Type ğ“¤) (is-truncated n)

PropU = Trunc-U 1
SetU = Trunc-U 2

TULift : âˆ€ {ğ“¤} n ğ“¥ â†’ Trunc-U n ğ“¤ â†’ Trunc-U n (ğ“¤ âŠ” ğ“¥)
TULift n ğ“¥ (t , p) = (ULift ğ“¥ t , Trunc.ULift-is-truncated p)

opaque
  unfolding is-n-separated
  Trunc-U-is-truncated : âˆ€ n {ğ“¤} â†’ is-truncated (suc n) (Trunc-U n ğ“¤)
  Trunc-U-is-truncated n (X , Xtr) (Y , Ytr)
    = Trunc.is-truncatedâ†equiv Î£-path
        (Trunc.Î£-is-truncated (Trunc.is-truncatedâ†equiv
                                (mkâ‰ƒ _ (is-equivâ»Â¹ UA))
                                (â‰ƒ-is-truncated n Xtr Ytr))
        (Î» where refl â†’ let is-sing = ï¼-singletonâ†is-prop
                                       (is-n-separated-is-prop _ n X) Xtr Ytr
                        in is-n-truncatedâ†is-single is-sing n))



  is-setâ†is-truncated
    : âˆ€ {ğ“¤} {A : Type ğ“¤}
      â†’ is-truncated 2 A
      â†’ is-set A
  is-setâ†is-truncated tr x y = is-propâ†is-truncated (tr x y)
}
%```
}

\subtree[stt-0073]{
\date{2025-06-29}
\title{Instance resolution for truncated types}

\p{Truncation is not a single modality but a tower of connected
modalities.  Whilst we [have](stt-006Z) instances in place for
automatically resolving goals of type #{\rm{is-modal}}, but if we just
naively implement rules #{\rm{is-modal}_n \implies
\rm{is-modal}_{n+1}} and #{\rm{is-modal}_{n+1}(A) \implies
\rm{is-modal}_{n}(x =_A y)}, we run into trouble with Agda's instance
search.
   }

\p{To remedy this, we follow the approach taken in the
\citek{1lab}{1Lab.HLevel.Closure}, and define instances uniformly for
all truncation levels.}

\todo{Get this working - or take a different approach all together}

%```agda
\agda{

_ : âˆ€ {ğ“¤} (A B : Type ğ“¤) â†’ (f : A â†’ B) â†’ Trunc 2 A â†’ Trunc 2 B
_ = Î» A B f â†’  Trunc.â—‹-rec Trunc.â—‹âˆˆS (Trunc.Î· âˆ˜ f)

record Is-truncated {ğ“¤} n (A : Type ğ“¤) : Type ğ“¤ where
  constructor mk-trunc
  no-eta-equality
  field
    has-is-truncated : is-truncated n A

open Is-truncated


truncation-instance : âˆ€ {ğ“¤} {A : Type ğ“¤} n
                      â†’ is-truncated n A
                      â†’ âˆ€ {k}
                      â†’ Is-truncated (k + n) A
truncation-instance n trunc {k} .has-is-truncated
  = tr (Î» n â†’ is-truncated n _) (+-comm {n}) (+-is-truncated n k trunc)


instance
  Truncated-Id : âˆ€ {ğ“¤} {A : Type ğ“¤} {n}
                   â¦ƒ _ : Is-truncated (suc n) A â¦„
                 â†’ âˆ€ {x y : A} â†’ Is-truncated n (x ï¼ y)
  Truncated-Id {n = n} â¦ƒ t â¦„ {x} {y} .has-is-truncated = a where
    opaque
      unfolding is-n-separated
      a : is-truncated n (x ï¼ y)
      a = t .has-is-truncated x y

instance
  Truncated-Î  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {n}
                  â¦ƒ _ : âˆ€ {a} â†’ Is-truncated n (B a) â¦„
                â†’ Is-truncated n (Î  A B)
  Truncated-Î  â¦ƒ t â¦„ .has-is-truncated
    = Trunc.Î -is-truncated Î» _ â†’ t .has-is-truncated

trunc! : âˆ€ {ğ“¤} {A : Type ğ“¤} {n} â†’ â¦ƒ _ : Is-truncated n A â¦„ â†’ is-truncated n A
trunc! â¦ƒ t â¦„ = t .has-is-truncated

instance
  Trunc-trunc : âˆ€ {ğ“¤} {A : Type ğ“¤}
                  {n k}
                â†’ Is-truncated (k + n) (Trunc n A)
  Trunc-trunc {n = n}{k} = truncation-instance n (Trunc.â—‹âˆˆS) {k}
  {-# INCOHERENT Trunc-trunc #-}

-- module TruncDo where
--   open Trunc

--   open Universal

-- instance opaque
--   Universal-â—‹ : âˆ€ {ğ“¤ ğ“¦} {A : Type ğ“¤} {n} {P : Trunc n A â†’ Type ğ“¤}
--                â†’ â¦ƒ _ : âˆ€ {a} â†’ Is-truncated n (P a) â¦„
--                â†’ â¦ƒ _ : Universal ((a : A) â†’ P (Trunc.Î· a)) ğ“¦ â¦„
--                â†’ Universal ((a : Trunc n A) â†’ P a) ğ“¦
--   Universal-â—‹ â¦ƒ t â¦„ â¦ƒ u â¦„ .Universal.methods
--     = u .Universal.methods
--   Universal-â—‹ .Universal.from
--     = Trunc.ind (Î» _ â†’ trunc!) âˆ˜ ind!
--   Universal-â—‹  â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.from-is-equiv
--     = ieq where
--     opaque
--       ieq : is-equiv (Trunc.ind (Î» _ â†’ trunc!) âˆ˜ ind!)
--       ieq = is-equiv-âˆ˜ (Trunc.ind-is-equiv (Î» _ â†’ trunc!)) (u .Universal.from-is-equiv)

--     Universal-â—‹ â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.methods = u .methods
--     Universal-â—‹ {n = n} â¦ƒ mod â¦„ â¦ƒ u â¦„ .Universal.from
--        = ind' n (is-trunc! n) âˆ˜ u .from
--     Universal-â—‹ {n = n} â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.from-is-equiv
--       = is-equiv-âˆ˜ (ind'-is-equiv n) (u .from-is-equiv)

-- It can't figure this out
-- _>>=_ : âˆ€ {ğ“¤} {A : Type ğ“¤}{n} {B : Type ğ“¤}
--           â¦ƒ _ : âˆ€ {k} â†’ Is-truncated (n + k) B â¦„
--         â†’ (Trunc n A)
--         â†’ (A â†’ B)
--         â†’ B
-- _>>=_ {n = n}{B = B} â¦ƒ t â¦„ x f
--   = Trunc.untrunc (t {0} .has-is-truncated) (Trunc.ind (Î» _ â†’ Trunc.â—‹âˆˆS) (Trunc.Î· âˆ˜ f) x)

-- return : âˆ€ {ğ“¤} {A : Type ğ“¤} {n} â†’ A â†’ Trunc n A
-- return = Trunc.Î·


module _ {ğ“¤} {A : Type ğ“¤} â¦ƒ _ : âˆ€ {k} â†’ Is-truncated (suc (suc k)) A â¦„ where
  _ : is-truncated 3 A
  _ = trunc!

  _ : âˆ€ {x y : A} â†’ is-truncated 1 (x ï¼ y)
  _ = trunc!

  _ : is-truncated 2 (A â†’ A)
  _ = trunc!

  _ : âˆ€ {f g : S 5 â†’ A} â†’ is-truncated 1 (f ~ g)
  _ = trunc!

  _ : is-truncated 1 (A â†’ Trunc 1 (S 5))
  _ = trunc!
}
%```
}
