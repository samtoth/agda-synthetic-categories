\title{Spine lifting}
\taxon{Module}
\date{2026-01-24}
\author{samueltoth}

\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.SpineLifting
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Separated
open import Modalities.Instances.Truncation

open import Data.Bool

open import Core.CanonicalPushouts
open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.CosliceOrthogonality
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.PushoutProduct
open import Core.FunctorialPullback
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.CoSlice
open import Core.Slice
open import Core.Cube
open import Core.ArrowEquiv
open import Core.ArrowRetract
open import Core.FlatteningPushouts
open import Core.Join

open import Ergonomics.Notations.Orthogonality
open Core.Orthogonal.notation
open import Ergonomics.Extensionality
open import Ergonomics.Representation
open import Ergonomics.Auto

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
}
%```


\subtree[tot-0000]{
\title{Bi-pointed wedge sum}
\taxon{Definition}

%```agda
\agda{
âˆ‚Î”Â¹-Wedge : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
              (a : Î´Î”Â¹ â†’ A) (b : Î´Î”Â¹ â†’ B)
            â†’ Î£[ X âˆ¶ Type (ğ“¤ âŠ” ğ“¥) ] (Î´Î”Â¹ â†’ X)
âˆ‚Î”Â¹-Wedge {A = A} {B} a b .fst = Pushout {A = ğŸ™} (Î» _ â†’ a Î´Î”Â¹-1) (Î» _ â†’ b Î´Î”Â¹-0)
âˆ‚Î”Â¹-Wedge {A = A} {B} a b .snd = Î´Î”Â¹-UPâ†’ (Î¹â‚ (a Î´Î”Â¹-0) , Î¹â‚‚ (b Î´Î”Â¹-1))
-- (mk-lift true)  = Î¹â‚ (a Î´Î”Â¹-0)
-- âˆ‚Î”Â¹-Wedge {A = A} {B} a b .snd (mk-lift false) = Î¹â‚‚ (b Î´Î”Â¹-1)

âˆ‚Î”Â¹-Wedge-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {A' : Type ğ“¦} {B' : Type ğ“œ}
      (a : Î´Î”Â¹ â†’ A) (b : Î´Î”Â¹ â†’ B) (a' : Î´Î”Â¹ â†’ A') (b' : Î´Î”Â¹ â†’ B')
    â†’ Coslice-map a a' â†’ Coslice-map b b'
    â†’ Coslice-map (âˆ‚Î”Â¹-Wedge a b .snd) (âˆ‚Î”Â¹-Wedge a' b' .snd)
âˆ‚Î”Â¹-Wedge-map a b a' b' F G .fst
  = Pushoutâ‚
      (mk-span-map
        (F .fst) id (G .fst)
        (Î» _ â†’ F .snd Î´Î”Â¹-1)
        (Î» _ â†’ G .snd Î´Î”Â¹-0))
âˆ‚Î”Â¹-Wedge-map a b a' b' F G .snd (mk-lift true)
  = ap Î¹â‚‚ (G .snd Î´Î”Â¹-1)
âˆ‚Î”Â¹-Wedge-map a b a' b' F G .snd (mk-lift false)
  = ap Î¹â‚ (F .snd Î´Î”Â¹-0)

Wedge : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â†’ B â†’ Type (ğ“¤ âŠ” ğ“¥)
Wedge a b = Pushout (const _ ğŸ™ a) (const _ ğŸ™ b)
{-# NOINLINE Wedge #-}

Wedge-embed
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
    â†’ Wedge a b â†’ A Ã— B
Wedge-embed {a = a} {b = b}
  = cogap (mk-cocone
      (Î» a' â†’ (a' , b))
      (Î» b' â†’ (a , b'))
      ~refl)

Wedge-fibre
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
    â†’ âˆ€ x y â†’ fibre (Wedge-embed {a = a}{b}) (x , y) â‰ƒ ((b ï¼ y) * (a ï¼ x))
Wedge-fibre {ğ“¤} {ğ“¥} {a = a}{b} x y
  = fibre Wedge-embed (x , y) â‰ƒâŸ¨ cogap-fibre _ (x , y) âŸ©
    Pushoutâ‚€ total-fibre-span â‰ƒâŸ¨ coeâ‰ƒ (ap Pushoutâ‚€
                                      (sym (ext! (span-map , span-map-eqv)))) âŸ©
    Pushoutâ‚€ intended-span    â‰ƒâŸ¨âŸ©
    (ULift ğ“¤ (b ï¼ y) * ULift ğ“¥ (a ï¼ x))
                              â‰ƒâŸ¨ mkâ‰ƒ _
                                  (is-equivâ†qiso
                                    (Pushout-qiso span-qisoâ†’ span-qiso)) âŸ©
    ((b ï¼ y) * (a ï¼ x))     â‰ƒâˆ where

  total-fibre-span : Span (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥)
  total-fibre-span = total-span (const _ ğŸ™ a) (const _ ğŸ™ b)
                       (Fibre-family _ (x , y))

  intended-span : Span (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥)
  intended-span .Span.Centre = ULift ğ“¤ (b ï¼ y) Ã— ULift ğ“¥ (a ï¼ x)
  intended-span .Span.Left = ULift ğ“¤ (b ï¼ y)
  intended-span .Span.left = fst
  intended-span .Span.Right = ULift ğ“¥ (a ï¼ x)
  intended-span .Span.right = snd

  span-qisoâ†’ : Span-map  intended-span (mk-span ((b ï¼ y) Ã— (a ï¼ x)) fst snd)
  span-qisoâ†’ .Span-map.hâ‚ = unlift
  span-qisoâ†’ .Span-map.hâ‚‚ = unlift âŠ— unlift
  span-qisoâ†’ .Span-map.hâ‚ƒ = unlift
  span-qisoâ†’ .Span-map.H = ~refl
  span-qisoâ†’ .Span-map.K = ~refl

  span-qiso : Span-quasi-iso span-qisoâ†’
  span-qiso .Span-quasi-iso.bwd .Span-map.hâ‚ = mk-lift
  span-qiso .Span-quasi-iso.bwd .Span-map.hâ‚‚ = mk-lift âŠ— mk-lift
  span-qiso .Span-quasi-iso.bwd .Span-map.hâ‚ƒ = mk-lift
  span-qiso .Span-quasi-iso.bwd .Span-map.H = ~refl
  span-qiso .Span-quasi-iso.bwd .Span-map.K = ~refl
  span-qiso .Span-quasi-iso.Îµ = Span-map-homotopy-refl _
  span-qiso .Span-quasi-iso.Î· = Span-map-homotopy-refl _

  opaque
    span-map : Span-map intended-span total-fibre-span
    span-map .Span-map.hâ‚ p = (x , Ã—-pathâ†’ (refl , unlift p))
    span-map .Span-map.hâ‚‚ p = (tt , Ã—-pathâ†’ (Ã—-swapâ†’ ((unlift âŠ— unlift) p)))
    span-map .Span-map.hâ‚ƒ p = (y , Ã—-pathâ†’ (unlift p , refl))
    span-map .Span-map.H (mk-lift refl , mk-lift refl)
      = Î£-pathâ†’ (refl , sym (IdP-funcâ†Square (sym (glue tt)) refl refl
          (Square-degen-hor _ _
            ( ap-sym Wedge-embed (glue tt)
            âˆ™ ap sym (pushout-rec-apÎ² _)
            âˆ™ sym (ap-const (sym (glue tt)))))))
    span-map .Span-map.K (mk-lift refl , mk-lift refl) = refl

    span-map-eqv : is-Span-equiv span-map
    span-map-eqv .fst
      = is-equiv-âˆ˜
          (is-total-equivâ†is-fibrewise-equiv (Î» x â†’ Ã—-path ._â‰ƒ_.has-is-eqv))
          ((mkâ‰ƒ _ (is-equivâ»Â¹ lift-is-equiv) âˆ™â‰ƒ Î£-ï¼singl eâ»Â¹) ._â‰ƒ_.has-is-eqv)
    span-map-eqv .snd .fst
      = (Ã—-swap âˆ™â‰ƒ mkâ‰ƒ _ (is-equivâ»Â¹ (âŠ—-is-equiv lift-is-equiv lift-is-equiv))
        âˆ™â‰ƒ Ã—-path âˆ™â‰ƒ Î£-singl ğŸ™-is-singleton tt eâ»Â¹)._â‰ƒ_.has-is-eqv
    span-map-eqv .snd .snd
      = is-equiv-âˆ˜
          (is-total-equivâ†is-fibrewise-equiv (Î» x â†’ Ã—-path ._â‰ƒ_.has-is-eqv))
          ((mkâ‰ƒ _ (is-equivâ»Â¹ lift-is-equiv)
           âˆ™â‰ƒ Î£-ï¼singl eâ»Â¹ âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» aâ‚ â†’ Ã—-swap)) ._â‰ƒ_.has-is-eqv)

Wedge-is-set
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
    â†’ is-truncated 2 A â†’ is-truncated 2 B â†’ is-truncated 2 (Wedge a b)
Wedge-is-set {A = A}{B}{a}{b} as bs = Trunc.is-truncatedâ†equiv
  ((Î£[ (x , y) âˆ¶ A Ã— B ] ((b ï¼ y) * (a ï¼ x)))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (_eâ»Â¹ âˆ˜ uncurry Wedge-fibre) âŸ©
   (Î£[ x âˆ¶ A Ã— B ] fibre Wedge-embed x) â‰ƒâŸ¨âŸ©
   total-fibre Wedge-embed â‰ƒâŸ¨ totalâ‰ƒtotal-fibre Wedge-embed âŸ©
   Wedge a b â‰ƒâˆ)
  (Trunc.Î£-is-truncated
    trunc!
    (Î» _ â†’ suc-is-truncated 1
            (is-truncatedâ†is-prop
              (*-is-prop
                (is-propâ†is-truncated trunc!)
                (is-propâ†is-truncated trunc!)))))
  where instance
    at : Is-truncated 2 A
    at .Is-truncated.has-is-truncated = as
    bt : Is-truncated 2 B
    bt .Is-truncated.has-is-truncated = bs

instance
  Wedge-Is-set
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
        â¦ƒ _ : Is-truncated 2 A â¦„ â¦ƒ _ : Is-truncated 2 B â¦„
      â†’ Is-truncated 2 (Wedge a b)
  Wedge-Is-set .Is-truncated.has-is-truncated = Wedge-is-set trunc! trunc!
}
%```
}

\subtree[tot-0001]{
\title{The #{n}-spine}
\taxon{Definition}

%```agda
\agda{
Spine-coslice : â„• â†’ Î£[ X âˆ¶ Type ğ“˜ ] (Î´Î”Â¹ â†’ X)
Spine-coslice zero = (ULift ğ“˜ ğŸ™ , mk-lift âˆ˜ !)
Spine-coslice (suc zero) = (Î”Â¹ , Î´Î”Â¹-incl)
Spine-coslice (suc (suc n)) = âˆ‚Î”Â¹-Wedge (Spine-coslice (suc n) .snd) Î´Î”Â¹-incl

Spine : â„• â†’ Type ğ“˜
Spine = fst âˆ˜ Spine-coslice

spine-agrees-[2,1]-horn : Spine-coslice 2 .snd ~ Î´Î›[2,1]-incl
spine-agrees-[2,1]-horn = Î´Î”Â¹-UPâ†’ (refl , refl)


Spine-is-set : âˆ€ {n} â†’ is-truncated 2 (Spine n)
Spine-is-set {zero} = trunc!
Spine-is-set {suc zero} = trunc!
Spine-is-set {suc (suc n)} = Wedge-is-set (Spine-is-set {suc n}) trunc!

-- Don't add n = 1 and 2 as instances
-- instance
--   Spine-Is-set : âˆ€ {n k} â†’ Is-truncated (k + 2) (Spine (n + 2))
--   Spine-Is-set {n} = truncation-instance 2 (Spine-is-set {n + 2})


Spine-incl-â–¡ : âˆ€ {n} â†’ Spine n â†’ â–¡^ n
Spine-incl-â–¡ {zero} = id
Spine-incl-â–¡ {suc zero} = id
Spine-incl-â–¡ {suc (suc n)} = (Spine-incl-â–¡ âŠ—1 Î”Â¹) âˆ˜ Wedge-embed

Spine-subtype : âˆ€ {n} â†’ Subtype (â–¡^ n) ğ“˜
Spine-subtype {zero} = ULift-subtype ğ“˜ (SubtypeLattice.âŠ¤ _)
Spine-subtype {suc zero} = ULift-subtype ğ“˜ (SubtypeLattice.âŠ¤ _)
Spine-subtype {suc (suc n)} .Subtype.family (i , j)
  = (i âˆˆ Spine-subtype) * (j ï¼ i0)
Spine-subtype {suc (suc n)} .Subtype.has-is-subtype (i , j)
  = *-is-prop (âˆˆ-is-prop Spine-subtype i)
              (is-propâ†is-truncated trunc!)
}
%```
}

%```agda
\agda{
is-inner-anodyne : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ TypeÏ‰
is-inner-anodyne f = âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (k : A â†’ B)
                      â†’ Î›[2,1]-incl âŠ¥ k â†’ f âŠ¥ k

is-inner-anodyne-homotopy
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B} â†’ f ~ g
    â†’ is-inner-anodyne f â†’ is-inner-anodyne g
is-inner-anodyne-homotopy H fia k o = left-orthogonal-homotopy k H (fia k o)

is-inner-anodyne-cancelr
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {f : B â†’ C} {g : A â†’ B}
    â†’ is-inner-anodyne (f âˆ˜ g) â†’ is-inner-anodyne g â†’ is-inner-anodyne f
is-inner-anodyne-cancelr fgia gia k ko
  = left-orthogonal-right-cancel (gia k ko) (fgia k ko)

is-inner-anodyne-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {f : B â†’ C} {g : A â†’ B}
    â†’ is-inner-anodyne f â†’ is-inner-anodyne g â†’ is-inner-anodyne (f âˆ˜ g)
is-inner-anodyne-âˆ˜ fia gia k ko
  =  left-orthogonal-âˆ˜ _ _ _ (fia k ko) (gia k ko)

wedge-map-is-inner-anodyne
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {A' : Type ğ“¦} {B' : Type ğ“œ}
      (a : Î´Î”Â¹ â†’ A) (b : Î´Î”Â¹ â†’ B) (a' : Î´Î”Â¹ â†’ A') (b' : Î´Î”Â¹ â†’ B')
      (F : Coslice-map a a') (G : Coslice-map b b')
    â†’ is-inner-anodyne (F .fst) â†’ is-inner-anodyne (G .fst)
    â†’ is-inner-anodyne (âˆ‚Î”Â¹-Wedge-map _ _ _ _ F G .fst)
wedge-map-is-inner-anodyne a b a' b' F G fia gia {A = U} {V} k ik
  = left-orthogonal-pushoutâ‚
      (extend-coslice-map _ _ (const _ _ Î´Î”Â¹-1) F )
      (extend-coslice-map _ _ (const _ _ Î´Î”Â¹-0) G)
      k
      (fia  k ik)
      (gia k ik)
}
%```


%```agda
\agda{
incl-mid : âˆ€ n â†’ â–¡^ n Ã— Î›[2,1] â†’ â–¡^ n Ã— Î”Â²
incl-mid n = (â–¡^ n) 1âŠ— Î›[2,1]-incl

data Î”^_ : (n : â„•) â†’ Type ğ“˜
last-Î” : âˆ€ {n} â†’ Î”^ n â†’ Î”Â¹

data Î”^_ where
  Â· : Î”^ 0
  _â‰¥,_ : âˆ€ {n} â†’ (i : Î”^ n) â†’ (j : Î”Â¹) â†’ â¦ƒ j â‰¤ last-Î” i â¦„ â†’ Î”^ (suc n)

infixl 5 _â‰¥,_

last-Î” Â· = i1
last-Î” (x â‰¥, j) = j

data Î”-path : {n : â„•} â†’ Î”^ n â†’ Î”^ n â†’ Type ğ“˜ where
  Â· : Î”-path Â· Â·
  _â‰¥,_ : âˆ€ {n} {x x' : Î”^ n} {i i' : Î”Â¹} {p : i â‰¤ last-Î” x}
           { q : i' â‰¤ last-Î” x' } â†’ Î”-path x x' â†’ i ï¼ i'
         â†’ Î”-path ((x â‰¥, i) â¦ƒ p â¦„) ((x' â‰¥, i') â¦ƒ q â¦„)

Î”-refl : âˆ€ {n} {p : Î”^ n} â†’ Î”-path p p
Î”-refl {p = Â·} = Â·
Î”-refl {p = p â‰¥, j} = Î”-refl â‰¥, refl

Î”-suc : âˆ€ {n} â†’ (Î”^ suc n) â‰… (Î£[ x âˆ¶ (Î”^ n)] Î£[ y âˆ¶ Î”Â¹ ] (y â‰¤ last-Î” x))
Î”-suc ._â‰…_.fwd (x â‰¥, j) = (x , j , auto!)
Î”-suc ._â‰…_.fwd-iso .fst (x , j , p) = (x â‰¥, j) â¦ƒ p â¦„
Î”-suc ._â‰…_.fwd-iso .snd .fst (x â‰¥, j) = refl
Î”-suc ._â‰…_.fwd-iso .snd .snd = ~refl

Î”-path-suc
  : âˆ€ {n} {a b : Î”^ n} {i j : Î”Â¹} â¦ƒ p : i â‰¤ last-Î” a â¦„ â¦ƒ q : j â‰¤ last-Î” b â¦„
    â†’ Î”-path (a â‰¥, i) (b â‰¥, j) â‰… (Î”-path a b Ã— (i ï¼ j))
Î”-path-suc ._â‰…_.fwd (x â‰¥, p) = (x , p)
Î”-path-suc ._â‰…_.fwd-iso .fst (x , p) = (x â‰¥, p)
Î”-path-suc ._â‰…_.fwd-iso .snd .fst (x â‰¥, p) = refl
Î”-path-suc ._â‰…_.fwd-iso .snd .snd = ~refl


opaque
  Î”-path-is-torsorial
    : âˆ€ {n} (a : Î”^ n) â†’ is-singleton (Î£ (Î”^ n) (Î”-path a))
  Î”-path-is-torsorial Â· = mk-singl (Â· , Â·) (Î» { (Â· , Â·) â†’ refl})
  Î”-path-is-torsorial {suc n} (a â‰¥, j)
    = is-singleâ†equiv-to-single
        (  (Î£-ap-â‰ƒ (Î» where (x â‰¥, i) â†’ equivâ†qiso Î”-path-suc)
        âˆ™â‰ƒ Î£-ap-â‰ƒ-fst (equivâ†qiso (Î”-suc {n}))) eâ»Â¹)
        (is-singleton-structureâ†parts
          (Î”-path-is-torsorial a)
          (a , Î”-refl)
          (is-singleâ†equiv-to-single
            (remove-singleton-structure
              Sing-is-singleton
              (j , refl) eâ»Â¹)
            (mk-singl auto! (â‰¤-is-prop auto!))))

instance
  Î”-IdS : âˆ€ {n} â†’ Identity-system (Î”^ n) ğ“˜
  Î”-IdS .Identity-system.IdS = Î”-path
  Î”-IdS .Identity-system.IdSâ†Id refl = Î”-refl
  Î”-IdS .Identity-system.has-is-ids a
    = fundamental-Id _ (Î”-path-is-torsorial a) _

Î”-ext : âˆ€ {n} {p q : Î”^ n} â†’ Î”-path p q â†’ p ï¼ q
Î”-ext = ext!

Î”-path-is-prop : âˆ€ {n} {a b : Î”^ n} â†’ is-prop (Î”-path a b)
Î”-path-is-prop Â· Â· = refl
Î”-path-is-prop (p â‰¥, q) (r â‰¥, s)
  = apâ‚‚ _â‰¥,_ (Î”-path-is-prop p r) (is-propâ†is-truncated trunc! _ _)

opaque
  unfolding is-n-separated
  Î”-is-set : âˆ€ {n} â†’ is-truncated 2 (Î”^ n)
  Î”-is-set {n} _ _ = Trunc.is-truncatedâ†equiv
                       (ext!â‰ƒ â¦ƒ Î”-IdS â¦„ eâ»Â¹)
                       (is-truncatedâ†is-prop (Î”-path-is-prop))
instance
  Î”-Is-set : âˆ€ {n k} â†’ Is-truncated (k + 2) (Î”^ n)
  Î”-Is-set = truncation-instance 2 Î”-is-set

â–¡â†Î” : âˆ€ {n} â†’ Î”^ n â†’ â–¡^ n
â–¡â†Î” Â· = _
â–¡â†Î” (Â· â‰¥, j) = j
â–¡â†Î” (x â‰¥, i â‰¥, j) = â–¡â†Î” (x â‰¥, i) , j

lmap : âˆ€ {n} â†’ Î”^ (n + 2) â†’ â–¡^ n Ã— Î”Â²
lmap (x â‰¥, i â‰¥, j) = â–¡â†Î” x , (i , j)

Î”â†â–¡ : âˆ€ {n} â†’ â–¡^ n â†’ Î”Â¹ â†’ Î”^ n
Î”â†â–¡-â‰¤ : âˆ€ {n} (x : â–¡^ n) i â†’ i â‰¤ last-Î” (Î”â†â–¡ x i)

Î”â†â–¡ {zero} x j = Â·
Î”â†â–¡ {suc zero} x j = Â· â‰¥, x âˆ¨ j
Î”â†â–¡ {suc (suc n)} (x , i) j = (Î”â†â–¡ x (i âˆ¨ j) â‰¥, i âˆ¨ j) â¦ƒ Î”â†â–¡-â‰¤ x (i âˆ¨ j) â¦„

Î”â†â–¡-â‰¤ {zero} x i = auto!
Î”â†â–¡-â‰¤ {suc zero} x i = âˆ¨-â‰¤-intror auto!
Î”â†â–¡-â‰¤ {suc (suc n)} x i = âˆ¨-â‰¤-intror auto!

ret-lmap : âˆ€ {n} â†’ â–¡^ n Ã— Î”Â² â†’ Î”^ (n + 2)
ret-lmap (x , (i , j)) = ((Î”â†â–¡ x i â‰¥, i) â¦ƒ Î”â†â–¡-â‰¤ x i â¦„ â‰¥, j)

is-ret' : âˆ€ {n} (p : Î”^ n) i â¦ƒ k : i â‰¤ last-Î” p â¦„ â†’ Î”-path (Î”â†â–¡ (â–¡â†Î” p) i) p
is-ret' Â· i = Â·
is-ret' (Â· â‰¥, j) i = Â· â‰¥, âˆ¨-comm âˆ™ â‰¤-max auto!
is-ret' (p â‰¥, i â‰¥, j) k
  = is-ret' (p â‰¥, i) (j âˆ¨ k) â¦ƒ âˆ¨-UP (auto! , (â‰¤-trans {b = j}auto! auto!)) â¦„
  â‰¥, (âˆ¨-comm âˆ™ â‰¤-max auto!)

is-ret-lmap : âˆ€ {n} â†’ ret-lmap {n} âˆ˜ lmap ~ id
is-ret-lmap (p â‰¥, i â‰¥, j) = Î”-ext (is-ret' p i â‰¥, refl â‰¥, refl)

Î”-1 : âˆ€ {n} â†’ Î”^ n

Î”-1-â‰¤ : âˆ€ {i n} â†’ i â‰¤ last-Î” {n} (Î”-1)

Î”-1 {zero} = Â·
Î”-1 {suc n} = (Î”-1 â‰¥, i1) â¦ƒ Î”-1-â‰¤ {i1} {n} â¦„

Î”-1-â‰¤ {i} {zero} = auto!
Î”-1-â‰¤ {i} {suc n} = auto!

Î”-0 : âˆ€ {n} â†’ Î”^ n
Î”-0 {zero} = Â·
Î”-0 {suc n} = (Î”-0 â‰¥, i0)

âˆ‚Î”^_ : âˆ€ n â†’ Î´Î”Â¹ â†’ Î”^ n
(âˆ‚Î”^ n) (mk-lift true) = Î”-1
(âˆ‚Î”^ n) (mk-lift false) = Î”-0

incl-GWB2 : âˆ€ n â†’ âˆ‚Î”Â¹-Wedge (âˆ‚Î”^ n) Î´Î”Â¹-incl .fst â†’ Î”^ (suc n)
incl-GWB2 n = cogap (mk-cocone (Î» x â†’ x â‰¥, i0) (Î» i â†’ (Î”-1 â‰¥, i)â¦ƒ Î”-1-â‰¤ {n = n} â¦„)
                    Î» a â†’ Î”-ext (Î”-refl â‰¥, refl))

Î”â†â–¡-1 : âˆ€ {n} (x : â–¡^ n) {i} â†’ (i ï¼ i1) â†’ Î”-path (Î”â†â–¡ x i) Î”-1
Î”â†â–¡-1 {zero} x _ = Â·
Î”â†â–¡-1 {suc zero} x refl = Â· â‰¥, (â‰¤-max auto!)
Î”â†â–¡-1 {suc (suc n)} (x , i) refl
  = Î”â†â–¡-1 {suc n} x (â‰¤-max auto!) â‰¥, (â‰¤-max auto!)

amap2 : âˆ€ n â†’ Arrow-map (incl-GWB2 (suc n)) (incl-mid n)
amap2 n .Arrow-map.top = cogap
  (mk-cocone
    (Î» { (x â‰¥, i) â†’ (â–¡â†Î” x , Î¹â‚ i)})
    (Î» i â†’ â–¡â†Î” Î”-1 , Î¹â‚‚ i)
    Î» a â†’ Ã—-pathâ†’ (refl , glue tt))
amap2 n .Arrow-map.bot = lmap
amap2 n .Arrow-map.comm = pushout-ind _
  (mk-coconeD
    (Î» { (x â‰¥, j) â†’ refl})
    ~refl
    Î» _ â†’ is-setâ†is-truncated
            (Trunc.Ã—âˆˆS (â–¡-is-set trunc!) Î”Â²-is-set)
            _ _ _ _)

amap2-ret : âˆ€ n â†’ retract-arrow-map (amap2 n)
amap2-ret n .fst .Arrow-map.top = uncurry (Î» x â†’ cogap
  (mk-cocone
    (Î» i â†’ Î¹â‚ ((Î”â†â–¡ x i â‰¥, i) â¦ƒ Î”â†â–¡-â‰¤ x i â¦„))
    (Î» i â†’ Î¹â‚‚ i)
    Î» _ â†’ ap Î¹â‚ (Î”-ext (Î”â†â–¡-1 x refl â‰¥, refl)) âˆ™ glue tt))
amap2-ret n .fst .Arrow-map.bot = ret-lmap
amap2-ret n .fst .Arrow-map.comm = uncurry (Î» x â†’ pushout-ind _
  (mk-coconeD
    ~refl
    (Î» i â†’ Î”-ext (Î”â†â–¡-1 x refl â‰¥, refl â‰¥, refl))
    Î» _ â†’ prop!))
amap2-ret n .snd .fst = pushout-ind _
  (mk-coconeD
    (Î» { (l â‰¥, j) â†’ ap Î¹â‚ (Î”-ext ((is-ret' {n} l j) â‰¥, refl))})
    ~refl
    Î» _ â†’ prop!)
amap2-ret n .snd .snd .fst = is-ret-lmap
amap2-ret n .snd .snd .snd x = prop!


incl-mid-inner-anodyne : âˆ€ {n} â†’ is-inner-anodyne (incl-mid n)
incl-mid-inner-anodyne k = left-orthogonal-Ã— id Î›[2,1]-incl k (idâŠ¥ k)

Lemma1 : âˆ€ {n} â†’ is-inner-anodyne (incl-GWB2 (suc n))
Lemma1 {n} f finn
  = left-orthogonal-retract
      (incl-GWB2 (suc n)) _
      (amap2 n) (amap2-ret n)
      f (incl-mid-inner-anodyne f finn)


Spine-incl : âˆ€ {n} â†’ Spine n â†’ Î”^ n
Spine-top : âˆ€ {n} â†’ Î”-path (Spine-incl (Spine-coslice n .snd Î´Î”Â¹-1)) (Î”-1 {n})

Spine-incl {zero} s = Â·
Spine-incl {suc zero} i = (Â· â‰¥, i)
Spine-incl {suc (suc n)} = cogap
  (mk-cocone
    (Î» s â†’ Spine-incl s â‰¥, i0)
    (Î» i â†’ Î”-1 â‰¥, i)
    Î» _ â†’ Î”-ext (Spine-top â‰¥, refl))

Spine-top {zero} = Â·
Spine-top {suc zero} = Â· â‰¥, refl
Spine-top {suc (suc n)} = Î”-refl â‰¥, refl â‰¥, refl

Spine-bot : âˆ€ {n} â†’ Î”-path (Spine-incl (Spine-coslice n .snd Î´Î”Â¹-0)) (Î”-0 {n})
Spine-bot {zero} = Â·
Spine-bot {suc zero} = Â· â‰¥, refl
Spine-bot {suc (suc zero)} = Â· â‰¥, refl â‰¥, refl
Spine-bot {suc (suc (suc n))} = Spine-bot â‰¥, refl â‰¥, refl

âˆ‚Î”Â¹-Spine-incl : âˆ€ n â†’ Coslice-map (Spine-coslice n .snd) (âˆ‚Î”^ n)
âˆ‚Î”Â¹-Spine-incl n .fst = Spine-incl
âˆ‚Î”Â¹-Spine-incl n .snd (mk-lift true ) = Î”-ext Spine-top
âˆ‚Î”Â¹-Spine-incl n .snd (mk-lift false) = Î”-ext Spine-bot

inter-map : âˆ€ n â†’ Spine (suc n) â†’ âˆ‚Î”Â¹-Wedge (âˆ‚Î”^ n) Î´Î”Â¹-incl .fst
inter-map zero i = Î¹â‚‚ i
inter-map (suc n) = âˆ‚Î”Â¹-Wedge-map
                        (Spine-coslice (suc n) .snd) Î´Î”Â¹-incl
                        (âˆ‚Î”^ (suc n)) Î´Î”Â¹-incl
                        (Spine-incl ,
                        (Î» {
                          (mk-lift true ) â†’ Î”-ext Spine-top
                        ; (mk-lift false) â†’ Î”-ext Spine-bot}))
                        (id , ~refl) .fst

factorisation : âˆ€ n â†’ incl-GWB2 n âˆ˜ inter-map n ~ Spine-incl {suc n}
factorisation zero = ~refl
factorisation (suc n) = pushout-rec-unique _ _
  ~refl ~refl Î» _ â†’ prop!

Î”â†Î”Â² : Î”Â² â†’ Î”^ 2
Î”â†Î”Â² (i , j) = (Â· â‰¥, i â‰¥, j)

Î”â†Î”Â²-is-equiv : is-equiv Î”â†Î”Â²
Î”â†Î”Â²-is-equiv = is-equivâ†qiso
  ( (Î» { (Â· â‰¥, i â‰¥, j) â†’ (i , j) })
  , (Î» { (i , j) â†’ refl})
  , Î» { (Â· â‰¥, i â‰¥, j) â†’ Î”-ext (Â· â‰¥, refl â‰¥, refl)})

opaque
  Spine-lifting : âˆ€ n â†’ is-inner-anodyne (Spine-incl {suc (suc n)})
  Spine-lifting zero k ko
    = left-orthogonal-equiv
       Î›[2,1]-incl Spine-incl
       (mk-amap id (Î» where (i , j) â†’ Â· â‰¥, i â‰¥, j)
       (pushout-ind _
         (mk-coconeD ~refl ~refl
           (Î» _ â†’ prop!))))
       (id-is-equiv , Î”â†Î”Â²-is-equiv)
       k ko
  Spine-lifting (suc n)
    = is-inner-anodyne-homotopy
        {f = incl-GWB2 (n + 2) âˆ˜ inter-map (n + 2)}
        {g = Spine-incl}
        (factorisation (n + 2))
        (is-inner-anodyne-âˆ˜
          {f = incl-GWB2 (n + 2)}
          {g = inter-map (n + 2)}
          Lemma1
          (wedge-map-is-inner-anodyne
            (Spine-coslice (suc (suc n)) .snd) Î´Î”Â¹-incl
            (âˆ‚Î”^ (n + 2)) Î´Î”Â¹-incl
            (âˆ‚Î”Â¹-Spine-incl (n + 2))
            (id , ~refl)
            (Spine-lifting n)
            Î» k _ â†’ idâŠ¥ k))
}
%```
