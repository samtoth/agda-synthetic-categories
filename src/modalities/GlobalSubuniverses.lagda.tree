\date{2025-06-14}
\title{Global subuniverses}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb modalities.GlobalSubuniverses \stopverb}
\import{stt-macros}


\p{The developments in this module follow \citet{foundations.global-subuniverses}{agda-unimath}.}

%```agda
\agda{
module modalities.GlobalSubuniverses where

open import foundations.Prelude
open import modalities.Subuniverses
open import core.Postwhisker
open import core.PiSection
open import ergonomics.Extensionality
}
%```

\subtree[stt-007A]{
\title{Global subuniverses}

\p{A global subuniverse is a subuniverse for each #{\UU}
which is closed under equivalence. (Which hold via univalence for
a particular univalent universe but not for equivalences between
of different universes).}

% ```agda
\agda{
record GSU (α : Level → Level) : Typeω where
  constructor mk-GSU
  field
    S : ∀ {𝓤} → SubU 𝓤 (α 𝓤)
    S-equiv : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
              → A ≃ B
              → A ∈ S → B ∈ S

SubU←global : ∀ {α} → GSU α →  ∀ {𝓤} → SubU 𝓤 (α 𝓤)
SubU←global (mk-GSU s _) = s
}
%```
}

\subtree[stt-007B]{
\taxon{definition}
\title{Global reflectors}

\p{For a particular type #{A : \UU},
we say that #{(\bigcirc A, \eta : A \to \bigcirc A)} is a global
reflector for #{A} when postcomposition by #{\eta} at modal types (of any universe)
is an equivalence. This equivalence gives us a recursion principal for #{\bigcirc A}.}


%```agda
\agda{
record is-global-reflector {α} (GS : GSU α)
         {𝓤} (A : Type 𝓤)
         (○A : Type 𝓤) (η : A → ○A) : Typeω where
  constructor mk-grfltor
  open GSU GS
  field
    ○∈S : ○A ∈ S
    reflects : ∀ {𝓥} {Q : Type 𝓥}
               → Q ∈ S → is-equiv (postcomp Q η)

  ○-rec : ∀ {𝓥} {Q : Type 𝓥} → Q ∈ S → (A → Q) → (○A → Q)
  ○-rec cs = is-equiv.bwd (reflects cs)

  ○-rec-β : ∀ {𝓥} {Q : Type 𝓥} (p : Q ∈ S) (f : A → Q)
             → ○-rec p f ∘ η ~ f
  ○-rec-β p f a = happly (is-equiv.ε (reflects p) f) a

  module ∈S▸η {𝓦} {C : Type 𝓦} {g h} (C∈S : C ∈ S)
    = is-equiv (postwhisker-is-equiv←ap-compose {A = A} {g = g}{h}
                         (is-embedding←is-equiv (reflects C∈S)))

is-reflector←global : ∀ {α} {GS : GSU α} {𝓤}
                        {A : Type 𝓤} {○A : Type 𝓤} {η : A → ○A}
                      → is-global-reflector GS A ○A η
                      → let open GSU GS in is-reflector S A ○A η
is-reflector←global (mk-grfltor ○∈S reflects) = mk-is-rfltor ○∈S reflects
}
%```

\p{A global subuniverse is said to be reflective if we have all
reflectors.}

%```agda
\agda{
record is-globally-reflective {α} (GS : GSU α) : Typeω where
  constructor mk-gReflectors
  open GSU GS
  field
    ○ : ∀ {𝓤} → Type 𝓤 → Type 𝓤
    η : ∀ {𝓤} {A : Type 𝓤} → A → ○ A
    has-is-reflector : ∀ {𝓤} {A : Type 𝓤} → is-global-reflector GS A (○ A) η

  module R {𝓤} {A} = is-global-reflector (has-is-reflector {𝓤} {A})
  open R public

  module ▸η {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {g h}
    = is-equiv (postwhisker-is-equiv←ap-compose {g = g}{h}
                         (is-embedding←is-equiv (reflects {A = B} (○∈S {𝓤}{A}))))

  reflector : ∀ {𝓤} (A : Type 𝓤) → Reflector S A
  reflector A = mk-rfltor (○ A) η (is-reflector←global has-is-reflector)


reflective←global :  ∀ {α} {GS : GSU α} → is-globally-reflective GS
                     → ∀ {𝓤} → Reflective (SubU←global GS {𝓤})
reflective←global (mk-gReflectors ○ η has-is-reflector)
  = mk-reflective ○ η (is-reflector←global has-is-reflector)
}
%```
}


\subtree[stt-007C]{
\taxon{definition}
\title{Sigma closed global reflective subuniverses}


%```agda
\agda{
is-globally-Σ-closed : ∀ {α} (GS : GSU α) → Typeω
is-globally-Σ-closed (mk-GSU S _) = ∀ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥}
                                    → A ∈ S → (∀ a → B a ∈ S)
                                    → Σ A B ∈ S


}
%```
}
\subtree[stt-007D]{
\taxon{theorem}
\title{Induction for sigma closed [GRSU](stt-007C)}

\p{When a global reflective subuniverse is closed under sigma types
we can extend the recursion principal in \ref{stt-007B} to an induction
prinicipal.}

\proof{
\p{Because #{S} is closed under #{\Sigma} types, we can use the universal property
of the reflector at #{A} to define a map
#{\bar{f} : \bigcirc A \to \Sigma_{(x : \bigcirc A)} \bigcirc P(x)} just by it's action
on #{\eta(x)} for #{x : A}. This map is given by #{\eta(x) \mapsto (\eta(x), f(x))}.}

\p{To show that #{\bar{f}} is indeed a section, we first note that
the universal property of the reflector gives us #{\pi \bar{f} \eta \sim \eta}.
Then because postcomposition by #{\eta} at a modal type is an equivalence,
[so is postwhiskering](stt-006I) by #{\eta} (assuming funext), thus we can apply the
inverse map to get a homotopy #{\pi \bar{f} \sim \id}.}
}


%```agda
\agda{
module GRSUInduction {α} {GS : GSU α}
        (Sref : is-globally-reflective GS)
        (SΣ : is-globally-Σ-closed GS) where
  open GSU GS
  open is-globally-reflective Sref

  ind : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : ○ A → Type 𝓥} (P∈S : ∀ a → P a ∈ S)
        → (Π A (P ∘ η)) → Π (○ A) P
  ind {A = A} {P} ps f = Π←section (f' , ▸η.bwd secη) module ind where
    f'' : A → Σ (○ A) P
    f'' a = (η a , f a)

    f' : ○ A → Σ (○ A) P
    f' = ○-rec (SΣ ○∈S ps) f''

    secη : fst ∘ f' ∘ η ~ η
    secη = fst ◂ ○-rec-β _ _

  ind-β : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : ○ A → Type 𝓥} (P∈S : ∀ a → P a ∈ S)
        → (f : Π A (P ∘ η)) → ind P∈S f ∘ η ~ f
  ind-β {A = A} {P} PS f a
    = tr P (▸η.bwd secη (η a)) (snd (f' (η a)))
        ＝⟨ ap (λ p → tr P p (snd (f' (η a)))) (happly (▸η.ε secη) a) ⟩
      tr P (ap fst (○-rec-β _ f'' a)) (snd (f' (η a)))
        ＝⟨ ap (λ p → coe p (snd (f' (η a)))) (sym (ap-∘ P fst _)) ⟩
      tr (P ∘ fst) (○-rec-β _ f'' a) (snd (f' (η a)))
        ＝⟨ apᵈ snd (○-rec-β _ f'' a) ⟩
      snd (f'' a)
        ＝⟨⟩
      f a ∎       where open ind PS f


  ind-qiso : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : ○ A → Type 𝓥} (PS : ∀ a → P a ∈ S)
                 → quasi-iso {A = (a : A) → P (η a)} {B = (a : ○ A) → P a}
                            (ind PS)
  ind-qiso PS .fst = _∘ η
  ind-qiso PS .snd .fst f = ext! (ind-β _ f)
  ind-qiso {A = A} {P} PS .snd .snd f = ext!
    (ind (λ a → is-modal-＝ (reflective←global Sref) (PS a))
         (ind-β _ (f ∘ η)))

  ind-is-equiv : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : ○ A → Type 𝓥} (PS : ∀ a → P a ∈ S)
                 → is-equiv {A = (a : A) → P (η a)} {B = (a : ○ A) → P a}
                            (ind PS)
  ind-is-equiv = is-equiv←qiso ∘ ind-qiso
}
%```
}

%```agda
\agda{
-- module GRSUInstances {α} (GS : GSU α) (Grfl : Global-reflectors GS) where
--   open GSU GS
--   open Global-reflectors Grfl

--   record IsModal {𝓤} (A : Type 𝓤) : Type (α 𝓤) where
--     constructor mk-is-modal
--     field
--       has-is-modal : A ∈ S

--   ∈S! : ∀ {𝓤} {A : Type 𝓤} ⦃ _ : IsModal A ⦄ → A ∈ S
--   ∈S! {A = _} ⦃ mk-is-modal m ⦄ = m

--   instance opaque
--     ○-Modal : ∀ {𝓤} {A : Type 𝓤} → IsModal (○ A)
--     ○-Modal = mk-is-modal ○∈S

--     ＝-Modal : ∀ {𝓤} {A : Type 𝓤} → ⦃ IsModal A ⦄ → {a b : A} → IsModal (a ＝ b)
--     ＝-Modal ⦃ (mk-is-modal H) ⦄ = mk-is-modal (is-modal-＝ (reflectors←global Grfl) H)

--     Π-Modal : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥}
--                 ⦃ _ : ∀ {x} → IsModal (B x) ⦄
--               → IsModal (∀ x → B x)
--     Π-Modal {A = A} {B}
--       = mk-is-modal (in-SubU←η-retract (reflector _) retr) where
--       retr : retract (Reflector.η (reflector ((x : A) → B x)))
--       retr .fst f a = ○-rec ∈S! (ev a) f
--       retr .snd f = funext→ λ a → ○-rec-β ∈S! (ev a) f

--   {-# INCOHERENT  ＝-Modal #-}

--   ○-elim! : ∀ {𝓤} {A : Type 𝓤} ⦃ _ : IsModal A ⦄
--             → ○ A → A
--   ○-elim! = ○-rec ∈S! id

--   private module test where
--     test : ∀ {𝓤} {A : Type 𝓤} → ○ (○ A) → ○ A
--     test = ○-elim!


--   instance
--     Universal-○ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {P : ○ A → Type 𝓥}
--                  → ⦃ _ : ∀ {a} → IsModal (P a) ⦄
--                  → ⦃ _ : Universal ((a : A) → P (η a)) 𝓦 ⦄
--                  → Universal ((a : ○ A) → P a) 𝓦
--     Universal-○ ⦃ _ ⦄ ⦃ u ⦄ .Universal.methods = u .methods
--     Universal-○ ⦃ mod ⦄ ⦃ u ⦄ .Universal.from
--       = ind (λ _ → mod .IsModal.has-is-modal) ∘ u .from
--     Universal-○ ⦃ _ ⦄ ⦃ u ⦄ .Universal.from-is-equiv
--       = is-equiv-∘ (ind-is-equiv _) (u .from-is-equiv)




-- private
--   module test {α} {T : ∀ (n : ℕ) → GSU α}
--                      {Grf : ∀ {k} → Global-reflectors (T k)}
--                      {GΣ : ∀ {k} → is-globally-Σ-closed (T k)}
--                      {𝓤} {A : Type 𝓤}
--                      ⦃ _ : ∀ {k} → GRSUInstances.IsModal (T (suc k)) Grf A ⦄ where
--     module T n = GSU (T n)
--     open T
--     module R n = Global-reflectors (Grf {n})
--     open R
--     module I {n} = GRSUInstances (T n) Grf
--     open I
--     module In {n} = GlobalInduction {_} {T n} Grf GΣ
--     open In

--     tst : A ∈ S 1
--     tst = ∈S!

--     tst2 : ∀ {x y : A} → (x ＝ y) ∈ S 1
--     tst2 = ∈S!

--     tst3 : (A → A) ∈ S 1
--     tst3 = ∈S!

--     tst4 : ∀ {f g : 𝟙 → A} → (f ~ g) ∈ S 1
--     tst4 = ∈S!

--     tst5 : ∀ {𝓥} {B : Type 𝓥} → (f : B → A) → (x : ○ 1 B) → A
--     tst5 = ○-rec 1 ∈S!

--     tst6 : ∀ {𝓥} {B : Type 𝓥} → (f : B → A) → is-embedding f
--            → (x y : ○ 1 B) → tst5 f x ＝ tst5 f y → x ＝ y
--     tst6 f emb = ind! λ x y p → ap (η 1)
--                    (unap emb (sym (○-rec-β 1 ∈S! f x) ∙ p ∙ ○-rec-β 1 ∈S! f y))

--     postulate instance
--       ＝-suc : ∀ {𝓤} {A : Type 𝓤}
--                  {k}
--                  ⦃ _ : IsModal {suc k} A ⦄
--                → {x y : A}
--                → IsModal {k} (x ＝ y)
--     tst7 :  ∀ {x y : A} → (x ＝ y) ∈ S 0
--     tst7 = ∈S!
}
%```
