\date{2025-08-17}
\author{samueltoth}
\title{The flattening lemma for coequalisers}
\taxon{module}
\meta{module}{Core.FlatteningCoequalisers}
\import{stt-macros}

%```agda
\agda{
module Core.FlatteningCoequalisers where

open import Foundations.Prelude
open import ufAxioms

open import Core.Coequalisers
open import Core.CanonicalPushouts
open import Core.PushoutDescent
open import Core.PushoutEquiv
}
%```

\subtree[stt-009A]{
\title{Flattening for coequalisers}
\taxon{lemma}

\p{
In \ref{Core.PushoutDescent}, we showed that [pushouts preserve sigma
types](stt-stt-008D) in the sense that the total type of a family over
a pushout is given by a pushout of the total types of each component.
Here we prove an analogous theorem for coequalisers.
}

\p{Given a pair of maps #{f,g : A \to B}, and a type family #{P} over
the coequaliser of #{f} and #{g}, we define a fork at #{\tilde{P}}
over the pair of maps #{\tilde{f}, \tilde{g} : \Sigma_{(a : A)}
P(\iota(f a)) \to \Sigma{(b : B)}(P(b))}, flattening states that this
fork is a coequaliser.}

\proof{
\p{Since we defined coequalisers in terms of pushouts, we can reuse
the result we have already shown. To be precise, the coequaliser of
#{f} and #{g} is given by the following pushout:}

\quiver{
\begin{tikzcd}
	{A+B} && B \\
	\\
	B && {\rm{Coeq}_{f,g}}
	\arrow["{[f,\id]}", from=1-1, to=1-3]
	\arrow["{[g,\id]}"', from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
\end{tikzcd}
}

\p{Consider the following diagram:}

\quiver{
\begin{tikzcd}
	{\Sigma_A(P\iota g) + \Sigma_B(P\iota)} \\
	& {\Sigma_{A+B}(P\iota[g,\id])} && {\Sigma_BP\iota} \\
	\\
	& {\Sigma_B P \iota} && {\Sigma_{\rm{Coeq}_{f,g}} P}
	\arrow[from=1-1, to=2-2]
	\arrow[curve={height=-24pt}, from=1-1, to=2-4]
	\arrow["{[\rm{total}_g,id]}"', curve={height=24pt}, from=1-1, to=4-2]
	\arrow[from=2-2, to=2-4]
	\arrow["{[g,\id]}"', from=2-2, to=4-2]
	\arrow[from=2-4, to=4-4]
	\arrow[from=4-2, to=4-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=4-4, to=2-2]
\end{tikzcd}
}

\p{The flattening lemma for pushouts states that the inner square is a
pushout quare.  Then, sinse the top right map is an equivalence, we
get that the outer square is a pushout.}

}

%```agda
\agda{

module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
         (f : A â†’ B) (g : A â†’ B) where
  total-maps : âˆ€ {ğ“œ} (P : Coeq f g â†’ Type ğ“œ)
               â†’ (Î£ A (P âˆ˜ Î¹-coeq âˆ˜ g ) â†’ Î£ B (P âˆ˜ Î¹-coeq))
               Ã— (Î£ A (P âˆ˜ Î¹-coeq âˆ˜ g ) â†’ Î£ B (P âˆ˜ Î¹-coeq))
  total-maps P .fst (a , p) = (f a , tr P (sym (glue-coeq a)) p)
  total-maps P .snd = total-map-fst g

  total-cofork : âˆ€ {ğ“œ} (P : Coeq f g â†’ Type ğ“œ)
               â†’ Cofork (total-maps P .fst) (total-maps P .snd) (Î£ _ P)
  total-cofork P .fst = total-map-fst Î¹-coeq
  total-cofork P .snd (a , p) = Î£-pathâ†’ (glue-coeq a , trâˆ™tr-sym' (glue-coeq a) p)

  -- total-fork-is-coeq
  --   : âˆ€ {ğ“œ} (P : Coeq f g â†’ Type ğ“œ) â†’ is-coeq (total-fork P)
  -- total-fork-is-coeq P = {!is-coeqâ†is-pushout!}

  total-forkâ‰ƒ : âˆ€ {ğ“œ} (P : Coeq f g â†’ Type ğ“œ)
                â†’ Î£ _ P
                â‰ƒ Coeq (total-maps P .fst) (total-maps P .snd)
  total-forkâ‰ƒ P
    = Î£ (Coeq f g) P â‰ƒâŸ¨ mkâ‰ƒ _ ((cogap-is-equivâ†is-pushout _ (total-is-pushout (Coeq.l f g) (Coeq.r f g) P))) eâ»Â¹ âŸ©
      Pushout (Span.left (total-span _ _ P)) (total-map-fst (Coeq.r f g))
              â‰ƒâŸ¨ Pushout-adjust-equiv~ {f = (Span.left (total-span _ _ P))} eq H K eâ»Â¹ âŸ©
      Pushout (total-map (tr P âˆ˜ sym âˆ˜ glue âˆ˜ inl) âˆ˜ Coeq.l (total-maps P .fst) (total-maps P .snd))
              (Coeq.r (total-maps P .fst) (total-maps P .snd))
              â‰ƒâŸ¨ Pushout-vert-extendâ‰ƒ (is-total-equivâ†is-fibrewise-equiv
                    (tr-is-equiv âˆ˜ sym âˆ˜ glue âˆ˜ inl)) _ _ eâ»Â¹ âŸ©
      Coeq (total-maps P .fst) (total-maps P .snd)    â‰ƒâˆ where
    eq : Coeq.span (total-maps P .fst) (total-maps P .snd) .Span.Centre
       â‰ƒ total-span (Coeq.l f g) (Coeq.r f g) P .Span.Centre
    eq = Î£-âŠâ‰ƒ (P âˆ˜ _)

    H : total-span _ _ P .Span.left âˆ˜ _â‰ƒ_.fwd eq ~  total-map (tr P âˆ˜ sym âˆ˜ glue âˆ˜ inl) âˆ˜ Coeq.l (total-maps P .fst) (total-maps P .snd)
    H (inl x) = refl
    H (inr (a , p)) = Î£-pathâ†’ (refl ,
      sym (trâˆ™tr {P = P} (sym (glue-coeq a)) (sym (glue (inl (f a)))) p
      âˆ™ ap (Î» x â†’ tr P x p)
         (sym (sym (glue (inl (f a))) âˆ™ glue (inr a)) âˆ™ sym (glue (inl (f a)))

               ï¼âŸ¨ âˆ™-symsym _ (glue (inr a)) âŸ©âˆ™âŸ¨ refl âŸ©

         (sym (glue (inr a)) âˆ™ sym (sym (glue (inl (f a)))))
                    âˆ™ sym (glue (inl (f a)))

               ï¼âŸ¨ âˆ™.cancell _ (âˆ™-sym' (sym (glue (inl (f a))))) âŸ©

         sym (glue (inr a)) âˆ)))

    K : total-map-fst (Coeq.r f g) {P âˆ˜ Î¹â‚‚} âˆ˜ _â‰ƒ_.fwd eq ~  Coeq.r (total-maps P .fst) (total-maps P .snd)
    K (inl x) = refl
    K (inr x) = refl
}
%```
}
