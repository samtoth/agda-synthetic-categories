\date{2025-02-24}
\title{Dependent Identity Types}
\author{samueltoth}

\import{stt-macros}

% ```agda
\agda{
module Foundations.DependentIdentity where

open import Foundations.Universes
open import Foundations.Identity
open import Foundations.Functions
open import Foundations.Sigma
}
% ```


\p{Suppose we have types #{A, B : \UU}, and a path between them #{A =_\UU B}.
We want to talk about equalities between terms #{a : A} and #{b : B}, but the type #{a =_{?} b} is not well formed (what type
do we put for \em{?}).
}

\subtree{
\taxon{Example}

\def\Fin[n]{\mathbb{N}^{\n}  }

\p{Consider the type of the standard finite types indexed over natural numbers. Addition can be defined as a function
#{(x : \Fin{<m}) \to (y : \Fin{<n}) \to \Fin{<(m + n)}}. Then consider the type of #{n + 2} and #{2 + n}. The types aren't definitionally
equal but are equal up to a path (the proof of commutativity of natural number addition). }
}

\p{The indexed case is so common that it is treated as the default, and the case of identity over an identity between types
can be recovered by identity over the identity type family.}

\subtree{
\taxon{Definition}
\title{Dependent Identity}

\p{
Given:
\ul{
\li{a base type #{A : \UU}}
\li{a family #{B : A \to \UV} over A}
\li{a path #{p : a =_A b}}
\li{a term #{(x : B a)} over a}
\li{a term #{(y : B b)} over b}
}

We define the type of dependent identifications over p, written #{x =_B^p y}.
}


% ```agda
\agda{
module _ {ð“¤} {A : Type ð“¤} {B : Type ð“¤} (P : A ï¼ B) where
  IdP : A â†’ B â†’ Type ð“¤
  IdP a b = coe P a ï¼ b


IdP-syntax : âˆ€ {ð“¤} {A B : Type ð“¤} â†’ A ï¼ B â†’ A â†’ B â†’ Type ð“¤
IdP-syntax = IdP

infix 6 IdP-syntax
syntax IdP-syntax P a b = a ï¼[ P ] b

module _ {ð“¤} {A B : Type ð“¤} where

  symP : âˆ€ {P : A ï¼ B} {a} {b} â†’ IdP P a b â†’ IdP (sym P) b a
  symP {P = refl} p = sym p

  symP' : âˆ€ {P : A ï¼ B} {a} {b} â†’ IdP (sym P) b a â†’ IdP P a b
  symP' {P = refl} p = sym p

  IdP-inl : âˆ€ {P : A ï¼ B} {a : A} {b : B} â†’ coe P a ï¼ b â†’ IdP P a b
  IdP-inl {P = P} p = p

  IdP-inr :  âˆ€ {P : A ï¼ B} {a : A} {b : B} â†’ a ï¼ coe (sym P) b â†’ IdP P a b
  IdP-inr {P = refl} p = p


  IdP-right : âˆ€ {P : A ï¼ B} {a : A} {b : B}
            â†’ IdP P a b â†’ a ï¼ coe (sym P) b
  IdP-right {P = refl} p = p

IdP-refl : âˆ€ {ð“¤} {A : Type ð“¤} {P : A ï¼ A} (_ : P ï¼ refl) {a : A} â†’ IdP P a a
IdP-refl refl = refl

module _ {ð“¤} {A : Type ð“¤} where
  apáµˆ : âˆ€ {ð“¥} {B : A â†’ Type ð“¥}
           (f : (a  : A) â†’ B a)
           {a b : A}
         â†’ (p : a ï¼ b)
         â†’ IdP (ap B p) (f a) (f b)
  apáµˆ f refl = refl

  apáµˆ-is-ap : âˆ€ {ð“¥} {B : Type ð“¥}
              â†’ {f : A â†’ B}
              â†’ {a b : A}
              â†’ {p : a ï¼ b}
              â†’ apáµˆ f p ï¼[ (tr-constant _ _) âˆ™- ]  ap f p
  apáµˆ-is-ap {p = refl} = refl

apáµˆ-âˆ˜ : âˆ€ {ð“¤ ð“¥ ð“¦} {A : Type ð“¤} {A' : Type ð“¥} {B : A â†’ Type ð“¦}
          {f : Î  A B}
          {a b : A'}
          {g : A' â†’ A}
          {p : a ï¼ b}
        â†’ apáµˆ (f âˆ˜ g) p ï¼[ (trâˆ˜ B g p âˆ™-) ] apáµˆ f (ap g p)
apáµˆ-âˆ˜ {p = refl} = refl

transp-leftP : âˆ€ {ð“¤}
                 {A B : Type ð“¤} (P : A ï¼ B)
                 {a : A}  {b : B}
                 â†’ a ï¼[ P ] b â†’ {b' : B} â†’ b ï¼ b' â†’ a ï¼[ P ] b'
transp-leftP refl p q = p âˆ™ q

transIdP : âˆ€ {ð“¤} {A B C : Type ð“¤}
             (P : A ï¼ B) (Q : B ï¼ C)
             {a : A} {b : B} {c : C}
           â†’ a ï¼[ P ] b â†’ b ï¼[ Q ] c
           â†’ a ï¼[ P âˆ™ Q ] c
transIdP P Q {a} p q = sym (coeâˆ™coe P Q a) âˆ™ ap (coe Q) p âˆ™ q
{-# NOINLINE transIdP #-}

syntax transIdP P Q p q = p âˆ™[ P âˆ™ Q ] q

-- syntax transp-rightP B p q r = p âˆ™[ B âˆ£ q ] r
-- syntax transp-leftP  B p q r = q [ B âˆ£ p ]âˆ™ r
}
% ```
}

\subtree{
\title{Squares and dependent squares}



}
