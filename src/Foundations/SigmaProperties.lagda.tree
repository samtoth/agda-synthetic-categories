\date{2025-04-14}
\title{Miscellaneous properties of Sigma Types}
\taxon{Module}
\import{stt-macros}

% ```agda
\agda{
module Foundations.SigmaProperties where

open import Foundations.Universes
open import Foundations.Empty
open import Foundations.Sigma
open import Foundations.SigmaPath
open import Foundations.Identity
open import Foundations.DependentIdentity
open import Foundations.Functions
open import Foundations.QuasiIsomorphism
open import Foundations.CoherentIsomorphism
open import Foundations.Singleton
open import Foundations.EquivContrFibre
open import Foundations.EquivSingleton
open import Foundations.Coproducts
open import Foundations.Homotopy
}
% ```

% ```agda
\agda{
total-map-fst : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¥} (f : A' â†’ A)
                â†’ {B : A â†’ Type ğ“¦} â†’ Î£ A' (B âˆ˜ f) â†’ Î£ A B
total-map-fst f (a , b) = (f a , b)

total-is-equivâ†fst-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¥} {B : A â†’ Type ğ“¦}
    {f : A' â†’ A} â†’ is-equiv f â†’ is-equiv (total-map-fst f {B})
total-is-equivâ†fst-is-equiv {B = B} {f} feq = is-equivâ†qiso the-iso where
  open is-equiv feq

  lem : âˆ€ {a} {b : (B âˆ˜ f) a} â†’
      tr (B âˆ˜ f) (Î· a) (tr B (sym (Îµ (f a))) b) ï¼ b
  lem {a} {b} = tr (B âˆ˜ f ) (Î· a) _   ï¼âŸ¨ trâˆ˜ B f (Î· a) âŸ©
                tr B (ap f (Î· a)) _   ï¼âŸ¨ ap (Î» p â†’ tr B p (tr B (sym (Îµ (f a))) b))
                                             (coherent a) âŸ©
                tr B (Îµ (f a)) _      ï¼âŸ¨ trâˆ™tr-sym' {P = B} (Îµ (f a)) b âŸ©
                b âˆ

  the-iso : quasi-iso (total-map-fst f)
  the-iso .fst (a , b) = (bwd a , tr B (sym (Îµ a)) b)
  the-iso .snd .fst (a , b) = Î£-pathâ†’ (Î· a ,  lem)
  the-iso .snd .snd (a , b) = Î£-pathâ†’ (Îµ a ,  trâˆ™tr-sym' (Îµ a) b)

Î£-ap-â‰ƒ-fst : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¥} {B : A â†’ Type ğ“¦}
             â†’ ((mkâ‰ƒ f _) : A' â‰ƒ A) â†’ Î£ A' (B âˆ˜ f) â‰ƒ Î£ A B
Î£-ap-â‰ƒ-fst {A = A} {A'} {B} eq
  = mkâ‰ƒ (total-map-fst fwd) (total-is-equivâ†fst-is-equiv has-is-eqv)
  where open _â‰ƒ_ eq


Î£-assoc : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {C : (a : A) â†’ B a â†’ Type ğ“¦}
          â†’ Î£ (Î£ A B) (Î» x â†’ C (fst x) (snd x)) â‰ƒ Î£ A Î» a â†’ Î£ (B a) Î» b â†’ C a b
Î£-assoc {A = A} {B} {C} = equivâ†qiso iso where
  fwd : Î£ (Î£ A B) (Î» x â†’ C (fst x) (snd x)) â†’ Î£ A (Î» a â†’ Î£ (B a) (C a))
  fwd ((a , b) , c) = a , (b , c)

  iso : Î£ (Î£ A B) (Î» x â†’ C (fst x) (snd x)) â‰… Î£ A (Î» a â†’ Î£ (B a) (C a))
  iso ._â‰…_.fwd = fwd
  iso ._â‰…_.fwd-iso .fst (x , y , z) = (x , y) , z
  iso ._â‰…_.fwd-iso .snd .fst a = refl
  iso ._â‰…_.fwd-iso .snd .snd a = refl


Î£-singl : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
          â†’ is-singleton A
          â†’ (x : A) -- todo use @default to make it use singleton if not given
          â†’ Î£[ a âˆ¶ A ] B a
          â‰ƒ B x
Î£-singl {A = A} {B} sa x = equivâ†qiso iso where
  prp : is-prop A
  prp = is-propâ†is-single sa

  iso : Î£ A B â‰… B x
  iso ._â‰…_.fwd (a , b) = tr B (prp a x) b
  iso ._â‰…_.fwd-iso .fst b = (x , b)
  iso ._â‰…_.fwd-iso .snd .fst (a , b)
    = Î£-pathâ†’ ((prp x a) ,  IdP-inr {P = ap B (prp x a)}
              (ap (Î» p â†’ coe p b)
               (ap (ap B) (is-propâ†is-single (ï¼-singletonâ†is-prop prp _ _) _ _)
               âˆ™ ap-sym B (prp x a))))
  iso ._â‰…_.fwd-iso .snd .snd bx
    = ap (Î» p â†’ tr B p bx) (âˆ™-sym' (sa .central x))

Î£-ï¼singl : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a' : A} {B : (a : A) â†’ a ï¼ a' â†’ Type ğ“¥}
        â†’ Î£ A (Î» a â†’ Î£ (a ï¼ a') Î» p â†’ B a p) â‰ƒ B a' refl
Î£-ï¼singl {A = A} {a'} {B} = equivâ†qiso iso where
  iso : Î£ A (Î» a â†’ Î£ (a ï¼ a') (B a)) â‰… B a' refl
  iso ._â‰…_.fwd (.a' , refl , ba) = ba
  iso ._â‰…_.fwd-iso .fst ba = a' , refl , ba
  iso ._â‰…_.fwd-iso .snd .fst (.a' , refl , ba) = refl
  iso ._â‰…_.fwd-iso .snd .snd _ = refl


Î£-ï¼singl' : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a' : A} {B : (a : A) â†’ a' ï¼ a â†’ Type ğ“¥}
        â†’ Î£ A (Î» a â†’ Î£ (a' ï¼ a) Î» p â†’ B a p) â‰ƒ B a' refl
Î£-ï¼singl' {A = A} {a'} {B} = equivâ†qiso iso where
  iso : Î£ A (Î» a â†’ Î£ (a' ï¼ a) (B a)) â‰… B a' refl
  iso ._â‰…_.fwd (.a' , refl , ba) = ba
  iso ._â‰…_.fwd-iso .fst ba = a' , refl , ba
  iso ._â‰…_.fwd-iso .snd .fst (.a' , refl , ba) = refl
  iso ._â‰…_.fwd-iso .snd .snd _ = refl


Î£-comm : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : A â†’ B â†’ Type ğ“¦}
         â†’ (Î£ A Î» a â†’ Î£ B (C a)) â‰ƒ (Î£ B Î» b â†’ Î£ A Î» a â†’ C a b)
Î£-comm {A = A} {B} {C} = mkâ‰ƒ f (is-equivâ†qiso iso) where
  f : Î£ A (Î» a â†’ Î£ B (C a)) â†’ Î£ B (Î» b â†’ Î£ A (Î» a â†’ C a b))
  f (a , b , c) = b , a , c

  iso : quasi-iso f
  iso .fst (b , a , c) = a , b , c
  iso .snd .fst _ = refl
  iso .snd .snd _ = refl

Ã—-âˆ… : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ âˆ… Ã— A â‰ƒ âˆ…
Ã—-âˆ… = mkâ‰ƒ fst (is-equivâ†qiso iso) where
  iso : quasi-iso fst
  iso .fst ()
  iso .snd .fst ()
  iso .snd .snd ()


Ã—-swapâ†’ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A Ã— B â†’ B Ã— A
Ã—-swapâ†’ (a , b) = b , a

Ã—-swap : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
         â†’ (A Ã— B) â‰ƒ (B Ã— A)
Ã—-swap {A = A} {B} = mkâ‰ƒ Ã—-swapâ†’ (is-equivâ†qiso qiso)  where
  qiso : quasi-iso Ã—-swapâ†’
  qiso .fst (b , a) = (a , b)
  qiso .snd .fst (a , b) = refl
  qiso .snd .snd (b , a) = refl

Ã—-assoc
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦}
      {A : Type ğ“¤}
      {B : Type ğ“¥}
      {C : Type ğ“¦}
    â†’ (A Ã— B) Ã— C â‰ƒ A Ã— (B Ã— C)
Ã—-assoc = Î£-assoc

âŠ—-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
               {C : Type ğ“¦} {D : Type ğ“œ}
               {f : A â†’ B} {g : C â†’ D}
             â†’ is-equiv f â†’ is-equiv g
             â†’ is-equiv (f âŠ— g)
âŠ—-is-equiv {f = f}{g} feq geq = is-equivâ†qiso the-iso where
    open is-equiv
    the-iso : quasi-iso (f âŠ— g)
    the-iso .fst (b , d) = (bwd feq b , bwd geq d)
    the-iso .snd .fst (a , c) = Ã—-pathâ†’ ((Î· feq a) , (Î· geq c))
    the-iso .snd .snd (b , d) = Ã—-pathâ†’ ((Îµ feq b) , (Îµ geq d))

_Ã—â‰ƒ_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {D : Type ğ“œ}
       â†’ A â‰ƒ C â†’ B â‰ƒ D â†’ (A Ã— B) â‰ƒ (C Ã— D)
(mkâ‰ƒ f ef) Ã—â‰ƒ (mkâ‰ƒ g eg) = mkâ‰ƒ (f âŠ— g) (âŠ—-is-equiv ef eg)

Î£-tr : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : A â†’ B â†’ Type ğ“¦}
         {a b : A} {p : a ï¼ b} {b : B} {c : C a b}
       â†’ (tr (Î» a â†’ Î£ B (C a)) p (b , c)) ï¼ (b , tr (Î» a â†’ C a b) p c)
Î£-tr {p = refl} = refl

Î£-interchange : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {C : A â†’ Type ğ“¦}
                  {D : (a : A) â†’ B a â†’ C a â†’ Type ğ“œ} â†’
                  (Î£[ t@(a , b) âˆ¶ Î£ A B ] (Î£ (C a) (D a b)))
                    â‰ƒ
                  (Î£[ t@(a , c) âˆ¶ Î£ A C ] (Î£[ b âˆ¶ B a ] (D a b c)))
Î£-interchange = equivâ†qiso iso where
  iso : âˆ€ {ğ“¤} {ğ“¥} {ğ“¦} {ğ“œ} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
        {C : A â†’ Type ğ“¦} {D : (a : A) â†’ B a â†’ C a â†’ Type ğ“œ} â†’
      Î£ (Î£ A B) (Î» t â†’ Î£ (C (t .fst)) (D (t .fst) (t .snd))) â‰…
      Î£ (Î£ A C) (Î» t â†’ Î£ (B (t .fst)) (Î» b â†’ D (t .fst) b (t .snd)))
  iso ._â‰…_.fwd ((a , b) , (c , d))= (a , c) , (b , d)
  iso ._â‰…_.fwd-iso .fst ((a , c) , (b , d))= ((a , b) , (c , d))
  iso ._â‰…_.fwd-iso .snd .fst ((_ , _) , (_ , _))= refl
  iso ._â‰…_.fwd-iso .snd .snd a = refl
}
% ```

\subtree[stt-002T]{
\taxon{Theorem}
\title{Sums of singleton}

\p{Given a family of singleton types #{P : A \to \UU}, the projection from the straightening is an equivalence.}
\proof{
\citet{4.9.3}{HoTT}
\p{The fibre of the projection #{\pi : \Sigma_{(x : A)}P(x) \to A} at some #{x : A} is equivalent to #{P(x)}. By assumption
we have the each #{P(x)} is singleton, and therefore so is each fibre of #{\pi}, thus it is an equivalence. }

% ```agda
\agda{
fibre-straighten : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) â†’
                   âˆ€ x â†’ fibre (fst {B = P}) x â‰ƒ P x
fibre-straighten P x = equivâ†qiso lem where
  lem : fibre fst x â‰… P x
  lem ._â‰…_.fwd ((a , p) , refl) = p
  lem ._â‰…_.fwd-iso .fst p = (x , p) , refl
  lem ._â‰…_.fwd-iso .snd .fst (_ , refl) = refl
  lem ._â‰…_.fwd-iso .snd .snd a = refl

singleton-fst-is-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
              â†’ (âˆ€ x â†’ is-singleton (P x))
              â†’ is-equiv (fst {B = P})
singleton-fst-is-equiv {P = P} sngl
  = is-equivâ†is-contr-map Î»
      b â†’ is-singleâ†equiv-to-single (fibre-straighten P b eâ»Â¹) (sngl b)


Î£-singleton : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
              â†’ (âˆ€ x â†’ is-singleton (P x))
              â†’ Î£ A P â‰ƒ A
Î£-singleton {P = P} sngl
  = mkâ‰ƒ fst (singleton-fst-is-equiv sngl)
}
% ```
}
}

\subtree[stt-009B]{
\title{Commuting coproducts with dependent sums}
\taxon{Theorem}

\p{There is an equivalence #{\Sigma_{A + B} (Q[f,g]) \simeq
\Sigma_A(Qf) + \Sigma_B(Qg)}}

%```agda
\agda{
Î£-âŠâ‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} (P  : A âŠ B â†’ Type ğ“¦)
      â†’ (Î£ _ (P âˆ˜ inl)) âŠ (Î£ _ (P âˆ˜ inr)) â‰ƒ Î£ (A âŠ B) P
Î£-âŠâ‰ƒ P = mkâ‰ƒ âŠ[ total-map-fst inl , total-map-fst inr ]
            (is-equivâ†qiso iso) where
  iso : quasi-iso âŠ[ total-map-fst inl , total-map-fst inr ]
  iso .fst (inl x , p) = inl (x , p)
  iso .fst (inr x , p) = inr (x , p)
  iso .snd .fst = âŠ-ind (~refl , ~refl)
  iso .snd .snd (inl x , p) = refl
  iso .snd .snd (inr x , p) = refl
}
%```
}
