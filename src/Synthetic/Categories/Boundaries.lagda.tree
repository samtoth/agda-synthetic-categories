\date{2025-12-18}
\title{The boundary of simplices}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Boundaries
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I


open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr

open import Ergonomics.Extensionality

open import Modalities.Instances.Truncation

open import Data.Bool

open import Core.CanonicalPushouts
open import Core.Join
open import Core.FlatteningPushouts
open import Core.FunctorialPushout
open import Core.SpanMap
}
%```

\subtree[tot-000O]{
\title{Boundary of the interval}
\taxon{Definition}

\p{The boundary of the interval (#{\Delta^1}) is just the type of Booleans. For
the sake of uniformity, we lift it into the same universe that the interval
lives in. We define the inclusion #{\delta\Delta^1 \to \Delta^1} and show that
it is an embedding exactly when the lattice of the interval #{I} is non-trivial.}

%```agda
\agda{
Î´Î”Â¹ : Type ğ“˜
Î´Î”Â¹ = ULift _ Bool

Î´Î”Â¹-0 Î´Î”Â¹-1 : Î´Î”Â¹
Î´Î”Â¹-0 = mk-lift false
Î´Î”Â¹-1 = mk-lift true

make-Î´Î”Â¹ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ A â†’ Î´Î”Â¹ â†’ A
make-Î´Î”Â¹ a b (mk-lift true) = a
make-Î´Î”Â¹ a b (mk-lift false) = b

Î´Î”Â¹-UPâ†’ : âˆ€ {ğ“¤} {A : Î´Î”Â¹ â†’ Type ğ“¤} â†’ (A Î´Î”Â¹-0 Ã— A Î´Î”Â¹-1) â†’ Î  _ A
Î´Î”Â¹-UPâ†’ x (mk-lift false) = x .fst
Î´Î”Â¹-UPâ†’ x (mk-lift true)  = x .snd

Î´Î”Â¹-UP : âˆ€ {ğ“¤} {A : Î´Î”Â¹ â†’ Type ğ“¤} â†’ (A Î´Î”Â¹-0 Ã— A Î´Î”Â¹-1) â‰ƒ Î  _ A
Î´Î”Â¹-UP = mkâ‰ƒ Î´Î”Â¹-UPâ†’ (is-equivâ†qiso ((Î» x â†’ (x Î´Î”Â¹-0 , x Î´Î”Â¹-1))
                                    , ~refl
                                    , (Î» f â†’ funextâ†’ (Î´Î”Â¹-UPâ†’ (refl , refl)))))

Î´Î”Â¹-incl : Î´Î”Â¹ â†’ Î”Â¹
Î´Î”Â¹-incl (mk-lift false) = i0
Î´Î”Â¹-incl (mk-lift true) = i1

Î´Î”Â¹-embeds : ((i0 ï¼ i1) â†’ âˆ…) â†’ is-embedding (Î´Î”Â¹-incl)
Î´Î”Â¹-embeds nt = is-equivâ†inverse
                  (is-propâ†is-truncated
                    (Trunc.ULift-is-truncated
                      (is-truncatedâ†is-set Bool-is-set) _ _))
                  (is-propâ†is-truncated (car-is-set _ _))
                  map where
  map : âˆ€ {x y} â†’ Î´Î”Â¹-incl x ï¼ Î´Î”Â¹-incl y â†’ x ï¼ y
  map {mk-lift true} {mk-lift true} _ = refl
  map {mk-lift true} {mk-lift false} p = Â¡ nt (sym p)
  map {mk-lift false} {mk-lift true} p = Â¡ nt p
  map {mk-lift false} {mk-lift false} _ = refl

Î´Î›[2,1]-incl : Î´Î”Â¹ â†’ Î›[2,1]
Î´Î›[2,1]-incl (mk-lift false) = Î¹â‚ i0
Î´Î›[2,1]-incl (mk-lift true ) = Î¹â‚‚ i1
}
%```
}

\subtree[tot-000W]{
\title{Boundary of the 2-simplex}
\taxon{Definition}

\p{We define the boundary of the 2 simplex by glueing an interval along the
endpoints of the inner horn. (This reflects it's typical use as in connection
to the [Segal condition](stt-00AI) of precategories)}


\p{We show that there is an embedding #{\delta\Delta^2 \to \Delta^2} which
identifies this boundary with the subtype of #{(i,j) : \Delta^2} where
#{i = 1 \lor j = 0 \lor i = j}.}


%```agda
\agda{
Î´Î”Â² : Type ğ“˜
Î´Î”Â² = Pushout {A = Î´Î”Â¹} {B = Î›[2,1]} {C = Î”Â¹} Î´Î›[2,1]-incl Î´Î”Â¹-incl

Î´Î”Â²-Î”Â²-cocone : Cocone (mk-span _ Î´Î›[2,1]-incl Î´Î”Â¹-incl) Î”Â²
Î´Î”Â²-Î”Â²-cocone = (mk-cocone Î›[2,1]-incl Î”Â²-diagonal Î» where
                         (mk-lift true) â†’ Î”Â²-refl
                         (mk-lift false) â†’ Î”Â²-refl)

Î´Î”Â²-incl : Î´Î”Â² â†’ Î”Â²
Î´Î”Â²-incl = pushout-rec Î´Î”Â²-Î”Â²-cocone

Î´Î”Â²â†Î›[2,1] : Î›[2,1] â†’ Î´Î”Â²
Î´Î”Â²â†Î›[2,1] = Î¹â‚

Î´Î´Î›[2,1]-incl : Î”Â²-diagonal âˆ˜ Î´Î”Â¹-incl ~ Î›[2,1]-incl âˆ˜ Î´Î›[2,1]-incl
Î´Î´Î›[2,1]-incl (mk-lift true) = Î”Â²-refl
Î´Î´Î›[2,1]-incl (mk-lift false) = Î”Â²-refl

Î´Î”Â²-sub : Subtype Î”Â² ğ“˜
Î´Î”Â²-sub .Subtype.family t@(i , j) = (t âˆˆ Î›[2,1]Sub) * (j ï¼ i)
Î´Î”Â²-sub .Subtype.has-is-subtype a@(i , j)
  = *-is-prop (âˆˆ-is-prop Î›[2,1]Sub a) (is-prop-separated _ _)

Î´Î”Â²-as-subtype : (i0 ï¼ i1 â†’ âˆ…) â†’ âˆ€ a â†’ fibre Î´Î”Â²-incl a â‰ƒ a âˆˆ Î´Î”Â²-sub
Î´Î”Â²-as-subtype non-triv a@(i , j)
  = fibre Î´Î”Â²-incl a â‰ƒâŸ¨ cogap-fibre _ a âŸ©
    Pushout (total-fibre-span .left) (total-fibre-span .right)
        â‰ƒâŸ¨ Pushout-equivâ†logical total-span-is-prop intended-span-is-prop sle âŸ©
    Pushout (intended-span .left) (intended-span .right)
                              â‰ƒâŸ¨âŸ©
    (a âˆˆ Î´Î”Â²-sub)             â‰ƒâˆ where
  open Span

  total-fibre-span : Span ğ“˜ ğ“˜ ğ“˜
  total-fibre-span = total-span Î´Î›[2,1]-incl Î´Î”Â¹-incl
                                (Fibre-family Î´Î”Â²-Î”Â²-cocone a)

  intended-span : Span ğ“˜ ğ“˜ ğ“˜
  intended-span = mk-span ((a âˆˆ Î›[2,1]Sub) Ã— (j ï¼ i)) fst snd

  intended-span-is-prop : is-prop-span intended-span
  intended-span-is-prop .fst = âˆˆ-is-prop Î›[2,1]Sub (i , j)
  intended-span-is-prop .snd .fst
    = is-prop-Î£ (âˆˆ-is-prop Î›[2,1]Sub (i , j)) Î» _ â†’ is-prop-separated _ _
  intended-span-is-prop .snd .snd = is-prop-separated _ _

  total-fibre-span' : Span ğ“˜ ğ“˜ ğ“˜
  total-fibre-span' = mk-span (fibre (Î”Â²-diagonal âˆ˜ Î´Î”Â¹-incl) (i , j))
                              {Left = fibre Î›[2,1]-incl (i , j)}
                              _
                              {Right = fibre Î”Â²-diagonal (i , j)}
                              (total-map-fst Î´Î”Â¹-incl)

  _ : total-fibre-span ï¼ total-fibre-span'
  _ = refl

  total-span-is-prop : is-prop-span total-fibre-span
  total-span-is-prop .fst = Î›[2,1]-is-prop-map (i , j)
  total-span-is-prop .snd .fst
    = is-prop-mapâ†is-embedding
        (is-embedding-âˆ˜ Î”Â²-diagonal-is-embedding (Î´Î”Â¹-embeds non-triv))
        (i , j)
  total-span-is-prop .snd .snd
    = is-prop-mapâ†is-embedding Î”Â²-diagonal-is-embedding (i , j)


  sle : Span-logical-equiv total-fibre-span intended-span
  sle .fst = logicalâ†equiv (Î›[2,1]-as-subtype (i , j))
  sle .snd .fst .fst (mk-lift true , refl) = (Î¹â‚‚ refl , refl)
  sle .snd .fst .fst (mk-lift false , refl) = (Î¹â‚ refl , refl)
  sle .snd .fst .snd (x , refl)
    = pushout-rec (mk-cocone (Î» {refl â†’ (Î´Î”Â¹-0 , Î”Â²-refl)})
                             (Î» {refl â†’ (Î´Î”Â¹-1 , Î”Â²-refl)})
                             Î» {(p , q) â†’ Â¡ non-triv (p âˆ™ sym q) }) x
  sle .snd .snd .fst (x , refl) = refl
  sle .snd .snd .snd refl = (i , Î”Â²-refl)

Î´Î”Â²â‰ƒSub : (i0 ï¼ i1 â†’ âˆ…) â†’ Î´Î”Â² â‰ƒ Subtype.Î£Ìƒ Î´Î”Â²-sub
Î´Î”Â²â‰ƒSub nt
  = Î´Î”Â²                               â‰ƒâŸ¨ totalâ‰ƒtotal-fibre Î´Î”Â²-incl eâ»Â¹ âŸ©
    total-fibre Î´Î”Â²-incl              â‰ƒâŸ¨âŸ©
    (Î£[ a âˆ¶ Î”Â² ] fibre Î´Î”Â²-incl a)    â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î´Î”Â²-as-subtype nt) âŸ©
    (Î£[ a âˆ¶ Î”Â² ] (a âˆˆ Î´Î”Â²-sub))       â‰ƒâŸ¨âŸ©
    Subtype.Î£Ìƒ Î´Î”Â²-sub                 â‰ƒâˆ

make-Î´Î”Â² : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z}
          â†’ Hom A y z â†’ Hom A x y â†’ Hom A x z
          â†’ Î´Î”Â² â†’ A
make-Î´Î”Â² f@(mk-hom fh f0 f1) g@(mk-hom gh g0 g1) h@(mk-hom hh h0 h1)
  = pushout-rec (mk-cocone (make-horn f g) (h .HomP.hom) Î» where
                               (mk-lift false) â†’ g0 âˆ™ sym h0
                               (mk-lift true ) â†’ f1 âˆ™ sym h1)
}
%```
}


\subtree[tot-000U]{
\title{Boundaries of squares}
\taxon{Definition}

\p{We define the boundary of a square by glueing a pair of horns together.}

%```agda
\agda{
Î´â–¡Â² : Type ğ“˜
Î´â–¡Â² = Pushout Î´Î›[2,1]-incl Î´Î›[2,1]-incl

Î´â–¡Â²-incl : Î´â–¡Â² â†’ â–¡^ 2
Î´â–¡Â²-incl
  = cogap (mk-cocone (â–¡â†Î”Â²-upper âˆ˜ Î›[2,1]-incl) (â–¡â†Î”Â²-lower âˆ˜ Î›[2,1]-incl)
                     Î» { (mk-lift true)  â†’ refl
                       ; (mk-lift false) â†’ refl})

Î´â–¡Â²-Sub : Subtype (â–¡^ 2) ğ“˜
Î´â–¡Â²-Sub .Subtype.family (i , j) = ((i0 ï¼ j) * (i1 ï¼ i)) Ã— ((i0 ï¼ i) * (i1 ï¼ j))
Î´â–¡Â²-Sub .Subtype.has-is-subtype _
  = is-prop-Î£
      (*-is-prop
        (is-prop-separated _ _)
        (is-prop-separated _ _))
      (Î» _ â†’
       *-is-prop
        (is-prop-separated _ _)
        (is-prop-separated _ _))

mk-Î´â–¡Â² : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z w}
         â†’ Hom A x y â†’ Hom A y z â†’ Hom A x w â†’ Hom A w z
         â†’ (Î´â–¡Â² â†’ A)
mk-Î´â–¡Â² f g h k = cogap (mk-cocone (make-horn g f) (make-horn k h)
                        Î» { (mk-lift true)  â†’ HomP.hom1 g âˆ™ sym (HomP.hom1 k)
                          ; (mk-lift false) â†’ HomP.hom0 f âˆ™ sym (HomP.hom0 h) })
  where open HomP
}
%```
}
