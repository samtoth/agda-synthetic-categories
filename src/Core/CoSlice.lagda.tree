\date{2025-06-20}
\title{Coslices of types}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.CoSlice where

open import Foundations.Prelude
open import ufAxioms

open import Ergonomics.Extensionality
}
%```

\subtree[stt-0062]{
\title{Coslice maps}
\taxon{Definition}

\p{Fixing a type #{A}, there is a category
#{\SS_{A/}} called the coslice category under #{A}.
Maps in this category are commuting triangles:}

%```agda
\agda{
Coslice-map : âˆ€ {ğ“¤} {A : Type ğ“¤}
                {ğ“¥} {X : Type ğ“¥}
                (p : A â†’ X)
                {ğ“¦} {Y : Type ğ“¦}
                (q : A â†’ Y)
               â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Coslice-map {X = X} p {Y = Y} q
  = Î£[ f âˆ¶ (X â†’ Y) ] (f âˆ˜ p ~ q)

Coslice-id : âˆ€ {ğ“¤} {A : Type ğ“¤}
               {ğ“¥} {X : Type ğ“¥}
               (p : A â†’ X)
             â†’ Coslice-map p p
Coslice-id p = (id , ~refl)

Coslice-map-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {X : Type ğ“¥} {Y : Type ğ“¦} {Z : Type ğ“œ}
      (p : A â†’ X) (q : A â†’ Y) (r : A â†’ Z)
    â†’ Coslice-map q r â†’ Coslice-map p q â†’ Coslice-map p r
Coslice-map-âˆ˜ p q r (f , H) (g , K) = (f âˆ˜ g , f â—‚ K ~âˆ™ H)


Coslice-map-precompose
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {X : Type ğ“¥} {Y : Type ğ“¦} {Z : Type ğ“œ}
      (p : A â†’ X) {q : A â†’ Y} {r : A â†’ Z}
    â†’ Coslice-map q r â†’ (Coslice-map p q â†’ Coslice-map p r)
Coslice-map-precompose p F = Coslice-map-âˆ˜ p _ _ F

Coslice-map-postcompose
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {X : Type ğ“¥} {Y : Type ğ“¦} {Z : Type ğ“œ}
      {p : A â†’ X} {q : A â†’ Y} (r : A â†’ Z)
    â†’ Coslice-map p q â†’ (Coslice-map q r â†’ Coslice-map p r)
Coslice-map-postcompose r F G = Coslice-map-âˆ˜ _ _ r G F

Coslice-map-path
 : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {X : Type ğ“¥} {p : A â†’ X}
     {Y : Type ğ“¦} {q : A â†’ Y} â†’ (f g : Coslice-map p q) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Coslice-map-path {p = p} (f , H) (g , K) = Î£[ P âˆ¶ f ~ g ] (P â–¸ p ~âˆ™ K ~ H)

Coslice-map-path-refl
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {X : Type ğ“¥} {p : A â†’ X}
      {Y : Type ğ“¦} {q : A â†’ Y} â†’ (f : Coslice-map p q)
    â†’ Coslice-map-path f f
Coslice-map-path-refl f = (~refl , ~refl)

opaque
  Coslice-map-path-is-torsorial
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {X : Type ğ“¥} {p : A â†’ X}
        {Y : Type ğ“¦} {q : A â†’ Y} â†’ (f : Coslice-map p q)
      â†’ is-singleton (Î£ _ (Coslice-map-path f))
  Coslice-map-path-is-torsorial f
    = is-singleton-structureâ†parts
        (SingS-is-single _)
        (_ , ~refl)
        (SingS-is-single' _)

instance
  Coslice-IdS
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {X : Type ğ“¥} {p : A â†’ X}
        {Y : Type ğ“¦} {q : A â†’ Y}
     â†’ Identity-system (Coslice-map p q) (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
  Coslice-IdS .Identity-system.IdS = Coslice-map-path
  Coslice-IdS .Identity-system.IdSâ†Id refl = Coslice-map-path-refl _
  Coslice-IdS .Identity-system.has-is-ids f
    = fundamental-Id _ (Coslice-map-path-is-torsorial f) _
}
%```
}

\subtree[stt-00A1]{
\title{The initial coslice}
\taxon{Theorem}
\date{2025-11-15}

\p{The identity function is initial in the coslice category. That is,
fixing a type #{X}, for any #{f : A \to X}, there is a unique coslice
map #{\id} to #{f}.}

%```agda
\agda{
initial-coslice : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {X : Type ğ“¥}
                    (f : A â†’ X)
                  â†’ is-singleton (Coslice-map id f)
initial-coslice f = mk-singl (f , ~refl) unique where
  unique : (x : Coslice-map id f) â†’ (f , ~refl) ï¼ x
  unique (g , H) = funext-J (Î» h K â†’ (f , ~refl) ï¼ (h , K ~â»Â¹)) refl g (H ~â»Â¹)
                 âˆ™ Î£-pathâ†’ (refl , (funextâ†’ Î» _ â†’ sym-sym))
}
%```
}

\subtree[stt-0060]{
\taxon{Definition}
\title{Equivalences of coslices}

\p{A map of coslices is said to be an equivalence
if it's underlying map of types in an equivalence.}

%```agda
\agda{
Coslice-equiv : âˆ€ {ğ“¤} {A : Type ğ“¤}
                {ğ“¥} {X : Type ğ“¥}
                {p : A â†’ X}
                {ğ“¦} {Y : Type ğ“¦}
                {q : A â†’ Y}
               â†’ Coslice-map p q
               â†’ Type (ğ“¥ âŠ” ğ“¦)
Coslice-equiv (f , _) = is-equiv f
}
%```
}

\subtree[stt-006N]{
\taxon{Theorem}
\title{Equivalences, sections and retracts are closed under coslice equivalence}

%```agda
\agda{
secâ†sec-Coslice-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
      {ğ“¥} {X : Type ğ“¥}
      {p : A â†’ X}
      {ğ“¦} {Y : Type ğ“¦}
      {q : A â†’ Y}
      (f : Coslice-map p q)
    â†’ Coslice-equiv f
    â†’ section p
    â†’ section q
secâ†sec-Coslice-equiv (f , H) feq (ps , sp)
  = homotopy-section H ((ps âˆ˜ f.bwd) , f â—‚ sp â–¸ f.bwd ~âˆ™ f.Îµ) where
  module f = is-equiv feq



secâ†sec-Coslice-equiv'
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
      {ğ“¥} {X : Type ğ“¥}
      {p : A â†’ X}
      {ğ“¦} {Y : Type ğ“¦}
      {q : A â†’ Y}
      (f : Coslice-map p q)
    â†’ Coslice-equiv f
    â†’ section q
    â†’ section p
secâ†sec-Coslice-equiv' (f , H) feq (ps , sp)
  = homotopy-section (((f.Î· â–¸ _ ~â»Â¹) ~âˆ™ f.bwd â—‚ H) ~â»Â¹ )
                     ((ps âˆ˜ f) , f.bwd â—‚ sp â–¸ f ~âˆ™ f.Î·) where
  module f = is-equiv feq

equivâ†Coslice-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
      {ğ“¥} {X : Type ğ“¥}
      {p : A â†’ X}
      {ğ“¦} {Y : Type ğ“¦}
      {q : A â†’ Y}
      (f : Coslice-map p q)
    â†’ Coslice-equiv f
    â†’ is-equiv p
    â†’ is-equiv q
equivâ†Coslice-equiv (f , comm) feq peq
  = homotopy-is-equiv comm (is-equiv-âˆ˜ feq peq)
}
%```
}
