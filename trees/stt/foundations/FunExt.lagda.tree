\date{2025-02-26}
\title{Function extensionality}

\import{stt-macros}

\p{
Function extensionality says that any homotopy between functions can be made into an equality between functions.

Or equivalently, that #{\textrm{happly} : f = g \to f \sim g} is an equivalence.
}

% ```agda
\agda{

open import foundations.universe
open import foundations.Functions
open import foundations.CoherentIsomorphism
open import foundations.Identity
open import foundations.DependentIdentity
open import foundations.Homotopy
open import foundations.Sigma
open import foundations.DependentHomotopy

module foundations.FunExt where


FunExt : (ğ“¤ ğ“¥ : Level) â†’ Type (lsuc (ğ“¤ âŠ” ğ“¥))
FunExt ğ“¤ ğ“¥ = âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a}
           â†’ is-equiv (happly {f = f} {g})


FunExtGlobal : TypeÏ‰
FunExtGlobal = âˆ€ {ğ“¤ ğ“¥} â†’ FunExt ğ“¤ ğ“¥

module WithFunExt {ğ“¤ ğ“¥} (fe : FunExt ğ“¤ ğ“¥) where
  funextâ‰ƒ : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a} â†’ (f ï¼ g) â‰ƒ (f ~ g)
  funextâ‰ƒ = happly , fe

  funextâ†’ : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a} â†’ f ~ g â†’ f ï¼ g
  funextâ†’ p = is-equiv.bwd fe p

  funext-ind : âˆ€ {ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f : (a : A) â†’ B a}
               â†’ (M : (g : (a : A) â†’ B a) â†’ f ~ g â†’ Type ğ“¦) â†’ M f ~refl
               â†’ âˆ€ (g : (a : A) â†’ B a) (h : f ~ g) â†’ M g h
  funext-ind M mrfl g h = tr (M g) (is-equiv.Îµ fe h) (J (Î» g p â†’ M g (happly p)) mrfl (funextâ†’ h))

  funext-refl : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f : Î  A B} â†’ funextâ†’ (~refl) ï¼ refl {a = f}
  funext-refl = is-equiv.Î· fe refl


module WithFunExtGlobal (fe : FunExtGlobal) where
  module FE {ğ“¤} {ğ“¥} = WithFunExt (fe {ğ“¤} {ğ“¥})
  open FE public


  Î -path : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B C : A â†’ Type ğ“¥}
           â†’ B ï¼ C â†’ ((a : A) â†’ B a) ï¼ ((a : A) â†’ C a)
  Î -path p = ap (Î» f â†’ (a : _) â†’ f a) p

  funextáµˆâ†’ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B C : A â†’ Type ğ“¥} 
            {P : B ~ C}
            {f : (a : A) â†’ B a}
            {g : (a : A) â†’ C a}
            â†’ f ~[ P ] g â†’ f ï¼[ ap (Î» f â†’ (a : A) â†’ f a) (funextâ†’ P)  ] g
  funextáµˆâ†’ {A = A} {P = P} {f} = funext-ind (Î» C P â†’ âˆ€ {g : (a : A) â†’ C a} â†’ f ~[ P ] g â†’ f ï¼[  Î -path (funextâ†’ P) ] g)
                                 (funext-ind (Î» g h â†’ f ï¼[ Î -path (funextâ†’ ~refl) ] g) (IdP-refl (ap Î -path funext-refl)) _) _ P 
                                 

}
% ```
