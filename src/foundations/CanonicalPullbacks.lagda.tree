\date{2025-04-22}

\title{Canonical pullbacks}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb foundations.CanonicalPullbacks \stopverb}

\import{stt-macros}

% ```agda
\agda{
module foundations.CanonicalPullbacks where

open import foundations.Universes
open import foundations.Span
open import foundations.Functions
open import foundations.Identity
open import foundations.Homotopy
open import foundations.QuasiIsomorphism
open import foundations.CoherentIsomorphism
open import foundations.Pullbacks
open import foundations.Sigma
open import foundations.3for2
open import foundations.EquivProp
open import foundations.EquivHomotopy
import foundations.FunExt as FE
import foundations.Yoneda
}
% ```


\subtree[stt-003J]{
\taxon{definition}
\title{The canonical pullback of a cospan}
\meta{defines}{\startverb ["Pullback", "pullback"] \stopverb}

\p{For any cospan #{B \xrightarrow{f} A \xleftarrow{g} C}, there exists a pullback
   cone defined as: #{(\Sigma_{(x : B)}\Sigma_{(y : C)}(f(x) = g(y)), \pi_1, \pi_2)}
   which we call the canonical pullback of #{f} and #{g}. It is written #{B \times_A A}.}

% ```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         (f : B â†’ A) (g : C â†’ A) where
 Pullback : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
 Pullback = Î£[ x âˆ¶ B ] Î£[ y âˆ¶ C ] (f x ï¼ g y)

 pullback : Cone (mk-cospan A f g) Pullback
 pullback = mk-cone fst (fst âˆ˜ snd) (snd âˆ˜ snd)
}
% ```
}

\subtree[stt-003L]{
\taxon{definition}
\title{The gap map}
\meta{defines}{\startverb ["gap"] \stopverb}

\p{
Given a cone #{C} over a span #{S}, we can define a map called the gap-map from
the apex of #{C} to the pullback of #{S}.
}

% ```agda
\agda{
gap : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : B â†’ A} {g : C â†’ A}
        {ğ“œ} {D : Type ğ“œ}
      â†’ Cone (mk-cospan A f g) D
      â†’ D â†’ Pullback f g
gap (mk-cone i j filler) d = (i d , j d , filler d)
}
% ```
}

\subtree[stt-003K]{
\taxon{theorem}
\title{Canonical pullbacks are pullbacks}

\meta{defines}{\startverb ["pullback-is-pullback"] \stopverb}

\p{This either follows from noticing that the gap map on the pullback cone itself
is definitionally a section and a retraction of [cone-map](stt-003I), or from
repeatedly applying the universal property of sigma types:}

##{
\begin{align*}
  (Q \to \Sigma_{(x : B)}\Sigma_{(y : C)}(f(x) = g(y)))
    &\simeq \Sigma_{(i : Q \to B)}((q : Q) \to (\Sigma_{(y : C)}(f(i(q)) = g(y)))) \\
    &\simeq \Sigma_{(i : Q \to B)}\Sigma_{(j : Q \to C)}((q : Q) \to f(i(q)) = g(j(q))) \\
    &\simeq \textrm{Cone}_S(Q) 
\end{align*}
}

% ```agda
\agda{
pullback-is-pullback : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                         {f : B â†’ A} {g : C â†’ A}
                       â†’ is-pullbackÏ‰ (mk-cospan _ f g) (pullback f g)
pullback-is-pullback {f = f} {g = g} Q
  = is-equivâ†qiso (gap , ~refl , ~refl)
}
% ```
}

% ```agda
\agda{
module WithFunExt (FE : FE.FunExt-global) where
  open FE.WithFunExt-global FE
  open foundations.Yoneda FE
}
% ```

\subtree[stt-003M]{
\taxon{theorem}
\title{Pullbacks via the gap map}
\p{A cone #{D} is a pullback iff #{\textrm{gap}(D)} is an equivalence}
\meta{defines}{\startverb ["is-pullbackâ†gap"] \stopverb}

\proof{
\p{We need to show that for any #{Q}, #{\textrm{gap}(D) : D \toeq B \times_A C} is an
equivalence iff 
#{\textrm{cone-map}(D) : (Q \to D) \to Cone_S(Q)} is.
We know that #{- \circ \textrm{gap}(D) : (Q \to D) \to (Q \to B \times_A C)} is an equivalence
iff the gap map is, so we use then use the fact canonical pullbacks are pullbacks and
[[foundations.3for2]] to finish the proof. The situation can be summarised as follows:
}
\quiver{
\begin{tikzcd}
        {Q \to D} && {Q \to B \times_A C} \\
	\\
	& {\textrm{Cone}_S(Q)}
	\arrow["{- \circ \textrm{gap}(D)}", from=1-1, to=1-3]
	\arrow["{\textrm{cone-map}(D)}"'{pos=0.4}, from=1-1, to=3-2]
	\arrow["\sim", from=1-3, to=3-2]
\end{tikzcd}
}
}

% ```agda
\agda{
  is-pullbackâ†gap : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                      {f : B â†’ A} {g : C â†’ A}
                      {ğ“œ} {D : Type ğ“œ}
                      (C : Cone (mk-cospan _ f g) D)
                    â†’ is-equiv (gap C)
                    â†’ is-pullbackÏ‰ (mk-cospan _ f g) C
  is-pullbackâ†gap C ge@(mk-eqv bwd qi) Q
    = is-equiv-âˆ˜ (pullback-is-pullback Q) (precomp-equiv FE ge)

  gap-is-equivâ†is-pullback : âˆ€ {ğ“¤ ğ“¥ ğ“¦}
                      {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                      {f : B â†’ A} {g : C â†’ A}
                      {ğ“œ} {D : Type ğ“œ}
                      (C : Cone (mk-cospan _ f g) D)
                     â†’ is-pullbackÏ‰ (mk-cospan _ f g) C
                     â†’ is-equiv (gap C)
  gap-is-equivâ†is-pullback C Cpb
    = is-equivâ†precomp (gap C)
      Î» {_} {Q} â†’ 3-for-2 (pullback-is-pullback Q) (Cpb Q)

}
% ```
}

