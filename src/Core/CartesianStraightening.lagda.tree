\date{2025-08-08}
\title{Straightening for cartesian span maps}
\taxon{module}
\meta{module}{Core.CartesianStraightening}
\author{samueltoth}
\import{stt-macros}

\remark{
\p{The contents of this module isn't very polished and in particular
suffers from very slow type checking. Use with caution.}
}

%```agda
\agda{
module Core.CartesianStraightening where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import Ergonomics.Representation
}
%```

\subtree[stt-008M]{
\date{2025-08-03}
\title{Maps of spans}
\taxon{theorem}

\p{A map between spans #{S} and #{S'} is a diagram as follows where
all the squares commute:}

\quiver{
\begin{tikzcd}
	A && S && B \\
	\\
	{A'} && {S'} && {B'}
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=1-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=3-5]
	\arrow[from=3-3, to=3-1]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}

\p{Equivalently, a span map is a pair of arrow maps between the
left and right maps of each span, together with a homotopy between
the two maps between the centre of the spans.}

%```agda
\agda{
record Span-map {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                {ğ“¤' ğ“¥' ğ“¦'} (S' : Span ğ“¤' ğ“¥' ğ“¦')
                : Type (ğ“¤ âŠ” ğ“¤' âŠ” ğ“¥ âŠ” ğ“¥' âŠ” ğ“¦ âŠ” ğ“¦') where
   constructor mk-span-map
   module S = Span S
   module S' = Span S'
   field
     hâ‚ : S.Left â†’ S'.Left
     hâ‚‚ : S.Centre â†’ S'.Centre
     hâ‚ƒ : S.Right â†’ S'.Right
     H  : hâ‚ âˆ˜ S.left ~ S'.left âˆ˜ hâ‚‚
     K  : hâ‚ƒ âˆ˜ S.right ~ S'.right âˆ˜ hâ‚‚

   amap-lâ†“ : Arrow-map S.left S'.left
   amap-lâ†“ = mk-amap hâ‚‚ hâ‚ H

   amap-l : Arrow-map hâ‚‚ hâ‚
   amap-l = mk-amap S.left S'.left (H ~â»Â¹)

   amap-râ†“ : Arrow-map S.right S'.right
   amap-râ†“ = mk-amap hâ‚‚ hâ‚ƒ K

   amap-r : Arrow-map hâ‚‚ hâ‚ƒ
   amap-r = mk-amap S.right S'.right (K ~â»Â¹)


span-map-pathPâ†’
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {S'' : Span ğ“¤' ğ“¥' ğ“¦'}
      {f : Span-map S' S} {g : Span-map S'' S}
    â†’ let module S = Span S
          module S' = Span S'
          module S'' = Span S''
          module f = Span-map f
          module g = Span-map g
    in (p : S'.Centre ï¼ S''.Centre)
    â†’ (q : S'.Left ï¼ S''.Left)
    â†’ (r : S'.Right ï¼ S''.Right)
    â†’ (h : coe r âˆ˜ S'.right ï¼ S''.right âˆ˜ coe p)
    â†’ (k : coe q âˆ˜ S'.left ï¼ S''.left âˆ˜ coe p)
    â†’ (Q : f.hâ‚ ï¼ g.hâ‚ âˆ˜ coe q)
    â†’ (P : f.hâ‚‚ ï¼ g.hâ‚‚ âˆ˜ coe p)
    â†’ (R : f.hâ‚ƒ ï¼ g.hâ‚ƒ âˆ˜ coe r)
    â†’ (H : f.H ï¼ (happly Q â–¸ S'.left) ~âˆ™ (g.hâ‚ â—‚ happly k) ~âˆ™ (g.H â–¸ coe p) ~âˆ™ (S.left â—‚ happly (sym P)))
    â†’ (K : f.K ï¼ (happly R â–¸ S'.right) ~âˆ™ (g.hâ‚ƒ â—‚ happly h) ~âˆ™ (g.K â–¸ coe p) ~âˆ™ S.right â—‚ (happly (sym P)))
    â†’ IdP (ap (Î» P â†’ Span-map P S) (Span-pathâ†’ p q r h k)) f g
span-map-pathPâ†’ refl refl refl refl refl refl refl refl refl refl
  = apâ‚‚ (Î» P Q â†’ mk-span-map _ _ _ P Q)
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))
}
%```
}

\subtree[stt-008N]{
\date{2025-08-03}
\title{Cartesian maps of spans}
\taxon{definition}

\p{A map between spans is said to be cartesian when each square
is [cartesian](stt-003V) (i.e. a pullback square).}

%```agda
\agda{
is-cartesian-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {ğ“¤' ğ“¥' ğ“¦'} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S' â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
is-cartesian-span-map F = is-cartesian amap-l Ã— is-cartesian amap-r
  where open Span-map F

is-cartesian-span-map-is-prop
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {ğ“¤' ğ“¥' ğ“¦'} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {F : Span-map S S'}
    â†’ is-prop (is-cartesian-span-map F)
is-cartesian-span-map-is-prop
  = is-prop-Î£
      is-cartesian-is-prop
      (Î» _ â†’ is-cartesian-is-prop)

unquoteDecl Span-map-reprâ‰… Span-map-reprâ‰ƒ
  = make-record-repr Span-map-reprâ‰… Span-map-reprâ‰ƒ (quote Span-map)
}
%```
}


\subtree[stt-008Q]{
\title{Maps in #{\rm{Cart}(S)}}

%```agda
\agda{
record Cart {ğ“¤ ğ“¥ ğ“¦} (Sp : Span ğ“¤ ğ“¥ ğ“¦) ğ“¤' ğ“¥' ğ“¦'
         : Type (lsuc (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')) where
   constructor mk-cart
   field
     S' : Span ğ“¤' ğ“¥' ğ“¦'
     proj : Span-map S' Sp
     has-is-cartesian : is-cartesian-span-map proj

   open Span S' public
   open Span-map proj public


unquoteDecl Cart-reprâ‰… Cart-reprâ‰ƒ
  = make-record-repr Cart-reprâ‰… Cart-reprâ‰ƒ (quote Cart)
}
%```

\p{Given a span #{S} and a pair of cartesian span maps #{S'} and #{S''}
over #{S}, we define the type of maps between #{S'} and #{S''}.
In other words we consider the full subcategory of the slice category
of #{\rm{Span}} consisting of [cartesian span maps](stt-008N).}

\quiver{
\begin{tikzcd}
	&&&& {B'} \\
	&&&&&&&& {B''} \\
	&& {S'} &&&& B \\
	&&&&&& {S''} \\
	{A'} &&&& S \\
	&&&& {A''} \\
	&& A
	\arrow[from=1-5, to=2-9]
	\arrow[from=1-5, to=3-7]
	\arrow[from=2-9, to=3-7]
	\arrow[from=3-3, to=1-5]
	\arrow[from=3-3, to=4-7]
	\arrow[from=3-3, to=5-1]
	\arrow[from=3-3, to=5-5]
	\arrow[from=4-7, to=2-9]
	\arrow[from=4-7, to=5-5]
	\arrow[from=4-7, to=6-5]
	\arrow[from=5-1, to=6-5]
	\arrow[from=5-1, to=7-3]
	\arrow[from=5-5, to=3-7]
	\arrow[from=5-5, to=7-3]
	\arrow[from=6-5, to=7-3]
\end{tikzcd}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} where
  Cart-pathâ†’ : âˆ€ {ğ“¤' ğ“¥' ğ“¦'}
              â†’ {C C' : Cart S ğ“¤' ğ“¥' ğ“¦'}
              â†’ (p : C .Cart.S' ï¼ C' .Cart.S')
              â†’ IdP (ap (Î» p â†’ Span-map p S) p)
                    (C .Cart.proj)
                    (C' .Cart.proj)
              â†’ C ï¼ C'
  Cart-pathâ†’ {C = C} {mk-cart S' proj cart} refl refl
    = ap (mk-cart S' proj) (is-cartesian-span-map-is-prop _ _)


  record Cart-map {ğ“¤' ğ“¥' ğ“¦' ğ“¤'' ğ“¥'' ğ“¦''}
                  (S' : Cart S ğ“¤' ğ“¥' ğ“¦')
                  (S'' : Cart S ğ“¤'' ğ“¥'' ğ“¦'')
                  : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦' âŠ” ğ“¤'' âŠ” ğ“¥'' âŠ” ğ“¦'') where
    constructor mk-cart-map
    no-eta-equality
    module S' = Cart S'
    module S'' = Cart S''
    field
      map : Span-map (S'.S') (S''.S')

    module map = Span-map map

    field
      hâ‚-comm : S'.hâ‚ ~ S''.hâ‚ âˆ˜ map.hâ‚
      hâ‚‚-comm : S'.hâ‚‚ ~ S''.hâ‚‚ âˆ˜ map.hâ‚‚
      hâ‚ƒ-comm : S'.hâ‚ƒ ~ S''.hâ‚ƒ âˆ˜ map.hâ‚ƒ

  Cart-map-is-equiv
    : âˆ€ {ğ“¤' ğ“¥' ğ“¦' ğ“¤'' ğ“¥'' ğ“¦''}
        {S' : Cart S ğ“¤' ğ“¥' ğ“¦'} {S'' : Cart S ğ“¤'' ğ“¥'' ğ“¦''}
      â†’ Cart-map S' S'' â†’ Type (ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦' âŠ” ğ“¤'' âŠ” ğ“¥'' âŠ” ğ“¦'')
  Cart-map-is-equiv F = is-equiv map.hâ‚
                      Ã— is-equiv map.hâ‚‚
                      Ã— is-equiv map.hâ‚ƒ where
    open Cart-map F

  -- Cart-uaâ†’ F (feq , geq , heq)
  --   = Cart-pathâ†’ (Span-pathâ†’ (ua (mkâ‰ƒ _ geq)) (ua (mkâ‰ƒ _ feq)) (ua (mkâ‰ƒ _ heq))
  --                (ap (_âˆ˜ _) coe-ua âˆ™ funextâ†’ map.K âˆ™  sym (ap (map.S'.right âˆ˜_) coe-ua))
  --                (ap (_âˆ˜ _) coe-ua âˆ™ funextâ†’ map.H âˆ™ sym (ap (map.S'.left âˆ˜_) coe-ua)))
  --                (span-map-pathPâ†’ (ua (mkâ‰ƒ _ geq)) (ua (mkâ‰ƒ _ feq)) _ _ _
  --                  (funextâ†’ (Î» a â†’ hâ‚-comm a âˆ™ sym (ap S''.hâ‚ (happly coe-ua a))))
  --                  (funextâ†’ (Î» a â†’ hâ‚‚-comm a âˆ™ sym (ap S''.hâ‚‚ (happly coe-ua a))))
  --                  (funextâ†’ (Î» a â†’ hâ‚ƒ-comm a âˆ™ sym (ap S''.hâ‚ƒ (happly coe-ua a))))
  --                  (funextâ†’ (Î» a â†’ {!!}))
  --                  {!!}) where
  -- open Cart-map F
}
%```

\p{By the pullback pasting property the span map at the top is
cartesian when the two side maps are.}
}

\subtree[stt-008P]{
\title{Straightening cartesian span maps}
\taxon{lemma}
\citet{2.2.7}{rijke-2018}

\p{Given a span #{S}, we can define a map #{\rm{Cocone}(C,\UU) \to
\rm{Cart}(S)} - where #{\rm{Cart}(S)} is the type of spans #{S'}
together with a cartesian span map down into #{S}.}

%```agda
\agda{

module _ {ğ“¤ ğ“¥ ğ“¦} {Sp : Span ğ“¤ ğ“¥ ğ“¦}  where
  open Span Sp renaming (Centre to S;
                         left to f;
                         right to g;
                         Left to A;
                         Right to B) using ()


  cartâ†cocone : âˆ€ {ğ“œ} â†’ Cocone Sp (Type ğ“œ) â†’ Cart Sp (ğ“¤ âŠ” ğ“œ) (ğ“¥ âŠ” ğ“œ) (ğ“¦ âŠ” ğ“œ)
  cartâ†cocone cc = mk-cart span proj cart where
    open Cocone cc renaming (p to Pa; q to Pb)

    span : Span _ _ _
    span .Span.Centre = Î£[ s âˆ¶ S ] Pb (g s)
    span .Span.Left = Î£ A Pa
    span .Span.left a = (f (fst a) , coe (sym (filler (a .fst))) (a .snd) )
    span .Span.Right = Î£ B Pb
    span .Span.right x = (g (fst x) , snd x)

    proj : Span-map span Sp
    proj .Span-map.hâ‚ = fst
    proj .Span-map.hâ‚‚ = fst
    proj .Span-map.hâ‚ƒ = fst
    proj .Span-map.H = ~refl
    proj .Span-map.K = ~refl

    pbl : is-equiv (gap (mk-cone fst (span .Span.left) ~refl))
    pbl = is-equivâ†qiso qiso where
      qiso : quasi-iso (gap _)
      qiso .fst (s , (a , pa) , refl) = s , coe (filler s) pa
      qiso .snd .fst (s , pb) = Î£-pathâ†’ (refl , (coe-sym (filler s)))
      qiso .snd .snd (s , (a , pa) , refl)
        = Î£-pathâ†’ (refl
        , (Î£-pathâ†’ (
        (Î£-pathâ†’ (refl , (coe-sym' (filler s))))
        ,  IdP-funcâ†Square {f = Î» y â†’ f s} {fst} (Î£-pathâ†’ (refl , coe-sym' (filler s))) refl refl
            (âˆ™-reflr _ âˆ™ ap-const _ âˆ™ sym Î£-path-ap-fst) )))

    pbr : is-equiv (gap (mk-cone fst (span .Span.right) ~refl))
    pbr = is-equivâ†qiso qiso where
      qiso : quasi-iso (gap _)
      qiso .fst (s , (b , pb) , refl) = s , pb
      qiso .snd .fst = ~refl
      qiso .snd .snd (s , (b , pb) , refl) = refl


    opaque
      cart : is-cartesian-span-map proj
      cart .fst = is-cartesianâ†is-pullback _ (is-pullbackâ†gap _ pbl)
      cart .snd = is-cartesianâ†is-pullback _ (is-pullbackâ†gap _ pbr)
}
%```

\p{If the types in the span all live in a univalent unvirse #{\UU},
then this map is an equivalence.}

\proof{
\p{The type #{\rm{Cart}(S)} consists of the data:}

\ul{
\li{A span #{A' \xleftarrow{f} S' \xrightarrow{g} B'}}
\li{Maps #{h_A}, #{h_S}, #{h_B}}
\li{Homotopies #{H} and #{K}, witnessing the two squares involved commute}
\li{Proofs #{p_f} and #{p_g} witnessing that the squares are cartesian}
}

\p{We first note that the tuples #{f, H, p_f} and #{g,K,p_g} are
equivalent to fibrewise equivalences
#{\Pi_{(x : S)} \rm{fib}_{h_s}(x) \simeq \rm{fib}_{h_A}(f(x))} (and
respectively for #{g}). We then also pass #{(A', h_A)}, #{(S', h_S)}
and #{(B',h_B)} accross the straightning/unstraitening equivalences.
Resulting in the following data:}

\ul{
\li{#{Q : S \to \UU}}
\li{#{P_A : A \to \UU}}
\li{#{P_B : B \to \UU}}
\li{#{\Pi_{(x : S)} Q(x) \simeq P_A(f(x))}}
\li{#{\Pi_{(x : S)} Q(x) \simeq P_B(g(x))}}
}

\p{Now, by univalence, the first and last data together are
contractible, and so this is equivalent to the #{S} cocones at #{\UU}.
All that remains is to show that the map underlying this equivalence
is homotopic to the map we had preveously constructed.}
}

%```agda
\agda{
module _ {ğ“¤} {Sp : Span ğ“¤ ğ“¤ ğ“¤}  where
  bundle-map : âˆ€ {A B : Type ğ“¤} (f : A â†’ B)
                    â†’ Bundle A â†’ Bundle B â†’ Type ğ“¤
  bundle-map f (A' , pa) (B' , pb)
    = Î£[ f' âˆ¶ (A' â†’ B') ] (pb âˆ˜ f' ~ f âˆ˜ pa)

  amapâ†bmap : âˆ€ {A B : Type ğ“¤} (f : A â†’ B)
                    (A' : Bundle A) (B' : Bundle B)
                  â†’ bundle-map f A' B'
                  â†’ Arrow-map
                      (A' .snd)
                      (B' .snd)
  amapâ†bmap f (A' , pa) (B' , pb) (f' , H)
      = mk-amap f' f (H ~â»Â¹)

  is-cartesian-bmap
    : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
      â†’ bundle-map f A' B' â†’ Type ğ“¤
  is-cartesian-bmap {f = f} {(_ , pa)} {(_ , pb)} bmap
    = is-cartesian {f = pa} {f' = pb} (amapâ†bmap f _ _ bmap)

  tofib : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
          â†’ (bundle-map f A' B')
          â‰ƒ (âˆ€ b â†’ fibre (A' .snd) b â†’ fibre (B' .snd) (f b))
  tofib {A} {B}{f} {(A' , pa)} {(B' , pb)}
    = equivâ†qiso (mk-iso to (from , ret , sec)) where
    to : _ â†’ _
    to F = arrow-fibre (amapâ†bmap _ _ _ F)

    from : _ â†’ _
    from feq = Î£-Î -swap {X = A'} (Î» _ â†’ B')
                        (Î» a fa â†’ pb fa ï¼ f (pa a))
                        (Î» x â†’ feq (pa x) (x , refl))

    ret : (a : bundle-map f _ (B' , pb)) â†’ (from âˆ˜ to) a ï¼ a
    ret (f , H) = Î£-pathâ†’ (refl , (funextâ†’ (Î» a â†’ âˆ™-reflr _ âˆ™ sym-sym)))

    sec : _
    sec f = funextâ†’ (Î» a â†’ funextâ†’ (Î» where
      (a , refl) â†’ Î£-pathâ†’ (refl , (âˆ™-reflr _ âˆ™ sym-sym))))

  tofibeq : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
           â†’ (âˆ€ b â†’ fibre (A' .snd) b â‰ƒ fibre (B' .snd) (f b))
           â†’ (Î£[ F âˆ¶ bundle-map f A' B' ] is-cartesian-bmap {f = f}{A'}{B'} F)
  tofibeq {f = f}{A'}{B'} fmap
    = (_â‰ƒ_.bwd tofib (fmap.fwd) , eq' fmap.has-is-eqv) module tofibeq' where
    module fmap a = _â‰ƒ_ (fmap a)

    from-fmap : (âˆ€ b â†’ fibre (A' .snd) b â†’ fibre (B' .snd) (f b))
              â†’ bundle-map f A' B'
    from-fmap = _â‰ƒ_.bwd tofib

    lem : âˆ€ f' a â†’ f' a ~ arrow-fibre (amapâ†bmap f A' B' (from-fmap f')) a
    lem f' a = happly (happly (_â‰ƒ_.Îµ tofib f') a) ~â»Â¹

    opaque
      eq' : {f' : âˆ€ b â†’ fibre (A' .snd) b â†’ fibre (B' .snd) (f b)}
          â†’ is-fibrewise-equiv f'
          â†’ is-cartesian-bmap {f = f}{A'}{B'} (from-fmap f')
      eq' {f'} feq a = homotopy-is-equiv (lem f' a) (feq a)

  tofibeqâ‰ƒ : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
          â†’ (Î£[ F âˆ¶ bundle-map f A' B' ] is-cartesian-bmap {f = f}{A'}{B'} F)
          â‰ƒ (âˆ€ b â†’ fibre (A' .snd) b â‰ƒ fibre (B' .snd) (f b))
  tofibeqâ‰ƒ {A}{B}{f}{(A' , pa)}{(B' , pb)}
    = Î£ (bundle-map f _ (B' , pb)) (is-cartesian-bmap {f = f}{_}{B' , pb})
        â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst tofib âŸ©
      (Î£[ f' âˆ¶ (âˆ€ b â†’ fibre pa b â†’ fibre pb (f b))] is-fibrewise-equiv f')
        â‰ƒâŸ¨ fibrewise-equivâ‰ƒ  âŸ©
      ((b : A) â†’ fibre pa b â‰ƒ fibre pb (f b)) â‰ƒâˆ

  tofibeq-is-equiv : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A}
                       {B' : Bundle B}
                     â†’ is-equiv (tofibeq {f = f} {A'}{B'})
  tofibeq-is-equiv = homotopy-is-equiv tofibeq~ (is-equivâ»Â¹ (tofibeqâ‰ƒ ._â‰ƒ_.has-is-eqv)) where

    tofibeq~ : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
              â†’ _â‰ƒ_.bwd (tofibeqâ‰ƒ {f = f}{A'}{B'}) ~ tofibeq
    tofibeq~ fmap = Î£-pathâ†’ (refl , (is-cartesian-is-prop _ _))

  strait-bundle
    : âˆ€ {A B} {f : A â†’ B} (A' : Bundle A)
    â†’ (Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map f A' B') (is-cartesian-bmap {f = f}{A'} {B'}))
    â‰ƒ (Î£[ Q âˆ¶ (B â†’ Type ğ“¤)] (âˆ€ a â†’ fibre (A' . snd) a ï¼ Q (f a)))
  strait-bundle {A}{B}{f} Ab@(A' , pa)
    = (Î£[ B' âˆ¶ (Bundle B) ]
        Î£ (bundle-map f Ab B') (is-cartesian-bmap {f = f}{Ab}{B'}))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» bun â†’ tofibeqâ‰ƒ) âŸ©
      (Î£[ B' âˆ¶ (Bundle B)] (âˆ€ a â†’ fibre pa a â‰ƒ fibre (B' .snd) (f a)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» Q â†’ âˆ€ a â†’ fibre pa a â‰ƒ Q (f a)} straightenâ‰ƒ âŸ©
      (Î£[ Q âˆ¶ (B â†’ Type ğ“¤)] ((a : A) â†’ fibre pa a â‰ƒ Q (f a)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» Q â†’ precomp-Î -â‰ƒ (Î» c â†’ uaâ‰ƒ)) âŸ©
      Î£ (B â†’ Type ğ“¤) (Î» Q â†’ (a : A) â†’ fibre pa a ï¼ Q (f a)) â‰ƒâˆ

  strait-bundle-map : âˆ€ {A B} {f : A â†’ B} (A' : Bundle A)
                    â†’ (Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map f A' B') (is-cartesian-bmap {f = f}{A'}{B'}))
                    â†’ Î£[ Q âˆ¶ (B â†’ Type ğ“¤)] ((a : A) â†’ fibre (A' .snd) a ï¼ Q (f a))
  strait-bundle-map {f = f} A' (B' , bm , cart)
    = (straighten B' , Î» a â†’ ua (mkâ‰ƒ _ (cart a)))


  strait-bundle-map' : âˆ€ {A B} {f : A â†’ B} (A' : Bundle A)
                    â†’ Î£[ Q âˆ¶ (B â†’ Type ğ“¤)] ((a : A) â†’ fibre (A' .snd) a ï¼ Q (f a))
                    â†’ Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map f A' B') (is-cartesian-bmap {f = f}{A'}{B'})
  strait-bundle-map' {f = f} A' (Q , fmap)
    = (unstraighten Q)
    , tofibeq Î» a â†’ coeâ‰ƒ (fmap a) âˆ™â‰ƒ (fibre-straighten Q (f a)) eâ»Â¹
    where module fmap a = _â‰ƒ_ (coeâ‰ƒ (fmap a))

  strait-bundle-map-is-equiv : âˆ€ {A B} {f : A â†’ B}
                                 (A' : Bundle A)
                               â†’ is-equiv (strait-bundle-map' {f = f} A')
  strait-bundle-map-is-equiv {f = f} A' = is-equiv-âˆ˜ (total-is-equivâ†fst-is-equiv (is-equivâ»Â¹ straighten-is-equiv))
                                          (is-total-equivâ†is-fibrewise-equiv (Î» Pb
                                            â†’ is-equiv-âˆ˜
                                                tofibeq-is-equiv
                                                (lem Pb))) where
      map' : âˆ€ Pb â†’ (âˆ€ a â†’ fibre (A' .snd) a ï¼ Pb (f a)) â†’ (âˆ€ b â†’ fibre (A' .snd) b â‰ƒ fibre fst (f b))
      map' Pb fmap a = coeâ‰ƒ (fmap a) âˆ™â‰ƒ (fibre-straighten Pb (f a)) eâ»Â¹

      mapinv : âˆ€ Pb â†’ (âˆ€ b â†’ fibre (A' .snd) b â‰ƒ fibre fst (f b)) â†’ (âˆ€ a â†’ fibre (A' .snd) a ï¼ Pb (f a))
      mapinv Pb feq a = ua (feq a âˆ™â‰ƒ (fibre-straighten Pb (f a)))
      abstract
        lem : âˆ€ Pb â†’ is-equiv (map' Pb)
        lem Pb = is-equivâ†qiso Î» where
          .fst â†’ mapinv Pb
          .snd .fst feq â†’ funextâ†’ Î» a â†’ ap ua (âˆ™â‰ƒ-sym' (coeâ‰ƒ (feq a)) (fibre-straighten Pb (f a))) âˆ™ ua-coeâ‰ƒ
          .snd .snd feqv â†’ funextâ†’ Î» a â†’ ap (_âˆ™â‰ƒ (fibre-straighten Pb (f a)) eâ»Â¹) coeâ‰ƒ-ua
                           âˆ™ âˆ™â‰ƒ-sym (feqv a) (fibre-straighten Pb (f a))



  cartâ†cocone-is-equiv : is-equiv (cartâ†cocone {Sp = Sp} {ğ“¤})
  cartâ†cocone-is-equiv = homotopy-is-equiv H cartâ†cocone'-is-equiv where
    open Span Sp renaming (Centre to S;
                           left to f;
                           right to g;
                           Left to A;
                           Right to B) using ()

    shuffle : Cart Sp ğ“¤ ğ“¤ ğ“¤
            â‰ƒ (Î£[ S' âˆ¶ Bundle S ] (
                 (Î£[ A' âˆ¶ Bundle A ] Î£ (bundle-map f S' A') (is-cartesian-bmap {f = f}{S'} {A'}))
                 Ã—
                 (Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map g S' B') (is-cartesian-bmap {f = g}{S'}{B'}))))
    shuffle = mkâ‰ƒ map (is-equivâ†qiso map-qiso) where
      map : Cart Sp ğ“¤ ğ“¤ ğ“¤ â†’ _
      map (mk-cart
            (mk-span S' f' g')
            (mk-span-map hâ‚ hâ‚‚ hâ‚ƒ H K)
            (pf , pg))
        = (S' , hâ‚‚)
        , ((_ , hâ‚) , ((f' , H) , pf))
        , ((_ , hâ‚ƒ) , ((g' , K) , pg))

      bwd : _ â†’ Cart Sp ğ“¤ ğ“¤ ğ“¤
      bwd ((S' , hâ‚‚)
          , ((A' , hâ‚) , ((f' , H) , pf))
          , ((B' , hâ‚ƒ) , ((g' , K) , pg)))
          = mk-cart (mk-span S' f' g')
                    (mk-span-map hâ‚ hâ‚‚ hâ‚ƒ H K)
                    (pf , pg)

      map-qiso : quasi-iso map
      map-qiso .fst = bwd
      map-qiso .snd .fst = ~refl
      map-qiso .snd .snd = ~refl

    unshuffle
      : (Î£[ Q âˆ¶ (S â†’ Type ğ“¤)]
          ((Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] (Q ~ Pa âˆ˜ f))
           Ã—
          (Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] (Q ï¼ Pb âˆ˜ g))))
      â‰ƒ Cocone Sp (Type ğ“¤)
    unshuffle = mkâ‰ƒ map (is-equivâ†qiso qiso) where
      map : _ â†’ Cocone Sp (Type ğ“¤)
      map (_ , ((Pa , H) , (Pb , refl)))
        = mk-cocone Pa Pb (sym âˆ˜ H)

      unmap : Cocone Sp (Type ğ“¤) â†’ _
      unmap (mk-cocone p q filler)
        = q âˆ˜ g , ((p , sym âˆ˜ filler) , (q , refl))

      ret : retract-witness map unmap
      ret (S' , (Pb , H) , Pa , refl)
        = Î£-pathâ†’ (refl , Ã—-pathâ†’ ( Î£-pathâ†’ (refl
                                            , (funextâ†’ (Î» _ â†’ sym-sym)))
                                  , refl))

      qiso : quasi-iso map
      qiso .fst = unmap
      qiso .snd .fst = ret
      qiso .snd .snd (mk-cocone p q filler)
        = ap (mk-cocone p q) (funextâ†’ (Î» _ â†’ sym-sym))



    intermap : Î£[ Q âˆ¶ (S â†’ Type ğ“¤)]
            ((Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] (Q ~ Pa âˆ˜ f))
              Ã—
            (Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] (Q ï¼ Pb âˆ˜ g)))
        â†’ Î£[ S' âˆ¶ Bundle S ]
           (Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] (fibre (S' .snd) ~ Pa âˆ˜ f)
             Ã—
           Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] (fibre (S' .snd) ï¼ Pb âˆ˜ g))
    intermap (Q , (Pa , H) , (Pb , K))
      = (unstraighten Q) , (Pa , (ua âˆ˜ fibre-straighten Q ~âˆ™ H)) , (Pb ,  funextâ†’ (ua âˆ˜ fibre-straighten Q) âˆ™ K)

    intermap-is-equiv : is-equiv intermap
    intermap-is-equiv
      = is-equiv-âˆ˜
         (total-is-equivâ†fst-is-equiv (is-equivâ»Â¹ straighten-is-equiv))
         (is-total-equivâ†is-fibrewise-equiv (Î»
           Q â†’ âŠ—-is-equiv
                 (is-total-equivâ†is-fibrewise-equiv Î» Pa â†’ ~âˆ™-is-equiv _)
                 (is-total-equivâ†is-fibrewise-equiv (Î» Pb â†’ âˆ™-is-equiv _)))) where
      intermap' : _ â†’ _
      intermap' = total-map-fst unstraighten {B = Î» S' â†’
        (Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] (fibre (S' .snd) ~ Pa âˆ˜ f)
          Ã—
         Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] (fibre (S' .snd) ï¼ Pb âˆ˜ g))}
       âˆ˜ total-map (Î» Q â†’ total-map (Î» Pa â†’ ua âˆ˜ fibre-straighten Q ~âˆ™_)
                        âŠ— total-map (Î» Pb â†’ funextâ†’ (ua âˆ˜ fibre-straighten Q) âˆ™_))


    intermap2 : Î£[ S' âˆ¶ Bundle S ]
                  (Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] (fibre (S' .snd) ~ Pa âˆ˜ f)
                    Ã—
                   Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] (fibre (S' .snd) ï¼ Pb âˆ˜ g))
           â†’ Î£[ S' âˆ¶ (Bundle S)]
                 ((Î£[ A' âˆ¶ Bundle A ] Î£ (bundle-map f S' A') (is-cartesian-bmap {f = f}{S'}{A'}))
                 Ã—
                 ((Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map g S' B') (is-cartesian-bmap{f = g}{S'}{B'}))))
    intermap2 = total-map (Î» bs â†’ strait-bundle-map' bs âŠ— (strait-bundle-map' bs âˆ˜ total-map (Î» _ â†’ happly)))

    intermap2-is-equiv : is-equiv intermap2
    intermap2-is-equiv = is-total-equivâ†is-fibrewise-equiv
      Î» a â†’ âŠ—-is-equiv (strait-bundle-map-is-equiv a)
              (is-equiv-âˆ˜ (strait-bundle-map-is-equiv a)
                          (is-total-equivâ†is-fibrewise-equiv (Î» _ â†’ global-funext)))

    cartâ†cocone' : Cocone Sp (Type ğ“¤) â†’ Cart Sp ğ“¤ ğ“¤ ğ“¤
    cartâ†cocone' = _â‰ƒ_.bwd shuffle
                 âˆ˜ intermap2
                 âˆ˜ intermap
                 âˆ˜ _â‰ƒ_.bwd unshuffle

    cartâ†cocone'-is-equiv : is-equiv cartâ†cocone'
    cartâ†cocone'-is-equiv
      =  is-equiv-âˆ˜ (is-equivâ»Â¹ (shuffle ._â‰ƒ_.has-is-eqv))
        (is-equiv-âˆ˜  intermap2-is-equiv
        (is-equiv-âˆ˜  intermap-is-equiv
                    (is-equivâ»Â¹ (unshuffle ._â‰ƒ_.has-is-eqv))))


    H : cartâ†cocone' ~ cartâ†cocone
    H (mk-cocone Pa Pb filler)
      = cartâ†cocone' (mk-cocone Pa Pb filler) ï¼âŸ¨âŸ©
        (_â‰ƒ_.bwd shuffle (intermap2 (intermap ((Pb âˆ˜ g , ((Pa , filler ~â»Â¹) , (Pb , refl)))))))   ï¼âŸ¨âŸ©
        (_â‰ƒ_.bwd shuffle (intermap2 (((Î£ _ (Pb âˆ˜ g) , fst) , (Pa , (ua âˆ˜ fibre-straighten (Pb âˆ˜ g)) ~âˆ™ (filler ~â»Â¹))
                            , (Pb , (funextâ†’ (ua âˆ˜ fibre-straighten (Pb âˆ˜ g)) âˆ™ refl))))))
            ï¼âŸ¨ ap (Î» p â†’ (_â‰ƒ_.bwd shuffle (intermap2 (((Î£ _ (Pb âˆ˜ g) , fst) , (Pa , (ua âˆ˜ fibre-straighten (Pb âˆ˜ g)) ~âˆ™ (filler ~â»Â¹))
                            , (Pb , p)))))) (âˆ™-reflr (funextâ†’ (ua âˆ˜ fibre-straighten (Pb âˆ˜ g))))  âŸ©

        (_â‰ƒ_.bwd shuffle (intermap2 ((Î£ _ (Pb âˆ˜ g) , fst) , (Pa , (ua âˆ˜ fibre-straighten (Pb âˆ˜ g)) ~âˆ™ (filler ~â»Â¹))
                                                          , (Pb , funextâ†’ (ua âˆ˜ fibre-straighten (Pb âˆ˜ g))))))
            ï¼âŸ¨ ap (_â‰ƒ_.bwd shuffle) lem5' âŸ©
        _â‰ƒ_.bwd shuffle ((Î£ _ (Pb âˆ˜ g) , fst) ,
                             ((Î£ _ Pa , fst) , (((Î» a â†’ f (fst a) , coe (sym (filler (fst a))) (snd a)) , ~refl)) , PACART)
                             ,(Î£ _ Pb , fst) , ((Î» a â†’ g (fst a) , snd a) , ~refl) , _) ï¼âŸ¨ Cart-pathâ†’ refl refl âŸ©
        cartâ†cocone (mk-cocone Pa Pb filler) âˆ where
      -- lem1 : strait-bundle-map' (Î£ _ (Pb âˆ˜ g) , fst) (Pa , (ua âˆ˜ fibre-straighten (Pb âˆ˜ g)) ~âˆ™ (filler ~â»Â¹))
      --        ï¼ ((Î£ _ Pa , fst) , tofibeq' Î» a â†’ coeâ‰ƒ (ua (fibre-straighten (Pb âˆ˜ g) a) âˆ™ (sym (filler a))) âˆ™â‰ƒ (fibre-straighten Pa (f a)) eâ»Â¹)
      -- lem1 = refl


      lem2 : âˆ€ a â†’ coeâ‰ƒ (ua (fibre-straighten (Pb âˆ˜ g) a) âˆ™ (sym (filler a))) âˆ™â‰ƒ (fibre-straighten Pa (f a)) eâ»Â¹
                 ï¼ fibre-straighten (Pb âˆ˜ g) a âˆ™â‰ƒ coeâ‰ƒ (sym (filler a)) âˆ™â‰ƒ (fibre-straighten Pa (f a)) eâ»Â¹
      lem2 a = ap (_âˆ™â‰ƒ (fibre-straighten Pa (f a)) eâ»Â¹)
                 (â‰ƒ-pathâ†’ {e1 = coeâ‰ƒ (ua (fibre-straighten (Pb âˆ˜ g) a) âˆ™ (sym (filler a)))}
                          {fibre-straighten (Pb âˆ˜ g) a âˆ™â‰ƒ coeâ‰ƒ (sym (filler a))}
                   (funextâ†’ Î» aâ‚
                     â†’ sym (coeâˆ™coe (ua (fibre-straighten (Pb âˆ˜ g) a)) (sym (filler a)) aâ‚) âˆ™ ap (coe (sym (filler a))) (happly coe-ua aâ‚)))

      -- lem3 : fst (tofibeq' (Î» a â†’ fibre-straighten (Pb âˆ˜ g) a âˆ™â‰ƒ coeâ‰ƒ (sym (filler a)) âˆ™â‰ƒ (fibre-straighten Pa (f a)) eâ»Â¹))
      --      ï¼ (((Î» a â†’ f (fst a) , coe (sym (filler (fst a))) (snd a)) , ~refl))
      -- lem3 = refl

      -- lem3' : happly (funextâ†’ (ua âˆ˜ fibre-straighten (Pb âˆ˜ g))) ï¼ ua âˆ˜ fibre-straighten (Pb âˆ˜ g)
      -- lem3' = refl

      -- lem4 : strait-bundle-map' (Î£ _ (Pb âˆ˜ g) , fst) (Pb , happly (funextâ†’ (ua âˆ˜ fibre-straighten (Pb âˆ˜ g))))
      --        ï¼ ((Î£ _ Pb , fst) , tofibeq' Î» a â†’ coeâ‰ƒ (ua (fibre-straighten (Pb âˆ˜ g) a)) âˆ™â‰ƒ (fibre-straighten Pb (g a)) eâ»Â¹)
      -- lem4 = refl

      lem4' : âˆ€ a â†’ coeâ‰ƒ (ua (fibre-straighten (Pb âˆ˜ g) a)) âˆ™â‰ƒ (fibre-straighten Pb (g a)) eâ»Â¹
                  ï¼ (fibre-straighten (Pb âˆ˜ g) a) âˆ™â‰ƒ (fibre-straighten Pb (g a)) eâ»Â¹
      lem4' a = ap (_âˆ™â‰ƒ (fibre-straighten Pb (g a)) eâ»Â¹) coeâ‰ƒ-ua

      -- lem5 : fst (tofibeq' Î» a â†’ (fibre-straighten (Pb âˆ˜ g) a) âˆ™â‰ƒ (fibre-straighten Pb (g a)) eâ»Â¹)
      --        ï¼ ((Î» a â†’ (g (fst a)) , a .snd) , ~refl)
      -- lem5 = refl

      PACART : is-cartesian-bmap _
      PACART = tofibeq'.eq'
                    (Î» a â†’
                      fibre-straighten (Pb âˆ˜ g) a âˆ™â‰ƒ coeâ‰ƒ (sym (filler a)) âˆ™â‰ƒ fibre-straighten Pa (f a) eâ»Â¹)
                    (Î» a â†’
                      _â‰ƒ_.has-is-eqv (fibre-straighten (Pb âˆ˜ g) a âˆ™â‰ƒ coeâ‰ƒ (sym (filler a)) âˆ™â‰ƒ fibre-straighten Pa (f a) eâ»Â¹))

      PBCART : is-cartesian-bmap _
      PBCART = tofibeq'.eq'
                  (Î» aâ‚ â†’
                     fibre-straighten (Pb âˆ˜ g) aâ‚ âˆ™â‰ƒ fibre-straighten Pb (g aâ‚) eâ»Â¹)
                  (Î» aâ‚ â†’
                     _â‰ƒ_.has-is-eqv
                     (fibre-straighten (Pb âˆ˜ g) aâ‚ âˆ™â‰ƒ fibre-straighten Pb (g aâ‚) eâ»Â¹))

      lem5'' : strait-bundle-map' (Î£ _ (Pb âˆ˜ g) , fst)
                                  (Pa , (ua âˆ˜ fibre-straighten (Pb âˆ˜ g)) ~âˆ™ (filler ~â»Â¹))
             ï¼ ((Î£ _ Pa , fst) , (((Î» a â†’ f (fst a) , coe (sym (filler (fst a))) (snd a)) , ~refl)) , PACART)
      lem5'' = Î£-pathâ†’ (refl , ap tofibeq (funextâ†’ lem2))

      lem5''' : strait-bundle-map' (Î£ _ (Pb âˆ˜ g) , fst) (Pb , ua âˆ˜ fibre-straighten (Pb âˆ˜ g))
              ï¼ ((Î£ _ Pb , fst) , ((Î» a â†’ g (fst a) , snd a) , ~refl) , PBCART)
      lem5''' = Î£-pathâ†’ (refl , (ap tofibeq (funextâ†’ lem4')))


      lem5' : intermap2 ( (Î£ _ (Pb âˆ˜ g) , fst)
                        , (Pa , (ua âˆ˜ fibre-straighten (Pb âˆ˜ g)) ~âˆ™ (filler ~â»Â¹))
                        , (Pb , funextâ†’ (ua âˆ˜ fibre-straighten (Pb âˆ˜ g))))
            ï¼ ((Î£ _ (Pb âˆ˜ g) , fst)
               , ((Î£ _ Pa , fst) , (((Î» a â†’ f (fst a) , coe (sym (filler (fst a))) (snd a)) , ~refl)) , PACART)
               , (Î£ _ Pb , fst) , ((Î» a â†’ g (fst a) , snd a) , ~refl) , PBCART)
      lem5' = Î£-pathâ†’ (refl , (Ã—-pathâ†’ (lem5'' , lem5''')))
}
%```
}
