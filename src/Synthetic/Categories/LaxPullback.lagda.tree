\title{Lax pullbacks}
\taxon{Module}
\author{samueltoth}
\date{2025-12-09}

\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.LaxPullback
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Core.Orthogonal
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.NaturalTransformation Î”Â¹ I I-distr
}
%```

\subtree[tot-0000]{
\title{Lax cones over a cospan}
\taxon{Definition}

\p{Given a [cospan diagram](stt-0039) #{S}, we consider the lax cones over #{S}.
This is analogous to the type of [cones over #{S}](stt-003A) but with the filler now
being a morphism, not a path.}

%```agda
\agda{
record Lax-cone {ğ“¤ ğ“¥ ğ“¦} (S : Cospan ğ“¤ ğ“¥ ğ“¦) {ğ“›} (Carrier : Type ğ“›)
  : Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›) where
  constructor mk-lax-cone
  open Cospan S
  field
    p : Carrier â†’ Left
    q : Carrier â†’ Right
    filler : âˆ€ (a : Carrier) â†’ Hom Centre (left (p a)) (right (q a))
}
%```
}


\subtree[tot-0001]{
\title{Lax pullback}
\taxon{Definition}

\p{Again analogously to undirected pullbacks, for any lax cone #{C} over a cospan
#{S}, we can define a canonical map #{(Q \to C) \to \mathrm{Lax-cone}_S(Q)}.
We call #{C} a lax pullback cone when this map is an equivalence.}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {S : Cospan ğ“¤ ğ“¥ ğ“¦} {ğ“›} {Carrier : Type ğ“›} where
  lax-cone-map : Lax-cone S Carrier
               â†’ âˆ€ {ğ“ } {Q : Type ğ“ } â†’ (Q â†’ Carrier) â†’ Lax-cone S Q
  lax-cone-map cone f = mk-lax-cone (p âˆ˜ f) (q âˆ˜ f) (filler âˆ˜ f) where
    open Lax-cone cone

  is-lax-pullback : Lax-cone S Carrier â†’ TypeÏ‰
  is-lax-pullback cone
    = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-equiv (lax-cone-map cone {ğ“ }{Q})
}
%```
}

\subtree[tot-0002]{
\title{Canonical lax pullbacks}
\taxon{Construction}

\p{The lax pullback of a [cospan diagram](stt-0039) (called the comma category
when type involved are all [(pre)categories](stt-00AI)) is written
#{f \downarrow g}. It can be constructed as the type:}

##{\Sigma_{a : A} \Sigma_{c : C} \Hom_B(f(a), g(c))}


%```agda
\agda{
_â†“_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : A â†’ B) (g : C â†’ B) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
f â†“ g = Î£[ a âˆ¶ _ ] Î£[ c âˆ¶ _ ] Hom _ (f a) (g c)

â†“-cone : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : A â†’ B) (g : C â†’ B) â†’ Lax-cone (mk-cospan _ f g) (f â†“ g)
â†“-cone f g = mk-lax-cone fst (fst âˆ˜ snd) (snd âˆ˜ snd)

â†“-is-lax-pullback
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {f : A â†’ B} {g : C â†’ B}
    â†’ is-lax-pullback (â†“-cone f g)
â†“-is-lax-pullback = is-equivâ†qiso qiso where
  open Lax-cone
  qiso : quasi-iso (lax-cone-map (â†“-cone _ _))
  qiso .fst cone x = (cone .p x , cone .q x , cone .filler x)
  qiso .snd .fst = ~refl
  qiso .snd .snd = ~refl
}
%```
}

\subtree[tot-0004]{
\title{Slice categories as lax pullbacks}
\taxon{Example}

\p{A common example of a comma category is a slice category. Given a type
#{C} and #{c}, an object of #{C}, we consider the category #{C/c} of which
the objects consists of pairs of objects of #{C} together with maps into #{c}.
}

\p{We generalise this notation slightly, to consider any diagram
#{F : \mathcal{I}\to C}, which gives rise to the slice category #{C/F} for which
the objects consists of pairs of objects of #{c}, now with a natural transformation
#{\Delta_c \to F}. This type #{C/F} is the lax pullback of the following diagram:}

\quiver{
\begin{tikzcd}[cramped]
	{C/F} && C \\
	\\
	1 && {C^I}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=3-3]
	\arrow["\Delta", from=1-3, to=3-3]
	\arrow["F"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{We retain the original notion of slice category by taking the slice of an
object #{c} considered as a function #{1 \to C}.}

%```agda
\agda{
Slice : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} (F : I â†’ C) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
Slice f = Î£[ c âˆ¶ _ ] âˆ€ i â†’ Hom _ c (f i)

Slice-cone : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥}
           (F : I â†’ C) â†’ Lax-cone (mk-cospan _ (const C I) (const _ ğŸ™ F)) (Slice F)
Slice-cone F .Lax-cone.p (c , _) = c
Slice-cone F .Lax-cone.q (c , g) = tt
Slice-cone F .Lax-cone.filler (_ , f) = Homâ†NT f

Slice-is-lax-pullback : âˆ€ {ğ“¤ ğ“¥} {C : Type ğ“¤} {I : Type ğ“¥} (F : I â†’ C)
                    â†’ is-lax-pullback (Slice-cone F)
Slice-is-lax-pullback F = is-equivâ†qiso qiso where
  qiso : quasi-iso (lax-cone-map (Slice-cone F))
  qiso .fst cone x = (cone .Lax-cone.p x , NTâ†Hom (cone .Lax-cone.filler x))
  qiso .snd .fst f = funextâ†’ (Î» q â†’ Î£-pathâ†’ (refl , _â‰ƒ_.Îµ NTâ‰ƒHom (f q .snd)))
  qiso .snd .snd c = ap (mk-lax-cone (Lax-cone.p c) (Î» _ â†’ tt))
                        (funextâ†’ (_â‰ƒ_.Î· NTâ‰ƒHom âˆ˜ Lax-cone.filler c))
}
%```
}
