\title{The pushout join}
\taxon{Module}
\date{2026-01-12}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.PushoutJoin
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Data.Bool

open import Core.Orthogonal
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.PushoutSum
open import Core.FunctorialPullback
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.CoSlice
open import Core.Slice

open import Ergonomics.Notations.Orthogonality
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.JoinSlice Î”Â¹ I I-distr
}
%```

\subtree[stt-00DE]{
\taxon{Definition}
\title{Pushout joins}

\p{Just as we could [extend the product bifunctor to an operation on
arrows](stt-00BS), we can do the same for the [directed join](stt-00CW)
bifunctor. Given maps #{f : A \to B} and #{g : C \to D}, we define
#{f \hat{\rtimes} g} to be the cogap map of the following square.}

\quiver{
\begin{tikzcd}
	{A \rtimes C} && {A \rtimes D} \\
	& \bullet \\
	{B \rtimes C} && {B \rtimes D}
	\arrow["{A \rtimes g}", from=1-1, to=1-3]
	\arrow["{f\rtimes C}"', from=1-1, to=3-1]
	\arrow[from=1-3, to=2-2]
	\arrow["{f \rtimes D}", from=1-3, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=2-2, to=1-1]
	\arrow["{f \hat{\rtimes}g}", from=2-2, to=3-3]
	\arrow[from=3-1, to=2-2]
	\arrow["{B \rtimes g}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{We also note that this map can be considered a map in the slice over #{D}.}

%```agda
\agda{
Join-square
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (g : X â†’ Y)
    â†’ Arrow-map (f â‹‰â‚ id {A = X}) (f â‹‰â‚ id {A = Y})
Join-square f g .Arrow-map.top = id â‹‰â‚ g
Join-square f g .Arrow-map.bot = id â‹‰â‚ g
Join-square f g .Arrow-map.comm = (â‹‰â‚-âˆ˜ id f g id ~â»Â¹) ~âˆ™ â‹‰â‚-âˆ˜ f id id g

Pushout-join
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (g : X â†’ Y)
    â†’ Pushoutâ‚€ (Coconeâ†Arrow-map (Join-square f g) .fst) â†’ B â‹‰ Y
Pushout-join f g = cogap-mapâ†square (Join-square f g)

Pushout-join-coslice
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (g : X â†’ Y)
    â†’ Coslice-map {X = Pushoutâ‚€ (Coconeâ†Arrow-map (Join-square f g) .fst)}
                  (Î¹â‚‚ âˆ˜ â†‘-Î¹â‚‚)
                  {Y = B â‹‰ Y} â†‘-Î¹â‚‚
Pushout-join-coslice f g .fst = Pushout-join f g
Pushout-join-coslice f g .snd = ~refl
}
%```
}

\subtree[stt-00DF]{
\title{Pullback Slices}
\taxon{Definition}

\p{Now given a map in the coslice #{s : t \to^A t'}, and a map #{f : X \to Y},
we construct the \strong{pullback slice} #{s \hat{/} f} as the gap map of the
following square:}

\quiver{
\begin{tikzcd}
	{S_{/t}} && {S_{/tf}} \\
	& \bullet \\
	{T_{/t'}} && {T_{/t'f}}
	\arrow[from=1-1, to=1-3]
	\arrow["{s \hat{/}f}", dashed, from=1-1, to=2-2]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=2-2, to=1-3]
	\arrow[from=2-2, to=3-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
	\arrow[from=3-1, to=3-3]
\end{tikzcd}
}


%```agda
\agda{
extend-slice-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§} {P : Type ğ“¤} {Q : Type ğ“¥} {A : Type ğ“¦} {B : Type ğ“§}
      (p : P â†’ A) (q : Q â†’ A) (f : A â†’ B)
    â†’ Slice-map p q â†’ Slice-map (f âˆ˜ p) (f âˆ˜ q)
extend-slice-map p q f = total-map (Î» _ â†’ f â—‚_)

slice-square
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ} {p : K â†’ A}
       {S : Type ğ“} {q : S â†’ A} (g : Slice-map p q)
    â†’ Arrow-map (precompose-slice q f) (precompose-slice p f)
slice-square f {p = p} {q = q} G .Arrow-map.top
  = slice-map-slice p q G
slice-square f {p = p} {q = q} G .Arrow-map.bot
  = slice-map-slice (f âˆ˜ p) (f âˆ˜ q) (extend-slice-map p q f G)
slice-square f G .Arrow-map.comm a
  = Î£-pathâ†’ (refl , (funextâ†’
      (Î» k â†’ Hom-extâ†’ (~refl , ap-âˆ™ f _ refl , ap-âˆ™ f _ (G .snd k)))))

pullback-slice
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ} {p : K â†’ A}
       {S : Type ğ“} {q : S â†’ A} (g : Slice-map p q)
    â†’ Slice A q
    â†’ Pullback (slice-map-slice (f âˆ˜ p) (f âˆ˜ q) (extend-slice-map _ q f g))
               (precompose-slice p f)
pullback-slice f g = gap-mapâ†square (slice-square f g)

slice-hom
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ}
       {S : Type ğ“} {q : S â†’ A} (t : K â†’ S)
     â†’ Arrow-map (precompose-slice q f) (precompose-slice (q âˆ˜ t) f)
slice-hom f t .Arrow-map.top = postcompose-slice _ t
slice-hom f t .Arrow-map.bot = postcompose-slice _ t
slice-hom f t .Arrow-map.comm a = refl

pullback-slice'
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ}
       {S : Type ğ“} (q : S â†’ A) (t : K â†’ S)
    â†’ Slice A q â†’ Pullback (postcompose-slice (f âˆ˜ q) t)
                           (precompose-slice (q âˆ˜ t) f)
pullback-slice' f q t = gap-mapâ†square (slice-hom f t)

hom-fam-as-slice : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’
  âˆ€ x â†’ Arrow-map (pullback-slice (! {A = A}) {p = Â¡_} {q = Î» (_ : ğŸ™) â†’ x}
                                  (Â¡_ , (Î» ())))
                  (fst {B = (Î» y â†’ Hom A y x)})
hom-fam-as-slice x .Arrow-map.top (a , b) = a , b tt
hom-fam-as-slice x .Arrow-map.bot (a , b , p) = b .fst
hom-fam-as-slice x .Arrow-map.comm = ~refl
}
%```
}

\subtree[stt-00DR]{
\title{The pushout join, pullback slice adjunction}
\taxon{Theorem}

\p{Just as the product-hom adjunction can be extended to an adjunction between
the [pushout product](stt-00BS) and the [pullback power](Core.PullbackPower), we
can extend the [join-slice adjunction](stt-00D5), to an adjunction between the
[pushout join](stt-00DE) and [pullback slice](stt-00DF).}

\remark{
\p{This result has not been formalised - and I suspect it would be quite involved
and require dealing with a lot of coherence. See \citek{JKL2026} for a
discussion (and formalisation) of the pushout-product and pullback-hom adjunction
mentioned above.}
}

%```agda
\agda{
power-hom-coslice
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
      {A : Type ğ“¤} {B : Type ğ“¥} (p : Y â†’ A) (q : Y â†’ B) (F : Coslice-map p q)
      {C : Type ğ“¦} {D : Type ğ“œ} (r : Y â†’ C) (s : Y â†’ D) (G : Coslice-map r s)
    â†’ Arrow-map (Coslice-map-postcompose r F) (Coslice-map-postcompose s F)
power-hom-coslice p q F r s G .Arrow-map.top = Coslice-map-precompose q G
power-hom-coslice p q F r s G .Arrow-map.bot = Coslice-map-precompose p G
power-hom-coslice p q F r s G .Arrow-map.comm x
  = Î£-pathâ†’ (refl , (funextâ†’ (Î» a â†’ ap (_âˆ™ G .snd a) (ap-âˆ™ (G .fst) _ (x .snd a)
                  âˆ™ ap (_âˆ™ ap (G .fst) _)
                         (sym (ap-âˆ˜ (G .fst) (x .fst) (F .snd a))))
                  âˆ™ âˆ™-assoc _ (ap (G .fst) (x .snd a)) (G .snd a))))

pullback-coslice-power
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
      {A : Type ğ“¤} {B : Type ğ“¥} (p : Y â†’ A) (q : Y â†’ B) (F : Coslice-map p q)
      {C : Type ğ“¦} {D : Type ğ“œ} (r : Y â†’ C) (s : Y â†’ D) (G : Coslice-map r s)
    â†’ Coslice-map q r
    â†’ Pullback (Coslice-map-precompose p G) (Coslice-map-postcompose s F)
pullback-coslice-power p q F r s G
  = gap-mapâ†square (power-hom-coslice p q F r s G)
}
%```
}
