\date{2025-11-24}
\title{Covariant families}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Covariant
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Core.Orthogonal
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
}
%```



\subtree[stt-00AO]{
\title{Covariant families}

%```agda
\agda{
is-left : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-left = is-local (Î» (_ _ : ğŸ™) â†’ i0)

is-groupoid : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-groupoid = is-null (Î» (_ : ğŸ™) â†’ Î”Â¹)

module Grpd where
  Grpd-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
  Grpd-SubU = Null-SubU (Î» (_ : ğŸ™) â†’ Î”Â¹) _

  Grpd-GSU : GSU (_âŠ” ğ“˜)
  Grpd-GSU = Null-GSU (Î» (_ : ğŸ™) â†’ Î”Â¹)

  Grpd-is-globally-reflective
    : is-globally-reflective Grpd-GSU
  Grpd-is-globally-reflective = Null-globally-reflective

  open GRSUInduction Grpd-is-globally-reflective
                     Null-globally-Î£-closed public

  open GSU Grpd-GSU public renaming (S-equiv to is-simplicialâ†equiv)

  open GPiClosure Grpd-is-globally-reflective public

  open is-globally-reflective Grpd-is-globally-reflective

  Î£-is-groupoid = Null-globally-Î£-closed

is-groupoidâ†is-left : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-left A â†’ is-groupoid A
is-groupoidâ†is-left {_}{A} il x
  = is-equiv~âˆ˜ lem (is-equivâ»Â¹ (il x))
                   unit-const-is-equiv where
  open is-equiv (il x)

  lem : const A Î”Â¹ ~ bwd âˆ˜ const A ğŸ™
  lem = il x â—‚eqv ((Îµ â–¸ const A ğŸ™) ~â»Â¹)


is-leftâ†is-groupoid : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-groupoid A â†’ is-left A
is-leftâ†is-groupoid {_} {A} gp x
  =  is-equiv~âˆ˜ H unit-const-is-equiv (is-equivâ»Â¹ (gp x)) where
  open is-equiv (gp x)

  H : postcomp A (Î» (_ : ğŸ™) â†’ i0) ~ const A ğŸ™ âˆ˜ bwd
  H = ((const A ğŸ™ â—‚ Î·) ~â»Â¹) â–¸eqv (gp x)


is-covariant : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
               â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-covariant {A = A} B
    = âˆ€ (x : Î”Â¹ â†’ A) (xâ‚€ : B (x i0))
      â†’ is-singleton (Î£[ xâ‚ âˆ¶ B (x i1)] HomP (B âˆ˜ x) xâ‚€ xâ‚)

tr-cov : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
       â†’ is-covariant P â†’ (h : Î”Â¹ â†’ A) â†’ P (h i0) â†’ P (h i1)
tr-cov cov h = fst âˆ˜ centre âˆ˜ cov h
}
%```
}


\subtree[stt-00AV]{
\title{Left fibrations}
\taxon{Definition}

%```agda
\agda{
is-left-fibration : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B)
                    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“˜)
is-left-fibration f = (Î» (_ : ğŸ™) â†’ i0) âŠ¥ f
}
%```
}


\subtree[stt-00AR]{
\title{Covariant families straighten to left fibrations}
\taxon{Theorem}

\p{We show that some family #{P : A \to \UU} is [covariant](stt-00AO) iff the map
#{\pi : \tilde{P} \to A} is a [left fibration](stt-00AV).}

%```agda
\agda{
is-covariantâ‡”is-left-fibration
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
    â†’ is-covariant B â‡” is-left-fibration (fst {B = B})
is-covariantâ‡”is-left-fibration {A = A} B
  = (fwd , bwd) where
  opaque
    arrow-map-snd : (F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B}))
                    â†’ B (F .Arrow-map.bot i0)
    arrow-map-snd (mk-amap top bot comm) = tr B (sym (comm tt)) (top tt .snd)

    Î£â†arrow-map : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
                â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (B (f i0))
    Î£â†arrow-map F = F .bot , arrow-map-snd F where open Arrow-map

    lemma : âˆ€ (f : Î”Â¹ â†’ A) (xâ‚€ : B (f i0))
            â†’ let F = mk-amap {f = Î» (_ : ğŸ™) â†’ i0} {f' = fst {B = B}}
                              (Î» _ â†’ f i0 , xâ‚€) f ~refl
            in Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€)
            â‰ƒ Lift F
    lemma f xâ‚€ = eqv where
      F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
      F = mk-amap (Î» _ â†’ f i0 , xâ‚€) f ~refl

      open Arrow-map F
      open HomP
      bwd : Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â†’ Lift F
      bwd (xâ‚ , h@(mk-hom hom refl hom1))
          = mk-lift (Î» x â†’ f x , hom x) ~refl ~refl ~refl

      lemma2 : (Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
                ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚)))
              â‰… (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
      lemma2 ._â‰…_.fwd (_ , h , p , refl) = (h , p)
      lemma2 ._â‰…_.fwd-iso .fst (h , p) = (h i1 , h , p , refl)
      lemma2 ._â‰…_.fwd-iso .snd .fst (_ , h , p , refl) = refl
      lemma2 ._â‰…_.fwd-iso .snd .snd = ~refl


      eqv : Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒ Lift F
      eqv
        = Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» _ â†’ HomP-reprâ‰ƒ) âŸ©
          Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
            ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚))
                                         â‰ƒâŸ¨ equivâ†qiso lemma2 âŸ©
          (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
                                         â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst
                                              {B = Î» where (f , p) â†’ tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€}
                                              (mkâ‰ƒ (extensionâ†Î  {B = B} f) (extensionâ†Î -is-equiv f)) âŸ©
          (Î£[ (f , p) âˆ¶ fibre (precomp Î”Â¹ (Î» r â†’ fst r)) f ]
           (tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€))
                                         â‰ƒâŸ¨ Î£-assoc âŸ©
          Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ]
              Î£[ H âˆ¶ (fst âˆ˜ f' ï¼ f) ]
              (tr B (happly H i0) (snd (f' i0)) ï¼ xâ‚€)
                  â‰ƒâŸ¨ Î£-ap-â‰ƒ
                       (Î» f' â†’ Î£-ap-â‰ƒ-fst
                               {B = Î» H â†’ tr B (H i0) (snd (f' i0)) ï¼ xâ‚€}
                               funextâ‰ƒ) âŸ©
          Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
              (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
                 â‰ƒâŸ¨ Î£-ap-â‰ƒ
                     (Î» f' â†’ Î£-ap-â‰ƒ
                       (Î» H â†’ Î£-singl
                         {B = Î» (K , _) â†’ tr B K (snd (f' i0)) ï¼ xâ‚€ }
                         Sing-is-singleton
                         (H i0 , refl) eâ»Â¹
                       âˆ™â‰ƒ Î£-assoc âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ Ã—-swap âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» _ â†’ symâ‰ƒ) ))) âŸ©

          Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
            Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
              (K1 ï¼ H i0)
                                         â‰ƒâŸ¨ Î£-ap-â‰ƒ
                                             (Î» f' â†’ Î£-ap-â‰ƒ
                                               (Î» H â†’ Î£-ap-â‰ƒ-fst
                                                       {B = Î» (K , _) â†’ K ï¼ H i0}
                                                       (Î£-path {x = f' i0}
                                                               {y = _ , xâ‚€} eâ»Â¹)
                                               âˆ™â‰ƒ Î£-assoc)) eâ»Â¹ âŸ©

          Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
            Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
                â‰ƒâŸ¨ Î£-ap-â‰ƒ
                    (Î» f' â†’ Î£-ap-â‰ƒ
                             (Î» H â†’ Î£-ap-â‰ƒ-fst {B = Î» K â†’ ap fst K ï¼ H i0}
                                               (unit-UPâ‰ƒ) eâ»Â¹
                                    âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ unit-UPâ‰ƒ eâ»Â¹))
                            âˆ™â‰ƒ Î£-comm) âŸ©
          Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
             Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
               â‰ƒâŸ¨ Î£-ap-â‰ƒ
                   (Î» f' â†’ Î£-ap-â‰ƒ
                     (Î» K â†’ Î£-ap-â‰ƒ (Î» H â†’ ~reflrâ‰ƒ {f = const _ _ (f i0)} _ _))) âŸ©
          Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
             Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0) ~âˆ™ ~refl )
               â‰ƒâŸ¨ Lift-reprâ‰ƒ F eâ»Â¹ âŸ©
          Lift F                         â‰ƒâˆ



    fwd : is-covariant B â†’ is-left-fibration (fst {B = B})
    fwd cov a@(mk-amap top bot comm)
      = is-singleâ†equiv-to-single
          ( lemma bot (tr B (sym (comm tt)) (snd (top tt)))
          âˆ™â‰ƒ coeâ‰ƒ (ap Lift (Arrow-map-pathâ†’ ((Î» aâ‚ â†’ Î£-pathâ†’ ((comm tt) , trâˆ™tr-sym' (comm tt) (snd (top tt))))
                                            , (~refl , (Î» _ â†’ Î£-path-ap-fst))))))
          (cov bot (arrow-map-snd a))

    bwd : is-left-fibration (fst {B = B}) â†’ is-covariant B
    bwd lfib f xâ‚€ = is-singleâ†equiv-to-single
         (lemma f xâ‚€  eâ»Â¹)
         (lfib (mk-amap (Î» _ â†’ (f i0 , xâ‚€)) f ~refl))
}
%```
}

\subtree[stt-00AS]{
\title{There is a universe of amazingly covariant types}
\taxon{Cosntruction}

\p{Assuming that the interval is [tiny](Synthetic.Tiny), there is a universe of
\em{amazingly covariant types}, which weakly classify the left fibrations.
We denote it #{\mathcal{s}}.}

\proof{
\p{Since being covariant is equivalent to being a left fibration, it is stable
under base change, and so is a [relative notion of fibrancy](stt-00AO). By the machinery
developed for [amazing right adjoints](stt-00AA) we can construct a universe.
}
}

%```agda
\agda{
module UCov where
  open import Synthetic.Tiny Î”Â¹

  is-covariant-is-relative : is-relative is-covariant
  is-covariant-is-relative {A = A} P = (fwd , bwd) where
    fwd : is-covariant P â†’ (x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)
    fwd cov f h = cov (f âˆ˜ h)

    bwd : ((x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)) â†’ is-covariant P
    bwd cov h xâ‚€ = cov h id xâ‚€

  open AFib is-covariant is-covariant-is-relative public
    renaming (is-afib to is-acov;
              UFib to ğ“¢;
              UFibâˆ™ to ğ“¢âˆ™;
              F-Ï€-is-fib to ğ“¢-Ï€-is-covariant)
}
%```
}

\subtree[stt-00AU]{
\title{The objects of #{\mathcal{S}} are groupoids}
\taxon{Theorem}

\p{If #{A :^\flat \UU} is a groupoid, then #{A} is amazing covariant and so
factors through #{\mathcal{S}}.}

%```agda
\agda{
  groupoids-in-ğ“¢ : âˆ€ {@â™­ ğ“¤} (@â™­ A : Type ğ“¤) â†’ @â™­ is-groupoid A â†’ is-acov A
  groupoids-in-ğ“¢ A gpd
    = Îµâ™­ (liftFib .fst
           (modâ™­ (is-covariantâ‡”is-left-fibration
                   (Î» _ â†’ A) .snd
                     (is-orthogonalâ‡”orthogonal-! .snd
                       (is-leftâ†is-groupoid
                         (Null-globally-Î£-closed
                           (Grpd.ğŸ™âˆˆS)
                           (Î» _ â†’ gpd)) tt))))) tt
}
%```
}


\subtree[stt-00AT]{
\title{#{\mathcal{S}} is directed univalent}
\taxon{Theorem}

\p{We show that #{\mathcal{S}} is directed univalent. That is, arrows in
#{\mathcal{S}} correspond exactly to pairs of groupoids, together with a function
between them.}

%```agda
\agda{
  tr-ğ“¢ : âˆ€ {@â™­ ğ“¤} â†’ (f : Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ fst (f i0) â†’ fst (f i1)
  tr-ğ“¢ = tr-cov {P = fst} ğ“¢-Ï€-is-covariant

  duaâ†’ : âˆ€ {@â™­ ğ“¤} â†’ (Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ Î£[ A âˆ¶ ğ“¢ ğ“¤ ] Î£[ B âˆ¶ ğ“¢ ğ“¤ ] (fst A â†’ fst B)
  duaâ†’ h = (h i0 , h i1 , tr-ğ“¢ h)
}
%```
}
