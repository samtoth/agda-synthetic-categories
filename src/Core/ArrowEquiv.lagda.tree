\date{2025-06-03}
\title{Equivalences of arrows}
\author{samueltoth}
\import{stt-macros}
\taxon{Module}

%```agda
\agda{
module Core.ArrowEquiv where

open import ufAxioms
open import Foundations.Prelude
open import Foundations.TypeFamily

open import Core.Arrow
open import Core.CoSlice
}
%```

\subtree[stt-004R]{
\taxon{Definition}
\title{Arrow equivalences}

\p{A pair of arrows #{A \xrightarrow{f} B} and #{X \xrightarrow{g} Y} are said
to be equivalent if there exists an [arrow map](stt-003U) where both horizontal
morphisms are themselves equivalences.}

\quiver{
\begin{tikzcd}
	A && X \\
	\\
	B && Y
	\arrow["\sim", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["\sim"', from=3-1, to=3-3]
\end{tikzcd}
}

%```agda
\agda{
is-Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                   {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                 â†’ Arrow-map f g â†’ Type _
is-Arrow-equiv {f = f} {g} (mk-amap top bot comm)
  = is-equiv top Ã— is-equiv bot

id-square-is-equiv
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
      {f : A â†’ B}
    â†’ is-Arrow-equiv (id-square {f = f})
id-square-is-equiv .fst = id-is-equiv
id-square-is-equiv .snd = id-is-equiv

Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                {Y : Type ğ“œ} (f : A â†’ B) (g : X â†’ Y)
              â†’ Type _
Arrow-equiv f g = Î£[ F âˆ¶ Arrow-map f g ] is-Arrow-equiv F

Arrowâ»Â¹â†is-Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                     â†’ (F : Arrow-map f g)
                     â†’ is-Arrow-equiv F
                     â†’ Arrow-map g f
Arrowâ»Â¹â†is-Arrow-equiv {f = f}{g} (mk-amap top bot comm) (teq , beq)
  = mk-amap top.bwd bot.bwd H module Arrowâ»Â¹ where opaque
  module top = is-equiv teq
  module bot = is-equiv beq

  K : bot âˆ˜ bot.bwd âˆ˜ g âˆ˜ top ~ bot âˆ˜ f âˆ˜ top.bwd âˆ˜ top
  K =   bot.Îµ â–¸ g â–¸ top
     ~âˆ™ (comm ~â»Â¹)
     ~âˆ™ (bot â—‚ f â—‚ top.Î· ~â»Â¹)

  H : (bot.bwd âˆ˜ g) ~ (f âˆ˜ top.bwd)
  H = beq â—‚eqv K â–¸eqv teq

Arrowâ»Â¹-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                     â†’ (F : Arrow-map f g)
                     â†’ (eq : is-Arrow-equiv F)
                     â†’ is-Arrow-equiv (Arrowâ»Â¹â†is-Arrow-equiv F eq)
Arrowâ»Â¹-is-equiv F (teq , beq) = (is-equivâ»Â¹ teq  , is-equivâ»Â¹ beq)
}
%```
}

\subtree[fre-0004]{
\title{Basic operations on arrow equivalences}
\author{fredrikbakke}

%```agda
\agda{
Arrow-equivâ†â‰ƒá¶ 
  : {ğ“¤1 ğ“¤2 ğ“¥1 ğ“¥2 : Level}
    (F : Fam ğ“¤1 ğ“¤2)
    (G : Fam ğ“¥1 ğ“¥2)
  â†’ F â‰ƒá¶  G â†’ Arrow-equiv (arrâ†Fam F) (arrâ†Fam G)
Arrow-equivâ†â‰ƒá¶  (A , B) (X , Y) (e , ef)
  = mk-amap top bot ~refl
  , top-is-equiv
  , bot-is-equiv
  where
  top : Î£ A B â†’ Î£ X Y
  top = total-map-fst (e ._â‰ƒ_.fwd) âˆ˜ total-map (Î» a â†’ ef a ._â‰ƒ_.fwd)

  bot : A â†’ X
  bot = e ._â‰ƒ_.fwd

  top-is-equiv : is-equiv top
  top-is-equiv
    = is-equiv-âˆ˜
        (total-is-equivâ†fst-is-equiv (e ._â‰ƒ_.has-is-eqv))
        (is-total-equivâ†is-fibrewise-equiv (Î» a â†’ ef a ._â‰ƒ_.has-is-eqv))

  bot-is-equiv : is-equiv bot
  bot-is-equiv = e ._â‰ƒ_.has-is-eqv

concat-Arrow-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“  ğ“¡}
      {A : Type ğ“¤}
      {B : Type ğ“¥}
      {C : Type ğ“¦}
      {D : Type ğ“œ}
      {E : Type ğ“ }
      {F : Type ğ“¡}
      {f : A â†’ B}
      {g : C â†’ D}
      {h : E â†’ F}
    â†’ Arrow-equiv f g
    â†’ Arrow-equiv g h
    â†’ Arrow-equiv f h
concat-Arrow-equiv (p , peq) (q , qeq)
  = paste-squares q p
  , is-equiv-âˆ˜ (qeq .fst) (peq .fst)
  , is-equiv-âˆ˜ (qeq .snd) (peq .snd)

concat-Arrow-equiv-â‰ƒá¶ 
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦1 ğ“¦2 ğ“›1 ğ“›2}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      (F : Fam ğ“¦1 ğ“¦2) (G : Fam ğ“›1 ğ“›2)
    â†’ Arrow-equiv f (arrâ†Fam F)
    â†’ F â‰ƒá¶  G
    â†’ Arrow-equiv f (arrâ†Fam G)
concat-Arrow-equiv-â‰ƒá¶  F G eâ‚€ e
  = concat-Arrow-equiv eâ‚€ (Arrow-equivâ†â‰ƒá¶  F G e)

inv-Arrow-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤}
      {B : Type ğ“¥}
      {C : Type ğ“¦}
      {D : Type ğ“œ}
      {f : A â†’ B}
      {g : C â†’ D}
    â†’ Arrow-equiv f g
    â†’ Arrow-equiv g f
inv-Arrow-equiv (p , peq)
  = Arrowâ»Â¹â†is-Arrow-equiv p peq
  , Arrowâ»Â¹-is-equiv p peq
}
%```
}

\subtree[stt-004S]{
\taxon{Theorem}
\title{Arrow equivalences preserve equivalences}

\p{If there is an [arrow equivalence](stt-004R) from #{A \xrightarrow{f} B} to
#{X \xrightarrow{g} Y}, then #{f} is an equivalence iff #{g} is.
}

\proof{This is a simple application of the [3-for-2](stt-003E) property of
equivalences.}

%```agda
\agda{
is-equivâ†Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ is-equiv f â†’ is-equiv g
is-equivâ†Arrow-equiv {F = mk-amap top bot comm} (teq , beq) feq
  = 3-for-2~' comm teq (is-equiv-âˆ˜ beq feq)

is-equivâ†Arrow-equivâ»Â¹ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ is-equiv g â†’ is-equiv f
is-equivâ†Arrow-equivâ»Â¹ {F = mk-amap top bot comm} (teq , beq) geq
  = 3-for-2~ (comm ~â»Â¹) beq (is-equiv-âˆ˜ geq teq)

topâ‡”bot-is-equivâ†Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       (F : Arrow-map f g)
                       â†’ is-Arrow-equiv F
                       â†’ is-equiv f â‡” is-equiv g
topâ‡”bot-is-equivâ†Arrow-equiv F eq = ( is-equivâ†Arrow-equiv {F = F} eq
                                    , is-equivâ†Arrow-equivâ»Â¹ {F = F} eq)
}
%```
}

\subtree[stt-0069]{
\title{Arrow equivalences preserve sections}
\taxon{Theorem}

\p{If there is an [arrow equivalence](stt-004R) from #{A \xrightarrow{f} B} to
#{X \xrightarrow{g} Y}, then sections of #{f} are equivalent to sections of #{g}.
}

% TODO(sam): Look into why unification isn't working so well for arrow
%            map

%```agda
\agda{
sectionâ†Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ section f â†’ section g
sectionâ†Arrow-equiv {f = f} {g} {F = F} eq (secf , p) .fst
  = top âˆ˜ secf âˆ˜ bot.bwd where
  open Arrow-map F
  module top = is-equiv (eq .fst)
  module bot = is-equiv (eq .snd)
sectionâ†Arrow-equiv {f = f} {g} {F} eq (secf , p) .snd
  =  H â–¸ top â–¸ secf â–¸ bot.bwd
  ~âˆ™ bot â—‚ f â—‚ top.Î· â–¸ secf â–¸ bot.bwd
  ~âˆ™ bot â—‚ p â–¸ bot.bwd
  ~âˆ™ bot.Îµ where
  open Arrow-map F
  module top = is-equiv (eq .fst)
  module bot = is-equiv (eq .snd)
  H : g ~ bot âˆ˜ f âˆ˜ top.bwd
  H = comm â–¸ top.bwd ~âˆ™ g â—‚ top.Îµ ~â»Â¹

sectionâ†Arrow-equivâ»Â¹ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ section g â†’ section f
sectionâ†Arrow-equivâ»Â¹ {f = f}{g}{F} EF sec = sectionâ†Arrow-equiv {f = g}{f}
                                               {Arrowâ»Â¹â†is-Arrow-equiv F EF}
                                               (Arrowâ»Â¹-is-equiv F EF) sec
}
%```
}

\subtree[stt-007M]{
\taxon{Theorem}
\title{Pre/post-composition of arrow equivalences}
\p{Precomposition preserves arrow equivalences}

%```agda
\agda{
postcomp-Arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
    â†’ (Q : Type ğ“ )
    â†’ Arrow-map f g
    â†’ Arrow-map (postcomp Q f) (postcomp Q g)
postcomp-Arrow-map Q F = mk-amap (top âˆ˜_) (bot âˆ˜_) (funextâ†’ âˆ˜ (comm â–¸_)) where
  open Arrow-map F


postcomp-square-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
      {Q : Type ğ“ }
    â†’ is-Arrow-equiv F
    â†’ is-Arrow-equiv (postcomp-Arrow-map Q F)
postcomp-square-is-equiv F eq
  = (postcomp-equiv (eq .fst) , postcomp-equiv (eq .snd))

precomp-Arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
    â†’ (Q : Type ğ“ )
    â†’ Arrow-map f g
    â†’ Arrow-map (precomp Q g) (precomp Q f)
precomp-Arrow-map Q F = mk-amap (_âˆ˜ bot) (_âˆ˜ top) (funextâ†’ âˆ˜ (_â—‚ (comm ~â»Â¹))) where
  open Arrow-map F

precomp-square-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
      {Q : Type ğ“ }
    â†’ is-Arrow-equiv F
    â†’ is-Arrow-equiv (precomp-Arrow-map Q F)
precomp-square-is-equiv F eq
  = (precomp-equiv (eq .snd) , precomp-equiv (eq .fst))
}
%```
}

\subtree[stt-00BQ]{
\title{Arrow equivalences are cartesian squares}
\taxon{Lemma}

%```agda
\agda{
opaque
  is-cartesianâ†is-equiv
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
        {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
      â†’ (F : Arrow-map f g)
      â†’ is-Arrow-equiv F â†’ is-cartesian F
  is-cartesianâ†is-equiv F@(mk-amap top bot p) (teq , beq) b
    = is-equiv-âˆ˜
        {f = total-map-fst top}
        (total-is-equivâ†fst-is-equiv teq)
        (is-total-equivâ†is-fibrewise-equiv
          (Î» a â†’ is-equiv-âˆ˜
                   {f = sym (p a) âˆ™_}
                   (âˆ™-is-equiv (sym (p a)))
                   (is-embeddingâ†is-equiv beq)))
}
%```
}

\subtree[stt-00D7]{
\title{Right cancelling a cartesian square by an arrow equivalence}
\taxon{Lemma}

%```agda
\agda{
right-cancel-cartesian
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {ğ“¤' ğ“¥'} {A' : Type ğ“¤'} {B' : Type ğ“¥'} {f' : A' â†’ B'}
      {ğ“¤'' ğ“¥''} {A'' : Type ğ“¤''} {B'' : Type ğ“¥''} {f'' : A'' â†’ B''}
      {a : Arrow-map f' f''} {b : Arrow-map f f'}
      {H : Arrow-map f f''}
    â†’ Arrow-map-path H (paste-squares a b)
    â†’ is-cartesian H
    â†’ is-Arrow-equiv b
    â†’ is-cartesian a
right-cancel-cartesian {a = a}{b}{H} path Hc bc b'
  = is-equivâ†Arrow-equivâ»Â¹ {F = hom} hom-eq lem where
  open Arrow-map
  open is-equiv
  lem : is-equiv (arrow-fibre a (b .bot (bwd (bc .snd) b')))
  lem = 3-for-2~' {f = arrow-fibre a (b .bot (bwd (bc .snd) b'))}
                  {g = arrow-fibre b (bwd (bc .snd) b')}
                 (arrow-fibre-âˆ˜ a b (bwd (bc .snd) b'))
                 (is-cartesianâ†is-equiv b bc (bwd (bc .snd) b'))
                 (tr is-cartesian (Arrow-map-pathâ†’ path) Hc (bwd (bc .snd) b'))

  hom : Arrow-map (arrow-fibre a b') (arrow-fibre a (b .bot (bwd (bc .snd) b')))
  hom .top = total-map (Î» x â†’ _âˆ™ sym (Îµ (bc .snd) b'))
  hom .bot = total-map (Î» x â†’ _âˆ™ ap (bot a) (sym (Îµ (bc .snd) b')))
  hom .comm (x , refl)
    = Î£-pathâ†’ (refl , ap (_âˆ™ ap (bot a) _) (âˆ™-reflr (sym (comm a x))))

  hom-eq : is-Arrow-equiv hom
  hom-eq .fst = is-total-equivâ†is-fibrewise-equiv Î» _ â†’ âˆ™-is-equiv' _
  hom-eq .snd = is-total-equivâ†is-fibrewise-equiv Î» _ â†’ âˆ™-is-equiv' _
}
%```
}
