\date{2025-06-17}
\title{Localisations}
\taxon{module}
\meta{module}{\startverb modalities.instances.Localisation \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module modalities.instances.Localisation where

open import ufAxioms
open import axioms.FreeAlgInj
open import foundations.Prelude
open import core.Orthogonal
open import core.CanonicalPushouts
open import ergonomics.notations.Orthogonality
open core.Orthogonal.notation
}
%```

\subtree[stt-005F]{
\taxon{definition}
\title{Local types}

\p{Given a family of maps #{f_i : A_i \to B_i}, we say that a type
is #{f}-local if it is [orthogonal](stt-004O) to each map.}

%```agda
\agda{
is-local : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘} {A : I → Type 𝓤} {B : I → Type 𝓥}
               → (f : (i : I) → A i → B i)
               → Type 𝓦
               → Type (𝓘 ⊔ 𝓤 ⊔ 𝓥 ⊔ 𝓦)
is-local f A = ∀ i → orthogonal-type (f i) A
}
%```
}


\subtree[stt-005G]{
\taxon{definition}
\title{Null types}

\p{Given a family of types #{A_i}, we say a type #{X} is #{A} null if
it is right orthogonal to each #{A_i}. Or equivalently, if the
obvious maps #{X \to (A_i \to X)} are equivalences for each #{i}.}

%```agda
\agda{
is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} (A : I → Type 𝓤)
            → Type 𝓥 → Type (𝓘 ⊔ 𝓤 ⊔ 𝓥)
is-null A X = ∀ i → is-equiv (const X (A i))
}
%```
}

\subtree[stt-005H]{
\taxon{theorem}
\title{Null types are #{!\rm{-local}}}

\p{A type is #{A_i}-null iff it is #{(! : A_i \to 1)\rm{-local}}.}

\proof{
\p{A type #{X} is #{!\rm{-local}} when the map #{- \circ\ ! : (1 \to X) \to (A_i \to X)}
is an equivalence.}
}

%```agda
\agda{
is-local←is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} {A : I → Type 𝓤}
                   → {X : Type 𝓥}
                   → is-null A X
                   → is-local (λ i → ! {A = A i}) X
is-local←is-null eq i = 3-for-2' (is-equiv⁻¹ unit-ev-is-equiv) (eq i)

is-null←is-local : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} {A : I → Type 𝓤}
                   → {X : Type 𝓥}
                   → is-local (λ i → ! {A = A i}) X
                   → is-null A X
is-null←is-local eq i = is-equiv-∘ (eq i) unit-const-is-equiv
}
%```
}

\subtree[stt-005K]{
\title{Nullfication at an pointed family}
\taxon{definition}

\p{The nullification of a pointed type can be constructed
using the [free algabraic injection](stt-005I)
higher inductive type. By definition, the free
algabraic injection already gives a section to
the precomposition map. Because any map #{A \to 1}
has a section, then the precomposition by this
map already has a retract, and so the type is not just
algabraicly #{A}-injective, but #{A}-null.}

%```agda
\agda{
Null∙ : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} (A : I → Type 𝓤)
         (A∙ : Π _ A) (X : Type 𝓥)
       → Type 𝓥
Null∙ A _ X = Free-inj
               (λ i → ! {A = A i})
                X

Null∙-is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘}
                 {A : I → Type 𝓤} {A∙ : Π _ A}
                 {X : Type 𝓥}
               → is-null A (Null∙ A A∙ X)
Null∙-is-null {A∙ = a} = is-null←is-local I where
  I : is-local (λ _ → !) _
  I i = is-equiv←qiso λ where
    .fst → injector-Free-inj i .fst
    .snd .fst α → funext→ (λ _ → Free-inj.is-ext (α ∘ !) (a i))
    .snd .snd → injector-Free-inj i .snd
}
%```
}


\subtree[stt-005Z]{
\taxon{lemma}
\title{Locality via sections of the codiagonal}
\citet{rijkeMod2020}{2.13}

\p{Given maps #{f_i : A_i \to B_i}, a type #{X} is #{f\rm{-local}}
iff #{-\circ f_i} and #{-\circ \nabla_f_i} all have sections.}

%```agda
\agda{
}
%```
}

\subtree[stt-005Y]{
\title{Localisation}
\taxon{definition}

\p{Unlike in the case of [nullification](stt-005K), we cannot
in general expect the family of functions against which we are
localising to all have sections. As such the [Free algabraicly injective](stt-005I)
type will not get us all the way to a localisation.}


\p{As explained in \citet{2.14}{rijkeMod2020}, even though the free algabraicly
#{f}-injective type is not a localisation, we can add some morphisms to the class
with which we localise against to make it so. By the observation in \ref{stt-005Z},
we need to add all maps of the form #{\nabla_f_i} to #{f}.}

%```agda
\agda{

module _ {𝓘 𝓤 𝓦 : Level} {I : Type 𝓘}
         {A : I → Type 𝓤} {B : I → Type 𝓤}
         where
  private
    A' : (f : ∀ i → A i → B i) → I ⊎ I → Type 𝓤
    A' f (left i) = A i
    A' f (right i) = Pushout (f i) (f i)

    B' : (f : ∀ i → A i → B i) → I ⊎ I → Type 𝓤
    B' f (left i)  = B i
    B' f (right i) = B i

    f' : (f : ∀ i → A i → B i) → (i : I ⊎ I) → A' f i → B' f i
    f' f (left i) = f i
    f' f (right i) = ∇ (f i)

  Loc : (f : ∀ i → A i → B i) → Type 𝓦 → Type 𝓦
  Loc f = Free-inj (f' f)

  Loc-is-local : ∀ {X : Type 𝓦}
                   {f : ∀ i → A i → B i}
                 → is-local f (Loc f X)
  Loc-is-local = {!is-local←sec-∇ !}
}
}
