\date{2025-04-18}
\taxon{module}
\title{Equivalences of pre(post)-composed functions}
\author{samueltoth}
\meta{module}{\startverb foundations.CompositionEquiv \stopverb}
\import{stt-macros}


% ```agda
\agda{
open import foundations.FunExt

module foundations.CompositionEquiv (FE : FunExt-global) where

open import foundations.Universes 
open import foundations.QuasiIsomorphism
open import foundations.CoherentIsomorphism
open import foundations.Singleton
open import foundations.Functions
open import foundations.Sigma
open import foundations.Identity
open import foundations.Homotopy
open import foundations.FunctionInverses
open import foundations.FunExt
open import foundations.EquivContrFibre
}
% ```



\subtree[stt-000O]{
\taxon{lemma}
\meta{defines}{\startverb ["precomp-qinv", "precomp-equiv", "precomp-equiv", "family-precomp-qinv",
                           "postcomp-qinv", "postcomp-equiv", "postcomp-â‰ƒ"] \stopverb}

% HoTT 4.2.8 \citet{4.2.8}{HoTT}

\p{If #{f} has a quasi-inverse, then so do ##{f \circ - : (A \to B) \to (A \to C)} ##{- \circ f : (B \to C) \to (A \to C)}}

\proof{
% ```agda
\agda{
precomp-qinv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
             â†’ quasi-iso f â†’ quasi-iso {B = C â†’ B} (f âˆ˜_)
precomp-qinv {f = f} (g , ret , sec) = (g âˆ˜_) , retâˆ˜ , secâˆ˜ where
  secâˆ˜ : section-witness (_âˆ˜_ f) (g âˆ˜_)
  secâˆ˜ h  = WithFunExtÏ‰.funextâ†’ FE (sec â–¸ h)

  retâˆ˜ : retract-witness (_âˆ˜_ f) (g âˆ˜_)
  retâˆ˜ h = WithFunExtÏ‰.funextâ†’ FE (ret â–¸ h)

precomp-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
                â†’ is-equiv f â†’ is-equiv {B = C â†’ B} (f âˆ˜_)
precomp-equiv eq = is-equivâ†qiso (precomp-qinv (qisoâ†is-equiv eq))                

precomp-â‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} (e : A â‰ƒ B) {X : Type ğ“¦}
                â†’ (X â†’ A) â‰ƒ (X â†’ B)
precomp-â‰ƒ (mkâ‰ƒ f e) = mkâ‰ƒ (f âˆ˜_) (precomp-equiv e)

family-precomp-qinv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {C : Type ğ“¦} {A : C â†’ Type ğ“¤} {B : C â†’ Type ğ“¥} {f : âˆ€ {c} â†’ A c â†’ B c} 
                â†’ (âˆ€ {q} â†’ quasi-iso (f {q})) â†’ quasi-iso {A = âˆ€ c â†’ A c} {B = âˆ€ c â†’ B c} (Î» g a â†’ f {a} (g a))
family-precomp-qinv {f = f} eq = (Î» g c â†’ eq .fst (g c)) , ret , sec where
   ret : retract-witness (Î» g a â†’ f (g a)) (Î» g c â†’ eq .fst (g c))
   ret f = WithFunExtÏ‰.funextâ†’ FE (Î» c â†’ eq .snd .fst (f c))

   sec : section-witness  (Î» g a â†’ f (g a)) (Î» g c â†’ eq .fst (g c))
   sec g = WithFunExtÏ‰.funextâ†’ FE (Î» c â†’ eq .snd .snd (g c))

family-precomp-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {C : Type ğ“¦} {A : C â†’ Type ğ“¤} {B : C â†’ Type ğ“¥} {f : âˆ€ {c} â†’ A c â†’ B c} 
                â†’ (âˆ€ {q} â†’ is-equiv (f {q})) â†’ is-equiv {A = âˆ€ c â†’ A c} {B = âˆ€ c â†’ B c} (Î» g a â†’ f {a} (g a))
family-precomp-equiv eq = is-equivâ†qiso (family-precomp-qinv (qisoâ†is-equiv eq))


postcomp-qinv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
             â†’ quasi-iso f â†’ quasi-iso {B = A â†’ C} (_âˆ˜ f)
postcomp-qinv {f = f} (g , Î· , Îµ) = (_âˆ˜ g) , Î·âˆ˜ , Îµâˆ˜ where
  Î·âˆ˜ : retract-witness (_âˆ˜ f) (_âˆ˜ g)
  Î·âˆ˜ h = WithFunExtÏ‰.funextâ†’ FE (h â—‚ Îµ)

  Îµâˆ˜ : section-witness (_âˆ˜ f) (_âˆ˜ g)
  Îµâˆ˜ h = WithFunExtÏ‰.funextâ†’ FE (h â—‚ Î·)

postcomp-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
                â†’ is-equiv f â†’ is-equiv {B = A â†’ C} (_âˆ˜ f)
postcomp-equiv eq = is-equivâ†qiso (postcomp-qinv (qisoâ†is-equiv eq))


postcomp-â‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} (e : A â‰ƒ B) {C : Type ğ“¦}
                â†’ (B â†’ C) â‰ƒ (A â†’ C)
postcomp-â‰ƒ (mkâ‰ƒ f e) = mkâ‰ƒ (_âˆ˜ f) (postcomp-equiv e)

}
% ```
}
}

\subtree[stt-003N]{
\taxon{theorem}
\title{equivalences from composition equivalences}
\p{We can extend this to show that the following are equivalent:}

\ul{
\li{#{f : A \to B} is an equivalence}
\li{#{- \circ f} is an equivalence}
\li{#{f \circ -} is an equivalence}
}

% ```agda
\agda{
is-equivâ†postcomp : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (f : A â†’ B)
        â†’ (H : âˆ€ {ğ“¦} {X : Type ğ“¦} â†’ is-equiv {B = A â†’ X} (_âˆ˜ f))
        â†’ is-equiv f
is-equivâ†postcomp f H = is-equivâ†qiso iso where
  module e {ğ“¦} {X : Type ğ“¦} = is-equiv (H {ğ“¦} {X})
  open e

  iso : quasi-iso f
  iso .fst = bwd id
  iso .snd .fst = happly (Îµ id)
  iso .snd .snd = happly
    (ap fst (is-propâ†is-single (is-contr-mapâ†is-equiv H f)
      (f âˆ˜ bwd id , ap (f âˆ˜_) (Îµ id)) (id , refl)) )


is-equivâ†precomp : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (f : A â†’ B)
        â†’ (H : âˆ€ {ğ“¦} {X : Type ğ“¦} â†’ is-equiv {B = X â†’ B} (f âˆ˜_))
        â†’ is-equiv f
is-equivâ†precomp f H = is-equivâ†qiso iso where
  module e {ğ“¦} {X : Type ğ“¦} = is-equiv (H {ğ“¦} {X})
  open e

  iso : quasi-iso f
  iso .fst = bwd id
  iso .snd .fst = happly
    (ap fst
      (is-propâ†is-single (is-contr-mapâ†is-equiv H f)
                          ((bwd id âˆ˜ f) , ap (_âˆ˜ f) (Îµ id))
                          (id , refl)))
  iso .snd .snd = happly (Îµ id)

}
% ```

}
