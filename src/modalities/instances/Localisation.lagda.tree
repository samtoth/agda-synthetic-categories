\date{2025-06-17}
\title{Localisations}
\taxon{module}
\meta{module}{\startverb modalities.instances.Localisation \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module modalities.instances.Localisation where

open import ufAxioms
open import axioms.FreeAlgInj
open import foundations.Prelude
open import core.Orthogonal
open import core.CanonicalPushouts
open import ergonomics.notations.Orthogonality
open core.Orthogonal.notation
}
%```

\subtree[stt-005F]{
\taxon{definition}
\title{Local types}

\p{Given a family of maps #{f_i : A_i \to B_i}, we say that a type
is #{f}-local if it is [orthogonal](stt-004O) to each map.}

%```agda
\agda{
is-local : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦} {I : Type ğ“˜} {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
               â†’ (f : (i : I) â†’ A i â†’ B i)
               â†’ Type ğ“¦
               â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
is-local f A = âˆ€ i â†’ orthogonal-type (f i) A
}
%```
}


\subtree[stt-005G]{
\taxon{definition}
\title{Null types}

\p{Given a family of types #{A_i}, we say a type #{X} is #{A} null if
it is right orthogonal to each #{A_i}. Or equivalently, if the
obvious maps #{X \to (A_i \to X)} are equivalences for each #{i}.}

%```agda
\agda{
is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} (A : I â†’ Type ğ“¤)
            â†’ Type ğ“¥ â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-null A X = âˆ€ i â†’ is-equiv (const X (A i))
}
%```
}

\subtree[stt-005H]{
\taxon{theorem}
\title{Null types are #{!\rm{-local}}}

\p{A type is #{A_i}-null iff it is #{(! : A_i \to 1)\rm{-local}}.}

\proof{
\p{A type #{X} is #{!\rm{-local}} when the map #{- \circ\ ! : (1 \to X) \to (A_i \to X)}
is an equivalence.}
}

%```agda
\agda{
is-localâ†is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
                   â†’ {X : Type ğ“¥}
                   â†’ is-null A X
                   â†’ is-local (Î» i â†’ ! {A = A i}) X
is-localâ†is-null eq i = 3-for-2' (is-equivâ»Â¹ unit-ev-is-equiv) (eq i)

is-nullâ†is-local : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
                   â†’ {X : Type ğ“¥}
                   â†’ is-local (Î» i â†’ ! {A = A i}) X
                   â†’ is-null A X
is-nullâ†is-local eq i = is-equiv-âˆ˜ (eq i) unit-const-is-equiv
}
%```
}

\subtree[stt-005K]{
\title{Nullfication at an pointed family}
\taxon{definition}

\p{The nullification of a pointed type can be constructed
using the [free algabraic injection](stt-005I)
higher inductive type. By definition, the free
algabraic injection already gives a section to
the precomposition map. Because any map #{A \to 1}
has a section, then the precomposition by this
map already has a retract, and so the type is not just
algabraicly #{A}-injective, but #{A}-null.}

%```agda
\agda{
Nullâˆ™ : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} (A : I â†’ Type ğ“¤)
         (Aâˆ™ : Î  _ A) (X : Type ğ“¥)
       â†’ Type ğ“¥
Nullâˆ™ A _ X = Free-inj
               (Î» i â†’ ! {A = A i})
                X

Nullâˆ™-is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜}
                 {A : I â†’ Type ğ“¤} {Aâˆ™ : Î  _ A}
                 {X : Type ğ“¥}
               â†’ is-null A (Nullâˆ™ A Aâˆ™ X)
Nullâˆ™-is-null {Aâˆ™ = a} = is-nullâ†is-local I where
  I : is-local (Î» _ â†’ !) _
  I i = is-equivâ†qiso Î» where
    .fst â†’ injector-Free-inj i .fst
    .snd .fst Î± â†’ funextâ†’ (Î» _ â†’ Free-inj.is-ext (Î± âˆ˜ !) (a i))
    .snd .snd â†’ injector-Free-inj i .snd
}
%```
}


\subtree[stt-005Z]{
\taxon{lemma}
\title{Locality via sections of the codiagonal}
\citet{rijkeMod2020}{2.13}

\p{Given maps #{f_i : A_i \to B_i}, a type #{X} is #{f\rm{-local}}
iff #{-\circ f_i} and #{-\circ \nabla_f_i} all have sections.}

%```agda
\agda{
}
%```
}

\subtree[stt-005Y]{
\title{Localisation}
\taxon{definition}

\p{Unlike in the case of [nullification](stt-005K), we cannot
in general expect the family of functions against which we are
localising to all have sections. As such the [Free algabraicly injective](stt-005I)
type will not get us all the way to a localisation.}


\p{As explained in \citet{2.14}{rijkeMod2020}, even though the free algabraicly
#{f}-injective type is not a localisation, we can add some morphisms to the class
with which we localise against to make it so. By the observation in \ref{stt-005Z},
we need to add all maps of the form #{\nabla_f_i} to #{f}.}

%```agda
\agda{

module _ {ğ“˜ ğ“¤ ğ“¦ : Level} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¤}
         where
  private
    A' : (f : âˆ€ i â†’ A i â†’ B i) â†’ I âŠ I â†’ Type ğ“¤
    A' f (left i) = A i
    A' f (right i) = Pushout (f i) (f i)

    B' : (f : âˆ€ i â†’ A i â†’ B i) â†’ I âŠ I â†’ Type ğ“¤
    B' f (left i)  = B i
    B' f (right i) = B i

    f' : (f : âˆ€ i â†’ A i â†’ B i) â†’ (i : I âŠ I) â†’ A' f i â†’ B' f i
    f' f (left i) = f i
    f' f (right i) = âˆ‡ (f i)

  Loc : (f : âˆ€ i â†’ A i â†’ B i) â†’ Type ğ“¦ â†’ Type ğ“¦
  Loc f = Free-inj (f' f)

  Loc-is-local : âˆ€ {X : Type ğ“¦}
                   {f : âˆ€ i â†’ A i â†’ B i}
                 â†’ is-local f (Loc f X)
  Loc-is-local = {!is-localâ†sec-âˆ‡ !}
}
}
