\date{2025-04-16}
\title{Suspensions}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb Core.Suspensions \stopverb}

\import{stt-macros}


% ```agda
\agda{
module Core.Suspensions where

open import Foundations.Prelude
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import ufAxioms
open import Ergonomics.Universal
open import Ergonomics.PushoutUniv
open import Ergonomics.Representation
open Universal â¦ƒ...â¦„
}
% ```


\subtree[stt-002M]{
\taxon{definition}
\title{Suspension}
\meta{defines}{\startverb ["Susp", "N", "S", "merid"] \stopverb}

\p{Given a type #{X}, we define the suspension #{Î£X} to be the pushout of:}

\quiver{
\begin{tikzcd}
	X && 1 \\
	\\
	1 && {\Sigma X}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow["N", from=1-3, to=3-3]
	\arrow["S"', from=3-1, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
\end{tikzcd}
}

\p{We call the two distinguished points \em{N}orth and \em{S}outh and the family of maps from North to South
   the \em{merid}ians.}

% ```agda
\agda{
Susp : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
Susp X = Pushout {A = X} ! !
{-# NOINLINE Susp #-}

North South : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ Susp A
North = Î¹â‚ tt
South = Î¹â‚‚ tt

merid : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ Id (Susp A) North South
merid = glue
}
% ```
}


\subtree[stt-002N]{
\title{universal property of suspensions}

\p{The type #{\Sigma X \to Y} is equivalent to #{\Sigma_{y_N, y_S : Y} (X \to y_N = y_S)}.} 

\proof{
##{
\begin{align*}
  (\Sigma X \to Y) & \simeq (1 +^X 1 \to Y) \\
                   & \simeq (\Sigma_{(x, y : 1 \to Y)}(X \to x \sim y)) \\
                   & \simeq (\Sigma_{(x, y : Y)}(X \to x = y))
\end{align*}
}
}

\todo{
\p{Ideally we use universal property for pushouts macro,
   followed by coconeáµ˜ representation macro, but the latter isn't
   working at the moment.}
}

%```agda
\agda{
Susp-UPâ†’ :  âˆ€ {ğ“¤ ğ“¥} {X : Type ğ“¤}
            {Y : Type ğ“¥}
          â†’ Î£[ x âˆ¶ Y ] Î£[ y âˆ¶ Y ] (X â†’ x ï¼ y)
          â†’ Susp X â†’ Y
Susp-UPâ†’ (x , y , p) = pushout-rec (mk-cocone (Î» _ â†’ x) (Î» _ â†’ y) p)

Susp-UP-is-equiv
  : âˆ€ {ğ“¤ ğ“¥} {X : Type ğ“¤}
      {Y : Type ğ“¥}
    â†’ is-equiv (Susp-UPâ†’ {X = X}{Y})
Susp-UP-is-equiv = is-equivâ†qiso (Î» where
  .fst po â†’ (po (Î¹â‚ tt) , po (Î¹â‚‚ tt) , po â—‚ glue)
  .snd .fst (a , b , H) â†’ ap ((a ,_) âˆ˜ (b ,_)) (funextâ†’ pushout-rec-apÎ²)
  .snd .snd â†’ is-equiv.Î· Pushout-is-pushoutÏ‰)

Susp-UPâ‰ƒ : âˆ€ {ğ“¤ ğ“¥} {X : Type ğ“¤}
            {Y : Type ğ“¥}
          â†’  (Susp X â†’ Y) â‰ƒ (Î£[ x âˆ¶ Y ] Î£[ y âˆ¶ Y ] (X â†’ x ï¼ y))
Susp-UPâ‰ƒ {X = X} {Y} = mkâ‰ƒ _ (is-equivâ»Â¹ Susp-UP-is-equiv)
  -- = (Susp X â†’ Y) â‰ƒâŸ¨ mkâ‰ƒ _ Pushout-is-pushoutÏ‰  âŸ©
  --   Cocone _ Y                                            â‰ƒâŸ¨ cocone-reprâ‰ƒ âŸ©
  --   (Î£[ f âˆ¶ (ğŸ™ â†’ Y) ] Î£[ g âˆ¶ (ğŸ™ â†’ Y )] (X â†’ f tt ï¼ g tt)) â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst unit-UPâ‰ƒ âŸ©
  --   (Î£[ x âˆ¶ Y ] Î£[ g âˆ¶ (ğŸ™ â†’ Y) ] (X â†’ x ï¼ g tt))          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» x â†’ Î£-ap-â‰ƒ-fst (unit-UPâ‰ƒ)) âŸ©
  --   Î£[ x âˆ¶ Y ] Î£[ y âˆ¶ Y ] (X â†’ x ï¼ y) â‰ƒâˆ
}
%```
}

\subtree[stt-007G]{
\title{Suspension is a functor}
\taxon{theorem}

%```agda
\agda{
Susp-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
           â†’ (f : A â†’ B)
           â†’ Susp A â†’ Susp B
Susp-map f = Susp-UPâ†’ (Î¹â‚ tt , Î¹â‚‚ tt , glue âˆ˜ f)
}
%```
}

\subtree[stt-007J]{
\title{Suspension preserves the unit type}
\taxon{theorem}

%```agda
\agda{
Susp-ğŸ™ : Susp ğŸ™ â‰ƒ ğŸ™
Susp-ğŸ™ = equivâ†qiso (Î» where
  ._â‰…_.fwd â†’ !
  ._â‰…_.fwd-iso .fst _ â†’ North
  ._â‰…_.fwd-iso .snd .fst
    â†’ pushout-ind _ (mk-coconeD ~refl glue Î»
                        a â†’ IdPâ†Square refl refl _ (glue a)
                              (sym ( âˆ™-reflr _
                                   âˆ™ coe-precompï¼ refl (glue a))))
  ._â‰…_.fwd-iso .snd .snd â†’ ~refl)
}
%```
}


\subtree[stt-007K]{
\title{Suspension map of #{!}}
\taxon{corollary}
\p{There exists an equivalence of arrows #{!_{\Sigma A} \simeq \Sigma !_A}}

%```agda
\agda{
Susp-! : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ Arrow-map (Susp-map (! {A = A})) (! {A = Susp A})
Susp-! .Arrow-map.top = id
Susp-! .Arrow-map.bot = !
Susp-! .Arrow-map.comm = ~refl

Susp-!-is-equiv : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-Arrow-equiv (Susp-! {A = A})
Susp-!-is-equiv .fst = id-is-equiv
Susp-!-is-equiv .snd = Susp-ğŸ™ ._â‰ƒ_.has-is-eqv

Susp-!â»Â¹ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ Arrow-map (! {A = Susp A}) (Susp-map (! {A = A}))
Susp-!â»Â¹ = Arrowâ»Â¹â†Arrow-equiv Susp-! Susp-!-is-equiv
}
%```
}
