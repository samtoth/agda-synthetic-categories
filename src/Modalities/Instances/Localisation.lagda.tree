\date{2025-06-17}
\title{Localisations}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Modalities.Instances.Localisation where

open import ufAxioms
open import Axioms.FreeAlgInj
open import Foundations.Prelude
open import Core.Orthogonal
open import Core.PullbackPower
open import Core.CanonicalPushouts
open import Core.Codiagonal
open import Core.CoSlice
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Postwhisker
open import Ergonomics.Notations.Orthogonality
open import Modalities.HigherModality
open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.ModalMaps

open Core.Orthogonal.notation
}
%```

\subtree[stt-005F]{
\taxon{Definition}
\title{Local types}

\p{Given a family of maps #{f_i : A_i \to B_i}, we say that a type
is #{f}-local if it is [orthogonal](stt-004O) to each map.}

%```agda
\agda{
is-local : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦} {I : Type ğ“˜} {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
               â†’ (f : (i : I) â†’ A i â†’ B i)
               â†’ Type ğ“¦
               â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
is-local f A = âˆ€ i â†’ orthogonal-type (f i) A

is-local-is-prop
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦} {I : Type ğ“˜} {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
      {f : (i : I) â†’ A i â†’ B i}
    â†’ âˆ€ (A : Type ğ“¦) â†’ is-prop (is-local f A)
is-local-is-prop A = is-prop-Î  Î» i â†’ is-equiv-is-prop
}
%```
}

\subtree[stt-007L]{
\title{Equivalent local maps}
\taxon{Theorem}

\p{If #{f_i} and #{g_i} are [equivalent maps](stt-004R), then #{f}-local
types are #{g}-local.}

%```agda
\agda{
is-local-equiv : âˆ€ {ğ“˜ ğ“¤ ğ“¤' ğ“¥ ğ“¥' ğ“¦} {I : Type ğ“˜}
                   {A : I â†’ Type ğ“¤} {A' : I â†’ Type ğ“¤'}
                   {B : I â†’ Type ğ“¥} {B' : I â†’ Type ğ“¥'}
                   {f : (i : I) â†’ A i â†’ B i}
                   {f' : (i : I) â†’ A' i â†’ B' i}
                   (F : âˆ€ i â†’ Arrow-map (f i) (f' i))
                 â†’ (âˆ€ i â†’ is-Arrow-equiv (F i))
                 â†’ {X : Type ğ“¦}
                 â†’ is-local f X â†’ is-local f' X
is-local-equiv F eq loc i
  = is-equivâ†Arrow-equivâ»Â¹ {F = postcomp-Arrow-map _ (F i)}
      (is-Arrow-equiv-postcomp (F i) (eq i))
      (loc i)
}
%```
}


\subtree[stt-005G]{
\taxon{Definition}
\title{Null types}

\p{Given a family of types #{A_i}, we say a type #{X} is #{A} null if
it is right orthogonal to each #{A_i}. Or equivalently, if the
obvious maps #{X \to (A_i \to X)} are equivalences for each #{i}.}

%```agda
\agda{
is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} (A : I â†’ Type ğ“¤)
            â†’ Type ğ“¥ â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-null A X = âˆ€ i â†’ is-equiv (const X (A i))

is-null-is-prop
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
    â†’ âˆ€ (X : Type ğ“¥) â†’ is-prop (is-null A X)
is-null-is-prop X = is-prop-Î  Î» a â†’ is-equiv-is-prop

nullâ‰ƒ : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
          {X : Type ğ“¥} (_ : is-null A X) i
        â†’ X
        â‰ƒ (A i â†’ X)
nullâ‰ƒ {A = A}{X} An i = mkâ‰ƒ (const X (A i)) (An i)
}
%```
}

\subtree[stt-005H]{
\taxon{Theorem}
\title{Null types are #{!\rm{-local}}}

\p{A type is #{A_i}-null iff it is #{(! : A_i \to 1)\rm{-local}}.}

\proof{ \p{A type #{X} is #{!\rm{-local}} when the map #{- \circ\ ! :
(1 \to X) \to (A_i \to X)} is an equivalence.}
}

%```agda
\agda{
is-localâ†is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
                   â†’ {X : Type ğ“¥}
                   â†’ is-null A X
                   â†’ is-local (Î» i â†’ ! {A = A i}) X
is-localâ†is-null eq i = 3-for-2' (unit-const-is-equiv) (eq i)

is-local-singâ†is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦} {I : Type ğ“˜}
                          {A : I â†’ Type ğ“¤}
                          {B : I â†’ Type ğ“¥}
                          (Bsing : âˆ€ i â†’ is-singleton (B i))
                          (f : âˆ€ i â†’ A i â†’ B i)
                        â†’ {X : Type ğ“¦}
                        â†’ is-null A X
                        â†’ is-local f X
is-local-singâ†is-null Bsing f null i
  = 3-for-2'
    (is-equivâ»Â¹ (sing-ev-is-equiv global-funext (Bsing i)))
    (null i)

is-nullâ†is-local : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
                   â†’ {X : Type ğ“¥}
                   â†’ is-local (Î» i â†’ ! {A = A i}) X
                   â†’ is-null A X
is-nullâ†is-local eq i = is-equiv-âˆ˜ (eq i) unit-const-is-equiv

is-nullâ†is-local-sing : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦} {I : Type ğ“˜}
                          {A : I â†’ Type ğ“¤}
                          {B : I â†’ Type ğ“¥}
                          (Bsing : âˆ€ i â†’ is-singleton (B i))
                          (f : âˆ€ i â†’ A i â†’ B i)
                        â†’ {X : Type ğ“¦}
                        â†’ is-local f X
                        â†’ is-null A X
is-nullâ†is-local-sing Bs f loc i
  = is-equiv-âˆ˜
      (loc i)
      ((is-equivâ»Â¹ (sing-ev-is-equiv global-funext (Bs i))))

}
%```
}

\subtree[stt-005K]{
\title{Nullification at a pointed family}
\taxon{Definition}

\p{The nullification of a pointed type can be constructed
using the [free algabraic injection](stt-005I)
higher inductive type. By definition, the free
algabraic injection already gives a section to
the precomposition map. Because any map #{A \to 1}
has a section, then the precomposition by this
map already has a retract, and so the type is not just
algabraicly #{A}-injective, but #{A}-null.}

%```agda
\agda{
Nullâˆ™ : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} (A : I â†’ Type ğ“¤)
         (Aâˆ™ : Î  _ A) (X : Type ğ“¥)
       â†’ Type ğ“¥
Nullâˆ™ A _ X = Free-inj
               (Î» i â†’ ! {A = A i})
                X

Nullâˆ™-is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜}
                 {A : I â†’ Type ğ“¤} (Aâˆ™ : Î  _ A)
                 {X : Type ğ“¥}
               â†’ is-null A (Nullâˆ™ A Aâˆ™ X)
Nullâˆ™-is-null a = is-nullâ†is-local I where
  I : is-local (Î» _ â†’ !) _
  I i = is-equivâ†qiso Î» where
    .fst â†’ injector-Free-inj i .fst
    .snd .fst Î± â†’ funextâ†’ (Î» _ â†’ Free-inj.is-ext (Î± âˆ˜ !) (a i))
    .snd .snd â†’ injector-Free-inj i .snd
}
%```
}


\subtree[stt-005Z]{
\taxon{Lemma}
\title{Locality via sections of the codiagonal}
\citet{RSS2020}{2.13}

\p{Given maps #{f_i : A_i \to B_i}, a type #{X} is #{f\rm{-local}}
iff #{-\circ f_i} and #{-\circ \nabla_{f_i}} all have sections.}

%```agda
\agda{
is-localâ†secâ†sec-âˆ‡
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦} {I : Type ğ“˜}
      {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
      {f : (i : I) â†’ A i â†’ B i}
      {X : Type ğ“¦}
    â†’ (âˆ€ i â†’ section (postcomp X (f i)))
    â†’ (âˆ€ i â†’ section (postcomp X (âˆ‡ (f i))))
    â†’ is-local f X
is-localâ†secâ†sec-âˆ‡ sec secâˆ‡ i
  = is-equivâ†is-pathsplit
      (is-pathsplitâ†sec-diag
        (sec i)
        (secâ†sec-Coslice-equiv'
          (Î”â†âˆ‡ _ _)
          Î”â†âˆ‡-is-equiv
          (secâˆ‡ i)))


secâˆ‡â†is-local
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦} {I : Type ğ“˜}
      {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
      {f : (i : I) â†’ A i â†’ B i}
      {X : Type ğ“¦}
    â†’ is-local f X
    â†’ âˆ€ i â†’ section (postcomp X (âˆ‡ (f i)))
secâˆ‡â†is-local loc i = secâ†sec-Coslice-equiv
                        (Î”â†âˆ‡ _ _)
                        Î”â†âˆ‡-is-equiv
                        (sec-diagâ†is-pathsplit
                          (is-pathsplitâ†is-equiv (loc i)))
}
%```
}

\subtree[stt-005Y]{
\title{Localisation}
\taxon{Definition}

\p{Unlike in the case of [nullification](stt-005K), we cannot in
general expect the family of functions against which we are localising
to all have sections, and so the [Free algabraicly
injective](stt-005I) type will not get us all the way to a
localisation.}


\p{As explained in \citet{2.14}{RSS2020}, even though we don't
immediately get a localisation, we can add some morphisms to the class
with which we localise against to make it so. By the observation in
\ref{stt-005Z}, we need to add all maps of the form #{\nabla_{f_i}} to
#{f}.}

%```agda
\agda{

module _ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ : Level} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
         where
  private
    A' : (f : âˆ€ i â†’ A i â†’ B i) â†’ I âŠ I â†’ Type (ğ“¤ âŠ” ğ“¥)
    A' f (inl i) = ULift ğ“¥ (A i)
    A' f (inr i) = Pushout (f i) (f i)

    B' : (f : âˆ€ i â†’ A i â†’ B i) â†’ I âŠ I â†’ Type ğ“¥
    B' f (inl i)  = B i
    B' f (inr i) = B i

    f' : (f : âˆ€ i â†’ A i â†’ B i) â†’ (i : I âŠ I) â†’ A' f i â†’ B' f i
    f' f (inl i) =  f i âˆ˜ unlift
    f' f (inr i) = âˆ‡ (f i)

  Loc : (f : âˆ€ i â†’ A i â†’ B i) â†’ Type ğ“¦ â†’ Type ğ“¦
  Loc f = Free-inj (f' f)

  Loc-is-local : âˆ€ {X : Type ğ“¦}
                   {f : âˆ€ i â†’ A i â†’ B i}
                 â†’ is-local f (Loc f X)
  Loc-is-local {X}{f}
    =  is-localâ†secâ†sec-âˆ‡
         (Î» i â†’ sec-3-for-2 {f = postcomp _ unlift} {postcomp _ (f i)}
                             (postcomp-equiv (is-equivâ»Â¹ lift-is-equiv))
                             (injector-Free-inj (inl i)))
         (Î» i â†’ injector-Free-inj (inr i))
}
%```
}


\subtree[stt-006C]{
\date{2025-06-23}
\taxon{Theorem}
\title{A partial universal property for Free Algebraic Injectives}

\p{The Free Algebraic Injective type former is the left adjoint to the
forgetful functor from Algabraic injectives on #{\SS} to #{\SS}.  In
this formalisaton we have shied away from formalising this full
universal property, but we now formalise the (easier) restriction to
the category of #{f\rm{-local}} types.}

\p{For an #{f\rm{-local}} type #{Y}, and any type #{X},
   the map #{- \circ \eta : (\mathcal{J}_f(X) \to Y) \to (X \to Y)}
   is an equivalence.
   }

%```agda
\agda{
postcomp-inj : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ ğ“œ}
                   {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
                   {B : I â†’ Type ğ“¥}
                   {f : (i : I) â†’ A i â†’ B i}
                   (X : Type ğ“¦) {Y : Type ğ“œ}
                 â†’ (Free-inj f X â†’ Y)
                 â†’ (X â†’ Y)
postcomp-inj X {Y} = postcomp Y Free-inj.inc
}
%```
\proof{

\p{To prove this, we use [pathsplit](stt-005Q) as our notion of
   equivalence.  So we have to give a section to #{(- \circ \eta)} and
   to #{\rm{ap}_{- \circ \eta}^{g,h}} for any pair of maps #{g, h :
   \mathcal{J}_f(X) \to Y}.  }

%```agda
\agda{
Free-inj-reflects : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ ğ“œ}
                   {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
                   {B : I â†’ Type ğ“¥}
                 {f : (i : I) â†’ A i â†’ B i}
                 (X : Type ğ“¦) {Y : Type ğ“œ}
               â†’ is-local f Y
               â†’ is-equiv (postcomp-inj {f = f} X {Y})
Free-inj-reflects {I = I} {A}{B}{f} X {Y} Y-loc
  = is-equivâ†is-pathsplit ps where
  module Y {i} = is-equiv (Y-loc i)
}
%```

\p{In the first case, the section of #{(- \circ \eta)} is relatively
trivial to construct. To do so, we are given a map #{g : X \to Y} and
need to construct one #{\mathcal{J}_f(X) \to Y}. We induct on the free
algebraic injective:}

\ol{
\li{case \strong{inc}: We need a map #{X \to Y}, which is given by
     #{g}.  The map we are constructing needs to be a section of #{-
     \circ \eta}, but the computation rule says that
     #{\rm{ind}(g,..)(\eta(x)) = g(x)}, and thus our map is a section
     by definition.
     }
\li{case \strong{ext}: For all #{f' : A_i \to \mathcal{J}_f(X)} we
    need a map #{(A_i \to Y) \to (B_i \to Y)} which is equal to #{f'}
    under postcomposition by #{f}. This map is obtained by the fact
    that #{Y} is #{f}-local.}
}


%```agda
\agda{
  sec-postcomp-inj : section (postcomp-inj X)
  sec-postcomp-inj .fst g = Free-inj.ind
                     (Î» _ â†’ Y)
                     g
                     (Î» _ â†’ Y.bwd)
                     Î» g' h a â†’ tr-const (Free-inj.is-ext g' a)
                                âˆ™ happly (Y.Îµ h) a
  sec-postcomp-inj .snd h = refl
}
%```

\p{Now we fix a pair of maps #{g, h : \mathcal{J}_f(X) \to Y}, and
give a section to #{\rm{ap}_{- \circ \eta}^{g,h} : g = h \to g\eta =
h\eta}.}

\p{[We can construct](stt-006I) an [equivalence of arrows](stt-004R)
between [postwhiskering](stt-006G) by #{\eta} and #{\rm{ap}_{- \circ
\eta}} using function extensionality. As a result, [it
suffices](stt-0069) then to give a section to the map by
\em{postwhiskering} with #{\eta}.  By the same result, we note that
because postcomposition by #{f_i} at #{Y} is an equivalence, then so
is the postwhiskering by #{f_i} at maps #{B_i \to Y}}

%```agda
\agda{
  opaque
    Yâ–¸-is-equiv : âˆ€ {i} {g h : B i â†’ Y} â†’ is-equiv (postwhisker (f i) g h)
    Yâ–¸-is-equiv {i} = postwhisker-is-equivâ†ap-compose
      (is-embeddingâ†is-equiv (Y-loc i))

  module Yâ–¸ {i} {g h} = is-equiv (Yâ–¸-is-equiv {i} {g} {h})
}
%```

\p{Now, we are ready to construct the section. Given #{H : g\eta \sim
h\eta} we want to show for all #{x : \mathcal{J}_f(X)}, #{g(x) =
h(x)}, which we do again by induction on #{x} with the motive #{x
\mapsto g(x) = h(x)}.}

\ol{
\li{case \strong{inc}: We require #{g\eta \sim h\eta}, so as above, we
     can supply the #{H} in the hypothesis. As above, the #{\beta}
     rule for HITs means, that the map we are constructing will be a
     definitional section of postwhiskering by #{\eta}.}
\li{case \strong{ext}: Now, for any #{f' : A_i \to \mathcal{J}_f(X)},
     we need to give a map #{f'' : gf' \sim hf' \to g\rm{ext}(f') \sim
     h\rm{ext}(f')}, such that for any #{(K : gf' \sim hf')},
     #{f''(K)f_i =_{x â†¦ g(x) = h(x)}^{\rm{is-ext}_{f'}} K}
     (N.B. #{\rm{ext}(f') : B_i \to \mathcal{J}_f(X)})

     \p{For the map in question, we take:
       ##{(K : gf' \sim hf') \mapsto
         (- â–¸ f_f)^{-1}(g(\rm{is-ext}_{f'}) \cdot K \cdot h(\rm{is-ext}_{f'})^{-1})}
      }

      \p{Unfolding #{f''(K)f_i =_{x â†¦ g(x) = h(x)}^{\rm{is-ext}_{f'}} K},
         we find that we need to give a witness to the following square:
         }

      \quiver{
        \begin{tikzcd}
	{gf'} && {g\textrm{ext}_{f'}f_i} \\
	\\
	{hf'} && {h\textrm{ext}_{f'}f_i}
	\arrow["{g(\textrm{is-ext}_{f'})^{-1}}", no head, from=1-1, to=1-3]
	\arrow["{K}"', no head, from=1-1, to=3-1]
	\arrow["{(- \blacktriangleright f')^{-1}(f''(K))f_i}", no head, from=1-3, to=3-3]
	\arrow["{h(\textrm{is-ext}_{f'})}^{-1}"', no head, from=3-1, to=3-3]
        \end{tikzcd}
      }

      \p{But now we have the postwhiskering applied to the inverse of postwhiskering
         on the right hand side. Once this is eliminated, and #{f''} is unfolded,
         we get:}

      \quiver{
        \begin{tikzcd}
	{gf'} && {g\rm{ext}_{f'}f_i} && {gf'} \\
	\\
	{hf'} && {h\rm{ext}_{f'}f_i} && {hf'}
	\arrow["{g(\textrm{is-ext}_{f'})^{-1}}", no head, from=1-1, to=1-3]
	\arrow["K"', no head, from=1-1, to=3-1]
	\arrow["{g(\textrm{is-ext}_{f'})}", no head, from=1-3, to=1-5]
	\arrow[""{name=0, anchor=center, inner sep=0}, "{(- \blacktriangleright f')^{-1}(f''(K))f_i}"{description}, no head, from=1-3, to=3-3]
	\arrow[""{name=1, anchor=center, inner sep=0}, "K", no head, from=1-5, to=3-5]
	\arrow["{h(\textrm{is-ext}_{f'})^{-1}}"', no head, from=3-1, to=3-3]
	\arrow["{h(\textrm{is-ext}_{f'})}"', no head, from=3-3, to=3-5]
	\arrow["\epsilon"{pos=0.7}, shorten <=41pt, shorten >=14pt, Rightarrow, from=0, to=1]
        \end{tikzcd}
      }

      \p{and this square clearly commutes.}
     }
}

%```agda
\agda{
  lem : (g h : Free-inj f X â†’ Y)
     (i : I)
     (g' : A i â†’ Free-inj _ X)
     (q : g âˆ˜ g' ~ h âˆ˜ g') â†’
     postcomp Y (f i) (g âˆ˜ Free-inj.ext g') ~
     postcomp Y (f i) (h âˆ˜ Free-inj.ext g')
  lem g h i g' K =      g â—‚ (Free-inj.is-ext g')
                     ~âˆ™ K
                     ~âˆ™ (h â—‚ Free-inj.is-ext g' ~â»Â¹)

  opaque
    secAp : âˆ€ (g h : Free-inj f XÂ â†’ Y)
            â†’ section (postwhisker Free-inj.inc g h)
    secAp g h .fst H
      = Free-inj.ind (Î» z â†’ g z ï¼ h z)
          H
          (Î» f' (K : g âˆ˜ f' ~ h âˆ˜ f')
            â†’ Yâ–¸.bwd (lem g h _ f' K))
          Î» f' (K : g âˆ˜ f' ~ h âˆ˜ f') a
            â†’ IdP-funcâ†Square
               (Free-inj.is-ext f' a)
               _
               (K a)
               (Squareâ†brtï¼l
                 (ap g (Free-inj.is-ext f' a))
                 {ap h (Free-inj.is-ext f' a)}
                 {Yâ–¸.bwd {g = g âˆ˜ Free-inj.ext f'}
                         {h = h âˆ˜ Free-inj.ext f'}
                         (lem g h _ f' K) (f _ a)}
                 (sym (happly (Yâ–¸.Îµ (lem g h _ f' K)) a)))
    secAp g h .snd K = refl

  ps : is-pathsplit (postcomp-inj X)
  ps .fst = sec-postcomp-inj
  ps .snd g h = sectionâ†Arrow-equivâ»Â¹ {F = postwhiskerâ†ap-compose _ _ _}
                                      postwhisker-funext(secAp g h)
}
%```
}
}

\subtree[stt-0065]{
\date{2025-06-21}
\title{Nullification is a [reflective subuniverse](stt-0041)}
\taxon{Corollary}


%```agda
\agda{
module _ where
  open is-globally-reflective
  open is-global-reflector

  Null-SubU
    : âˆ€ {ğ“˜ ğ“¤} {I : Type ğ“˜}
        (A : I â†’ Type ğ“¤)
        ğ“¦
      â†’ SubU ğ“¦ (ğ“¦ âŠ” ğ“˜ âŠ” ğ“¤)
  Null-SubU A ğ“¦ .Subtype.family = is-null A
  Null-SubU A ğ“¦ .Subtype.has-is-subtype = is-null-is-prop

  Null-GSU : âˆ€ {ğ“˜ ğ“¤} {I : Type ğ“˜}
               (A : I â†’ Type ğ“¤)
              â†’ GSU (_âŠ” (ğ“˜ âŠ” ğ“¤))
  Null-GSU A .GSU.S = Null-SubU A _
  Null-GSU A .GSU.S-equiv e anull i
    = is-equivâ†Arrow-equiv
        {F = mk-amap fwd (precomp _ fwd) ~refl}
        (has-is-eqv , precomp-equiv has-is-eqv)
        (anull i) where open _â‰ƒ_ e

  Nullâˆ™-global-reflectors
    : âˆ€ {ğ“˜ ğ“¤} {I : Type ğ“˜}
        {A : I â†’ Type ğ“¤}
        (aâˆ™ : âˆ€ i â†’ A i)
      â†’ is-globally-reflective (Null-GSU A)
  Nullâˆ™-global-reflectors a .â—‹ = Nullâˆ™ _ a
  Nullâˆ™-global-reflectors a .Î· = Free-inj.inc
  Nullâˆ™-global-reflectors a .has-is-reflector
    .â—‹âˆˆS = Nullâˆ™-is-null a
  Nullâˆ™-global-reflectors a .has-is-reflector
    .reflects cnull = Free-inj-reflects _ (is-localâ†is-null cnull)

  Nullâˆ™-reflective
    : âˆ€ {ğ“˜ ğ“¤ ğ“¦} {I : Type ğ“˜}
        {A : I â†’ Type ğ“¤}
        (aâˆ™ : âˆ€ i â†’ A i)
      â†’ is-reflective (Null-SubU A ğ“¦)
  Nullâˆ™-reflective a = is-reflectiveâ†global (Nullâˆ™-global-reflectors a)
}
%```
}

\subtree[stt-006E]{
\taxon{Theorem}
\date{2025-06-25}
\title{Nullification is a #{\Sigma}-closed reflective subuniverse}

\p{Nullification is a #{\Sigma}-closed reflective subuniverse and so
is also a higher modality.}

\proof{
\p{By calculation:}

##{
\begin{align}
  \Sigma_{(x : X)} Y(x)  &\simeq \Sigma_{(x : X)} A_i \to Y(x) \\
                         &\simeq \Sigma_{(x : A_i \to X)} \Pi_{(a : A_i)} Y(f(a))\\
                         &\simeq A_i \to \Sigma_{(x : X)} Y(x)
\end{align}
}

\p{Where (1) and (2) follow from the fact #{X} and each #{Y(x)} are
#{A}-[null](stt-005G), and (3) is the [type theoretic theorem of
choice](foundations.TheoremOfChoice).}  }

%```agda
\agda{
Null-globally-Î£-closed : âˆ€ {ğ“˜ ğ“¤} {I : Type ğ“˜}
                   {A : I â†’ Type ğ“¤}
                 â†’ is-globally-Î£-closed (Null-GSU A)
Null-globally-Î£-closed {A = A} {A = X} {Y} Xnull Ynull i
  = eqv where
  opaque
    I : Î£ X Y â‰ƒ (A i â†’ Î£ X Y)
    I = Î£ X Y
          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» x â†’ nullâ‰ƒ (Ynull x) i) âŸ©
        Î£ X (Î» x â†’ A i â†’ Y x)
          â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» f â†’ (a : A i) â†’ Y (f a)} (nullâ‰ƒ Xnull i)  âŸ©
        Î£ (A i â†’ X) (Î» f â†’ (a : A i) â†’ Y (f a))
          â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ (Î» _ â†’ X) (Î» _ â†’ Y) eâ»Â¹ âŸ©
        (A i â†’ Î£ X Y) â‰ƒâˆ

    eqv : is-equiv (const (Î£ X Y) (A i))
    eqv = I ._â‰ƒ_.has-is-eqv

Null-Î£-closed : âˆ€ {ğ“˜ ğ“¤ ğ“¦} {I : Type ğ“˜}
                   {A : I â†’ Type ğ“¤}
                 â†’ is-Î£-closed (Null-SubU A ğ“¦)
Null-Î£-closed {A = A}
  = is-Î£-closedâ†globally (Null-GSU A) Null-globally-Î£-closed

Nullâˆ™-HigherModality
  : âˆ€ {ğ“˜ ğ“¤ ğ“¦} {I : Type ğ“˜}
      {A : I â†’ Type ğ“¤}
      (a : Î  _ A)
    â†’ HigherModality ğ“¦
Nullâˆ™-HigherModality a = HigherModalityâ†SubU
                           (Nullâˆ™-reflective a)
                           (Null-Î£-closed)
}
%```
}

\subtree[stt-0079]{
\date{2025-06-29}
\title{Nullification is closed under #{Pi} and #{=}}
\taxon{Theorem}

%```agda
\agda{
Î -is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦}
              {I : Type ğ“˜}
              {X : I â†’ Type ğ“¤}
              {A : Type ğ“¥} {B : A â†’ Type ğ“¦}
            â†’ (âˆ€ a â†’ is-null X (B a))
            â†’ is-null X (Î  A B)
Î -is-null bn i = is-equiv-âˆ˜
                    flip-is-equiv
                   (precomp-Î -equiv (Î» {a} â†’ bn a i))
}
%```

\p{Closure under #{=} follows via 3-for-2 on the following diagram:}
\quiver{
\begin{tikzcd}
	{x = y} &&&& {A^{\Sigma S^n}} \\
	\\
	&& {\Delta(x) = \Delta(y)}
	\arrow["{\Delta_{x=y}}", from=1-1, to=1-5]
	\arrow["{\Delta_-}"', from=1-1, to=3-3]
	\arrow["\sim"', from=3-3, to=1-5]
\end{tikzcd}
}

%```agda
\agda{
ï¼-is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥}
                {I : Type ğ“˜}
                {X : I â†’ Type ğ“¥}
                {A : Type ğ“¤}
              â†’ is-null X A
              â†’ âˆ€ {x y : A}
                â†’ is-null X (x ï¼ y)
ï¼-is-null {X = X} {A} null i
  = is-equiv~âˆ˜ (Î» where refl â†’ refl)
               global-funext
               (is-embeddingâ†is-equiv (null i))
}
%```
}

\subtree[stt-006A]{
\date{2025-06-23}
\taxon{Lemma}
\title{#{f} local maps are #{\nabla(f)} local}

%```agda
\agda{
is-localâˆ‡â†is-local : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                 (f : A â†’ B)
                 {X : Type ğ“¦}
               â†’ is-equiv (postcomp X f)
               â†’ is-equiv (postcomp X (âˆ‡ f))
is-localâˆ‡â†is-local f {X} eq = equivâ†Coslice-equiv
                                (Î”â†âˆ‡ f X)
                                Î”â†âˆ‡-is-equiv
                                (diagonal-is-equiv eq)
}
%```
}

\subtree[stt-0066]{
\title{Localisation is a [reflective subuniverse](stt-0041)}
\taxon{Corollary}

\p{Localisation at any family of maps forms a reflective subuniverse
which is not in general #{\Sigma}-closed.}

%```agda
\agda{
module _ {ğ“˜ ğ“¤ ğ“¥ : Level} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
         where
  open is-reflective
  open is-reflector
  open is-globally-reflective
  open is-global-reflector

  Local-SubU
    : (f : (i : I) â†’ A i â†’ B i)
      (ğ“¦ : Level)
    â†’ SubU ğ“¦ (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
  Local-SubU f ğ“¦ = mk-subtype
                         {family = is-local f}
                         is-local-is-prop

  Local-GSU
    : (f : (i : I) â†’ A i â†’ B i)
    â†’ GSU ((ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥) âŠ”_)
  Local-GSU f .GSU.S {ğ“¤} = Local-SubU f ğ“¤
  Local-GSU f .GSU.S-equiv {A = A} {B} e aloc i
    = is-equivâ†Arrow-equiv
       {F = mk-amap (precomp _ fwd) (precomp _ fwd) ~refl}
       (precomp-equiv has-is-eqv , precomp-equiv has-is-eqv)
       (aloc i) where
    open _â‰ƒ_ e

  Local-global-reflectors
    : (f : (i : I) â†’ A i â†’ B i)
    â†’ is-globally-reflective (Local-GSU f)
  Local-global-reflectors f .â—‹ = Loc f
  Local-global-reflectors f .Î· = Free-inj.inc
  Local-global-reflectors f .has-is-reflector .â—‹âˆˆS = Loc-is-local
  Local-global-reflectors f .has-is-reflector .reflects cloc
    = Free-inj-reflects _ Î» where
       (inl i) â†’ is-equiv-âˆ˜ (postcomp-equiv (is-equivâ»Â¹ lift-is-equiv))
                             (cloc i)
       (inr i) â†’ is-localâˆ‡â†is-local (f i) (cloc i)

  Local-reflective
    : âˆ€ {ğ“¦} (f : (i : I) â†’ A i â†’ B i)
    â†’ is-reflective (Local-SubU f ğ“¦)
  Local-reflective f = is-reflectiveâ†global (Local-global-reflectors f)



Nullâ‰ƒ!Local : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
              â†’ Subtype-equiv (Local-SubU (Î» i â†’ ! {A = A i}) ğ“¥)
                              (Null-SubU A ğ“¥)
Nullâ‰ƒ!Local A = (is-nullâ†is-local , is-localâ†is-null )


Null-globally-reflective
  : âˆ€ {ğ“˜ ğ“¤} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
  â†’ is-globally-reflective (Null-GSU A)
Null-globally-reflective {A = A}
  = is-globally-reflective-subtype-equiv
      Nullâ‰ƒ!Local
      (Local-global-reflectors (Î» i â†’ ! {A = A i}))
}
%```
}

\subtree[stt-006R]{
\title{Localisation at a singleton codomain}
\taxon{Theorem}

\p{Localisation at a family of maps #{A_i \to B_i} where each #{B_i}
gives a reflective subuniverse
which is #{\Sigma}-closed.}

%```agda
\agda{
module _ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ : Level} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
         where
  open is-reflective
  open is-reflector

  Local-Î£-closed
    : (f : (i : I) â†’ A i â†’ B i)
    â†’ (âˆ€ i â†’ is-singleton (B i))
    â†’ is-Î£-closed (Local-SubU f ğ“¦)
  Local-Î£-closed f sngl aloc bloc
    = is-local-singâ†is-null sngl f
        (Null-Î£-closed
        (is-nullâ†is-local-sing sngl f aloc)
           Î» a â†’ is-nullâ†is-local-sing sngl f (bloc a))

  Local-HigherModality
    : (f : (i : I) â†’ A i â†’ B i)
    â†’ (âˆ€ i â†’ is-singleton (B i))
    â†’ HigherModality ğ“¦
  Local-HigherModality f s = HigherModalityâ†SubU
                               (Local-reflective f)
                               (Local-Î£-closed f s)
}
%```
}

\subtree[stt-00AP]{
\title{Local maps are fibrewise local}
\taxon{Theorem}

\p{A map is #{f}-local if it is right orthogonal to each #{f_i}. We show that
that a map is #{f}-local iff it is a [modal map](stt-0045) in the sense that each
fibre is local.}

\proof{
\p{Let #{p} be a mapÂ #{X \to Y}. First note that a type #{A} is right orthogonal
to #{f_i} iff the map #{! : A \to 1} is right orthogonal to #{f_i}. Then we
arrange the arrows as below, noting that the fibre is a pullback.}

\quiver{
\begin{tikzcd}
	{A_i} && {\fibre{p}{y}} && {\tilde{P}} \\
	\\
	{B_i} && 1 && Y
	\arrow[from=1-1, to=1-3]
	\arrow["{f_i}"', from=1-1, to=3-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-3, to=3-5]
	\arrow[from=1-5, to=3-5]
	\arrow[color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-1, to=1-3]
	\arrow[curve={height=6pt}, dashed, from=3-1, to=1-5]
	\arrow[from=3-1, to=3-3]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}

\p{We complete the proof by apealing to the fact that right orthogonality is
preserved by base change.}
}

%```agda
\agda{
module _ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ : Level} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
         (f : (i : I) â†’ A i â†’ B i)
         where

  is-modal-mapâ†is-local
    : âˆ€ {ğ“œ ğ“} {X : Type ğ“œ} {Y : Type ğ“} (p : X â†’ Y)
      â†’ (âˆ€ i â†’ are-orthogonal (f i) p) â†’ is-modal-map (Local-SubU f (ğ“œ âŠ” ğ“)) p
  is-modal-mapâ†is-local p orth y i
    = is-orthogonalâ‡”orthogonal-! .fst (orthogonalâ†pullback (f i)
                                         _
                                         (fibre-square-is-cartesian p y)
                                         (orth i))

}
%```
}
