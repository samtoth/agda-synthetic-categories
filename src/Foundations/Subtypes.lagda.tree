\date{2025-05-09}
\title{Subtypes}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

% ```agda
\agda{
module Foundations.Subtypes where

open import Foundations.Universes
open import Foundations.Sigma
open import Foundations.Functions
open import Foundations.QuasiIsomorphism
open import Foundations.CoherentIsomorphism
open import Foundations.Identity
open import Foundations.Singleton
open import Foundations.EquivContrFibre
open import Foundations.FibrePath
open import Foundations.EquivSingleton
open import Foundations.SigmaPath
open import Foundations.SigmaProperties
open import Foundations.FunextUnivalence
open import Foundations.PropExt
open import Foundations.PropClosure
open import Foundations.Unit
open import Foundations.Empty
open import Foundations.Lift
open import Foundations.Embedding
open import Foundations.PropMapEmbedding
}
% ```

% ```agda
\agda{
is-subtype : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) â†’ Type _
is-subtype P = âˆ€ x â†’ is-prop (P x)

record Subtype {ğ“¤} (A : Type ğ“¤) ğ“¥ : Type (ğ“¤ âŠ” lsuc ğ“¥) where
  constructor mk-subtype
  field
    {family} : A â†’ Type ğ“¥
    has-is-subtype : is-subtype family

  Î£Ìƒ : Type _
  Î£Ìƒ = Î£ A family

  Î£Ìƒ-Ï€ : Î£Ìƒ â†’ A
  Î£Ìƒ-Ï€ = fst

  Î£Ìƒ-Ï€-is-prop-map : is-prop-map Î£Ìƒ-Ï€
  Î£Ìƒ-Ï€-is-prop-map a = is-propâ†equiv-to-prop
               (fibre-straighten _ _ eâ»Â¹)
               (has-is-subtype a)

  Î£Ìƒ-Ï€-is-embedding : is-embedding Î£Ìƒ-Ï€
  Î£Ìƒ-Ï€-is-embedding = is-embeddingâ†is-prop-map Î£Ìƒ-Ï€-is-prop-map

  subtype-path : âˆ€ {x y : Î£Ìƒ} â†’ (Î£Ìƒ-Ï€ x ï¼ Î£Ìƒ-Ï€ y) â†’ x ï¼ y
  subtype-path = is-equiv.bwd Î£Ìƒ-Ï€-is-embedding

_âˆˆ_ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} â†’ A â†’ Subtype A ğ“¥ â†’ Type ğ“¥
a âˆˆ S = S .Subtype.family a

âˆˆ-is-prop : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} â†’ (S : Subtype A ğ“¥)
            â†’ is-subtype (_âˆˆ S)
âˆˆ-is-prop S = S .Subtype.has-is-subtype
}
% ```

% ```agda
\agda{
module _ {ğ“¤} {A : Type ğ“¤} {ğ“¥} (P : Subtype A ğ“¥) where
  open Subtype P
}
% ```

\subtree[stt-007N]{
\title{Equivalent subtypes}
\taxon{Definition}

\p{We say two subtypes #{S} and #{K} are equal if they contain the same
types, that is: #{\forall x, x \in S \iff x \in K}.}


%```agda
\agda{
Subtype-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¥'} {A : Type ğ“¤}
                  (S : Subtype A ğ“¥) (K : Subtype A ğ“¥')
                â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¥')
Subtype-equiv S K = âˆ€ a â†’ ((a âˆˆ S) â‡” (a âˆˆ K))

Subtype-equivâ†Id : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
                  {S : Subtype A ğ“¥} {K : Subtype A ğ“¥}
                 â†’ S ï¼ K â†’ Subtype-equiv S K
Subtype-equivâ†Id = (logicalâ†Id âˆ˜_) âˆ˜ happly âˆ˜ ap Subtype.family
}
%```
}

\subtree[stt-2082]{
\title{Join semi-lattice structure on subtypes}
\taxon{Construction}
\p{We can construct minimal and maximal subtypes as well as
 intersection of subtypes. In order to construct the union of
 subtypes, we will require a propositional truncation, so leave this
 for later.}

%```agda
\agda{
ULift-subtype : âˆ€ {ğ“¤ ğ“¥} ğ“¦ {A : Type ğ“¤}
                â†’ Subtype A ğ“¥ â†’ Subtype A (ğ“¥ âŠ” ğ“¦)
ULift-subtype ğ“¦ {A} S .Subtype.family a = ULift ğ“¦ (a âˆˆ S)
ULift-subtype ğ“¦ {A} S .Subtype.has-is-subtype a
  = is-prop-ULift (âˆˆ-is-prop S a)

module SubtypeLattice {ğ“¤} (A : Type ğ“¤) where
   _âˆ©_ : âˆ€ {ğ“¥ ğ“¦} â†’ Subtype A ğ“¥ â†’ Subtype A ğ“¦ â†’ Subtype A _
   (P âˆ© Q) .Subtype.family a = (a âˆˆ P) Ã— (a âˆˆ Q)
   (P âˆ© Q) .Subtype.has-is-subtype a
     = is-prop-Î£ (âˆˆ-is-prop P a) Î» _ â†’ âˆˆ-is-prop Q a

   âŠ¤ : Subtype A lzero
   âŠ¤ .Subtype.family _ = ğŸ™
   âŠ¤ .Subtype.has-is-subtype x _ _ = refl

   âŠ¥ : Subtype A lzero
   âŠ¥ .Subtype.family _ = âˆ…
   âŠ¥ .Subtype.has-is-subtype a ()
}
%```
}
