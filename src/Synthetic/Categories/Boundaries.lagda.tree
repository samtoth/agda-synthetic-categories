\date{2025-12-18}
\title{The booundary of simpleces}
\author{samtoth}
\taxon{module}
\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Boundaries
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I


open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr

open import Ergonomics.Extensionality

open import Modalities.Instances.Truncation

open import Data.Bool

open import Core.CanonicalPushouts
open import Core.Join
open import Core.FlatteningPushouts
open import Core.SpanMap
}
%```

\subtree[tot-000O]{

%```agda
\agda{
Î´Î”Â¹ : Type ğ“˜
Î´Î”Â¹ = ULift _ Bool

Î´Î”Â¹-0 Î´Î”Â¹-1 : Î´Î”Â¹
Î´Î”Â¹-0 = mk-lift false
Î´Î”Â¹-1 = mk-lift true

make-Î´Î”Â¹ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ A â†’ Î´Î”Â¹ â†’ A
make-Î´Î”Â¹ a b (mk-lift true) = a
make-Î´Î”Â¹ a b (mk-lift false) = b

Î´Î”Â¹-UPâ†’ : âˆ€ {ğ“¤} {A : Î´Î”Â¹ â†’ Type ğ“¤} â†’ (A Î´Î”Â¹-0 Ã— A Î´Î”Â¹-1) â†’ Î  _ A
Î´Î”Â¹-UPâ†’ x (mk-lift false) = x .fst
Î´Î”Â¹-UPâ†’ x (mk-lift true)  = x .snd

Î´Î”Â¹-UP : âˆ€ {ğ“¤} {A : Î´Î”Â¹ â†’ Type ğ“¤} â†’ (A Î´Î”Â¹-0 Ã— A Î´Î”Â¹-1) â‰ƒ Î  _ A
Î´Î”Â¹-UP = mkâ‰ƒ Î´Î”Â¹-UPâ†’ (is-equivâ†qiso ((Î» x â†’ (x Î´Î”Â¹-0 , x Î´Î”Â¹-1))
                                    , ~refl
                                    , (Î» f â†’ funextâ†’ (Î´Î”Â¹-UPâ†’ (refl , refl)))))

Î´Î”Â¹-incl : Î´Î”Â¹ â†’ Î”Â¹
Î´Î”Â¹-incl (mk-lift false) = i0
Î´Î”Â¹-incl (mk-lift true) = i1

Î´Î”Â¹-embeds : ((i0 ï¼ i1) â†’ âˆ…) â†’ is-embedding (Î´Î”Â¹-incl)
Î´Î”Â¹-embeds nt = is-equivâ†inverse
                  (is-propâ†is-truncated
                    (Trunc.ULift-is-truncated
                      (is-truncatedâ†is-set Bool-is-set) _ _))
                  (is-propâ†is-truncated (car-is-set _ _))
                  map where
  map : âˆ€ {x y} â†’ Î´Î”Â¹-incl x ï¼ Î´Î”Â¹-incl y â†’ x ï¼ y
  map {mk-lift true} {mk-lift true} _ = refl
  map {mk-lift true} {mk-lift false} p = Â¡ nt (sym p)
  map {mk-lift false} {mk-lift true} p = Â¡ nt p
  map {mk-lift false} {mk-lift false} _ = refl

Î´Î›[2,1]-incl : Î´Î”Â¹ â†’ Î›[2,1]
Î´Î›[2,1]-incl (mk-lift false) = Î¹â‚ i0
Î´Î›[2,1]-incl (mk-lift true ) = Î¹â‚‚ i1

Î´Î”Â² : Type ğ“˜
Î´Î”Â² = Pushout {A = Î´Î”Â¹} {B = Î›[2,1]} {C = Î”Â¹} Î´Î›[2,1]-incl Î´Î”Â¹-incl

Î´Î”Â²-Î”Â²-cocone : Cocone (mk-span _ Î´Î›[2,1]-incl Î´Î”Â¹-incl) Î”Â²
Î´Î”Â²-Î”Â²-cocone = (mk-cocone Î›[2,1]-incl Î”Â²-diagonal Î» where
                         (mk-lift true) â†’ Î”Â²-refl
                         (mk-lift false) â†’ Î”Â²-refl)

Î´Î”Â²-incl : Î´Î”Â² â†’ Î”Â²
Î´Î”Â²-incl = pushout-rec Î´Î”Â²-Î”Â²-cocone

Î´Î”Â²â†Î›[2,1] : Î›[2,1] â†’ Î´Î”Â²
Î´Î”Â²â†Î›[2,1] = Î¹â‚

Î´Î´Î›[2,1]-incl : Î”Â²-diagonal âˆ˜ Î´Î”Â¹-incl ~ Î›[2,1]-incl âˆ˜ Î´Î›[2,1]-incl
Î´Î´Î›[2,1]-incl (mk-lift true) = Î”Â²-refl
Î´Î´Î›[2,1]-incl (mk-lift false) = Î”Â²-refl


Î´Î”Â²-sub : Subtype Î”Â² ğ“˜
Î´Î”Â²-sub .Subtype.family t@(i , j) = (t âˆˆ Î›[2,1]Sub) * (j ï¼ i)
Î´Î”Â²-sub .Subtype.has-is-subtype a@(i , j)
  = *-is-prop (âˆˆ-is-prop Î›[2,1]Sub a) (is-prop-separated _ _)

-- Î´Î”Â²-as-subtype : (i0 ï¼ i1 â†’ âˆ…) â†’ âˆ€ a â†’ fibre Î´Î”Â²-incl a â‰ƒ a âˆˆ Î´Î”Â²-sub
-- Î´Î”Â²-as-subtype non-triv a@(i , j)
--   = fibre Î´Î”Â²-incl a â‰ƒâŸ¨ cogap-fibre _ a âŸ©
--     Pushout (total-fibre-span .left) (total-fibre-span .right)
--         â‰ƒâŸ¨  coeâ‰ƒ (ap (Î» x â†’ Pushout (left x) (right x))
--                            (ext! (span-map' , span-map-is-equiv))) âŸ©
--     Pushout (intended-span .left) (intended-span .right)
--                               â‰ƒâŸ¨âŸ©
--     (a âˆˆ Î´Î”Â²-sub)             â‰ƒâˆ where
--   open Span

--   total-fibre-span : Span ğ“˜ ğ“˜ ğ“˜
--   total-fibre-span = total-span Î´Î›[2,1]-incl Î´Î”Â¹-incl
--                                 (Fibre-family Î´Î”Â²-Î”Â²-cocone a)

--   intended-span : Span ğ“˜ ğ“˜ ğ“˜
--   intended-span = mk-span ((a âˆˆ Î›[2,1]Sub) Ã— (j ï¼ i)) fst snd

--   total-fibre-span' : Span ğ“˜ ğ“˜ ğ“˜
--   total-fibre-span' = mk-span (Î£[ x âˆ¶ Î´Î”Â¹ ] (Î”Â²-diagonal (Î´Î”Â¹-incl x) ï¼ (i , j)))
--                               {Left = Î£[ x âˆ¶ Î›[2,1] ] (Î›[2,1]-incl x ï¼ (i , j))}
--                               _
--                               {Right = Î£[ x âˆ¶ Î”Â¹ ] ((x , x) ï¼ (i , j))}
--                               (total-map-fst Î´Î”Â¹-incl)

--   _ : total-fibre-span ï¼ total-fibre-span'
--   _ = refl

--   span-map' : Span-map total-fibre-span intended-span
--   span-map' .Span-map.hâ‚ = _â‰ƒ_.fwd (Î›[2,1]-as-subtype a)
--   span-map' .Span-map.hâ‚‚ (mk-lift true , refl)
--      = (Î¹â‚‚ refl , refl)
--   span-map' .Span-map.hâ‚‚ (mk-lift false , refl)
--      = (Î¹â‚ refl , refl)
--   span-map' .Span-map.hâ‚ƒ (b , refl) = refl
--   span-map' .Span-map.H (mk-lift true , refl)
--     = âˆˆ-is-prop Î›[2,1]Sub a _ _
--   span-map' .Span-map.H (mk-lift false , refl)
--     = âˆˆ-is-prop Î›[2,1]Sub a _ _
--   span-map' .Span-map.K (mk-lift true , refl) = refl
--   span-map' .Span-map.K (mk-lift false , refl) = refl

--   span-map : Span-map intended-span total-fibre-span
--   span-map .Span-map.hâ‚ p =  _â‰ƒ_.bwd (Î›[2,1]-as-subtype a) p
--   span-map .Span-map.hâ‚‚ (asub , refl)
--     = pushout-rec (mk-cocone (Î» {refl â†’ (Î´Î”Â¹-0 , Î”Â²-refl)})
--                              (Î» {refl â†’ (Î´Î”Â¹-1 , Î”Â²-refl)})
--                              Î» {(p , q) â†’ Â¡ non-triv (p âˆ™ sym q) })
--                   asub
--   span-map .Span-map.hâ‚ƒ p = (j , Î”Â²-ext (p , refl))
--   span-map .Span-map.H = {!!}
--   span-map .Span-map.K = {!!}

--   span-map-is-equiv : is-Span-equiv span-map'
--   span-map-is-equiv .fst = _â‰ƒ_.has-is-eqv (Î›[2,1]-as-subtype a)
--   span-map-is-equiv .snd .fst
--     = is-equivâ†qiso (span-map .Span-map.hâ‚‚
--                     , (Î» { (mk-lift true , refl)
--                            â†’ Î£-pathâ†’ (refl , is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
--                          ; (mk-lift false , refl)
--                            â†’ Î£-pathâ†’ (refl , is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)})
--                     , Î» { (x , refl) â†’  pushout-ind
--               (Î» x â†’ Span-map.hâ‚‚ span-map' (Span-map.hâ‚‚ span-map (x , refl)) ï¼ (x , refl))
--                                            (mk-coconeD (Î» {refl â†’ {!!}}) {!!} {!!}) x })
--   span-map-is-equiv .snd .snd
--     = is-equivâ†qiso (span-map .Span-map.hâ‚ƒ
--                     , (Î» {(k , refl) â†’ Î£-pathâ†’ (refl ,
--                                    (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _))})
--                     , Î» p â†’ is-propâ†is-truncated (car-is-set _ _) _ _ )

-- Î´Î”Â²â‰ƒSub : (i0 ï¼ i1 â†’ âˆ…) â†’ Î´Î”Â² â‰ƒ Subtype.Î£Ìƒ Î´Î”Â²-sub
-- Î´Î”Â²â‰ƒSub nt
--   = Î´Î”Â²                               â‰ƒâŸ¨ totalâ‰ƒtotal-fibre Î´Î”Â²-incl eâ»Â¹ âŸ©
--     total-fibre Î´Î”Â²-incl              â‰ƒâŸ¨âŸ©
--     (Î£[ a âˆ¶ Î”Â² ] fibre Î´Î”Â²-incl a)    â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î´Î”Â²-as-subtype nt) âŸ©
--     (Î£[ a âˆ¶ Î”Â² ] (a âˆˆ Î´Î”Â²-sub))       â‰ƒâŸ¨âŸ©
--     Subtype.Î£Ìƒ Î´Î”Â²-sub                 â‰ƒâˆ

make-Î´Î”Â² : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z}
          â†’ Hom A y z â†’ Hom A x y â†’ Hom A x z
          â†’ Î´Î”Â² â†’ A
make-Î´Î”Â² f@(mk-hom fh f0 f1) g@(mk-hom gh g0 g1) h@(mk-hom hh h0 h1)
  = pushout-rec (mk-cocone (make-horn f g) (h .HomP.hom) Î» where
                               (mk-lift false) â†’ g0 âˆ™ sym h0
                               (mk-lift true ) â†’ f1 âˆ™ sym h1)
}
%```
}


\subtree[tot-000H]{
\title{Boundaries of squares}
\taxon{Definition}

\p{We define the boundary of a square by glueing a pair of horns together.}

%```agda
\agda{
Î´â–¡Â² : Type ğ“˜
Î´â–¡Â² = Pushout Î´Î›[2,1]-incl Î´Î›[2,1]-incl

Î´â–¡Â²-incl : Î´â–¡Â² â†’ â–¡^ 2
Î´â–¡Â²-incl
  = cogap (mk-cocone (Î”Â²-Î¹-upper âˆ˜ Î›[2,1]-incl) (Î”Â²-Î¹-lower âˆ˜ Î›[2,1]-incl)
                     Î» { (mk-lift true)  â†’ refl
                       ; (mk-lift false) â†’ refl})

Î´â–¡Â²-Sub : Subtype (â–¡^ 2) ğ“˜
Î´â–¡Â²-Sub .Subtype.family (i , j) = ((i0 ï¼ j) * (i1 ï¼ i)) Ã— ((i0 ï¼ i) * (i1 ï¼ j))
Î´â–¡Â²-Sub .Subtype.has-is-subtype _
  = is-prop-Î£
      (*-is-prop
        (is-prop-separated _ _)
        (is-prop-separated _ _))
      (Î» _ â†’
       *-is-prop
        (is-prop-separated _ _)
        (is-prop-separated _ _))

mk-Î´â–¡Â² : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z w}
         â†’ Hom A x y â†’ Hom A y z â†’ Hom A x w â†’ Hom A w z
         â†’ (Î´â–¡Â² â†’ A)
mk-Î´â–¡Â² f g h k = cogap (mk-cocone (make-horn g f) (make-horn k h)
                        Î» { (mk-lift true)  â†’ HomP.hom1 g âˆ™ sym (HomP.hom1 k)
                          ; (mk-lift false) â†’ HomP.hom0 f âˆ™ sym (HomP.hom0 h) })
  where open HomP
}
%```
}
