\taxon{Module}
\date{2025-04-18}
\title{Sigma representations for records}

\import{stt-macros}

% ```agda
\agda{
module Ergonomics.Representation where

open import Foundations.Prelude
open import Ergonomics.Builtins
open import Ergonomics.TCM
}
% ```

% ```agda
\agda{
Î£â†field-names : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ List A â†’ Term
Î£â†field-names [] = def (quote ğŸ™) []
Î£â†field-names (_ âˆ· []) = unknown
Î£â†field-names (_ âˆ· xs) =
  def (quote Î£) (lam visible (abs "_" (Î£â†field-names xs)) vâˆ· [])

Fields : Type
Fields = List (Name Ã— List Name)

-- an accessor is a term like fst (snd (snd (snd x)))
Fieldsâ†Field-names : List (Arg Name) â†’ Fields
Fieldsâ†Field-names [] = []
Fieldsâ†Field-names ((arg _ x) âˆ· []) = (x , []) âˆ· []
Fieldsâ†Field-names (arg ai x âˆ· y âˆ· ys) with Fieldsâ†Field-names (y âˆ· ys)
... | flds = (x , (quote fst âˆ· [])) âˆ· List-map (Î» (nm , p) â†’ nm , quote snd âˆ· p) flds

iso-typeâ†record : Name â†’ Name â†’ (List (Arg Term) â†’ TC Term) â†’ TC Term
iso-typeâ†record eqty namen unfolded = go [] =<< normalise =<< infer-type (def namen []) where
  open DoTC

  go : List ArgInfo â†’ Term â†’ TC Term
  go acc (pi argu@(arg i argTy) (abs s ty)) = do
    r â† extend-context "arg" argu (go (i âˆ· acc) ty)
    returnTC (pi (argH argTy) (abs s r))
  go acc (agda-sort _) = do
    let orig = def namen (reverse (map-up (Î» n ai â†’ arg ai (var n [])) 0 acc))
    repr     â† unfolded (reverse (map-up (Î» n _ â†’ argH (var n [])) 0 acc))
    returnTC (def eqty (orig vâˆ· repr vâˆ· []))
  go acc t = typeError (strErr "Not a record type " âˆ· nameErr namen âˆ· [])


-- repr ._â‰…_.fwd a .snd .snd .fst = field2 a
fwd-clause : Name Ã— List Name â†’ Clause
fwd-clause (field-nm , sel) = clause (("rec" , argN unknown) âˆ· [])
           (argN (proj (quote _â‰…_.fwd)) âˆ·
            argN (var 0) âˆ·
            List-map (argN âˆ˜ proj) sel)
           (def field-nm (var 0 [] vâˆ· []))

-- repr ._â‰…_.fwd-iso .fst x .fieldNm = fst (snd (snd ...))
bwd-clause : Name Ã— List Name â†’ Clause
bwd-clause (field-nm , sel)
  = clause (("sig" , argN unknown) âˆ· [])
           (argN (proj (quote _â‰…_.fwd-iso)) âˆ·
            argN (proj (quote fst)) âˆ·
            argN (var 0) âˆ·
            argN (proj field-nm)  âˆ·
            [])
           (foldr (Î» nm p â†’ def nm (p vâˆ· [])) (var 0 []) (reverse sel))

fwd-bwd-clause : Clause
fwd-bwd-clause
  = clause (("rec" , (argN unknown)) âˆ· [])
           (argN (proj (quote _â‰…_.fwd-iso)) âˆ·
            argN (proj (quote snd)) âˆ·
            argN (proj (quote fst)) âˆ·
            argN (var 0) âˆ· [])
           (con (quote refl) (unknown hâˆ· unknown hâˆ· unknown hâˆ· []))

bwd-fwd-clause : Clause
bwd-fwd-clause
  = clause (("sig" , (argN unknown)) âˆ· [])
           (argN (proj (quote _â‰…_.fwd-iso)) âˆ·
            argN (proj (quote snd)) âˆ·
            argN (proj (quote snd)) âˆ·
            argN (var 0) âˆ· [])
           (con (quote refl) (unknown hâˆ· unknown hâˆ· unknown hâˆ· []))

-- Look up a record type definition in the signature.
get-record-type : Name â†’ TC (Name Ã— List (Arg Name))
get-record-type n = get-definition n >>= Î» where
  (record-type conm fields) â†’ returnTC (conm , fields)
  _ â†’ typeError (
                strErr "get-record-type: definition " âˆ·
                nameErr n âˆ·
                strErr " is not a record type." âˆ·
                []) where
  open DoTC

private
  instantiate' : Term â†’ Term â†’ Term
  instantiate' (pi _ (abs _ xs)) (pi _ (abs _ b)) = instantiate' xs b
  instantiate' (agda-sort _) tm = tm
  instantiate' _ tm = tm

  sigmaâ†pi-term : Term â†’ TC Term
  sigmaâ†pi-term (pi (arg _ x) (abs n (def n' _))) = returnTC x
  sigmaâ†pi-term (pi (arg _ x) (abs n y)) = do
    sig â† sigmaâ†pi-term y
    returnTC (def (quote Î£) (x vâˆ· lam visible (abs n sig) vâˆ· []))
    where open DoTC
  sigmaâ†pi-term _ = typeError (strErr "Not a record type constructor! " âˆ· [])


make-record-repr : Name â†’ Name â†’ Name â†’ TC ğŸ™
make-record-repr iso eqv rec = do
  R-con , fields â† get-record-type rec
  let fields = Fieldsâ†Field-names fields

  R-ty â† get-type rec
  con-ty â† get-type R-con

  let fun args = do
    let tm = instantiate' R-ty con-ty
    sigmaâ†pi-term tm
  iso-type â† iso-typeâ†record (quote _â‰…_) rec fun
  eqv-type â† iso-typeâ†record (quote _â‰ƒ_) rec fun

  declare-def (argN iso) iso-type
  declare-def (argN eqv) eqv-type

  define-fun iso (List-map fwd-clause fields ++
                 (List-map bwd-clause fields ++
                 (fwd-bwd-clause âˆ· bwd-fwd-clause âˆ· [])))

  define-fun eqv (clause [] [] (def (quote equivâ†qiso) (def iso [] vâˆ· [])) âˆ· [])
  where open DoTC
}
% ```

\subtree[stt-0035]{
\taxon{Test}

% ```agda
\agda{
private module _ where
  record Test {ğ“¤} (A B : Type ğ“¤) : Type (lsuc ğ“¤) where
    constructor boo
    field
      f : A â†’ B
      g : B â†’ A
      h : f âˆ˜ g ~ id

  record NoCtx : Type where
    field
      b : Bool
      s : String

  unquoteDecl test-reprâ‰…' test-reprâ‰ƒ' = make-record-repr test-reprâ‰…' test-reprâ‰ƒ' (quote Test)

  unquoteDecl noctx-reprâ‰… noctx-reprâ‰ƒ = make-record-repr noctx-reprâ‰… noctx-reprâ‰ƒ (quote NoCtx)

  _ : NoCtx â‰ƒ (Bool Ã— String)
  _ = noctx-reprâ‰ƒ

}
% ```

}
