\date{2025-08-01}
\title{Descent for pushouts}
\taxon{module}
\meta{module}{Core.PushoutDescent}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.PushoutDescent where

open import Foundations.Prelude
open import Ergonomics.Extensionality
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
}
%```

\subtree[stt-008D]{
\title{Flattening lemma for pushouts}
\taxon{theorem}

\p{The flattening theorem essentially states that for a family #{P}
over a pushout #{A \times_C B}, the total type #{\tilde{P}} is
equivalent to the pushout of total types: #{\Sigma_A P
+_{\Sigma_C P} \Sigma_B P}.}

\proof{
\p{Given a span #{S : A \leftarrow B \rightarrow C} and a family #{P}
over the pushout of #{S}, we can define the total span #{\Sigma_{S}P}.
We first note that for some arbitrary type #{Q}, dependent cones over
#{S} at #{p \mapsto P(p) \to Q} are equivalent to cones over
#{\Sigma_{S} P} at #{Q} - this is analogous to [currying
functions](Foundations.PiProperties).  We then construct the following
square:
}

\quiver{
\begin{tikzcd}
	{\Pi_{p : A+^C B} Q^{P(p)}} && {Q^{\Sigma_{p : A+^CB} P(p)}} \\
	\\
	{\rm{cocone}^d(S,p \mapsto Q^{P(p)})} && {\rm{cocone}(\Sigma_S P,Q)}
	\arrow["{\rm{curry}}", from=1-1, to=1-3]
	\arrow["{\rm{cocone}^d}"', from=1-1, to=3-1]
	\arrow["{\rm{cocone}}", from=1-3, to=3-3]
	\arrow["{\rm{curry}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{Since, currying (functions or cocones) and the dependent cocone
map are equivalences, then so is the cocone map on the right.}

}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         (f : A â†’ B) (g : A â†’ C) where
  total-span : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
               â†’ Span _ _ _
  total-span P .Span.Centre = Î£ A (P âˆ˜ Î¹â‚‚ âˆ˜ g)
  total-span P .Span.Left = Î£ B (P âˆ˜ Î¹â‚)
  total-span P .Span.left (a , b) = (f a , tr P (sym (glue a)) b)
  total-span P .Span.Right = Î£ C (P âˆ˜ Î¹â‚‚)
  total-span P .Span.right = total-map-fst g

  total-cocone : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                 â†’ Cocone (total-span P) (Î£ (Pushout f g) P)
  total-cocone P .Cocone.p = total-map-fst Î¹â‚
  total-cocone P .Cocone.q = total-map-fst Î¹â‚‚
  total-cocone P .Cocone.filler (a , b)
    = Î£-pathâ†’ ( glue a , trâˆ™tr-sym' (glue a) b)

  total-is-pushout : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                     â†’ is-pushoutÏ‰ (total-span P) (total-cocone P)
  total-is-pushout P {ğ“ } {Q} = eqv where
    module S' = Span (total-span P)

    Q' : Pushout f g â†’ Type _
    Q' x = P x â†’ Q

    lem2 : âˆ€ {a b} (p : a ï¼ b) {x} {f : P a â†’ Q}
           â†’ (tr Q' p f) x ï¼ f (tr P (sym p) x)
    lem2 refl = refl

    curry-cocone
      : Cocone (total-span P) Q â†’ CoconeD _ pushout Q'
    curry-cocone (mk-cocone p q filler) = mk-coconeD (curry p) (curry q) Î»
      a â†’ funextâ†’ Î» b â†’ lem2 (glue a) âˆ™ curry filler a b

    H : Arrow-map (cocone-map _ (total-cocone P) {Q})
                  (coconeáµˆ-map (mk-span _ f g) pushout {Q'})
    H .Arrow-map.top = curry
    H .Arrow-map.bot = curry-cocone
    H .Arrow-map.comm h
      = ap (mk-coconeD (Î» a b â†’ h (Î¹â‚ a , b)) (Î» a b â†’ h (Î¹â‚‚ a , b)))
           (funextâ†’ Î» a â†’ J {a = Î¹â‚ (f a)} (Î» z G â†’
                 funextâ†’ (Î» b â†’ lem2 G âˆ™ ap h (Î£-pathâ†’ (G , trâˆ™tr-sym' G b)))
               ï¼ apáµˆ (curry h) G)
           funext-refl
           {Î¹â‚‚ (g a)} (glue a))

    curry-cocone-is-equiv : quasi-iso curry-cocone
    curry-cocone-is-equiv .fst (mk-coconeD p q filler)
      = mk-cocone (uncurry p) (uncurry q)
          Î» where (a , b) â†’ sym (lem2 (glue a)) âˆ™ happly (filler a) b
    curry-cocone-is-equiv .snd .fst (mk-cocone p q filler)
      = Cocone-pathâ†’ _  _ (funextâ†’ ~refl) (funextâ†’ ~refl)
          Î» a â†’ âˆ™-reflr _ âˆ™ sym'âˆ™ (lem2 (glue (fst a))) (filler a)
    curry-cocone-is-equiv .snd .snd (mk-coconeD p q filler)
      = ap (mk-coconeD p q) (funextâ†’ Î»
         a â†’   ap funextâ†’ (funextâ†’ (Î» b â†’ symâˆ™ (lem2 (glue a))
                                            (happly (filler a) b)))
             âˆ™ _â‰ƒ_.Î· funextâ‰ƒ (filler a))

    arr-eq : is-Arrow-equiv H
    arr-eq .fst = curry-is-equiv
    arr-eq .snd = is-equivâ†qiso curry-cocone-is-equiv

    eqv : is-equiv (cocone-map _ (total-cocone P))
    eqv = is-equivâ†Arrow-equivâ»Â¹ {F = H} arr-eq Pushout-is-pushoutÏ‰áµˆ
}
%```
}


\p{Before introducing the main descent theorem, we need some auxiliary
definitions.}


\subtree[stt-008M]{
\date{2025-08-03}
\title{Maps of spans}
\taxon{theorem}

\p{A map between spans #{S} and #{S'} is a diagram as follows where
all the squares commute:}

\quiver{
\begin{tikzcd}
	A && S && B \\
	\\
	{A'} && {S'} && {B'}
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=1-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=3-5]
	\arrow[from=3-3, to=3-1]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}

\p{Equivalently, a span map is a pair of arrow maps between the
left and right maps of each span, together with a homotopy between
the two maps between the centre of the spans.}

%```agda
\agda{
record Span-map {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                {ğ“¤' ğ“¥' ğ“¦'} (S' : Span ğ“¤' ğ“¥' ğ“¦')
                : Type (ğ“¤ âŠ” ğ“¤' âŠ” ğ“¥ âŠ” ğ“¥' âŠ” ğ“¦ âŠ” ğ“¦') where
   constructor mk-span-map
   module S = Span S
   module S' = Span S'
   field
     hâ‚ : S.Left â†’ S'.Left
     hâ‚‚ : S.Centre â†’ S'.Centre
     hâ‚ƒ : S.Right â†’ S'.Right
     H  : hâ‚ âˆ˜ S.left ~ S'.left âˆ˜ hâ‚‚
     K  : hâ‚ƒ âˆ˜ S.right ~ S'.right âˆ˜ hâ‚‚

   amap-lâ†“ : Arrow-map S.left S'.left
   amap-lâ†“ = mk-amap hâ‚‚ hâ‚ H

   amap-l : Arrow-map hâ‚‚ hâ‚
   amap-l = mk-amap S.left S'.left (H ~â»Â¹)

   amap-râ†“ : Arrow-map S.right S'.right
   amap-râ†“ = mk-amap hâ‚‚ hâ‚ƒ K

   amap-r : Arrow-map hâ‚‚ hâ‚ƒ
   amap-r = mk-amap S.right S'.right (K ~â»Â¹)
}
%```
}

\subtree[stt-008N]{
\date{2025-08-03}
\title{Cartesian maps of spans}
\taxon{definition}

\p{A map between spans is said to be cartesian when each square
is [cartesian](stt-003V) (i.e. a pullback square).}

%```agda
\agda{
is-cartesian-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {ğ“¤' ğ“¥' ğ“¦'} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S' â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
is-cartesian-span-map F = is-cartesian amap-l Ã— is-cartesian amap-r
  where open Span-map F

is-cartesian-span-map-is-prop
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {ğ“¤' ğ“¥' ğ“¦'} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {F : Span-map S S'}
    â†’ is-prop (is-cartesian-span-map F)
is-cartesian-span-map-is-prop
  = is-prop-Î£
      is-cartesian-is-prop
      (Î» _ â†’ is-cartesian-is-prop)
}
%```
}


\subtree[stt-008O]{
\date{2025-08-03}
\title{Pulling back squares}
\taxon{construction}

\p{Given span #{S}, and a cocone over #{S} centred at #{X}, we can
'pull this square back' along any map #{X' \to X}, to obtain a
span #{S'}, a cocone over #{S'} at #{X'} as well as a cartesian map
of spans #{S' \to S}.
}

%```agda
\agda{
module SquarePB {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {S : Span ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“œ}
                (C : Cocone S X) {X' : Type ğ“›} (f : X' â†’ X)
                where
  open Span S
  open Cocone C

  S' : Span (ğ“¤ âŠ” ğ“¥ âŠ” ğ“œ âŠ” ğ“›) (ğ“¥ âŠ” ğ“œ âŠ” ğ“›) (ğ“¦ âŠ” ğ“œ âŠ” ğ“›)
  S' .Span.Centre = Pullback {B = Pullback p f} fst left
  S' .Span.Left = Pullback p f
  S' .Span.left  = fst
  S' .Span.Right = Pullback q f
  S' .Span.right ((r , x , H) , c , K) = (right c  , x , sym (sym H âˆ™ ap p K âˆ™ filler c) )

  C' : Cocone S' X'
  C' .Cocone.p = pb.Ï€â‚‚ _ _
  C' .Cocone.q = pb.Ï€â‚‚ _ _
  C' .Cocone.filler _ = refl

  proj : Span-map S' S
  proj .Span-map.hâ‚ = pb.Ï€â‚ _ _
  proj .Span-map.hâ‚‚ = pb.Ï€â‚‚ _ _
  proj .Span-map.hâ‚ƒ = pb.Ï€â‚ q f
  proj .Span-map.H  = pb.filler _ _
  proj .Span-map.K _ = refl

  front-left : Arrow-map (pb.Ï€â‚ p f) f
  front-left = mk-amap (pb.Ï€â‚‚ p f) p (pb.filler p f)

  front-right : Arrow-map (pb.Ï€â‚ q f) f
  front-right = mk-amap (pb.Ï€â‚‚ q f) q (pb.filler _ _)

  front-right-is-cart : is-cartesian (front-right)
  front-right-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  front-left-is-cart : is-cartesian front-left
  front-left-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  amap-lâ†“-is-cart : is-cartesian (Span-map.amap-lâ†“ proj)
  amap-lâ†“-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  amap-l-is-cart : is-cartesian (Span-map.amap-l proj)
  amap-l-is-cart = rotate-is-cartesian _ amap-lâ†“-is-cart

  square~ : Arrow-map-path
              (paste-squares front-left (Span-map.amap-l proj))
              (paste-squares front-right (Span-map.amap-r proj))
  square~ .fst = ~refl
  square~ .snd .fst = filler
  square~ .snd .snd ((l , x' , H) , c , refl)
    = âˆ™-reflr _
    âˆ™ sym (ap (filler c âˆ™_) (âˆ™-symsym (sym H) (filler c))
          âˆ™ symâˆ™ (filler c) (sym (sym H))
          âˆ™ sym-sym)

  proj-is-cartesian : is-cartesian-span-map proj
  proj-is-cartesian .fst = amap-l-is-cart
  proj-is-cartesian .snd = 3-for-2-cartesian square~
    (compose-cartesian front-left-is-cart amap-l-is-cart)
    front-right-is-cart

}
%```
}

\subtree[stt-008P]{
\title{Cartesian span maps are descent data}
\taxon{lemma}

\p{Given a span #{S}, we can define a map #{\rm{Cocone}(C,\UU) \to
\rm{Cart}(S)} - where #{\rm{Cart}(S)} is the type of spans #{S'}
together with a cartesian span map down into #{S}.}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {Sp : Span ğ“¤ ğ“¥ ğ“¦}  where
  open Span Sp renaming (Centre to S;
                         left to f;
                         right to g;
                         Left to A;
                         Right to B) using ()

  Cart : âˆ€ ğ“œ â†’ Type (lsuc (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ))
  Cart ğ“œ = Î£[ S' âˆ¶ Span (ğ“¤ âŠ” ğ“¥ âŠ” ğ“œ) (ğ“¥ âŠ” ğ“œ) (ğ“¦ âŠ” ğ“œ) ] Î£[ proj âˆ¶ Span-map S' Sp ]
            is-cartesian-span-map proj

  Cart-pathâ†’ : âˆ€ {ğ“œ}
              â†’ {C C' : Cart ğ“œ}
              â†’ (p : C .fst ï¼ C' .fst)
              â†’ IdP (ap (Î» p â†’ Span-map p Sp) p) (C .snd .fst) (C' .snd .fst)
              â†’ C ï¼ C'
  Cart-pathâ†’ refl Q = Î£-pathâ†’ ( refl
                              , Î£-pathâ†’
                                 ( Q
                                 , is-cartesian-span-map-is-prop _ _
                                 )
                               )

  cartâ†cocone : âˆ€ {ğ“œ} â†’ Cocone Sp (Type ğ“œ) â†’ Cart ğ“œ
  cartâ†cocone cc = ( span , proj , cart) where
    open Cocone cc renaming (p to Pa; q to Pb)

    span : Span _ _ _
    span .Span.Centre = Î£[ s âˆ¶ S ] Î£[ a âˆ¶ A ] Î£[ p âˆ¶ f s ï¼ a ] Pa a -- we have to insert a singleton to make the universe lvl line up
    span .Span.Left = Î£ A Pa
    span .Span.left (s , .(f s) , refl , pa) = (f s , pa)
    span .Span.Right = Î£ B Pb
    span .Span.right (s , a , refl , pa) = (g s , coe (filler s) pa)

    proj : Span-map span Sp
    proj .Span-map.hâ‚ = fst
    proj .Span-map.hâ‚‚ = fst
    proj .Span-map.hâ‚ƒ = fst
    proj .Span-map.H (s , a , refl , pa) = refl
    proj .Span-map.K (s , a , refl , pa) = refl

    ramap : âˆ€ s â†’ Arrow-map
                    (Î» (a : Pb (g s)) â†’ a)
                    (arrow-fibre (Span-map.amap-r proj) s)
    ramap s .Arrow-map.top pb = ((s  , f s , refl , coe (sym (filler s)) pb ) ,  refl)
    ramap s .Arrow-map.bot pb = (g s , pb) , refl
    ramap s .Arrow-map.comm a
      = fibre-pathâ†’
          (  Î£-pathâ†’ (refl , (sym (coe-sym (filler s))))
          , (âˆ™-reflr _ âˆ™ Î£-path-ap-fst)
          )

    ramap-eq : âˆ€ s â†’ is-Arrow-equiv (ramap s)
    ramap-eq s .fst = is-equivâ†qiso (Î» where
      .fst ((_ , _ , refl , pa) , refl) â†’ coe (filler s) pa
      .snd .fst a â†’ coe-sym (filler s)
      .snd .snd ((s , a , refl , pa) , refl) â†’ fibre-pathâ†’ ((Î£-pathâ†’ (refl , (Î£-pathâ†’ (refl , (Î£-pathâ†’ (refl , coe-sym' (filler s)))))))
                , âˆ™-reflr _ âˆ™ Î£-path-ap-fst âˆ™ refl))
    ramap-eq s .snd = is-equivâ†qiso (Î» where
      .fst ((b , pb) , refl) â†’ pb
      .snd .fst â†’ ~refl
      .snd .snd ((b , pb) , refl) â†’ refl)

    cart : is-cartesian-span-map proj
    cart .fst = {!!}
    cart .snd s = is-equivâ†Arrow-equiv {F = ramap s} (ramap-eq s) id-is-equiv
}
%```
}

\subtree[stt-008L]{
\date{2025-08-03}
\title{Descent for pushouts}
\taxon{theorem}

\p{In the following, let #{S} be a span and #{C} be a cocone over #{S}
centred at #{X}.}

\p{Descent for pushouts states that if this cocone is a pushout, then
the map that takes a type #{X'} and a map #{X' \to X} to a span
together with a cartesian map down to #{S} is an equivalence.}


%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“œ}
         (C : Cocone S X) (C-pb : is-pushoutÏ‰ _ C) where

  cart-map : (Î£[ X' âˆ¶ Type ğ“œ ] (X' â†’ X)) â†’ Cart ğ“œ
  cart-map (X' , f) = (S' , proj , proj-is-cartesian) where
    open SquarePB C f


  descent-pushout : is-equiv cart-map
  descent-pushout = is-equivâ†Arrow-equiv {F = amap} amap-eqv (C-pb) where
    straighten : (X â†’ Type ğ“œ) â†’ Î£[ X' âˆ¶ Type ğ“œ ] (X' â†’ X)
    straighten B = (Î£ _ B , fst)

    straighten-equiv : is-equiv straighten
    straighten-equiv = is-equivâ†qiso {!!}

    amap : Arrow-map (cocone-map _ C) cart-map
    amap .Arrow-map.top = straighten
    amap .Arrow-map.bot = cartâ†cocone
    amap .Arrow-map.comm P = Cart-pathâ†’ {!!} {!!}

    amap-eqv : is-Arrow-equiv amap
    amap-eqv .fst = straighten-equiv
    amap-eqv .snd = {!!}
}
%```
}
