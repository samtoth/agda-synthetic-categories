\date{2025-07-30}
\title{Canonical Sequential Colimits}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.CanonicalSeqColims where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Coequalisers
open import Core.SeqMapHomotopy

open import Ergonomics.Marker
open import Ergonomics.Extensionality
}
%```

\subtree[stt-008B]{
\title{Canonical Sequential Colimits}
\taxon{Construction}

\p{Let #{A} be an [increasing sequence](stt-0085), and write #{\tilde{A}}
for the type #{\Sigma_{n : \mathbb{N}}A_n}.}

\p{We define the sequential colimit of #{A} to be the coequaliser of
#{\textit{incr} : \tilde{A} \to \tilde{A}} with #{\id}. We note that
this gives us a sequential cocone under #{A} which we write #{\iota_n}
and homotopies #{\textit{gl-suc}_n : \iota_n
\sim \iota_{n+1} \rm{incr}}, which we can extend to homotopies
#{\textit{gl}_{m,n} : \iota_n \sim \iota_{n+m} \rm{incr}_m}}

%```agda
\agda{
Seq-colimit : âˆ€ {ğ“¤} â†’ Incr-seq ğ“¤ â†’ Type ğ“¤
Seq-colimit S = Coeq id incrÎ£ where open Incr-seq S

seq-colimit : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) â†’ Cocone-seq S (Seq-colimit S)
seq-colimit S = mk-cocone-seq (Î» {n} a â†’ Î¹â‚‚ (n , a))
                              Î» {n} a â†’ sym (glue (inl (n , a)))
                                      âˆ™ glue (inr (n , a))

Î¹-seq : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) {n}
        â†’ S .Incr-seq.Point n â†’ Seq-colimit S
Î¹-seq S a = coeq _ _ .fst (_ , a)

{-# NOINLINE Î¹-seq #-}

glue-suc : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) {n}
           â†’ Î¹-seq S {n} ~ Î¹-seq S {suc n} âˆ˜ Incr-seq.incr S
glue-suc S = Cocone-seq.comm (seq-colimit S)
{-# NOINLINE glue-suc #-}

glue-n : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) n
         â†’ Î¹-seq S {0} ~ Î¹-seq S {n} âˆ˜ Incr-seq.incrâ„• S n
glue-n S zero = ~refl
glue-n S (suc n) = glue-n S n ~âˆ™ glue-suc S â–¸ Incr-seq.incrâ„• S n

glue-+ : âˆ€ {ğ“¤} (S : Incr-seq ğ“¤) {n} m
         â†’ Î¹-seq S {n} ~ Î¹-seq S {n + m} âˆ˜ Incr-seq.incr-+ S m
glue-+ S zero = ~refl
glue-+ S (suc m) = glue-+ S m ~âˆ™ glue-suc S â–¸ Incr-seq.incr-+ S m
}
%```
}

\subtree[stt-008C]{
\title{Cocones of canonical sequential colimits}
\taxon{Lemma}

\p{Coforks over the pair of arrows in \ref{stt-008B} defining the
canonical sequential colimits are equivalent to
[sequential cocones](stt-0088)}

\proof{
\p{This follows from the [curry/uncurry
equivalence](Foundations.PiProperties).}
}

%```agda
\agda{
seq-coconeâ‰ƒcofork : âˆ€ {ğ“¤ ğ“ } {S : Incr-seq ğ“¤} {Q : Type ğ“ }
                  â†’ Cofork id (Incr-seq.incrÎ£ S) Q
                  â‰ƒ Cocone-seq S Q
seq-coconeâ‰ƒcofork {_} {_} {S} {Q}
  = mkâ‰ƒ map (is-equivâ†qiso map-qiso) where
    open Incr-seq S

    map : Cofork id incrÎ£ Q â†’ Cocone-seq S Q
    map (p , H) = mk-cocone-seq (curry p _) (curry H _)

    map-qiso : quasi-iso map
    map-qiso .fst (mk-cocone-seq Î¹ comm)
      = (Î» (_ , a) â†’ Î¹ a) , (Î» (_ , a) â†’ comm a)
    map-qiso .snd .fst = ~refl
    map-qiso .snd .snd = ~refl
}
%```

\p{As a consequence, we then have that the canonical sequential colimit
is a sequential colimit and has a recursion principal.}

%```agda
\agda{
seq-colim-is-colim :  âˆ€ {ğ“¤} {S : Incr-seq ğ“¤}
                      â†’ is-seq-colim S (seq-colimit S)
seq-colim-is-colim Q = is-equiv-âˆ˜ (seq-coconeâ‰ƒcofork ._â‰ƒ_.has-is-eqv)
                                  coeq-is-coeq

seq-colim-rec : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {Q : Type ğ“¥}
                  â†’ Cocone-seq S Q â†’ (Seq-colimit S â†’ Q)
seq-colim-rec = is-equiv.bwd (seq-colim-is-colim _)

{-# DISPLAY is-equiv.bwd (seq-colim-is-colim _) f x = seq-colim-rec f x #-}

seq-colim-apÎ² : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {Q : Type ğ“¥}
                â†’ (CC : Cocone-seq S Q)
                â†’ âˆ€ a â†’ ap (seq-colim-rec CC) (glue-suc S (a .snd))
                ï¼ CC .Cocone-seq.comm (a .snd)
seq-colim-apÎ² CC a = let cocone = (coconeâ†cofork (_â‰ƒ_.bwd seq-coconeâ‰ƒcofork CC))
  in ap (seq-colim-rec CC) (sym (glue (inl a)) âˆ™ glue (inr a))
                          ï¼âŸ¨ ap-âˆ™ (seq-colim-rec CC) (sym (glue (inl a))) (glue (inr a)) âŸ©
     ap (seq-colim-rec CC) (sym (glue (inl a))) âˆ™ ap (seq-colim-rec CC) (glue (inr a))
                          ï¼âŸ¨ apâ‚‚ _âˆ™_ (ap-sym (seq-colim-rec CC) _ âˆ™ ap sym (pushout-rec-apÎ² (inl a))) (pushout-rec-apÎ² (inr a)) âŸ©
     sym (Cocone.filler cocone (inl a)) âˆ™ Cocone.filler cocone (inr a)  ï¼âŸ¨âŸ©
     CC .Cocone-seq.comm (a .snd) âˆ
}
%```
}

\subtree[stt-0099]{
\title{Induction for sequential colimits}
\taxon{Theorem}

\p{We can also define an induction principal for sequential colimits
directly via the [induction principal for coequalisers](stt-009O).}

%```agda
\agda{
seq-CoconeP : âˆ€ {ğ“¤ ğ“¥} (S : Incr-seq ğ“¤) â†’ (Q : Seq-colimit S â†’ Type ğ“¥)
              â†’ Type (ğ“¤ âŠ” ğ“¥)
seq-CoconeP S Q = Î£[ f âˆ¶ (âˆ€ {n} â†’ (p : Point n) â†’ Q (Î¹-seq S p))]
                     (âˆ€ {n} (a : Point n)
                        â†’ IdP (ap Q (glue-suc S a)) (f a) (f (incr a)))
  where open Incr-seq S


forkPâ†coconeP : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {Q : Seq-colimit S â†’ Type ğ“¥}
                  â†’ seq-CoconeP S Q â†’ CoforkP _ _ Q
forkPâ†coconeP scc .fst (n , p) = scc .fst p
forkPâ†coconeP scc .snd (n , p) = scc .snd p

seq-colimit-ind : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {Q : Seq-colimit S â†’ Type ğ“¥}
                  â†’ seq-CoconeP S Q â†’ Î  (Seq-colimit S) Q
seq-colimit-ind cc = coeq-ind (forkPâ†coconeP cc)
}
%```
}

\subtree[stt-008Z]{
\title{Taking the sequential colimit is functorial}
\taxon{Theorem}
\date{2025-08-15}

\p{Taking sequential colimits defines a functor between the category
of sequences and the category of types. Given a map between sequences
#{F : S \to S'}, we can define a map between their colimits
#{\rm{colim}(F) : \rm{colim}(S) \to \rm{colim}(S')}.}

\p{We then show that this map preserves the identity, composition and
homotopies of sequence maps.}

%```agda
\agda{
seq-colimit-map
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      (F : Incr-seq-map S S')
    â†’ Seq-colimit S â†’ Seq-colimit S'
seq-colimit-map {S = S} {S'} F = seq-colim-rec cc module seq-colim-map where
  open Incr-seq-map F

  cc : Cocone-seq _ (Seq-colimit _)
  cc .Cocone-seq.Î¹ = Î¹-seq S' âˆ˜ map
  cc .Cocone-seq.comm = glue-suc S' â–¸ map ~âˆ™ Î¹-seq S' â—‚ comm

ap-seq-colimit-map-glue-suc
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      (F : Incr-seq-map S S')
    â†’ âˆ€ {n} (a : Incr-seq.Point S n)
    â†’ ap (seq-colimit-map F) (glue-suc S a)
    ï¼ glue-suc S' (Incr-seq-map.map F a) âˆ™ ap (Î¹-seq S') (Incr-seq-map.comm F a)
ap-seq-colimit-map-glue-suc {S = S} {S'} F a
  = ap (seq-colim-rec (seq-colim-map.cc F)) (glue-suc _ a)
                      ï¼âŸ¨ seq-colim-apÎ² (seq-colim-map.cc F) (_ , a) âŸ©
    seq-colim-map.cc F .Cocone-seq.comm a
                                        ï¼âŸ¨âŸ©
    glue-suc S' (Incr-seq-map.map F a)
      âˆ™ ap (Î¹-seq S') (Incr-seq-map.comm F a) âˆ


seq-colimit-map~
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      {F G : Incr-seq-map S S'}
    â†’ iseq-map~ F G â†’ seq-colimit-map F ~ seq-colimit-map G
seq-colimit-map~ H = happly (ap (seq-colimit-map) (ext! H))

seq-colimit-rec~
  : âˆ€ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      {f g : Seq-colimit S â†’ Seq-colimit S'}
    â†’ seq-cocone-map (seq-colimit S) f
        ï¼â‚‘
      seq-cocone-map (seq-colimit S) g
    â†’ f ï¼ g
seq-colimit-rec~ {S = S}{S'} p
  = unap-equiv {f = seq-cocone-map (seq-colimit S)}
               (seq-colim-is-colim (Seq-colimit S'))
               (ext! p)

seq-colimit-map-id
  : âˆ€ {ğ“¤} {S : Incr-seq ğ“¤}
  â†’ seq-colimit-map (id-iseq-map {S = S}) ï¼ id
seq-colimit-map-id {S = S} = seq-colimit-rec~ H where
  open Incr-seq

  H : IdS
       (seq-cocone-map _ (seq-colimit-map (id-iseq-map)))
       (seq-cocone-map _ id)
  H .fst = ~refl
  H .snd {n}
    = {- (seq-colimit-map id-iseq-map) â—‚ (seq-incr S)
          ~âˆ™ ~refl â–¸ incr S        ~âŸ¨âŸ© -}
      (seq-colimit-map id-iseq-map) â—‚ (glue-suc S) ~âˆ™ ~refl
                          ~âŸ¨ ~âˆ™-reflr _ âŸ©
      (seq-colimit-map id-iseq-map) â—‚ (glue-suc S)
                          ~âŸ¨ ap-seq-colimit-map-glue-suc id-iseq-map âŸ©
      glue-suc S ~âˆ™ ~refl ~âŸ¨ ~âˆ™-reflr _ âŸ©
      glue-suc S          ~âŸ¨ sym âˆ˜ ap-id âˆ˜ glue-suc S âŸ©
      id â—‚ glue-suc S     ~âˆ

seq-colimit-mapâˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
      {S'' : Incr-seq ğ“¦}
      (f : Incr-seq-map S S') (g : Incr-seq-map S'' S)
    â†’  seq-colimit-map f âˆ˜ seq-colimit-map g
    ï¼ seq-colimit-map (compose-iseq-map f g)
seq-colimit-mapâˆ˜ {S = S} {S'}{S''} f g = seq-colimit-rec~ H where
  open Incr-seq-map

  opaque
    lem2 : âˆ€ {n} (a : A.Point g n)
           â†’ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
           ï¼ ap (Î¹-seq S') (ap (map f) (comm g a))
    lem2 a
      = ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
             ï¼âŸ¨ sym (ap-âˆ˜ (seq-colimit-map f) (Î¹-seq S) (comm g a)) âŸ©
        ap (seq-colimit-map f âˆ˜ Î¹-seq S) (comm g a) ï¼âŸ¨âŸ©
        ap (Î¹-seq S' âˆ˜ map f) (comm g a)
             ï¼âŸ¨ ap-âˆ˜ (Î¹-seq S') (map f) (comm g a) âŸ©
        ap (Î¹-seq S') (ap (map f) (comm g a)) âˆ

    lemma : âˆ€ {n} (a : A.Point g n)
            â†’   ap (Î¹-seq S') (comm f (map g a))
              âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
            ï¼ ap (Î¹-seq S') (comm f (map g a) âˆ™ ap (map f) (comm g a))
    lemma {n} a
      = ap (Î¹-seq S') (comm f (map g a)) âˆ™
         ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
              ï¼âŸ¨ ap (ap (Î¹-seq S') (comm f (map g a)) âˆ™_) (lem2 a) âŸ©
        ap (Î¹-seq S') (comm f (map g a)) âˆ™ ap (Î¹-seq S') (ap (map f) (comm g a))
              ï¼âŸ¨ sym (ap-âˆ™ (Î¹-seq S') (comm f (map g a)) (ap (map f) (comm g a))) âŸ©
        ap (Î¹-seq S') (comm f (map g a) âˆ™ ap (map f) (comm g a))    âˆ

  H : IdS
       (seq-cocone-map _ (seq-colimit-map f âˆ˜ seq-colimit-map g))
       (seq-cocone-map _ (seq-colimit-map (compose-iseq-map f g)))
  H .fst = ~refl
  H .snd {n = n} a
    = ap (seq-colimit-map f âˆ˜ seq-colimit-map g) (glue-suc S'' a) âˆ™ refl
               ï¼âŸ¨ âˆ™-reflr _ âŸ©
      ap (seq-colimit-map f âˆ˜ seq-colimit-map g) (glue-suc S'' a)
               ï¼âŸ¨ ap-âˆ˜ (seq-colimit-map f) (seq-colimit-map g) (glue-suc S'' a) âŸ©
      ap (seq-colimit-map f) (ap (seq-colimit-map g) (glue-suc S'' a))
               ï¼âŸ¨ ap (ap (seq-colimit-map f)) (ap-seq-colimit-map-glue-suc g a) âŸ©
      ap (seq-colimit-map f)
        (glue-suc S (map g a) âˆ™ ap (Î¹-seq S) (comm g a))
               ï¼âŸ¨ ap-âˆ™ (seq-colimit-map f) (glue-suc S (map g a)) (ap (Î¹-seq S) (comm g a)) âŸ©
      ap (seq-colimit-map f) (glue-suc S (map g a))
        âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))
               ï¼âŸ¨ ap (_âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a))) (ap-seq-colimit-map-glue-suc f (map g a)) âŸ©
      (glue-suc S' (map f (map g a)) âˆ™ ap (Î¹-seq S') (comm f (map g a)))
        âˆ™ ap (seq-colimit-map f) (ap (Î¹-seq S) (comm g a)) ï¼âŸ¨ âˆ™.pulll _ (lemma a) âŸ©
      glue-suc S' (map f (map g a)) âˆ™  ap (Î¹-seq S') (comm (compose-iseq-map f g) a)
               ï¼âŸ¨âŸ©
      Cocone-seq.comm (seq-colim-map.cc (compose-iseq-map f g)) a
               ï¼âŸ¨ sym (seq-colim-apÎ² _ (n , a)) âŸ©
      Cocone-seq.comm
        (seq-cocone-map
          (mk-cocone-seq (Î» {n = nâ‚} z â†’ Î¹â‚‚ (nâ‚ , z)) (glue-suc S''))
          (seq-colim-rec (seq-colim-map.cc (compose-iseq-map f g))))
         a
               ï¼âŸ¨âŸ©
      comm
       (seq-mapâ†cocone
        (seq-cocone-map
         (mk-cocone-seq (Î» {n} z â†’ Î¹â‚‚ (n , z))
          (glue-suc S''))
         (seq-colimit-map (compose-iseq-map f g))))
       a âˆ
}
%```
}

\subtree[stt-008Y]{
\title{Sequential colimits of equivalent sequences}
\taxon{Corollary}
\date{2025-08-15}

\p{[Equivalent](stt-008X) sequences gives rise to equivalent sequential
colimits.}

\proof{
\p{This follows from the [functoriality of taking the colimit](stt-008Z)
and \ref{stt-0095}.}
}


%```agda
\agda{
module _ {ğ“¤ ğ“¥} {S : Incr-seq ğ“¤} {S' : Incr-seq ğ“¥}
         (F : Incr-seq-map S S')  where
  open Incr-seq-map F

  seq-colimit-map-is-equiv
    : is-iseq-equiv F â†’ is-equiv (seq-colimit-map F)
  seq-colimit-map-is-equiv Feq = is-equivâ†qiso iso where
    module F {n} = is-equiv (Feq n)
    Fbwd = seq-map-invâ†equiv {F = F} Feq

    iso : quasi-iso (seq-colimit-map F)
    iso .fst = seq-colimit-map Fbwd
    iso .snd .fst =  happly (seq-colimit-mapâˆ˜ Fbwd F)
                  ~âˆ™ seq-colimit-map~ (inverse-seq-map-section Feq)
                  ~âˆ™ happly seq-colimit-map-id
    iso .snd .snd = happly (seq-colimit-mapâˆ˜ F Fbwd)
                  ~âˆ™ seq-colimit-map~ (inverse-seq-map-retraction {F = F} Feq)
                  ~âˆ™ happly seq-colimit-map-id
}
%```
}

\subtree[stt-0097]{
\title{Colimit of the unit sequence}
\taxon{Lemma}

\p{The colimit of the constant sequence at the unit type is a
singleton.}

\proof{
Choose the centre of contraction to be #{\iota_0(*)}, and then
each #{\iota_{n}(x)} has a path given by glueing #{n} times.
}

%```agda
\agda{

ğŸ™-iseq : Incr-seq lzero
ğŸ™-iseq = const-incr-seq ğŸ™

colimğŸ™ : is-singleton (Seq-colimit ğŸ™-iseq)
colimğŸ™ = mk-singl (Î¹-seq _ {0} tt)
         (seq-colimit-ind ((Î» {n} p â†’ glue-n _ n tt)
                          , Î» a â†’ IdP-funcâ†Square
                                      {f = Î» _ â†’ Î¹-seq _ {0} tt}
                                      {g = id}
                                      (glue-suc _ a) _ _ sq)) where
  sq : âˆ€ {n} {a : Incr-seq.Point (const-incr-seq ğŸ™) n} â†’
      Square
      (ap (Î» z â†’ Î¹-seq _ tt) (glue-suc _ a))
      (ap id (glue-suc _ a))
      (glue-n _ n tt)
      (glue-n _ (suc n) tt)
  sq {n} {a}
    = ap (Î» _ â†’ Î¹-seq _ tt) (glue-suc _ a) âˆ™ (glue-n _ (suc n) tt)
                            ï¼âŸ¨ ap-const  (glue-suc _ a)  âŸ©âˆ™âŸ¨ refl âŸ©
      (glue-n _ (suc n) tt) ï¼âŸ¨âŸ©
      glue-n _ n tt âˆ™ glue-suc _ a
                            ï¼âŸ¨ refl âŸ©âˆ™âŸ¨ sym (ap-id (glue-suc _ a)) âŸ©
      glue-n _ n tt âˆ™ ap id (glue-suc _ a)    âˆ
}
%```
}

\subtree[stt-0096]{
\title{Sequential colimits of constant sequences are singletons}
\taxon{Theorem}
\date{2025-08-16}

\p{Given a sequence #{A} with points #{a_n : A_n}, the colimit of
#{A} is a singleton if each map #{A_n \to A_{n+1}} is homotopic
to the constant map at #{a_{n+1}}.}

\proof{
\p{We take #{\iota_0(a_0)} to be the centre of contraction, then to
show there is a path #{\iota_0(a_0) = x} for any #{x} in the colimit,
we use induction. This we need the following data:}

\ul{
\li{Homotopies #{H_n : \Delta_{\iota(a_0)} \sim \iota_n}}
\li{A homotopy between #{H_{n+1}\rm{incr}} and #{H_{n} \cdot gl_n}}
}


\p{The homotopy #{H_n} is constructed as follows:
##{gl_{0,n+1} \cdot K(\rm{incr}_n(a_0)) \cdot
  K(p)^{-1} \cdot gl_{n}^{-1}}
Where #{K} is the homotopy expressing the constancy of the sequence.}

\p{The second homotopy follows via naturality of #{gl} and #{K}, modulo
some slightly awkward path algebra.}
}

%```agda
\agda{
module _ {ğ“¤} {A : Incr-seq ğ“¤} (a : Î  â„• (Incr-seq.Point A)) where
  open Incr-seq A
  open Incr-seq-map

  colim-mapâ†const
    : (âˆ€ n â†’ incr {n} ~ const _ _ (a (suc n))) â†’ Incr-seq-map ğŸ™-iseq A
  colim-mapâ†const is-const .map _ = a _
  colim-mapâ†const is-const .comm _ = is-const _ _

  colim-pointâ†const
    : (âˆ€ n â†’ incr {n} ~ const _ _ (a (suc n))) â†’ Seq-colimit A
  colim-pointâ†const is-const = seq-colimit-map
                                 (colim-mapâ†const is-const)
                                 (centre colimğŸ™)

  colim-const-seq-is-single : (âˆ€ n â†’ incr {n} ~ const _ _ (a (suc n)))
                              â†’ is-singleton (Seq-colimit A)
  colim-const-seq-is-single is-const
    = mk-singl (colim-pointâ†const is-const) (seq-colimit-ind cc) where


    glue-up : âˆ€ {n} (p : Point n) â†’ Î¹-seq A (a 0) ï¼ Î¹-seq A p
    glue-up {n} p = (glue-n A (suc n) (a 0)
                     âˆ™ ap (Î¹-seq A) (is-const n (incrâ„• n (a 0))
                                    âˆ™ sym (is-const n p)))
                   âˆ™ sym (glue-suc A p)

    const-nat : âˆ€ {n} (p : Point n)
        â†’ is-const _ (incr p)
        ï¼ ap incr (is-const _ p) âˆ™ is-const _ (a (suc n))
    const-nat p = sym (âˆ™.eliml _ (ap-const _))
                âˆ™ homotopy-natural (is-const _) (is-const _ p)


    lemma : âˆ€ {n} (p : Point n)
           â†’ (is-const _ (incrâ„• (suc n) (a 0)) âˆ™ sym (is-const _ (incr p)))
          ï¼ ap incr (is-const _ (incrâ„• n (a 0)) âˆ™ sym (is-const _ p))
    lemma p
      = is-const (suc _) (incrâ„• (suc _) (a 0))
         âˆ™ sym (is-const (suc _) (incr p))
               ï¼âŸ¨ const-nat (incrâ„• _ (a 0))  âŸ©âˆ™âŸ¨ ap sym (const-nat p) âˆ™ âˆ™-symsym (ap incr (is-const _ p)) _ âŸ©

        (ap incr (is-const _ (incrâ„• _ (a 0))) âˆ™ is-const (suc _) (a (suc _)))
         âˆ™ (sym (is-const (suc _) (a (suc _))) âˆ™ sym (ap incr (is-const _ p)))

               ï¼âŸ¨ âˆ™.cancel-inner _ (âˆ™-sym (is-const _ (a (suc _)))) {f = sym (ap (incr) (is-const _ p))}  âŸ©

        ap incr (is-const _ (incrâ„• _ (a 0)))
          âˆ™ sym (ap incr (is-const _ p))
                ï¼âŸ¨ ap (ap incr _ âˆ™_) (sym (ap-sym incr (is-const _ p)))
                  âˆ™ sym (ap-âˆ™ incr _ (sym (is-const _ p)))  âŸ©
        ap incr (is-const _ (incrâ„• _ (a 0)) âˆ™ sym (is-const _ p))    âˆ

    glue-up-suc : âˆ€ {n} (p : Point n)
                â†’ glue-up (incr p) ï¼ glue-up p âˆ™ glue-suc A p
    glue-up-suc {n} p =
      ((glue-n A (suc n) (a 0) âˆ™ glue-suc A (incrâ„• (suc n) (a 0)))
        âˆ™ âŒœ ap (Î¹-seq A) ( is-const _ (incrâ„• (suc n) (a 0))
                         âˆ™ sym (is-const _ (incr p))) âŒ)
      âˆ™ sym (glue-suc A (incr p))

            ï¼âŸ¨ ap! (ap (ap (Î¹-seq A)) (lemma p)
                âˆ™ sym (ap-âˆ˜ (Î¹-seq A) incr _)) âŸ©

      (âŒœ (glue-n A (suc n) (a 0) âˆ™ glue-suc A (incrâ„• (suc n) (a 0)))
        âˆ™ ap (Î¹-seq A âˆ˜ incr) (is-const _ (incrâ„• n (a 0))
                              âˆ™ sym (is-const _ p)) âŒ)
      âˆ™ sym (glue-suc A (incr p))

            ï¼âŸ¨ ap! (âˆ™.extendl _
                      (homotopy-natural (glue-suc A)
                        (is-const n (incrâ„• n (a 0))
                        âˆ™ sym (is-const n p)))
                    {e = glue-n A (suc n) (a 0)}) âŸ©

      ((glue-n A (suc n) (a 0)
        âˆ™ ap (Î¹-seq A) (is-const n (incrâ„• n (a 0))
        âˆ™ sym (is-const n p)))
      âˆ™ glue-suc A (incr p))
      âˆ™ sym (glue-suc A (incr p))

            ï¼âŸ¨  âˆ™.cancell _ (âˆ™-sym (glue-suc A (incr p))) âŸ©

       glue-n A (suc n) (a 0)
       âˆ™ ap (Î¹-seq A) (is-const n (incrâ„• n (a 0)) âˆ™ sym (is-const n p))

            ï¼âŸ¨ sym (âˆ™.cancell _ (âˆ™-sym' (glue-suc A p))) âŸ©

       ((glue-n A (suc n) (a 0)
         âˆ™ ap (Î¹-seq A) (is-const n (incrâ„• n (a 0)) âˆ™ sym (is-const n p)))
       âˆ™ sym (glue-suc A p))
      âˆ™ glue-suc A p âˆ



    sq : âˆ€ {n} {p : Point n}
         â†’ Square (ap (Î» _ â†’ Î¹-seq A (a 0)) (glue-suc A p))
                  (ap id (glue-suc A p))
                  (glue-up p)
                  (glue-up (incr p))
    sq {n} {p}
     = ap (Î» _ â†’ Î¹-seq A (a 0)) (glue-suc A p) âˆ™ glue-up (incr p)
                  ï¼âŸ¨ ap-const (glue-suc A p) âŸ©âˆ™âŸ¨ refl âŸ©
       glue-up (incr p)
                  ï¼âŸ¨ glue-up-suc p âŸ©
       glue-up p âˆ™ glue-suc A p
                  ï¼âŸ¨ refl âŸ©âˆ™âŸ¨ sym (ap-id (glue-suc A p)) âŸ©
       glue-up p âˆ™ ap id (glue-suc A p)    âˆ

    cc : seq-CoconeP A (colim-pointâ†const is-const ï¼_)
    cc .fst = glue-up
    cc .snd p = IdP-funcâ†Square {f = Î» _ â†’ Î¹-seq A (a 0)} {g = id}
                  (glue-suc A p) _ _
                  sq
}
%```
}
