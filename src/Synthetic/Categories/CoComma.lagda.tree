\title{Cocomma types}
\taxon{Module}
\author{samueltoth}
\date{2026-01-11}

\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.CoComma
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Data.Bool

open import Core.Orthogonal
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection
open import Core.FunctorialPullback
open import Core.Slice

open import Ergonomics.Notations.Orthogonality
open Core.Orthogonal.notation
open import Ergonomics.Extensionality
open import Ergonomics.Representation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.NaturalTransformation Î”Â¹ I I-distr
}
%```

\subtree[tot-0010]{
\title{Right cocones over a span}
\taxon{Definition}

\p{Given a [span diagram](stt-0015) #{S}, we consider the right cocones over #{S}.
This is analogous to the type of [cocones over #{S}](stt-0016) but with the
filler now being a morphism, not a path. This dualises \ref{tot-0000}}

%```agda
\agda{
record Right-cocone {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) {ğ“›} (Carrier : Type ğ“›)
  : Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›) where
  constructor mk-right-cocone
  open Span S
  field
    i : Left â†’ Carrier
    j : Right â†’ Carrier
    filler : âˆ€ (a : Centre) â†’ Hom Carrier (i (left a)) (j (right a))


unquoteDecl Right-cocone-reprâ‰… Right-cocone-reprâ‰ƒ
  = make-record-repr Right-cocone-reprâ‰… Right-cocone-reprâ‰ƒ (quote Right-cocone)

Right-cocone-path
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} {ğ“›} {Carrier : Type ğ“›}
      (c c' : Right-cocone S Carrier) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›)
Right-cocone-path {S = S} c c'
  = Î£[ p âˆ¶ c .i ~ c' .i ] Î£[ q âˆ¶ c .j ~ c' .j ]
      (âˆ€ a â†’ Hom-pathP (p (left a)) (q (right a)) (c .filler a) (c' .filler a))
  where
  open Right-cocone
  open Span S

opaque
  Right-cocone-path-is-torsorial
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} {ğ“›} {Carrier : Type ğ“›}
        (c : Right-cocone S Carrier) â†’ is-singleton (Î£ _ (Right-cocone-path c))
  Right-cocone-path-is-torsorial c
    = is-singleâ†equiv-to-single (Î£-ap-â‰ƒ-fst (Right-cocone-reprâ‰ƒ eâ»Â¹))
        (is-singleton-structureâ†parts
          (SingS-is-single _)
          (_ , ~refl)
          (is-singleton-structureâ†parts
            (SingS-is-single _)
            (_ , ~refl)
            (is-singleâ†equiv-to-single
              (Î£-Î -swapâ‰ƒ _ Î» a h â†’ Hom-pathP refl refl (c .Right-cocone.filler a) h)
              (is-singleton-Î  (Î» a
               â†’ Hom-pathP-is-torsorial)))))

Right-cocone-path-refl
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} {ğ“›} {Carrier : Type ğ“›}
      {c : Right-cocone S Carrier} â†’ Right-cocone-path c c
Right-cocone-path-refl = (~refl , ~refl , Î» a â†’ Hom-pathP-refl)

instance
  IdS-right-cocone
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} {ğ“›} {Carrier : Type ğ“›}
      â†’ Identity-system (Right-cocone S Carrier) (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›)
  IdS-right-cocone .Identity-system.IdS = Right-cocone-path
  IdS-right-cocone .Identity-system.IdSâ†Id refl = Right-cocone-path-refl
  IdS-right-cocone .Identity-system.has-is-ids a
    = fundamental-Id _ (Right-cocone-path-is-torsorial a) _
}
%```
}


\subtree[tot-0011]{
\title{Cocomma cocones}
\taxon{Definition}

\p{Again analogously to undirected pushouts, for any right cocone #{C}
over a span #{S}, we can define a canonical map #{(C \to Q) \to \mathrm{Cocone}_S(Q)}.
We call #{C} a (right) cocomma cone when this map is an equivalence.}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} {ğ“›} {Carrier : Type ğ“›} where
  right-cocone-map : Right-cocone S Carrier
                   â†’ âˆ€ {ğ“ } {Q : Type ğ“ } â†’ (Carrier â†’ Q) â†’ Right-cocone S Q
  right-cocone-map cc f = mk-right-cocone (f âˆ˜ i) (f âˆ˜ j) (ap-hom f âˆ˜ filler) where
    open Right-cocone cc

  is-cocomma-cocone : Right-cocone S Carrier â†’ TypeÏ‰
  is-cocomma-cocone cone
    = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-equiv (right-cocone-map cone {ğ“ }{Q})
}
%```
}

\subtree[tot-0012]{
\title{Canonical cocomma types}
\taxon{Construction}

\p{The cocomma type of a [span diagram](stt-0015) is written
#{f \uparrow g}. If we had a notion of \em{directed} higher inductive
types, you might present it as the type generated by the following data:}

\ul{
\li{#{\iota_1 : A \to f \uparrow g}}
\li{#{\iota_2 : C \to f \uparrow g}}
\li{#{\mathit{gl} : \Pi_{b} \Hom_B(\iota_1(f(b)), \iota_2(g(b)))}}
}

\p{Whilst we don't have directed higher inductive types natively, we can
use [pushouts](stt-0017) to give an equivalent definition for cocomma types.}


\quiver{
    \begin{tikzcd}[cramped]
	{B\times\delta\Delta^1} && {A + C} \\
	\\
	{B \times \Delta^1} && \bullet
	\arrow["{\overline{[f,g]}}", from=1-1, to=1-3]
	\arrow[hook', from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
    \end{tikzcd}
}

%```agda
\agda{
_â†‘_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : B â†’ A) (g : B â†’ C) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
_â†‘_ {A = A} {B} {C} f g
  = Pushout (Î´Î”Â¹-incl âŠ—1 B)
            (uncurry (Î´Î”Â¹-UPâ†’ (inl âˆ˜ f , inr âˆ˜ g)))

â†‘-Î¹â‚ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         {f : B â†’ A} {g : B â†’ C} â†’ A â†’ f â†‘ g
â†‘-Î¹â‚ = Î¹â‚‚ âˆ˜ inl

â†‘-Î¹â‚‚ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         {f : B â†’ A} {g : B â†’ C} â†’ C â†’ f â†‘ g
â†‘-Î¹â‚‚ = Î¹â‚‚ âˆ˜ inr

â†‘-hom : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
          {f : B â†’ A} {g : B â†’ C} b â†’ Hom (f â†‘ g) (â†‘-Î¹â‚ (f b)) (â†‘-Î¹â‚‚ (g b))
â†‘-hom b .HomP.hom = Î¹â‚ âˆ˜ (_, b)
â†‘-hom b .HomP.hom0 = glue (Î´Î”Â¹-0 , b)
â†‘-hom b .HomP.hom1 = glue (Î´Î”Â¹-1 , b)

â†‘-cocone : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
             (f : B â†’ A) (g : B â†’ C) â†’ Right-cocone (mk-span _ f g) (f â†‘ g)
â†‘-cocone f g .Right-cocone.i = â†‘-Î¹â‚
â†‘-cocone f g .Right-cocone.j = â†‘-Î¹â‚‚
â†‘-cocone f g .Right-cocone.filler = â†‘-hom

â†‘-is-cocomma-cocone
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {f : B â†’ A} {g : B â†’ C}
    â†’ is-cocomma-cocone (â†‘-cocone f g)
â†‘-is-cocomma-cocone {f = f} {g = g} = is-equivâ†qiso qiso where
  open Right-cocone
  qiso : quasi-iso (right-cocone-map (â†‘-cocone f g))
  qiso .fst cone = pushout-rec
    (mk-cocone (uncurry (HomP.hom âˆ˜ cone .filler) âˆ˜ Ã—-swap ._â‰ƒ_.fwd)
               âŠ[ cone .i , cone .j ] Î»
     { ((mk-lift true) ,  b) â†’ filler cone b .HomP.hom1
     ; ((mk-lift false) , b) â†’ filler cone b .HomP.hom0})
  qiso .snd .fst f = sym
    (funextâ†’ (pushout-rec-unique _ _ ~refl
               (Î» { (inl x) â†’ refl
                  ; (inr x) â†’ refl})
               Î» { (mk-lift true , b) â†’ âˆ™-reflr _
                 ; (mk-lift false , b) â†’ âˆ™-reflr _}))
  qiso .snd .snd a = ext! (~refl , ~refl , Î» bÂ â†’ Hom-pathPâ†path
                            ( ~refl
                            , sym (pushout-rec-apÎ² _)
                            , sym (pushout-rec-apÎ² _)))

â†‘-rec : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} {ğ“ } {Q : Type ğ“ }
        â†’ let open Span S
        in Right-cocone S Q â†’ (left â†‘ right â†’ Q)
â†‘-rec = is-equiv.bwd (â†‘-is-cocomma-cocone)

â†‘-rec-unique
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} {ğ“ } {Q : Type ğ“ }
      {c : Right-cocone S Q} {f : Span.left S â†‘ Span.right S â†’ Q}
    â†’ IdS (right-cocone-map (â†‘-cocone (Span.left S) (Span.right S)) f) c
    â†’ f ~ â†‘-rec c
â†‘-rec-unique (p , q , r) = pushout-rec-unique _ _
  (Î» (i , c) â†’ r c .fst i)
  (Î» { (inl x) â†’ p x
     ; (inr x) â†’ q x })
  Î» { (mk-lift true  , c) â†’ sym (un-square (r c .snd .snd))
    ; (mk-lift false , c) â†’ sym (un-square (r c .snd .fst))}

}
%```
}



\subtree[tot-0013]{
\title{Directed join}
\taxon{Example}

\p{An example of a comma type is the \em{directed join} of a pair of types.
This is sometimes also called the \em{blunt join}.}

\p{The interval is the join #{1 \rtimes 1}.}

%```agda
\agda{
_â‹‰_ : âˆ€ {ğ“¤ ğ“¥} â†’ Type ğ“¤ â†’ Type ğ“¥ â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
A â‹‰ B = _â†‘_ {B = A Ã— B} fst snd

Î”Â¹-is-join : is-cocomma-cocone {S = mk-span (ğŸ™ Ã— ğŸ™) fst snd}
               (mk-right-cocone (const _ ğŸ™ i0) (const _ ğŸ™ i1) Î» _ â†’ 0â‰¤1)
Î”Â¹-is-join = is-equivâ†qiso qiso where
  qiso : quasi-iso _
  qiso .fst cc = cc .Right-cocone.filler _ .HomP.hom
  qiso .snd .fst = ~refl
  qiso .snd .snd cc
    = ext! ((Î» _ â†’ hom0) , (Î» _ â†’ hom1)
           , Î» _ â†’ ( ~refl
                   , (Square-flatten-hor refl) , Square-flatten-hor refl)) where
    open Right-cocone cc
    open HomP (filler _)

_â–» : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
A â–» = A â‹‰ ğŸ™

_â—… : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
A â—… = ğŸ™ â‹‰ A
}
%```
}

\subtree[tot-0014]{
\title{Functoriality of the directed join}
\taxon{Construction}

%```agda
\agda{
_â‹‰â‚_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
         {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
         {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
       â†’ A â‹‰ C â†’ B â‹‰ D
f â‹‰â‚ g = â†‘-rec (mk-right-cocone (â†‘-Î¹â‚ âˆ˜ f) (â†‘-Î¹â‚‚ âˆ˜ g) (â†‘-hom âˆ˜ (f âŠ— g)))

â‹‰â‚-id : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}  {B : Type ğ“¥}
     â†’ id â‹‰â‚ id ~ id {A = A â‹‰ A}
â‹‰â‚-id = sym âˆ˜ â†‘-rec-unique
  ( ~refl
  , ~refl
  , Î» _ â†’ Hom-pathPâ†path (~refl , sym (ap-id _) , sym (ap-id _)))

â‹‰â‚-âˆ˜ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›}
         {A : Type ğ“¤}  {B : Type ğ“¥} {C : Type ğ“¦}
         {D : Type ğ“œ} {E : Type ğ“} {F : Type ğ“›}
         (f : B â†’ C) (g : A â†’ B) (h : E â†’ F) (j : D â†’ E)
       â†’ (f âˆ˜ g) â‹‰â‚ (h âˆ˜ j) ~ (f â‹‰â‚ h) âˆ˜ (g â‹‰â‚ j)
â‹‰â‚-âˆ˜ f g h j = sym âˆ˜ â†‘-rec-unique
  ( ~refl
  , ~refl
  , Î» (a , d) â†’ Hom-pathPâ†path
     ( ~refl
     , sym (ap-âˆ˜ _ _ _ âˆ™ ap (ap _) (pushout-rec-apÎ² _) âˆ™ pushout-rec-apÎ² _)
     , sym (ap-âˆ˜ _ _ _ âˆ™ ap (ap _) (pushout-rec-apÎ² _) âˆ™ pushout-rec-apÎ² _)))
}
%```
}
