\date{2025-02-24}
\title{Dependent Identity Types}
\author{samueltoth}

\import{stt-macros}

% ```agda
\agda{

module foundations.DependentIdentity where

open import foundations.universe
open import foundations.Identity
open import foundations.Functions
}
% ```


\p{Suppose we have types #{A, B : \UU}, and a path between them #{A =_\UU B}.
We want to talk about equalities between terms #{a : A} and #{b : B}, but the type #{a =_{?} b} is not well formed (what type
do we put for \em{?}).
}

\subtree{
\taxon{example}

\def\Fin[n]{\mathbb{N}^{\n}  }

\p{Consider the type of the standard finite types indexed over natural numbers. Addition can be defined as a function
#{(x : \Fin{<m}) \to (y : \Fin{<n}) \to \Fin{<(m + n)}}. Then consider the type of #{n + 2} and #{2 + n}. The types aren't definitionally
equal but are equal up to a path (the proof of commutativity of natural number addition). }
}

\p{The indexed case is so common that it is treated as the default, and the case of identity over an identity between types
can be recovered by identity over the identity type family.}

\subtree{
\taxon{definition}
\title{Dependent Identity}

\p{
Given:
\ul{
\li{a base type #{A : \UU}}
\li{a family #{B : A \to \UV} over A}
\li{a path #{p : a =_A b}}
\li{a term #{(x : B a)} over a}
\li{a term #{(y : B b)} over b}
}

We define the type of dependent identifications over p, written #{x =_B^p y}.
}


% ```agda
\agda{
module _ {𝓤 𝓥} {A : Type 𝓤} (B : A → Type 𝓥)  where

  IdP : ∀ {a} (a' : B a) {b} (p : a ＝ b) (b' : B b) → Type 𝓥 
  IdP a p b = tr B p a ＝ b



module _ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥}  where

  infix 6 _＝[_]_
  _＝[_]_ : ∀ {a} (a' : B a) {b} (p : a ＝ b) (b' : B b) → Type _
  a ＝[ p ] b = IdP _ a p b


  {-# DISPLAY IdP _ a p b = a ＝[ p ] b #-}

  --     IdP : ∀ {a b : A} (p : a ＝ b) → B a →  B b → Type 𝓥
  --     IdP p a b = Subst B p a ＝ b
  symP : ∀ {a} {a' : B a} {b} {p : a ＝ b} {b' : B b} → IdP B a' p b' → IdP B b' (sym p) a'
  symP {p = refl} p = sym p

  symP' : ∀ {a} {a' : B a} {b} {p : b ＝ a} {b' : B b} → IdP B a' (sym p) b' → IdP B b' p a'
  symP' {p = refl} p = sym p

  IdP-inl : ∀ {a b : A} (p : a ＝ b) (a' : B a) (b' : B b) → tr B p a' ＝ b' → IdP B a' p b' 
  IdP-inl refl a b p = p

  IdP-inr :  ∀ {a b : A} (p : a ＝ b) (a' : B a) (b' : B b) → a' ＝ tr B (sym p) b' → IdP B a' p b' 
  IdP-inr refl a b p = p


  IdP-right : ∀ {a} {a' : B a} {b} {p : a ＝ b} {b' : B b}
            → IdP B a' p b' → a' ＝ tr B (sym p) b'
  IdP-right {p = refl} refl = refl

module _ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}  where
  -- happlyᵈ : ∀ {𝓦} {C : (a : A) → B → Type 𝓦}
  --           {x y : A} (p : x ＝ y)
  --           {f : (b : B) → C x b}
  --         → {g : (b : B) → C y b} → IdP (λ a → (b : B) → C a b) f p g
  --         → (b : B) → IdP id (f b) (ap (λ x → C x b) p) (g b)
  -- happlyᵈ refl refl b = refl

module _ {𝓤 𝓥} {A : Type 𝓤} {B : A → Type 𝓥}  where
  apᵈ : ∀ {a b : A} (f : (a : A) → B a) → (p : a ＝ b) → IdP B (f a) p (f b)
  apᵈ f refl = refl

apᵈ-constant : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
               → {a b : A} (f : A → B) → (p : a ＝ b) → apᵈ f p ＝ ap f p
apᵈ-constant f refl = refl

{-# REWRITE apᵈ-constant #-}

}
% ```

}

