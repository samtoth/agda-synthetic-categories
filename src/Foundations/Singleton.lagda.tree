\date{2025-02-19}
\import{stt-macros}
\title{Singleton types}
\taxon{Module}


% ```agda
\agda{
module Foundations.Singleton where

open import Foundations.Universes
open import Foundations.Identity
open import Foundations.Unit
open import Foundations.Sigma
}
% ```

\subtree[stt-0006]{

\taxon{Definition}

\p{A type is called a singleton when it has a unique inhabitant. Alluding to the #{\infty}-groupoid semantics of HoTT, we also sometimes call these types contractible.
}

% ```agda
\agda{
record is-singleton {ğ“¤} (A : Type ğ“¤) : Type ğ“¤ where
  constructor mk-singl
  field
    centre : A
    central : âˆ€ x â†’ centre ï¼ x

open is-singleton public
}
% ```
}

\subtree[stt-001D]{
\taxon{Example}

\p{The unit type is a singleton type}

% ```agda
\agda{
ğŸ™-is-singleton : is-singleton ğŸ™
ğŸ™-is-singleton = mk-singl tt (Î» _ â†’ refl)
}
% ```
}


\subtree[stt-0007]{
\taxon{Definition}
\title{The canonical singleton types}


\p{Given a type #{A : \UU} with a point #{a : A}, we define a type #{\textrm{Sing}(A,a) : \UU := \Sigma_{x : X}(a = x)}.
Under the #{\infty}-groupoid interpretation of type theory, this is the slice category of A under a (or equivalently coslice category).
}

% ```agda
\agda{
Sing : âˆ€ {ğ“¤} (A : Type ğ“¤) (a : A) â†’ Type ğ“¤
Sing A a = Î£ A (Î» x â†’ a ï¼ x)

Sing' : âˆ€ {ğ“¤} (A : Type ğ“¤) (a : A) â†’ Type ğ“¤
Sing' A a = Î£ A (Î» x â†’ x ï¼ a)
}
% ```
}


\subtree[stt-001E]{
\taxon{Theorem}
\title{Contractibility of singletons}

\p{ #{\textrm{Sing}(A,a)} is a singleton for any #{A : \UU} and #{a : A}.}

\proof{
\p{Clearly, it is inhabited with inhabitant #{(a, \refl)}. To show that any other #{(x,p) : \textrm{Sing}(A,a)} is equal to #{(a,\refl)}, we use identity induction, and the #{\eta}-rule for pair types.}

% ```agda
\agda{
Sing-is-singleton : âˆ€ {ğ“¤} {A : Type ğ“¤} {a : A} â†’ is-singleton (Sing A a)
Sing-is-singleton = mk-singl (_ , refl) (Î» where (._ , refl) â†’ refl)

Sing'-is-singleton : âˆ€ {ğ“¤} {A : Type ğ“¤} {a : A} â†’ is-singleton (Sing' A a)
Sing'-is-singleton = mk-singl (_ , refl) (Î» where (._ , refl) â†’ refl)
}
% ```
}
}


\subtree[stt-0008]{
\title{Subsingletons}

\p{An important class of types are those which are subtypes of singleton types, and we call these types propositions.
}


 \subtree[stt-0009]{
   \taxon{Definition}
   \title{Proposition}

   \p{A proposition is a type for which for any two inhabitants, there is a term of #{x = y}. Sometimes we call propositions subsingletons.}

   % ```agda
   \agda{
is-prop : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
is-prop A = âˆ€ (x y : A) â†’ x ï¼ y
   }
   % ```
 }

 \subtree[stt-000A]{
   \taxon{Theorm}
   \p{Every singleton is a subsingleton}


   % ```agda
   \agda{
is-propâ†is-single : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-singleton A â†’ is-prop A
is-propâ†is-single (mk-singl centre central) x y = sym (central x) âˆ™ central y
   }
   % ```
 }
}

\subtree[stt-000P]{
\taxon{Theorem}
\p{We can show that a type is a proposition by assuming it is inhabited then showing it is a singleton}

% ```agda
\agda{
is-propâ†is-single-if-inhabited : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ (A â†’ is-singleton A) â†’ is-prop A
is-propâ†is-single-if-inhabited f x = is-propâ†is-single (f x) x
}
% ```
}

\subtree[stt-002U]{
\taxon{Theorem}
\title{Props have singleton paths}

% ```agda
\agda{
ï¼-singletonâ†is-prop : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’
          is-prop A â†’
         âˆ€ (a b : A) â†’ is-singleton (a ï¼ b)
ï¼-singletonâ†is-prop prop a b
  = mk-singl (sym (prop a a) âˆ™ prop a b)
    Î» where refl â†’ âˆ™-sym' (prop a a)
}
% ```
}
