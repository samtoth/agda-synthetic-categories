\date{2025-06-17}
\title{The Free Algabraicly Injective HIT}
\taxon{module}
\meta{module}{\startverb axioms.FreeAlgInj \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
{-# OPTIONS --allow-unsolved-metas #-}
module axioms.FreeAlgInj where

open import ufAxioms
open import foundations.Prelude
open import core.Arrow
open import core.Lifts
open import core.PullbackPower
}
%```

\subtree[stt-0060]{
\taxon{remark}

\p{The condition of [orthogonality](stt-0048) says that lifting
problems as above have unique solutions. Algabraic injectivity
is a weakening of this to only require that a chosen solution.}
}

\subtree[stt-005L]{
\taxon{definition}
\title{Weak orthogonators of maps}

\p{[Orthogonal maps](stt-004A) require uniqueness of
lifting solution. When this uniqueness requirement is lifted
we can speak of the type of weak-orthogonators for a pair of
maps, which give a chosen lift for each lifting problem.
When this type is merely inhabited we say that a pair of maps
are weakly orthogonal.}

%```agda
\agda{
weak-orthogonator : ∀ {𝓤 𝓥 𝓦 𝓛} {A : Type 𝓤} {B : Type 𝓥}
                          {C : Type 𝓦} {D : Type 𝓛}
                        → (f : A → B)
                        → (g : C → D)
                        → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛)
weak-orthogonator f g = ∀ (H : Arrow-map f g) → Lift H
}
%```
}


\subtree[stt-005N]{
\taxon{theorem}
\title{Weakly orthogonal maps give a section of the pullback power}

\p{A map #{f} is weakly orthogonal to #{g} iff the [pullback power](stt-004D)
 #{f \pitchfork g} has a section.}

%```agda
\agda{
sec-pb-power←weak-orthogonator
  : ∀ {𝓤 𝓥 𝓦 𝓛} {A : Type 𝓤} {B : Type 𝓥}
      {C : Type 𝓦} {D : Type 𝓛}
      {f : A → B} {g : C → D}
    → weak-orthogonator f g
    → section (pullback-power f g)
sec-pb-power←weak-orthogonator {f = f} {g} lift
  = section←fibres _ fib where
  fib : ∀ (H : Arrow-map f g) → fibre (pullback-power f g) H
  fib H =  _≃_.bwd (pb-power-fibre≃lifts _ _ _) (lift H)

sec-pb-power≃weak-orthogonator
  : ∀ {𝓤 𝓥 𝓦 𝓛} {A : Type 𝓤} {B : Type 𝓥}
      {C : Type 𝓦} {D : Type 𝓛}
      {f : A → B} {g : C → D}
    → weak-orthogonator f g
    ≃ section (pullback-power f g)
sec-pb-power≃weak-orthogonator {f = f}{g}
  = Π (Arrow-map f g) Lift
      ≃⟨ precomp-Π-≃ (λ c → pb-power-fibre≃lifts _ _ c e⁻¹) ⟩
    Π (Arrow-map f g) (fibre (pullback-power f g))
      ≃⟨ section≃fibres _ ⟩
    section (pullback-power f g) ≃∎
}
%```
}

\subtree[stt-005O]{
\title{Weak orthogonators for types}
\taxon{definition}

\p{A weak orthogonator for a type mirrors the definitions
for the stronger notion of [orthogonality at types](stt-004O).
We require not that the precomposition by #{f} is an equivalence,
but instead talk about the \em{type} of sections to postcomposition by #{f}.
}

\p{A weak orthogonator for type #{X} with respect to a map #{f : A \to B}
is a section of #{X^f : (B \to X) \to (A \to X)}.}

%```agda
\agda{
weak-type-orthogonator
  : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
      (f : A → B) (X : Type 𝓦)
    → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦)
weak-type-orthogonator f X = section (postcomp X f)
}
%```
}

\subtree[stt-005P]{
\taxon{theorem}

\p{Mirroring the [corresponding theorem](stt-004Q) for orthogonality,
we can say that the type of weak type orthogonators for #{X} against #{f}
is equivalent to the type of weak orthoginators for the map #{! : A \to 1}
against #{f}.}


%```agda
\agda{
weak-type-orthogonator-!
  : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
      {f : A → B} {X : Type 𝓦}
    → weak-type-orthogonator f X
    ≃ weak-orthogonator f (! {A = X})
weak-type-orthogonator-! = {!!}
}
%```
}


\subtree[stt-005J]{
\taxon{definition}
\title{Algabraicly injective types}

\p{Given a family of maps #{f_i : A_i \to B_i}, we say that a type
#{X} is \em{algabraicly} #{f\rm{-injective}} if for any family of maps
#{a_i : A_i \to X}, there is a chosen extension of #{a} along #{f_i}, that
is, the following diagram commutes for all #{i}: }

\quiver{
\begin{tikzcd}
	{A_i} && X \\
	\\
	{B_i}
	\arrow["{a_i}", from=1-1, to=1-3]
	\arrow["{f_i}"', from=1-1, to=3-1]
	\arrow[dashed, from=3-1, to=1-3]
\end{tikzcd}
}

\p{We observe that this definition is equivalent to asking for
a chosen [weak orthogonator](stt-005O) for #{X} against each #{f_i}.}

%```agda
\agda{
algabraic-injector
  : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘}
      {A : I → Type 𝓤} {B : I → Type 𝓥}
      (f : (i : I) → A i → B i)
      (X : Type 𝓦)
     → Type (𝓘 ⊔ 𝓤 ⊔ 𝓥 ⊔ 𝓦)
algabraic-injector f X = ∀ i → weak-type-orthogonator (f i) X
}
%```
}

\subtree[stt-005I]{
\taxon{definition}
\title{Free algabraicly-injective types}
\citek{rijkeMod2020}

\p{Given a family of types #{f_i : A_i \to B_i} and a type #{X}, we can
define the free algabraicly #{f\rm{-injective}} type on #{X}, called
#{\mathcal{J}_{f}(X)} with the following
higher inductive type:}

\ul{
\li{#{\eta : X \to \mathcal{J}_{f}(X)}}
\li{#{\rm{ext}_i : (A_i \to \mathcal{J}_{f}(X)) \to (B_i \to \mathcal{J}_{f}(X))}}
\li{#{\rm{isext}_i : \Pi_{(g : A_i \to \mathcal{J}_{f}(X))} \Pi_{(a : A_i)}
                     \rm{ext}_i(g,f(a)) = g(a)}}
}

\p{In plain agda we have to define higher inductive types via
postulates.}

%```agda
\agda{
module _ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘} {A : I → Type 𝓤}
         {B : I → Type 𝓥} where
  postulate
    Free-inj : (f : ∀ i → A i → B i) → Type 𝓦 → Type 𝓦

  module Free-inj {f : ∀ i → A i → B i} {X : Type 𝓦} where
    postulate
      inc   : X → Free-inj f X
      ext : ∀ {i} → (g : A i → Free-inj f X)
                       → B i → Free-inj f X
      is-ext : ∀ {i} → (g : A i → Free-inj f X)
                          (a : A i) → ext g (f i a) ＝ g a

      ind : ∀ {𝓜} (P : Free-inj f X → Type 𝓜)
              (N : (x : X) → P (inc x))
              (R : ∀ {i} (g : A i → Free-inj f X)
                   → ((a : A i) → P (g a))
                   → ∀ (b : B i) → P (ext g b))
              (S : ∀ {i} (g : A i → Free-inj f X)
                    (h : (a : A i) → P (g a))
                    (a : A i)
                   → tr P (is-ext g a) (R g h (f i a)) ＝ h a)
            → (x : Free-inj f X) → P x

      ind-inc : ∀ {𝓜} {P : Free-inj f X → Type 𝓜}
                  {N : (x : X) → P (inc x)}
                  {R : ∀ {i} (g : A i → Free-inj f X)
                       → ((a : A i) → P (g a))
                       → ∀ (b : B i) → P (ext g b)}
                  {S : ∀ {i} (g : A i → Free-inj f X)
                         (h : (a : A i) → P (g a))
                         (a : A i)
                       → tr P (is-ext g a) (R g h (f i a)) ＝ h a}
                 → ∀ x → ind P N R S (inc x) ＝ N x

      ind-ext : ∀ {𝓜} {P : Free-inj f X → Type 𝓜}
                  {N : (x : X) → P (inc x)}
                  {R : ∀ {i} (g : A i → Free-inj f X)
                       → ((a : A i) → P (g a))
                       → ∀ (b : B i) → P (ext g b)}
                  {S : ∀ {i} (g : A i → Free-inj f X)
                         (h : (a : A i) → P (g a))
                         (a : A i)
                       → tr P (is-ext g a) (R g h (f i a)) ＝ h a}
                 → ∀ {i} (g : A i → Free-inj f X)
                     (h : (a : A i) → P (g a))
                   → (b : B i) → ind P N R S (ext g b) ＝ R g h b

      -- TODO: Formulate path beta rule for is-ext
      -- ind-is-ext : ∀ {𝓜} {P : Free-inj f X → Type 𝓜}
      --             {N : (x : X) → P (inc x)}
      --             {R : ∀ {i} (g : A i → Free-inj f X)
      --                  → ((a : A i) → P (g a))
      --                  → ∀ (b : B i) → P (ext g b)}
      --             {S : ∀ {i} (g : A i → Free-inj f X)
      --                    (h : (a : A i) → P (g a))
      --                    (a : A i)
      --                  → tr P (is-ext g a) (R g h (f i a)) ＝ h a}
      --            → ∀ {i} (g : A i → Free-inj f X)

    {-# REWRITE ind-inc #-}
}
%```
}

\subtree[stt-005W]{
\date{2025-06-18}
\title{Free algabraicly-injective types are algabraicly-injective}
\taxon{theorem}

%```agda
\agda{
module _ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘} {A : I → Type 𝓤}
         {B : I → Type 𝓥} where
  injector-Free-inj
    : ∀ {f : (i : I) → A i → B i}
        {X : Type 𝓦}
      → algabraic-injector f (Free-inj f X)
  injector-Free-inj i .fst = Free-inj.ext
  injector-Free-inj i .snd α
    = funext→ (Free-inj.is-ext α)
}
%```
}
