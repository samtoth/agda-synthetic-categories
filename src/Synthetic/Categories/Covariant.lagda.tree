\date{2025-11-24}
\title{Covariant families}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Covariant
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.PushoutProduct
open import Core.SpanMap
open import Core.Arrow
open import Core.ArrowRetract
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection
open import Core.CanonicalPushouts
open import Core.FunctorialPushout

open import Data.Bool

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open import Ergonomics.Auto
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
}
%```


\subtree[stt-00B6]{
\title{Groupoids}
\taxon{Definition}

\p{A type is a groupoid, or simplicially discrete if it is local with respect
to #{\Delta^1}. This forms a sigma closed reflective subuniverse.}

%```agda
\agda{
is-groupoid : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-groupoid = is-null (Î» (_ : ğŸ™) â†’ Î”Â¹)

module Grpd where
  Grpd-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
  Grpd-SubU = Null-SubU (Î» (_ : ğŸ™) â†’ Î”Â¹) _

  Grpd-GSU : GSU (_âŠ” ğ“˜)
  Grpd-GSU = Null-GSU (Î» (_ : ğŸ™) â†’ Î”Â¹)

  Grpd-is-globally-reflective
    : is-globally-reflective Grpd-GSU
  Grpd-is-globally-reflective = Null-globally-reflective

  open GRSUInduction Grpd-is-globally-reflective
                     Null-globally-Î£-closed public

  open GSU Grpd-GSU public renaming (S-equiv to is-simplicialâ†equiv)

  open GPiClosure Grpd-is-globally-reflective public

  open is-globally-reflective Grpd-is-globally-reflective

  Î£-is-groupoid = Null-globally-Î£-closed
}
%```
}


\subtree[stt-00B7]{
\title{Groupoids are left-local types}
\taxon{Theorem}

\p{A type is a groupoid iff it is local with respect to the map #{1 \to \Delta^1}
which picks out the left endpoint.}

%```agda
\agda{
is-left-local : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-left-local = is-local (Î» (_ _ : ğŸ™) â†’ i0)

is-groupoidâ†is-left : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-left-local A â†’ is-groupoid A
is-groupoidâ†is-left {_}{A} il x
  = is-equiv~âˆ˜ lem (is-equivâ»Â¹ (il x))
                   unit-const-is-equiv where
  open is-equiv (il x)

  lem : const A Î”Â¹ ~ bwd âˆ˜ const A ğŸ™
  lem = il x â—‚eqv ((Îµ â–¸ const A ğŸ™) ~â»Â¹)


is-leftâ†is-groupoid : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-groupoid A â†’ is-left-local A
is-leftâ†is-groupoid {_} {A} gp x
  =  is-equiv~âˆ˜ H unit-const-is-equiv (is-equivâ»Â¹ (gp x)) where
  open is-equiv (gp x)

  H : postcomp A (Î» (_ : ğŸ™) â†’ i0) ~ const A ğŸ™ âˆ˜ bwd
  H = ((const A ğŸ™ â—‚ Î·) ~â»Â¹) â–¸eqv (gp x)

}
%```
}

\subtree[stt-00AY]{
\taxon{Definition}
\title{Covariant families}

\p{We say that a type family #{P : A \to \UU} is covariant if for any arrow #{f}
in #{A}, and term #{x_0} at #{P_{f(0)}}, the type of homs over #{f} which extend
#{x_0} is a singleton type.}

\p{Covariant families admit a directed transport.}

%```agda
\agda{
is-covariant : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
               â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-covariant {A = A} B
    = âˆ€ (x : Î”Â¹ â†’ A) (xâ‚€ : B (x i0))
      â†’ is-singleton (Î£[ xâ‚ âˆ¶ B (x i1)] HomP (B âˆ˜ x) xâ‚€ xâ‚)

Hom-over
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {x y}
    â†’ Hom A x y â†’ B x â†’ B y â†’ Type (ğ“˜ âŠ” ğ“¥)
Hom-over {A = A} {B} f x' y'
  = HomP (B âˆ˜ f .HomP.hom)
         (tr B (sym (f .HomP.hom0)) x')
         (tr B (sym (f .HomP.hom1)) y')

is-covariant-hom
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
    â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-covariant-hom {A = A} B
  = âˆ€ {x y} (f : Hom A x y) (x' : B x)
    â†’ is-singleton (Î£[ y' âˆ¶ B y ] Hom-over f x' y')

is-covariant-homâ†is-covariant
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
    â†’ is-covariant B â†’ is-covariant-hom B
is-covariant-homâ†is-covariant B cov (mk-hom f refl refl) x' = cov f x'

is-covariantâ†is-covariant-hom
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
    â†’ is-covariant-hom B â†’ is-covariant B
is-covariantâ†is-covariant-hom B cov f x' = cov (Î»hom f) x'

tr-cov : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
       â†’ is-covariant P â†’ (h : Î”Â¹ â†’ A) â†’ P (h i0) â†’ P (h i1)
tr-cov cov h = fst âˆ˜ centre âˆ˜ cov h

tr-cov-hom
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
    â†’ is-covariant-hom P
    â†’ âˆ€ {x y} (h : Hom A x y) â†’ P x â†’ P y
tr-cov-hom cov h = fst âˆ˜ centre âˆ˜ cov h

tr-cov-over
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
    â†’ (cov : is-covariant-hom P)
    â†’ âˆ€ {x y} (h : Hom A x y) â†’ (x' : P x) â†’ Hom-over h x' (tr-cov-hom cov h x')
tr-cov-over cov h = snd âˆ˜ centre âˆ˜ cov h
}
%```
}


\subtree[stt-00AV]{
\title{Left fibrations}
\taxon{Definition}

\p{A map is a left fibration if it is [right orthogonal](stt-0048) to the left
endpoint of #{\Delta^1}.}

%```agda
\agda{
is-left-fibration : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B)
                    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“˜)
is-left-fibration f = (Î» (_ : ğŸ™) â†’ i0) âŠ¥ f

is-right-fibration : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B)
                    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“˜)
is-right-fibration f = (Î» (_ : ğŸ™) â†’ i1) âŠ¥ f
}
%```
}


\subtree[stt-00AW]{
\taxon{Lemma}

\p{Given some family #{B : A \to \UU}, an arrow #{f} in #{A} and a point over the
base #{x_0 : B(f(0))}, the type of dependent homs over #{f} based an #{x_0} is
equivalent to the type of lifts of the following square:}


\quiver{
\begin{tikzcd}
	1 && {\tilde{B}} \\
	\\
	{\Delta^1} && A
	\arrow["{x_0}", from=1-1, to=1-3]
	\arrow["0"', from=1-1, to=3-1]
	\arrow["\pi", from=1-3, to=3-3]
	\arrow["f"', from=3-1, to=3-3]
\end{tikzcd}
}


%```agda
\agda{
lifts-of-based-arrow : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
          (f : Î”Â¹ â†’ A) (xâ‚€ : B (f i0))
        â†’ let F = mk-amap {f = Î» (_ : ğŸ™) â†’ i0} {f' = fst {B = B}}
                          (Î» _ â†’ f i0 , xâ‚€) f ~refl
        in Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€)
        â‰ƒ Lift F
lifts-of-based-arrow {A = A} {B} f xâ‚€ = eqv where
  F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
  F = mk-amap (Î» _ â†’ f i0 , xâ‚€) f ~refl

  open Arrow-map F
  open HomP
}
%```

\closedScope{
\subtree[stt-00AX]{
\title{Details}
%```agda
\agda{
  by-contracting-singletons : (Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
            ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚)))
          â‰… (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
  by-contracting-singletons ._â‰…_.fwd (_ , h , p , refl) = (h , p)
  by-contracting-singletons ._â‰…_.fwd-iso .fst (h , p) = (h i1 , h , p , refl)
  by-contracting-singletons ._â‰…_.fwd-iso .snd .fst (_ , h , p , refl) = refl
  by-contracting-singletons ._â‰…_.fwd-iso .snd .snd = ~refl

  because-pi-types-are-extensions
    : (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
       â‰ƒ
      (Î£[ (f , p) âˆ¶ fibre (precomp Î”Â¹ (Î» r â†’ fst r)) f ]
       (tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€))
  because-pi-types-are-extensions
    = Î£-ap-â‰ƒ-fst
        {B = Î» where (f , p) â†’ tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€}
        (mkâ‰ƒ (extensionâ†Î  {B = B} f) (extensionâ†Î -is-equiv f))

  by-funext
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ï¼ f) ]
          (tr B (happly H i0) (snd (f' i0)) ï¼ xâ‚€)
    â‰ƒ Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
  by-funext
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ-fst
                {B = Î» H â†’ tr B (H i0) (snd (f' i0)) ï¼ xâ‚€}
                funextâ‰ƒ)

  inserting-singleton
    :   Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
     â‰ƒ  Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
          (K1 ï¼ H i0)
  inserting-singleton
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» H â†’ Î£-singl
                  {B = Î» (K , _) â†’ tr B K (snd (f' i0)) ï¼ xâ‚€ }
                  Sing-is-singleton
                  (H i0 , refl) eâ»Â¹
                âˆ™â‰ƒ Î£-assoc âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ Ã—-swap âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» _ â†’ symâ‰ƒ) )))

  by-characterising-Î£-path
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
      â‰ƒ
        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
           (K1 ï¼ H i0)
  by-characterising-Î£-path
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» H â†’ Î£-ap-â‰ƒ-fst
                {B = Î» (K , _) â†’ K ï¼ H i0}
                (  Î£-path {x = f' i0} {y = _ , xâ‚€} eâ»Â¹)
                âˆ™â‰ƒ Î£-assoc))


  by-UP-of-unit
    :  Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
      â‰ƒ
       Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
  by-UP-of-unit
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
                (Î» H â†’ Î£-ap-â‰ƒ-fst {B = Î» K â†’ ap fst K ï¼ H i0} (unit-UPâ‰ƒ) eâ»Â¹
                       âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ unit-UPâ‰ƒ eâ»Â¹))
               âˆ™â‰ƒ Î£-comm)

  postcomposing-reflr-is-equiv
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
      â‰ƒ
      Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0) ~âˆ™ ~refl )
  postcomposing-reflr-is-equiv
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» K â†’ Î£-ap-â‰ƒ (Î» H â†’ ~reflrâ‰ƒ {f = const _ _ (f i0)} _ _)))
}
%```
}
}

\proof{
%```agda
\agda{
  opaque
    eqv : Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒ Lift F
    eqv
      = Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» _ â†’ HomP-reprâ‰ƒ) âŸ©

        Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
          ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚))
                                       â‰ƒâŸ¨ equivâ†qiso by-contracting-singletons âŸ©

        (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
                                       â‰ƒâŸ¨ because-pi-types-are-extensions âŸ©

        (Î£[ (f , p) âˆ¶ fibre (precomp Î”Â¹ (Î» r â†’ fst r)) f ]
         (tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€))
                                       â‰ƒâŸ¨ Î£-assoc âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ï¼ f) ]
            (tr B (happly H i0) (snd (f' i0)) ï¼ xâ‚€)
                                       â‰ƒâŸ¨ by-funext âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
            (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
                                       â‰ƒâŸ¨ inserting-singleton âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K1 âˆ¶ fst (f' i0) ï¼ f i0 ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
            (K1 ï¼ H i0)
                                       â‰ƒâŸ¨ by-characterising-Î£-path eâ»Â¹ âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
                                       â‰ƒâŸ¨ by-UP-of-unit âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
           Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
                                       â‰ƒâŸ¨ postcomposing-reflr-is-equiv âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
           Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0) ~âˆ™ ~refl )
                                       â‰ƒâŸ¨ Lift-reprâ‰ƒ F eâ»Â¹ âŸ©

        Lift F                         â‰ƒâˆ
}
%```
}
}

\subtree[stt-00AR]{
\title{Covariant families straighten to left fibrations}
\taxon{Corollary}

\p{We show that some family #{P : A \to \UU} is [covariant](stt-00AO) iff the map
#{\pi : \tilde{P} \to A} is a [left fibration](stt-00AV).}

%```agda
\agda{
is-covariantâ‡”is-left-fibration
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
    â†’ is-covariant B â‡” is-left-fibration (fst {B = B})
is-covariantâ‡”is-left-fibration {A = A} B
  = (fwd , bwd) where
  opaque
    arrow-map-snd : (F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B}))
                    â†’ B (F .Arrow-map.bot i0)
    arrow-map-snd (mk-amap top bot comm) = tr B (sym (comm tt)) (top tt .snd)

    Î£â†arrow-map : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
                â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (B (f i0))
    Î£â†arrow-map F = F .bot , arrow-map-snd F where open Arrow-map

    fwd : is-covariant B â†’ is-left-fibration (fst {B = B})
    fwd cov a@(mk-amap top bot comm)
      = is-singleâ†equiv-to-single
          ( lifts-of-based-arrow bot (tr B (sym (comm tt)) (snd (top tt)))
          âˆ™â‰ƒ coeâ‰ƒ (ap Lift
              (Arrow-map-pathâ†’
                ((Î» aâ‚ â†’ Î£-pathâ†’ ((comm tt)
                                 , trâˆ™tr-sym' (comm tt) (snd (top tt))))
                , (~refl , (Î» _ â†’ Î£-path-ap-fst))))))
          (cov bot (arrow-map-snd a))

    bwd : is-left-fibration (fst {B = B}) â†’ is-covariant B
    bwd lfib f xâ‚€ = is-singleâ†equiv-to-single
         (lifts-of-based-arrow f xâ‚€  eâ»Â¹)
         (lfib (mk-amap (Î» _ â†’ (f i0 , xâ‚€)) f ~refl))
}
%```
}

\subtree[stt-00C7]{
\title{Left fibrations are inner}
\taxon{Lemma}

\proof{
\p{We use the fact that left orthogonal maps [are closed under pushout products
and embeddings](stt-00BV). In particular we take the pushout product:
#{\underset{\Delta^1}{\overset{\{0\}}{\downarrow}} \hat{\otimes}
\underset{\Delta^1}{\overset{\{1\}}{\downarrow}}}, which modulo some contracting
away singletons, is the [inner horn](stt-00AD) inclusion into the square. Now
the following retract square completes the proof:}

\quiver{
\begin{tikzcd}
	{\Lambda^2_1} && {\Lambda^2_1} && {\Lambda^2_1} \\
	\\
	{\Delta^2} && {\square^2} && {\Delta^2}
	\arrow["\id", from=1-1, to=1-3]
	\arrow[hook, from=1-1, to=3-1]
	\arrow["\id", from=1-3, to=1-5]
	\arrow[hook, from=1-3, to=3-3]
	\arrow[hook, from=1-5, to=3-5]
	\arrow["{(x,y)\mapsto(x,y)}"', from=3-1, to=3-3]
	\arrow["{(x,y)\mapsto(x,x\land y)}"', from=3-3, to=3-5]
\end{tikzcd}
}
}

%```agda
\agda{
â–¡-retract : retract {A = Î”Â²} {B = Î”Â¹ Ã— Î”Â¹} (Î» (x , y) â†’ (x , y))
â–¡-retract .fst (x , y) = (x , y âˆ§ x) â¦ƒ âˆ§-â‰¤-elimr auto! â¦„
â–¡-retract .snd (x , y) = Î”Â²-ext (refl , auto!)


Î›[2,1]â†ªâ–¡-section : Arrow-map Î›[2,1]-incl (pushout-product (Î» (_ : ğŸ™) â†’ i1) (Î» (_ : ğŸ™) â†’ i0))
Î›[2,1]â†ªâ–¡-section .Arrow-map.top = Pushoutâ‚
                       (mk-span-map (_, _) _ (_ ,_) ~refl ~refl)
Î›[2,1]â†ªâ–¡-section .Arrow-map.bot (x , y) = (x , y)
Î›[2,1]â†ªâ–¡-section .Arrow-map.comm
  = pushout-ind _ (mk-coconeD ~refl ~refl
                    Î» _ â†’ is-propâ†is-truncated (â–¡-is-set car-is-set _ _) _ _)

Î›[2,1]â†ªâ–¡-ret : retract-arrow-map Î›[2,1]â†ªâ–¡-section
Î›[2,1]â†ªâ–¡-ret .fst .Arrow-map.top
  = Pushoutâ‚ (mk-span-map fst _ snd ~refl ~refl)
Î›[2,1]â†ªâ–¡-ret .fst .Arrow-map.bot = â–¡-retract .fst
Î›[2,1]â†ªâ–¡-ret .fst .Arrow-map.comm
  = pushout-ind _
      (mk-coconeD
        (Î» l â†’ Î”Â²-ext (refl , 0-init))
        (Î» l â†’ Î”Â²-ext (refl , 1-top))
        Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
Î›[2,1]â†ªâ–¡-ret .snd .fst
  = pushout-ind _ (mk-coconeD ~refl ~refl
                    (Î» _ â†’ is-propâ†is-truncated (Î›[2,1]-is-set _ _) _ _))
Î›[2,1]â†ªâ–¡-ret .snd .snd .fst   = â–¡-retract .snd
Î›[2,1]â†ªâ–¡-ret .snd .snd .snd x = is-propâ†is-truncated (Î”Â²-is-set _ _) _ _

is-innerâ†is-left-fibration
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
    â†’ is-left-fibration f â†’ is-inner f
is-innerâ†is-left-fibration {f = f} lf
  = left-orthogonal-retract
      Î›[2,1]-incl (pushout-product (Î» _ â†’ i1) (Î» _ â†’ i0))
      Î›[2,1]â†ªâ–¡-section Î›[2,1]â†ªâ–¡-ret _
      (left-orthogonal-pushout-product'
        (Î» (_ : ğŸ™) â†’ i0) f
        lf (Î» (_ : ğŸ™) â†’ i1))

is-innerâ†is-right-fibration
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
    â†’ is-right-fibration f â†’ is-inner f
is-innerâ†is-right-fibration {f = f} rf
  = left-orthogonal-retract
      Î›[2,1]-incl (pushout-product (Î» _ â†’ i1) (Î» _ â†’ i0))
      Î›[2,1]â†ªâ–¡-section Î›[2,1]â†ªâ–¡-ret _
      (left-orthogonal-pushout-product
        (Î» (_ : ğŸ™) â†’ i1) f
        rf (Î» (_ : ğŸ™) â†’ i0))
}
%```
}

\subtree[stt-00C8]{
\taxon{Corollary}

\p{The total type of a covariant family over a precategory is a precategory.}

%```agda
\agda{
is-inner-familyâ†is-covariant
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
    â†’ is-covariant B â†’ is-inner-family B
is-inner-familyâ†is-covariant
  = is-innerâ†is-left-fibration âˆ˜ (is-covariantâ‡”is-left-fibration _ .fst)

is-inner-familyâ†is-covariant-hom
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
    â†’ is-covariant-hom B â†’ is-inner-family B
is-inner-familyâ†is-covariant-hom
  = is-inner-familyâ†is-covariant âˆ˜ is-covariantâ†is-covariant-hom _

is-precategory-cov-Î£
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
    â†’ is-precategory A â†’ is-covariant B â†’ is-precategory (Î£ A B)
is-precategory-cov-Î£ apc cov
  = is-precategory-Î£ apc
      (is-innerâ†is-left-fibration
        (is-covariantâ‡”is-left-fibration _ .fst  cov))
}
%```
}

\subtree[tot-000G]{
\title{Morphisms in Hom types}
\taxon{Lemma}

\p{We show that for a covariant family #{P}, given any #{f : \Hom_A(x,y)},
the type of dependent morphisms #{\Hom_{Pf}(x',y')} is equivalent to
#{f^*(x') = y'}.}

\proof{
\p{By identity induction, it suffices to give a morphism #{\Hom_{Pf}(x', f^*(x'))}
for each #{x'}. But this is just ??(the second component of is covariant).
Now since #{\Sigma_{y' : P(f(1))} \Hom_{Pf}(x',y')}, the fundamental theorem of
identity types gives us that this map is an equivalence.}
}

%```agda
\agda{
cov-hom : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) (cov : is-covariant P)
            (f : Î”Â¹ â†’ A) x' y'
          â†’ tr-cov {P = P} cov f x' ï¼ y' â†’ HomP (P âˆ˜ f) x' y'
cov-hom _ Pc f x' y' refl = Pc f x' .centre .snd

cov-hom-is-equiv
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) (cov : is-covariant P)
      (f : Î”Â¹ â†’ A) x' y'
    â†’ is-equiv (cov-hom P cov f x' y')
cov-hom-is-equiv P Pc f x' = fundamental-Id _ (Pc f x') (cov-hom P Pc f x')


tr-cov-id
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) (cov : is-covariant P) {x}
    â†’ tr-cov {P = P} cov (Î» _ â†’ x) ~ id
tr-cov-id P cov {x} x' = ap fst (cov (Î» _ â†’ x) x' .central (x' , idH x') )

Hom-Î£ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {x y} {x' : P x} {y' : P y}
        â†’ (Î£[ f âˆ¶ Hom A x y ] Hom-over f x' y') â†’ Hom (Î£ A P) (x , x') (y , y')
Hom-Î£ (mk-hom f refl refl , mk-hom f' refl refl) = Î»hom (Î» i â†’ f i , f' i)

Hom-Î£-fst : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {x y} {x' : P x} {y' : P y}
            â†’ Hom (Î£ A P) (x , x') (y , y') â†’ Hom A x y
Hom-Î£-fst (mk-hom f refl refl) = Î»hom (fst âˆ˜ f)

Hom-Î£-snd : âˆ€ {ğ“¤ ğ“¥}{A : Type ğ“¤} {P : A â†’ Type ğ“¥} {x y} {x' : P x} {y' : P y}
            â†’ (f : Hom (Î£ A P) (x , x') (y , y'))
            â†’ Hom-over (Hom-Î£-fst f) x' y'
Hom-Î£-snd (mk-hom f refl refl) = Î»hom (snd âˆ˜ f)

Hom-Î£-fst-Î²
  : âˆ€ {ğ“¤ ğ“¥}{A : Type ğ“¤} {P : A â†’ Type ğ“¥}
      {x y} {x' : P x} {y' : P y} (f : Hom A x y) (f' : Hom-over f x' y')
    â†’ Hom-Î£-fst (Hom-Î£ (f , f')) ï¼ f
Hom-Î£-fst-Î² (mk-hom f refl refl) (mk-hom f' refl refl) = refl

Hom-Î£-ap-fst
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {x y : Î£ A P}
    â†’ ap-hom fst {x = x} {y} ~ Hom-Î£-fst
Hom-Î£-ap-fst (mk-hom f refl refl) = refl

opaque
  ap-Î´Î”Â²
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (F : A â†’ B)
        {x y z} {f : Hom A y z} {g : Hom A x y} {h : Hom A x z}
      â†’ F âˆ˜ make-Î´Î”Â² f g h ~ make-Î´Î”Â² (ap-hom F f) (ap-hom F g) (ap-hom F h)
  ap-Î´Î”Â² F {f = f} {g} {h}
    = pushout-rec-unique _ _
        (pushout-rec-unique _ _
          ~refl
          ~refl
          (Î» _ â†’ âˆ™-reflr _ âˆ™ ap-âˆ˜ F _ (glue tt) âˆ™ ap (ap F) (pushout-rec-apÎ² _)
               âˆ™ ap-âˆ™ F (g .HomP.hom1) _
               âˆ™ ap (ap F (g .HomP.hom1) âˆ™_) (ap-sym F _)))
        ~refl
        Î» { (mk-lift true)  â†’ âˆ™-reflr _ âˆ™ ap-âˆ˜ F (make-Î´Î”Â² f g h) (glue Î´Î”Â¹-1)
                            âˆ™ ap (ap F) (pushout-rec-apÎ² _)
                            âˆ™ ap-âˆ™ F  (f .HomP.hom1) _
                            âˆ™ ap (ap F (f .HomP.hom1) âˆ™_) (ap-sym F _)
          ; (mk-lift false) â†’ âˆ™-reflr _ âˆ™ ap-âˆ˜ F (make-Î´Î”Â² f g h) (glue Î´Î”Â¹-0)
                            âˆ™ ap (ap F) (pushout-rec-apÎ² _)
                            âˆ™ ap-âˆ™ F  (g .HomP.hom0) _
                            âˆ™ ap (ap F (g .HomP.hom0) âˆ™_) (ap-sym F _)}

ap-hom2
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (F : A â†’ B)
      {x y z : A} (f : Hom A y z) (g : Hom A x y) (h : Hom A x z)
    â†’ Hom2 f g h â†’ Hom2 (ap-hom F f) (ap-hom F g) (ap-hom F h)
ap-hom2 F f g h K .fst = F âˆ˜ K .fst
ap-hom2 {B = B} F f g h K .snd
  = postcomp-Î  (Î» v â†’ B) Î´Î”Â²-incl (ap-hom2 F f g h K .fst)
      ï¼âŸ¨âŸ©
    postcomp B Î´Î”Â²-incl (ap-hom2 F f g h K .fst)
      ï¼âŸ¨âŸ©
    (F âˆ˜ K .fst âˆ˜ Î´Î”Â²-incl)
      ï¼âŸ¨ ap (F âˆ˜_) (K .snd) âŸ©
    F âˆ˜ (make-Î´Î”Â² f g h)
      ï¼âŸ¨ funextâ†’ (ap-Î´Î”Â² F) âŸ©
    make-Î´Î”Â² (ap-hom F f) (ap-hom F g) (ap-hom F h) âˆ

Hom2-Î£-fst
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
      {x y z} (g : Hom (Î£ A P) y z) (f : Hom (Î£ A P) x y) (h : Hom (Î£ A P) x z)
    â†’ Hom2 g f h
    â†’ Hom2 (Hom-Î£-fst g) (Hom-Î£-fst f) (Hom-Î£-fst h)
Hom2-Î£-fst f g h K
  = coe
     (apâ‚ƒ Hom2
          (Hom-Î£-ap-fst f)
          (Hom-Î£-ap-fst g)
          (Hom-Î£-ap-fst h))
     (ap-hom2 fst f g h K)

Hom-Î£-fst-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (Apc : is-precategory A)
      {P : A â†’ Type ğ“¥} (inn : is-inner-family P)
      {x y z} {x' : P x} {y' : P y} {z' : P z}
      (g : Hom _ (y , y') (z , z')) (f : Hom _ (x , x') (y , y'))
    â†’  Hom-Î£-fst (g âˆ˜[ is-precategory-Î£ Apc inn ] f)
    ï¼ (Hom-Î£-fst g âˆ˜[ Apc ] Hom-Î£-fst f)
Hom-Î£-fst-âˆ˜ Apc inn f g
  = unique-composite Apc (Hom-Î£-fst f) (Hom-Î£-fst g)
      (Hom-Î£-fst (f âˆ˜[ is-precategory-Î£ Apc inn ] g))
      (Hom2-Î£-fst _ _ _ âˆ˜[ is-precategory-Î£ Apc inn ]-is-composite)

opaque
  CompP
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (Apc : is-precategory A) (P : A â†’ Type ğ“¥)
        (inn : is-inner-family P) {x y z} (g : Hom A y z) (f : Hom A x y)
        {x' : P x} {y' : P y} {z' : P z}
        (g' : Hom-over g y' z') (f' : Hom-over f x' y')
      â†’ Hom-over (g âˆ˜[ Apc ] f) x' z'
  CompP apc P inn {x}{y}{z} g f {x'}{y'}{z'} g' f'
    = tr (Î» p â†’ Hom-over {x = x} {y = z} p x' z')
         {Hom-Î£-fst (Hom-Î£ (g , g') âˆ˜[ is-precategory-Î£ apc inn ] Hom-Î£ (f , f'))}
         {g âˆ˜[ apc ] f}
         (Hom-Î£-fst-âˆ˜ apc inn (Hom-Î£ (g , g')) (Hom-Î£ (f , f'))
          âˆ™ apâ‚‚ (_âˆ˜[ apc ]_) (Hom-Î£-fst-Î² _ _) (Hom-Î£-fst-Î² _ _))
         (Hom-Î£-snd ((Hom-Î£ (g , g')) âˆ˜[ is-precategory-Î£ apc inn ] (Hom-Î£ (f , f'))))

tr-cov-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (Apc : is-precategory A) (P : A â†’ Type ğ“¥)
      (cov : is-covariant-hom P) {x y z} (g : Hom A y z) (f : Hom A x y)
      (x' : P x)
      â†’  tr-cov-hom cov (g âˆ˜[ Apc ] f) x'
      ï¼ tr-cov-hom cov g (tr-cov-hom cov f x')
tr-cov-âˆ˜ apc P cov g f x'
  = ap fst
      (cov (g âˆ˜[ apc ] f) x' .central
        ( tr-cov-hom cov g (tr-cov-hom cov f x')
        , CompP apc P (is-inner-familyâ†is-covariant-hom cov) g f
                 (tr-cov-over cov g _) (tr-cov-over cov f _)))
}
%```
}

\subtree[stt-00AS]{
\title{There is a universe of amazingly covariant types}
\taxon{Cosntruction}

\p{Assuming that the interval is [tiny](Synthetic.Tiny), there is a universe of
\em{amazingly covariant types}, which weakly classify the left fibrations.
We denote it #{\mathcal{s}}.}

\proof{
\p{Since being covariant is equivalent to being a left fibration, it is stable
under base change, and so is a [relative notion of fibrancy](stt-00AO). By the machinery
developed for [amazing right adjoints](stt-00AA) we can construct a universe.
}
}

%```agda
\agda{
module UCov where
  open import Synthetic.Tiny Î”Â¹

  is-covariant-is-relative : is-relative is-covariant
  is-covariant-is-relative {A = A} P = (fwd , bwd) where
    fwd : is-covariant P â†’ (x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)
    fwd cov f h = cov (f âˆ˜ h)

    bwd : ((x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)) â†’ is-covariant P
    bwd cov h xâ‚€ = cov h id xâ‚€

  open AFib is-covariant is-covariant-is-relative public
    renaming (is-afib to is-acov;
              UFib to ğ“¢;
              UFibâˆ™ to ğ“¢âˆ™;
              F-Ï€-is-fib to ğ“¢-Ï€-is-covariant)
}
%```
}

\subtree[stt-00AU]{
\title{The objects of #{\mathcal{S}} are groupoids}
\taxon{Theorem}

\p{If #{A :^\flat \UU} is a groupoid, then #{A} is amazing covariant and so
factors through #{\mathcal{S}}.}

%```agda
\agda{
  groupoids-in-ğ“¢ : âˆ€ {@â™­ ğ“¤} (@â™­ A : Type ğ“¤) â†’ @â™­ is-groupoid A â†’ is-acov A
  groupoids-in-ğ“¢ A gpd
    = Îµâ™­ (liftFib .fst
           (modâ™­ (is-covariantâ‡”is-left-fibration
                   (Î» _ â†’ A) .snd
                     (is-orthogonalâ‡”orthogonal-! .snd
                       (is-leftâ†is-groupoid
                         (Null-globally-Î£-closed
                           (Grpd.ğŸ™âˆˆS)
                           (Î» _ â†’ gpd)) tt))))) tt
}
%```
}


\subtree[stt-00AT]{
\title{#{\mathcal{S}} is directed univalent}
\taxon{Theorem}

\p{We show that #{\mathcal{S}} is directed univalent. That is, arrows in
#{\mathcal{S}} correspond exactly to pairs of groupoids, together with a function
between them.}

%```agda
\agda{
  tr-ğ“¢ : âˆ€ {@â™­ ğ“¤} â†’ (f : Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ fst (f i0) â†’ fst (f i1)
  tr-ğ“¢ = tr-cov {P = fst} ğ“¢-Ï€-is-covariant

  duaâ†’ : âˆ€ {@â™­ ğ“¤} â†’ (Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ Î£[ A âˆ¶ ğ“¢ ğ“¤ ] Î£[ B âˆ¶ ğ“¢ ğ“¤ ] (fst A â†’ fst B)
  duaâ†’ h = (h i0 , h i1 , tr-ğ“¢ h)
}
%```


\remark{It remains to be shown that this map is an equivalence.}
}
