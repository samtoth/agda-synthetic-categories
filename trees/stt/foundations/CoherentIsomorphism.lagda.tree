\date{2025-02-22}
\title{Coherent Isomorphism}

\import{stt-macros}

% ```agda
\agda{
module foundations.CoherentIsomorphism where

open import foundations.universe
open import foundations.QuasiIsomorphism
open import foundations.Sigma
open import foundations.Functions
open import foundations.FunctionInverses
open import foundations.Homotopy
open import foundations.Identity
open import foundations.PathReasoning
}
% ```

\p{We can upgrade [quasi isomorphism](QuasiIsomorphism.lagda) into a [correct notion of equivalence](st-????) by adding an extra coherence condition, that makes it into a proposition. }

\subtree[stt-000K]{
\taxon{remark}
\title{Half adjoint equivalence}

\p{The defintion of a quasi isomorphism involves:}

\ul{
\li{#{f : A \to B}}
\li{#{g : B \to A}}
\li{#{\eta : f \circ g = \id}}
\li{#{\varepsilon : \id = g \circ f}}
}

\p{The names #{\eta} and #{\varepsilon} remind us that this looks like the data of an adjunction. But we are missing the laws, often called the zig-zag laws. One of which state that the following 2-cell contracts to the identity:
}

\quiver{
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJBIl0sWzIsMiwiQiJdLFs0LDAsIkEiXSxbNiwyLCJCIl0sWzAsMSwiZiIsMl0sWzEsMiwiZyIsMl0sWzIsMywiZiIsMl0sWzAsMiwiXFxpZCIsMCx7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJcXGlkIiwyLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFswLDIsIiIsMCx7Im9mZnNldCI6LTEsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCIiLDAseyJvZmZzZXQiOi0xLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzcsMSwiXFx2YXJlcHNpbG9uIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjMwfX1dLFsyLDgsIlxcZXRhIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfX1dXQ==
\begin{tikzcd}
	A &&&& A \\
	\\
	&& B &&&& B
	\arrow[""{name=0, anchor=center, inner sep=0}, no head, from=1-1, to=1-5]
	\arrow["\id", shift left, no head, from=1-1, to=1-5]
	\arrow["f"', from=1-1, to=3-3]
	\arrow["f"', from=1-5, to=3-7]
	\arrow["g"', from=3-3, to=1-5]
	\arrow[""{name=1, anchor=center, inner sep=0}, "\id"', no head, from=3-3, to=3-7]
	\arrow[shift left, no head, from=3-3, to=3-7]
	\arrow["\varepsilon", shorten <=7pt, shorten >=11pt, Rightarrow, from=0, to=3-3]
	\arrow["\eta", shorten <=7pt, shorten >=7pt, Rightarrow, from=1-5, to=1]
\end{tikzcd}
}

\p{In symbols, this is: #{f \cdot \varepsilon \circ \eta \cdot f = \id} (where #{\cdot} denotes horizontal composition and #{\circ} denotes vertical composition).}
}

\p{Note that in formalisation #{\varepsilon} is a 2-cell in the opposite direction, but since all 2-cells are invertible, this makes no difference to the definition and makes the formalization slightly smoother.}

% ```agda
\agda{
qiso-coh : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ quasi-iso f â†’ Type (ğ“¤ âŠ” ğ“¥)
qiso-coh {f = f} (g , Îµ , Î·) = f â—‚ Îµ ~ Î· â–¸ f

}
% ```

\subtree{
\taxon{definition}
\title{Equivalences}

\p{Of the many equivalent notions of equivelences in HoTT, we will single out coherent isomorphisms as the default one in the library.}

% ```agda
\agda{
record is-equiv {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) : Type (ğ“¤ âŠ” ğ“¥) where
  constructor mk-eqv
  field
    qiso     : quasi-iso f
    coherent : qiso-coh qiso
  
  has-qiso : A â‰… B
  has-qiso = mk-iso f qiso
  
  open _â‰…_ has-qiso public hiding (fwd)

  Îµ : f âˆ˜ bwd ~ id
  Îµ x = section-fwd .snd x

  Î· : bwd âˆ˜ f ~ id
  Î· x = retract-fwd .snd x

record _â‰ƒ_ {ğ“¤ ğ“¥} (A : Type ğ“¤) (B : Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  constructor _,_
  field
    fwd : A â†’ B
    has-is-eqv : is-equiv fwd

  open is-equiv has-is-eqv public
    

qisoâ†is-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ is-equiv f â†’ quasi-iso f
qisoâ†is-equiv = is-equiv.qiso

qisoâ†equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰ƒ B â†’ A â‰… B
qisoâ†equiv (_ , has-is-eqv) = has-qiso where open is-equiv has-is-eqv

}
% ```
}



\subtree[stt-000J]{
\taxon{theorem}
\title{Quasi isomorphisms are coherent}
% HoTT book. 4.2.3

\p{Every quasi-isomorphism can be upgraded to a coherent isomorphism.}

\proof{
\p{Since we (are soon to) know that being an equivalence is a proposition, and that quasi isomorphisms aren't equivalent to equivalences,
we know that whatever the map is, it cannot be a section of the obvious map #{\textrm{is-equiv}(f) \to \textrm{is-qiso}(f)}, and so as a
result we know we will have to be a bit clever about how we choose the 2-cells of our coherent isomorphism.}

\p{The proof goes through by cooking up a 2-cell #{\varepsilon} that makes the coherence go through trivially.
Working backwards, we need an #{\varepsilon '} such that #{f(\varepsilon') = \eta_f}. }


\quiver{
% https://q.uiver.app/#q=WzAsNSxbMCwwLCJmZ2YiXSxbNiwwLCJmIl0sWzEsMiwiZmdmZ2YiXSxbNCwxLCJmZ2YiXSxbNSwzLCJmZ2YiXSxbMCwxLCJmXFxldGEiXSxbMCwyLCJcXHZhcmVwc2lsb25eey0xfSBmZ2YiLDJdLFsyLDMsIlxcdmFyZXBzaWxvbiBmZ2YiXSxbMywxLCJmXFxldGEiLDJdLFswLDMsIiIsMSx7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzIsNCwiZmdmIFxcZXRhIiwwLHsiY3VydmUiOi0xfV0sWzQsMSwiXFx2YXJlcHNpbG9uIGYiLDIseyJjdXJ2ZSI6M31dLFs0LDMsIklJIiwyLHsic2hvcnRlbiI6eyJzb3VyY2UiOjMwLCJ0YXJnZXQiOjIwfSwibGV2ZWwiOjJ9XSxbMiw0LCJmXFxldGFfe2dmfSIsMix7ImN1cnZlIjoyfV0sWzIsOSwiSSIsMix7InNob3J0ZW4iOnsic291cmNlIjozMCwidGFyZ2V0IjozMH19XSxbMTMsMTAsIklJSSIsMix7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH19XV0=
\begin{tikzcd}
	fgf &&&&&& f \\
	&&&& fgf \\
	& fgfgf \\
	&&&&& fgf
	\arrow["{f\eta}", from=1-1, to=1-7]
	\arrow[""{name=0, anchor=center, inner sep=0}, equals, from=1-1, to=2-5]
	\arrow["{\varepsilon^{-1} fgf}"', from=1-1, to=3-2]
	\arrow["{f\eta}"', from=2-5, to=1-7]
	\arrow["{\varepsilon fgf}", from=3-2, to=2-5]
	\arrow[""{name=1, anchor=center, inner sep=0}, "{fgf \eta}", from=3-2, to=4-6]
	\arrow[""{name=2, anchor=center, inner sep=0}, "{f\eta gf}"', bend right,from=3-2, to=4-6]
	\arrow["{\varepsilon f}"', bend right, from=4-6, to=1-7]
	\arrow["2", shorten <=11pt, shorten >=8pt, Rightarrow, from=4-6, to=2-5]
	\arrow["1"', shorten <=11pt, shorten >=11pt, Rightarrow, from=3-2, to=0]
	\arrow["3"', shorten <=2pt, shorten >=2pt, Rightarrow, from=2, to=1]
\end{tikzcd}
}


\p{
Consider the above diagram, and in particular note that the lower boundary is given by morphisms of the form #{\alpha f} for some alpha.
By taking the horizontal composition of these #{\alpha}'s gives us our desired #{\epsilon' := \varepsilon^{-1} fg \cdot f \eta g \cdot \varepsilon}. It satisfies the necessary equations by the vertical composite of the cells: 
}

\ol{
\li{Trivially follws from paths forming groupoids.}
\li{The naturality of homotopies.}
\li{Lemma 2.4.3}
}

% ```agda
\agda{
is-equivâ†qiso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ quasi-iso f â†’ is-equiv f
is-equivâ†qiso {f = f} (g , Î· , Îµ) = mk-eqv (g , Î· , Îµ') coh where opaque
  Îµ' : f âˆ˜ g ~ id
  Îµ' = (Îµ ~â»Â¹) â–¸ f â–¸ g ~âˆ™
       f â—‚ Î· â–¸ g       ~âˆ™
       Îµ

  lem3 : g â—‚ f â—‚ Î· ~ Î· â–¸ g â–¸ f
  lem3 x = sym (ap-comp g f (Î· x)) âˆ™ n where
    n : (g âˆ˜ f â—‚ Î·) x ï¼ (Î· â–¸ g â–¸ f) x
    n = sym (homotopy-inverse (g âˆ˜ f) Î· x)

  lem2 : Îµ â–¸ f â–¸ g â–¸ f ~âˆ™ f â—‚ Î· ~ f â—‚ g â—‚ f â—‚ Î· ~âˆ™ Îµ â–¸ f
  lem2 x = I âˆ™ ap (_âˆ™ (Îµ (f x))) (ap-comp f g (ap f (Î· x))) where
    I : Îµ (f (g (f x))) âˆ™ (ap f (Î· x)) ï¼
         ap (Î» z â†’ (f âˆ˜ g) z) (ap f (Î· x)) âˆ™ Îµ (f x)
    I = homotopy-natural Îµ {f (g (f x))} (ap f (Î· x))

  lem1 : f â—‚ Î· ~
           ((Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ Îµ â–¸ f â–¸ g â–¸ f ~âˆ™ f â—‚ Î·)
  lem1 a = âˆ™.insertr _ {h = Îµ (f (g (f a)))} {i = sym (Îµ (f (g (f a))))} (âˆ™-sym' (Îµ (f (g (f a))))) {_} {ap f (Î· a)}


  coh : qiso-coh (g , Î· , Îµ')
  coh =   (f â—‚ Î·)                                       ~âŸ¨ lem1 âŸ©
          (Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ Îµ â–¸ f â–¸ g â–¸ f ~âˆ™ f â—‚ Î· ~âŸ¨ ~refl {f = Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹} âŸ©~âˆ™âŸ¨ lem2 âŸ©
          (Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ f â—‚ g â—‚ f â—‚ Î· ~âˆ™ Îµ â–¸ f ~âŸ¨ ~refl {f = Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹} âŸ©~âˆ™âŸ¨ f âŸ©~â—‚âŸ¨ lem3 âŸ©~âˆ™âŸ¨ ~refl {f = Îµ â–¸ f} âŸ©
          (Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ f â—‚ Î· â–¸ g â–¸ f ~âˆ™ Îµ â–¸ f ~âŸ¨âŸ©
           Îµ' â–¸ f                                       ~âˆ

equivâ†qiso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰… B â†’ A â‰ƒ B
equivâ†qiso (mk-iso fwd fwd-iso) = fwd , (is-equivâ†qiso fwd-iso)

â‰ƒ-repâ‰…  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â‰ƒ B) â‰… Î£ (A â†’ B) is-equiv
â‰ƒ-repâ‰… ._â‰…_.fwd (f , e) = f , e
â‰ƒ-repâ‰… ._â‰…_.fwd-iso .fst (f , e) = f , e
â‰ƒ-repâ‰… ._â‰…_.fwd-iso .snd .fst _ = refl
â‰ƒ-repâ‰… ._â‰…_.fwd-iso .snd .snd _ = refl

â‰ƒ-rep : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â‰ƒ B) â‰ƒ Î£ (A â†’ B) is-equiv
â‰ƒ-rep = equivâ†qiso â‰ƒ-repâ‰…
}
% ```


}
}

\transclude{EquivOfSingleton.lagda}

\transclude{EquivContrFibre.lagda}

\transclude{EquivSingleton.lagda}

\subtree{
\title{Equivalences form an #{\infty}-groupoid over types}

% ```agda
\agda{
id-is-equiv : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-equiv (id {A = A})
id-is-equiv =  (mk-eqv (id , ~refl , ~refl) ~refl)

idequiv : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â‰ƒ A
idequiv = id , id-is-equiv

equiv-comp : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
             â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ C
equiv-comp (f , e) (g , e') = g âˆ˜ f , is-equivâ†qiso (comp-has-qiso (qisoâ†is-equiv e) (qisoâ†is-equiv e'))

_âˆ™â‰ƒ_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
             â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ C
_âˆ™â‰ƒ_ = equiv-comp 

infix 29 _âˆ™â‰ƒ_

idâ†’equiv : âˆ€ {ğ“¤} {A B : Type ğ“¤} â†’ A ï¼ B â†’ A â‰ƒ B
idâ†’equiv refl = idequiv

_eâ»Â¹ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰ƒ B â†’ B â‰ƒ A
e eâ»Â¹ = equivâ†qiso (qisoâ†equiv e â‰…â»Â¹)

â‰ƒâŸ¨âŸ©-syntax : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (A : Type ğ“¤) {B : Type ğ“¥} {C : Type ğ“¦}
           â†’ B â‰ƒ C â†’ A â‰ƒ B â†’ A â‰ƒ C
â‰ƒâŸ¨âŸ©-syntax A g f = equiv-comp f g


_â‰ƒâŸ¨âŸ©_ : âˆ€ {ğ“¤ ğ“¥} (A : Type ğ“¤) {B : Type ğ“¥} â†’ A â‰ƒ B â†’ A â‰ƒ B
x â‰ƒâŸ¨âŸ© xâ‰ƒy = xâ‰ƒy

_â‰ƒâˆ : âˆ€ {â„“} (A : Type â„“) â†’ A â‰ƒ A
x â‰ƒâˆ = idequiv

infix 31 _eâ»Â¹

infixr 2 â‰ƒâŸ¨âŸ©-syntax _â‰ƒâŸ¨âŸ©_
infix  3 _â‰ƒâˆ
infix 21 _â‰ƒ_

syntax â‰ƒâŸ¨âŸ©-syntax x q p = x â‰ƒâŸ¨ p âŸ© q
}
% ```

}
