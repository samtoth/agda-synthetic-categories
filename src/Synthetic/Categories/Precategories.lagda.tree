\date{2025-11-17}
\title{Precategories}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Precategories
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms
open import Foundations.IdentitySystem
open import Ergonomics.Extensionality

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Core.Join
open import Core.CanonicalPushouts

open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Hom Î”Â¹ i0 i1
}
%```


\subtree[stt-00AI]{
%```agda
\agda{
open Subtype

is-precategory : âˆ€ {ğ“¤} (C : Type ğ“¤) â†’ Type (ğ“¤ âŠ” ğ“˜)
is-precategory = is-local Î» (tt : ğŸ™) â†’ Î›[2,1]-incl

Precats-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Precats-SubU = Local-SubU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl) _

Precats-GSU : GSU (_âŠ” ğ“˜)
Precats-GSU = Local-GSU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

Precats-is-globally-reflective
   : is-globally-reflective Precats-GSU
Precats-is-globally-reflective
  = Local-global-reflectors (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

module Precat where
  open GSU Precats-GSU public renaming (S-equiv to is-precategoryâ†equiv)

  open is-globally-reflective Precats-is-globally-reflective

-- _âŠ™_ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-precategory A
--         â†’ {x y z : A}
--         â†’ Hom A y z â†’ Hom A x y â†’ Hom A x z
-- _âŠ™_ {A = A} pc f g = mk-hom (Î» i â†’ simplex (i , i))
--                             (adjust âˆ™ happly (Îµ comp) (Î¹â‚ i0) âˆ™ g .hom0)
--                             (adjust âˆ™ happly (Îµ comp) (Î¹â‚‚ i1) âˆ™ f .hom1) where
--     open is-equiv (pc tt)
--     open HomP

--     comp : Î›[2,1]' â†’ A
--     comp = pushout-rec
--             (mk-cocone
--               (g .hom)
--               (f .hom)
--               Î» _ â†’ g .hom1 âˆ™ sym (f .hom0))

--     simplex : Î”Â² â†’ A
--     simplex = bwd comp

--     adjust : âˆ€ {i p q} â†’ simplex ((i , i) â¦ƒ p â¦„) ï¼ simplex ((i , i) â¦ƒ q â¦„)
--     adjust = ap simplex (Î”Â²-ext (refl , refl))



Hom-path : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (f g : Hom A x y)
           â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom-path (mk-hom f p q) (mk-hom g r s)
  = Î£[ H âˆ¶ f ~ g ] ((H i0 âˆ™ r ï¼ p) Ã— (H i1 âˆ™ s ï¼ q))

opaque
  Hom-path-torsorial : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (f : Hom A x y)
                       â†’ is-singleton (Î£[ g âˆ¶ Hom A x y ] Hom-path f g)
  Hom-path-torsorial f
    = is-singleâ†equiv-to-single (Î£-ap-â‰ƒ-fst (HomP-reprâ‰ƒ eâ»Â¹))
        (is-singleton-structureâ†parts
          (SingS-is-single (f .HomP.hom))
          (f .HomP.hom , ~refl)
          (is-singleton-structureâ†parts
            Sing'-is-singleton
            (_ , refl)
            Sing'-is-singleton))

instance
  IdS-Hom : âˆ€ {ğ“¤}{A : Type ğ“¤} {x y : A} â†’ Identity-system (Hom A x y) (ğ“˜ âŠ” ğ“¤)
  IdS-Hom .Identity-system.IdS = Hom-path
  IdS-Hom .Identity-system.IdSâ†Id refl = (~refl , refl , refl)
  IdS-Hom .Identity-system.has-is-ids f
    = fundamental-Id (Hom-path f) (Hom-path-torsorial f) _


Hom-extâ†’ : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} {f g : Hom A x y}
          â†’ Hom-path f g â†’ f ï¼ g
Hom-extâ†’ = ext!

-- Hom2 f g h ~> f âˆ˜ g ~ h
Hom2 : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
         (f : Hom _ y z) (g : Hom _ x y) (h : Hom _ x z)
       â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom2 {A = A} f g h
  = Î£[ H âˆ¶ (Î”Â² â†’ A) ] (
      (âˆ€ i â†’ H (i , i0) ï¼ g .HomP.hom i)
    Ã— (âˆ€ i â†’ H (i1 , i) ï¼ f .HomP.hom i)
    Ã— (âˆ€ i â†’ H (i , i)  ï¼ h .HomP.hom i))


precategory-unique-composite : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ is-precategory A
                             â†’ (f : Hom A y z) (g : Hom A x y)
                             â†’ is-singleton (Î£[ H âˆ¶ (Î”Â² â†’ A)]
                                               (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g))
precategory-unique-composite Apc f g
  = is-contr-mapâ†is-equiv (Apc tt) (make-horn f g)

compositeâ†horn-extension
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
    â†’ Î£[ H âˆ¶ (Î”Â² â†’ A)] (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g)
    â†’ Î£[ h âˆ¶ Hom A x z ] (Hom2 f g h)
compositeâ†horn-extension f g (H , extends)
  = (mk-hom (H âˆ˜ Î”Â²-diagonal)
            (ap H Î”Â²-refl âˆ™ happly extends (Î¹â‚ i0) âˆ™ g .HomP.hom0)
            (ap H Î”Â²-refl âˆ™ happly extends (Î¹â‚‚ i1) âˆ™ f .HomP.hom1)
    , (H , happly extends âˆ˜ Î¹â‚ , happly extends âˆ˜ Î¹â‚‚ , ~refl)
    )

_âŠ™[_]_ :  âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ Hom A y z â†’ is-precategory A
          â†’ Hom A x y â†’ Hom A x z
f âŠ™[ apc ] g = fst (compositeâ†horn-extension f g
                    (centre (precategory-unique-composite apc f g)))

}
%```
}
