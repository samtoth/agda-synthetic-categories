\date{2025-11-24}
\title{Covariant families}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Covariant
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Core.Orthogonal
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Lifts
open import Core.FlatteningPushouts
open import Core.PiSection
open import Core.CocartesianSquare

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Tiny Î”Â¹
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Homotopies Î”Â¹ I I-distr
}
%```


\subtree[stt-00B6]{
\title{Groupoids}
\taxon{Definition}

\p{A type is a groupoid, or simplicially discrete if it is local with respect
to #{\Delta^1}. This forms a sigma closed reflective subuniverse.}

%```agda
\agda{
is-groupoid : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-groupoid = is-null (Î» (_ : ğŸ™) â†’ Î”Â¹)

module Grpd where
  Grpd-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
  Grpd-SubU = Null-SubU (Î» (_ : ğŸ™) â†’ Î”Â¹) _

  Grpd-GSU : GSU (_âŠ” ğ“˜)
  Grpd-GSU = Null-GSU (Î» (_ : ğŸ™) â†’ Î”Â¹)

  Grpd-is-globally-reflective
    : is-globally-reflective Grpd-GSU
  Grpd-is-globally-reflective = Null-globally-reflective

  open GRSUInduction Grpd-is-globally-reflective
                     Null-globally-Î£-closed public

  open GSU Grpd-GSU public renaming (S-equiv to is-simplicialâ†equiv)

  open GPiClosure Grpd-is-globally-reflective public

  open is-globally-reflective Grpd-is-globally-reflective

  Î£-is-groupoid = Null-globally-Î£-closed
}
%```
}


\subtree[stt-00B7]{
\title{Groupoids are left-local types}
\taxon{Theorem}

\p{A type is a groupoid iff it is local with respect to the map #{1 \to \Delta^1}
which picks out the left endpoint.}

%```agda
\agda{
is-left-local : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-left-local = is-local (Î» (_ _ : ğŸ™) â†’ i0)

is-groupoidâ†is-left : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-left-local A â†’ is-groupoid A
is-groupoidâ†is-left {_}{A} il x
  = is-equiv~âˆ˜ lem (is-equivâ»Â¹ (il x))
                   unit-const-is-equiv where
  open is-equiv (il x)

  lem : const A Î”Â¹ ~ bwd âˆ˜ const A ğŸ™
  lem = il x â—‚eqv ((Îµ â–¸ const A ğŸ™) ~â»Â¹)


is-leftâ†is-groupoid : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-groupoid A â†’ is-left-local A
is-leftâ†is-groupoid {_} {A} gp x
  =  is-equiv~âˆ˜ H unit-const-is-equiv (is-equivâ»Â¹ (gp x)) where
  open is-equiv (gp x)

  H : postcomp A (Î» (_ : ğŸ™) â†’ i0) ~ const A ğŸ™ âˆ˜ bwd
  H = ((const A ğŸ™ â—‚ Î·) ~â»Â¹) â–¸eqv (gp x)

}
%```
}

\subtree[stt-00AY]{
\taxon{Definition}
\title{Covariant families}

\p{We say that a type family #{P : A \to \UU} is covariant if for any arrow #{f}
in #{A}, and term #{x_0} at #{P_{f(0)}}, the type of homs over #{f} which extend
#{x_0} is a singleton type.}

\p{Covariant families admit a directed transport.}

%```agda
\agda{
is-covariant : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
               â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-covariant {A = A} B
    = âˆ€ (x : Î”Â¹ â†’ A) (xâ‚€ : B (x i0))
      â†’ is-singleton (Î£[ xâ‚ âˆ¶ B (x i1)] HomP (B âˆ˜ x) xâ‚€ xâ‚)

tr-cov : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
       â†’ is-covariant P â†’ (h : Î”Â¹ â†’ A) â†’ P (h i0) â†’ P (h i1)
tr-cov cov h = fst âˆ˜ centre âˆ˜ cov h
}
%```
}

\subtree[stt-00BL]{
\title{Being covariant is stable under pullback}
\taxon{Lemma}

%```agda
\agda{
is-covariant-is-pullback-stable : is-pullback-stable is-covariant
is-covariant-is-pullback-stable {A = A} P Ïƒ co x = co (Ïƒ âˆ˜ x)
}
%```
}


\subtree[stt-00AV]{
\title{Left fibrations}
\taxon{Definition}

\p{A map is a left fibration if it is [right orthogonal](stt-0048) to the left
endpoint of #{\Delta^1}.}

%```agda
\agda{
is-left-fibration : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B)
                    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“˜)
is-left-fibration f = (Î» (_ : ğŸ™) â†’ i0) âŠ¥ f
}
%```
}


\subtree[stt-00AW]{
\taxon{Lemma}

\p{Given some family #{B : A \to \UU}, an arrow #{f} in #{A} and a point over the
base #{x_0 : B(f(0))}, the type of dependent homs over #{f} based an #{x_0} is
equivalent to the type of lifts of the following square:}


\quiver{
\begin{tikzcd}
	1 && {\tilde{B}} \\
	\\
	{\Delta^1} && A
	\arrow["{x_0}", from=1-1, to=1-3]
	\arrow["0"', from=1-1, to=3-1]
	\arrow["\pi", from=1-3, to=3-3]
	\arrow["f"', from=3-1, to=3-3]
\end{tikzcd}
}


%```agda
\agda{
lifts-of-based-arrow : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
          (f : Î”Â¹ â†’ A) (xâ‚€ : B (f i0))
        â†’ let F = mk-amap {f = Î» (_ : ğŸ™) â†’ i0} {f' = fst {B = B}}
                          (Î» _ â†’ f i0 , xâ‚€) f ~refl
        in Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€)
        â‰ƒ Lift F
lifts-of-based-arrow {A = A} {B} f xâ‚€ = eqv where
  F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
  F = mk-amap (Î» _ â†’ f i0 , xâ‚€) f ~refl

  open Arrow-map F
  open HomP
}
%```

\closedScope{
\subtree[stt-00AX]{
\title{Details}
%```agda
\agda{
  by-contracting-singletons : (Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
            ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚)))
          â‰… (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
  by-contracting-singletons ._â‰…_.fwd (_ , h , p , refl) = (h , p)
  by-contracting-singletons ._â‰…_.fwd-iso .fst (h , p) = (h i1 , h , p , refl)
  by-contracting-singletons ._â‰…_.fwd-iso .snd .fst (_ , h , p , refl) = refl
  by-contracting-singletons ._â‰…_.fwd-iso .snd .snd = ~refl

  because-pi-types-are-extensions
    : (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
       â‰ƒ
      (Î£[ (f , p) âˆ¶ fibre (precomp Î”Â¹ (Î» r â†’ fst r)) f ]
       (tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€))
  because-pi-types-are-extensions
    = Î£-ap-â‰ƒ-fst
        {B = Î» where (f , p) â†’ tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€}
        (mkâ‰ƒ (extensionâ†Î  {B = B} f) (extensionâ†Î -is-equiv f))

  by-funext
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ï¼ f) ]
          (tr B (happly H i0) (snd (f' i0)) ï¼ xâ‚€)
    â‰ƒ Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
  by-funext
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ-fst
                {B = Î» H â†’ tr B (H i0) (snd (f' i0)) ï¼ xâ‚€}
                funextâ‰ƒ)

  inserting-singleton
    :   Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
     â‰ƒ  Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
          (K1 ï¼ H i0)
  inserting-singleton
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» H â†’ Î£-singl
                  {B = Î» (K , _) â†’ tr B K (snd (f' i0)) ï¼ xâ‚€ }
                  Sing-is-singleton
                  (H i0 , refl) eâ»Â¹
                âˆ™â‰ƒ Î£-assoc âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ Ã—-swap âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» _ â†’ symâ‰ƒ) )))

  by-characterising-Î£-path
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
      â‰ƒ
        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
           (K1 ï¼ H i0)
  by-characterising-Î£-path
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» H â†’ Î£-ap-â‰ƒ-fst
                {B = Î» (K , _) â†’ K ï¼ H i0}
                (  Î£-path {x = f' i0} {y = _ , xâ‚€} eâ»Â¹)
                âˆ™â‰ƒ Î£-assoc))


  by-UP-of-unit
    :  Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
      â‰ƒ
       Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
  by-UP-of-unit
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
                (Î» H â†’ Î£-ap-â‰ƒ-fst {B = Î» K â†’ ap fst K ï¼ H i0} (unit-UPâ‰ƒ) eâ»Â¹
                       âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ unit-UPâ‰ƒ eâ»Â¹))
               âˆ™â‰ƒ Î£-comm)

  postcomposing-reflr-is-equiv
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
      â‰ƒ
      Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0) ~âˆ™ ~refl )
  postcomposing-reflr-is-equiv
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» K â†’ Î£-ap-â‰ƒ (Î» H â†’ ~reflrâ‰ƒ {f = const _ _ (f i0)} _ _)))
}
%```
}
}

\proof{
%```agda
\agda{
  opaque
    eqv : Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒ Lift F
    eqv
      = Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» _ â†’ HomP-reprâ‰ƒ) âŸ©

        Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
          ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚))
                                       â‰ƒâŸ¨ equivâ†qiso by-contracting-singletons âŸ©

        (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
                                       â‰ƒâŸ¨ because-pi-types-are-extensions âŸ©

        (Î£[ (f , p) âˆ¶ fibre (precomp Î”Â¹ (Î» r â†’ fst r)) f ]
         (tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€))
                                       â‰ƒâŸ¨ Î£-assoc âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ï¼ f) ]
            (tr B (happly H i0) (snd (f' i0)) ï¼ xâ‚€)
                                       â‰ƒâŸ¨ by-funext âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
            (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
                                       â‰ƒâŸ¨ inserting-singleton âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K1 âˆ¶ fst (f' i0) ï¼ f i0 ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
            (K1 ï¼ H i0)
                                       â‰ƒâŸ¨ by-characterising-Î£-path eâ»Â¹ âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
                                       â‰ƒâŸ¨ by-UP-of-unit âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
           Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
                                       â‰ƒâŸ¨ postcomposing-reflr-is-equiv âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
           Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0) ~âˆ™ ~refl )
                                       â‰ƒâŸ¨ Lift-reprâ‰ƒ F eâ»Â¹ âŸ©

        Lift F                         â‰ƒâˆ
}
%```
}
}

\subtree[stt-00AR]{
\title{Covariant families straighten to left fibrations}
\taxon{Corollary}

\p{We show that some family #{P : A \to \UU} is [covariant](stt-00AO) iff the map
#{\pi : \tilde{P} \to A} is a [left fibration](stt-00AV).}

%```agda
\agda{
is-covariantâ‡”is-left-fibration
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
    â†’ is-covariant B â‡” is-left-fibration (fst {B = B})
is-covariantâ‡”is-left-fibration {A = A} B
  = (fwd , bwd) where
  opaque
    arrow-map-snd : (F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B}))
                    â†’ B (F .Arrow-map.bot i0)
    arrow-map-snd (mk-amap top bot comm) = tr B (sym (comm tt)) (top tt .snd)

    Î£â†arrow-map : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
                â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (B (f i0))
    Î£â†arrow-map F = F .bot , arrow-map-snd F where open Arrow-map

    fwd : is-covariant B â†’ is-left-fibration (fst {B = B})
    fwd cov a@(mk-amap top bot comm)
      = is-singleâ†equiv-to-single
          ( lifts-of-based-arrow bot (tr B (sym (comm tt)) (snd (top tt)))
          âˆ™â‰ƒ coeâ‰ƒ (ap Lift
              (Arrow-map-pathâ†’
                ((Î» aâ‚ â†’ Î£-pathâ†’ ((comm tt)
                                 , trâˆ™tr-sym' (comm tt) (snd (top tt))))
                , (~refl , (Î» _ â†’ Î£-path-ap-fst))))))
          (cov bot (arrow-map-snd a))

    bwd : is-left-fibration (fst {B = B}) â†’ is-covariant B
    bwd lfib f xâ‚€ = is-singleâ†equiv-to-single
         (lifts-of-based-arrow f xâ‚€  eâ»Â¹)
         (lfib (mk-amap (Î» _ â†’ (f i0 , xâ‚€)) f ~refl))
}
%```
}


\subtree[stt-00BK]{
\title{The total type of a covariant family is a precategory}
\taxon{Theorem}

\p{Being a precategory is not #{\Sigma} closed, but if the base is a precategory
and the family is covariant, then the total type is a precategory.}

\proof{
\p{Fix a precategory #{A}, and a covariant family #{B} over #{A}. We aim to show
that the precomposition map #{\tilde{B}^{\Delta^2} \to \tilde{B}^{\Lambda^2_1}}
is an equivalence.}

##{
\begin{align*}
  \tilde{B}^{\Delta^2}
\end{align*}
}
}

%```agda
\agda{
Î›[2,1]-UP : âˆ€ {ğ“¤} (B : Î›[2,1] â†’ Type ğ“¤)
       â†’ Î  Î›[2,1] B
       â‰ƒ Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)]
            HomP (B âˆ˜ Î¹â‚‚) (tr B (glue tt) (f i1)) z
Î›[2,1]-UP B = mkâ‰ƒ (map2 ._â‰ƒ_.fwd âˆ˜ coconeáµˆ-map span pushout {Q = B})
              (is-equiv-âˆ˜ (_â‰ƒ_.has-is-eqv map2) Pushout-is-pushoutÏ‰áµˆ) where
  span : Span lzero ğ“˜ ğ“˜
  span = mk-span _ (const Î”Â¹ ğŸ™ i1) (const Î”Â¹ ğŸ™ i0)

  by-inserting-singleton
    : (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
          Î£[ g âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              (g i0 ï¼ coe (ap B (glue tt)) (f i1)))
    â‰ƒ (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)] Î£[ h âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              Î£[ h0 âˆ¶ h i0 ï¼ coe (ap B (glue tt)) (f i1) ]
               (h i1 ï¼ z) )
  by-inserting-singleton = equivâ†qiso qiso where
    qiso : _
    qiso ._â‰…_.fwd (f , g , h) = (f , g i1 , g , h , refl)
    qiso ._â‰…_.fwd-iso .fst (f , _ , g , h , refl) = (f , g , h)
    qiso ._â‰…_.fwd-iso .snd .fst = ~refl
    qiso ._â‰…_.fwd-iso .snd .snd (f , _ , g , h , refl) = refl

  map2 : CoconeD span pushout B
       â‰ƒ Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)]
            HomP (B âˆ˜ Î¹â‚‚) (tr B (glue tt) (f i1)) z

  map2
    = CoconeD span pushout B â‰ƒâŸ¨ coconeD-reprâ‰ƒ âŸ©

      (Î£[ f âˆ¶ ((l : Î”Â¹) â†’ B (Î¹â‚ l)) ]
        Î£[ g âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
          ((a : ğŸ™) â†’ f i1 ï¼[ ap B (glue a) ] g i0))

                          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» f â†’ Î£-ap-â‰ƒ (Î» g â†’ unit-UPâ‰ƒ âˆ™â‰ƒ symâ‰ƒ)) âŸ©

      (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
          Î£[ g âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              (g i0 ï¼ coe (ap B (glue tt)) (f i1)))

                         â‰ƒâŸ¨ by-inserting-singleton âŸ©

      (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)] Î£[ h âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              Î£[ h0 âˆ¶ h i0 ï¼ coe (ap B (glue tt)) (f i1) ]
               (h i1 ï¼ z) )

                          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-ap-â‰ƒ (Î» b â†’ HomP-reprâ‰ƒ eâ»Â¹)) âŸ©

      (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)]
            HomP (B âˆ˜ Î¹â‚‚) (tr B (glue tt) (f i1)) z)    â‰ƒâˆ

Î£-is-precategory-lemma : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} â†’ is-precategory A
                   â†’ {B : A â†’ Type ğ“¥}
                   â†’ is-covariant B
                   â†’ is-precategory (Î£ A B) â‡” ((id {A = Î”Â¹ â†’ Î”Â²} (_, i0)) âŠ¥ fst {B = B})
Î£-is-precategory-lemma {A = A} apc {B} bcv
  =  ((Î» pc â†’ pc tt) , (Î» e _ â†’ e))
  âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv sq1 sq1-is-equiv
  âˆ™â‡” map2-is-equiv where

  map2 : (Î£[ Ï• âˆ¶ (Î”Â² â†’ A)] Î  Î”Â² (B âˆ˜ Ï•)) â†’ Î£[ Ï• âˆ¶ (Î›[2,1] â†’ A)] Î  Î›[2,1] (B âˆ˜ Ï•)
  map2 (x , y) = (postcomp _ (Î›[2,1]-incl) x , postcomp-Î  _ Î›[2,1]-incl y)

  sq1 : Arrow-map (postcomp (Î£ A B) (Î›[2,1]-incl)) map2
  sq1 .Arrow-map.top = Î£-Î -swap _ _
  sq1 .Arrow-map.bot = Î£-Î -swap _ _
  sq1 .Arrow-map.comm = ~refl

  sq1-is-equiv : is-Arrow-equiv sq1
  sq1-is-equiv .fst = Î£-Î -swap-is-equiv
  sq1-is-equiv .snd = Î£-Î -swap-is-equiv

  map2-triangle
    : map2
    ~   total-map-fst (postcomp _ Î›[2,1]-incl) {Î» Ï• â†’ Î  Î›[2,1] (B âˆ˜ Ï•)}
      âˆ˜ total-map (Î» a â†’ postcomp-Î  _ Î›[2,1]-incl)
  map2-triangle = ~refl

  fibrewise : (âˆ€ (H : Î”Â² â†’ A) â†’ is-equiv (postcomp-Î  _ Î›[2,1]-incl))
            â‡” ((id {A = Î”Â¹ â†’ Î”Â²} (_, i0)) âŠ¥ fst {B = B})
  fibrewise
    = ( (Î» e â†’ lem .snd
          Î» H â†’ is-equiv-âˆ˜ {f = fst âˆ˜ Î›[2,1]-UP _ ._â‰ƒ_.fwd}
                  (is-equiv-âˆ˜
                     {f = fst}
                     (singleton-fst-is-equiv
                       (Î» f â†’ bch-cov H Î¹â‚‚
                                (tr (B âˆ˜ H âˆ˜ Î›[2,1]-incl) (glue tt) (f i1))))
                       (Î›[2,1]-UP (B âˆ˜ H âˆ˜ Î›[2,1]-incl) ._â‰ƒ_.has-is-eqv))
                  (e H))
      , Î» orth H â†’ 3-for-2
                   (is-equiv-âˆ˜ {f = fst}
                     (singleton-fst-is-equiv
                       (Î» f â†’ bch-cov H Î¹â‚‚ (tr (B âˆ˜ H âˆ˜ Î›[2,1]-incl) (glue tt) (f i1)) ))
                     (Î›[2,1]-UP (B âˆ˜ H âˆ˜ Î›[2,1]-incl) ._â‰ƒ_.has-is-eqv))
                   (lem .fst orth H)) where
    K : âˆ€ H
      â†’ fst âˆ˜ Î›[2,1]-UP (B âˆ˜ H âˆ˜ Î›[2,1]-incl) ._â‰ƒ_.fwd
           âˆ˜ postcomp-Î  (B âˆ˜ H) Î›[2,1]-incl
        ~
        (postcomp-Î  (B âˆ˜ H) (_, i0))
    K _ = ~refl

    bch-cov : âˆ€ H â†’ is-covariant (B âˆ˜ H âˆ˜ Î›[2,1]-incl)
    bch-cov H = is-covariant-is-pullback-stable B (H âˆ˜ Î›[2,1]-incl) bcv

    fst-is-left-local : âˆ€ H â†’ is-left-fibration fst
    fst-is-left-local H = is-covariantâ‡”is-left-fibration
                            (B âˆ˜ H âˆ˜ Î›[2,1]-incl) .fst (bch-cov H)

    lem : (id {A = Î”Â¹ â†’ Î”Â²} (_, i0) âŠ¥ fst {B = B})
        â‡” (âˆ€ H â†’ is-equiv (postcomp-Î  (B âˆ˜ H) (_, i0)))
    lem = x âˆ™â‡” y where
      x : (id {A = Î”Â¹ â†’ Î”Â²} (_, i0) âŠ¥ fst)
        â‡” (âˆ€ H â†’ is-equiv (postcomp-Î  (fibre (fst {B = B}) âˆ˜ H) (_, i0)))
      x = ((Î» o h â†’ postcomp-Î â†orthogonal h o) , orthogonalâ†postcomp-Î )

      SQ3,2 : âˆ€ H â†’ Arrow-map (postcomp-Î  (fibre (fst {B = B}) âˆ˜ H) (_, i0))
                     (postcomp-Î  (B âˆ˜ H) (_, i0))
      SQ3,2 H .Arrow-map.top = precomp-Î -â‰ƒ (fibre-straighten B âˆ˜ H) ._â‰ƒ_.fwd
      SQ3,2 H .Arrow-map.bot = precomp-Î -â‰ƒ (fibre-straighten B âˆ˜ H âˆ˜ (_, i0)) ._â‰ƒ_.fwd
      SQ3,2 H .Arrow-map.comm = ~refl

      SQ3,2-is-equiv : âˆ€ H â†’ is-Arrow-equiv (SQ3,2 H)
      SQ3,2-is-equiv H .fst = precomp-Î -â‰ƒ (fibre-straighten B âˆ˜ H) ._â‰ƒ_.has-is-eqv
      SQ3,2-is-equiv H .snd = precomp-Î -â‰ƒ (fibre-straighten B âˆ˜ H âˆ˜ (_, i0)) ._â‰ƒ_.has-is-eqv

      y' : âˆ€ H â†’ (is-equiv (postcomp-Î  (fibre (fst {B = B}) âˆ˜ H) (_, i0)))
          â‡” (is-equiv (postcomp-Î  (B âˆ˜ H) (_, i0)))
      y' H = topâ‡”bot-is-equivâ†Arrow-equiv (SQ3,2 H) (SQ3,2-is-equiv H)

      y : (âˆ€ H â†’ is-equiv (postcomp-Î  (fibre (fst {B = B}) âˆ˜ H) (_, i0)))
        â‡” (âˆ€ H â†’ is-equiv (postcomp-Î  (B âˆ˜ H) (_, i0)))
      y = ((Î» eq H â†’ y' H .fst (eq H) ) , Î» eq H â†’ y' H .snd (eq H))

  map2-is-equiv : is-equiv map2 â‡” ((_, i0) âŠ¥ fst)
  map2-is-equiv .fst e
    = fibrewise .fst
       (is-fibrewise-equivâ†is-total-equiv
         (3-for-2
           {f = total-map-fst (postcomp _ Î›[2,1]-incl) {Î» Ï• â†’ Î  Î›[2,1] (B âˆ˜ Ï•)}}
           {g = total-map (Î» a â†’ postcomp-Î  _ Î›[2,1]-incl)}
           (total-is-equivâ†fst-is-equiv (apc tt))
           e))
  map2-is-equiv .snd orth
    = is-equiv-âˆ˜ {f = total-map-fst (postcomp _ Î›[2,1]-incl) {Î» Ï• â†’ Î  Î›[2,1] (B âˆ˜ Ï•)}}
                 {g = total-map (Î» a â†’ postcomp-Î  _ Î›[2,1]-incl)}
                 (total-is-equivâ†fst-is-equiv (apc tt))
                 (is-total-equivâ†is-fibrewise-equiv (fibrewise .snd orth))
}
%```
}


\subtree[stt-00AS]{
\title{There is a universe of amazingly covariant types}
\taxon{Cosntruction}

\p{Assuming that the interval is [tiny](Synthetic.Tiny), there is a universe of
\em{amazingly covariant types}, which weakly classify the left fibrations.
We denote it #{\mathcal{s}}.}

\proof{
\p{Since being covariant is equivalent to being a left fibration, it is stable
under base change, and so is a [relative notion of fibrancy](stt-00AO). By the machinery
developed for [amazing right adjoints](stt-00AA) we can construct a universe.
}
}

%```agda
\agda{
module UCov where

  is-covariant-is-relative : is-relative is-covariant
  is-covariant-is-relative {A = A} P = (fwd , bwd) where
    fwd : is-covariant P â†’ (x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)
    fwd cov f h = cov (f âˆ˜ h)

    bwd : ((x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)) â†’ is-covariant P
    bwd cov h xâ‚€ = cov h id xâ‚€

  open AFib is-covariant is-covariant-is-relative public
    renaming (is-afib to is-acov;
              UFib to ğ“¢;
              UFibâˆ™ to ğ“¢âˆ™;
              F-Ï€-is-fib to ğ“¢-Ï€-is-covariant;
              U-classifies to ğ“¢-classifies)
}
%```
}

\subtree[stt-00AU]{
\title{The objects of #{\mathcal{S}} are groupoids}
\taxon{Theorem}

\p{If #{A :^\flat \UU} is a groupoid, then #{A} is amazing covariant and so
factors through #{\mathcal{S}}.}

%```agda
\agda{
  groupoids-in-ğ“¢ : âˆ€ {@â™­ ğ“¤} (@â™­ A : Type ğ“¤) â†’ @â™­ is-groupoid A â†’ is-acov A
  groupoids-in-ğ“¢ A gpd
    = Îµâ™­ (liftFib .fst
           (modâ™­ (is-covariantâ‡”is-left-fibration
                   (Î» _ â†’ A) .snd
                     (is-orthogonalâ‡”orthogonal-! .snd
                       (is-leftâ†is-groupoid
                         (Null-globally-Î£-closed
                           (Grpd.ğŸ™âˆˆS)
                           (Î» _ â†’ gpd)) tt))))) tt
}
%```
}


\subtree[stt-00AT]{
\title{#{\mathcal{S}} is directed univalent}
\taxon{Theorem}

\p{We show that #{\mathcal{S}} is directed univalent. That is, arrows in
#{\mathcal{S}} correspond exactly to pairs of groupoids, together with a function
between them.}

%```agda
\agda{
  tr-ğ“¢ : âˆ€ {@â™­ ğ“¤} â†’ (f : Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ fst (f i0) â†’ fst (f i1)
  tr-ğ“¢ = tr-cov {P = fst} ğ“¢-Ï€-is-covariant

  duaâ†’ : âˆ€ {@â™­ ğ“¤} â†’ (Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ Î£[ A âˆ¶ ğ“¢ ğ“¤ ] Î£[ B âˆ¶ ğ“¢ ğ“¤ ] (fst A â†’ fst B)
  duaâ†’ h = (h i0 , h i1 , tr-ğ“¢ h)
}
%```


\remark{It remains to be shown that this map is an equivalence.}
}
