\date{2025-03-07}
\title{Pushouts}
\author{samueltoth}


\import{stt-macros}

% ```agda
\agda{
module foundations.Pushout where

open import foundations.universe
open import foundations.Functions
open import foundations.Identity
open import foundations.CoherentIsomorphism
open import foundations.EquivSingleton
open import foundations.Singleton
open import foundations.Sigma
open import foundations.Homotopy
open import foundations.DependentIdentity
}
% ```


\subtree[stt-0015]{
\taxon{definition}

\title{Spans}

\p{
    A span is a diagram of types: #{C \xleftarrow{f} A \xrightarrow{g} B}.
}

% ```agda
\agda{
record Span 𝓤 𝓥 𝓦 : Type (lsuc (𝓤 ⊔ 𝓥 ⊔ 𝓦)) where
  constructor mk-span
  field
    Centre : Type 𝓤
    {Left} : Type 𝓥
    left   : Centre → Left
    {Right} : Type 𝓦
    right : Centre → Right
}
% ```

}

\subtree[stt-0016]{
 \taxon{definition}
 \title{cocone}
 \p{
  Given a span #{s : C \xleftarrow{f} A \xrightarrow{g} B}, and a type #{Q}, we define the type of #{Q}-cocones over #{s} to be the structure with:
   \ul{
     \li{A function #{i : C \to Q}}
     \li{A function #{j : B \to Q}}
     \li{A path #{i \circ f = j \circ g}}
}
}

% ```agda
\agda{
record Cocone  {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) {𝓛} (Carrier : Type 𝓛)
        : Type (lsuc (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛))  where
  constructor mk-cocone
  open Span S
  field
    p       : Left → Carrier
    q       : Right → Carrier
    filler  : p ∘ left ~ q ∘ right 


record CoconeD {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦)
               {𝓛} {Q : Type 𝓛} (cc : Cocone S Q)
               {𝓜} (P : Q → Type 𝓜) : Type (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛 ⊔ 𝓜) where
  constructor mk-coconeD
  open Span S
  open Cocone cc
  field
    p : (l : Left) → P (p l) 
    q : (r : Right) → P (q r)
    filler : (c : Centre) → IdP P (p (left c)) (filler c) (q (right c))
}
% ```
}


\subtree[stt-0017]{
  \taxon{definition}
  \title{is-pushout}

  \p{
    Given a span of types #{C \xleftarrow{f} A \xrightarrow{g} B}, we say that a type #{D} is it's pushout if it is the universal cocone. In other words it fits universally into the following commutative diagram:
  }

  \quiver{
  \begin{tikzcd}
	A && B \\
	\\
	C && D \\
        &&& Q
	\arrow["g", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[bend left, from=1-3, to=4-4]
	\arrow[from=3-1, to=3-3]
	\arrow[bend right, from=3-1, to=4-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[dashed, from=3-3, to=4-4]
  \end{tikzcd}
  }

  \p{In the language of type theory, given a cocone #{C}, this can be encoded by requiring
     that the obvious map #{(C \to Q) \to \mathrm{Cocone(Q)}} given by precomposition
     is an equivalence.
  }


% ```agda
\agda{
module _ {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) where
  construct-cocone : ∀ {𝓛 𝓜} {C : Type 𝓛} (C-cc : Cocone S C)
                {Q : Type 𝓜} → (C → Q) → Cocone S Q
  construct-cocone C f .Cocone.p = f ∘ p where open Cocone C
  construct-cocone C f .Cocone.q = f ∘ q where open Cocone C
  construct-cocone C f .Cocone.filler a = ap f (filler a) where open Cocone C

  is-pushout : ∀ {𝓛} {C : Type 𝓛} → Cocone S C → Type _
  is-pushout {𝓛} C = ∀ {Q : Type (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛)} → is-equiv (construct-cocone C {Q})

  is-pushoutω : ∀ {𝓛} {C : Type 𝓛} → Cocone S C → Typeω
  is-pushoutω {𝓛} C = ∀ {𝓜} {Q : Type 𝓜} → is-equiv (construct-cocone C {Q})
}
% ```
}

% ```agda
\agda{
  construct-coconeᵈ : ∀ {𝓛 𝓜} {C : Type 𝓛} (C-cc : Cocone S C)
                      → {Q : C → Type 𝓜}
                      → ((c : C) → Q c)
                      → CoconeD S C-cc Q 
  construct-coconeᵈ C f .CoconeD.p = f ∘ p where open Cocone C
  construct-coconeᵈ C f .CoconeD.q = f ∘ q where open Cocone C
  construct-coconeᵈ C f .CoconeD.filler c = apᵈ _ f (filler c) where open Cocone C

  is-pushoutᵈ : ∀ {𝓛} {C : Type 𝓛} → Cocone S C → Type _
  is-pushoutᵈ {𝓛} {C} Cc =  ∀ {Q : C → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛)} → is-equiv (construct-coconeᵈ Cc {Q})

  
  is-pushoutωᵈ : ∀ {𝓛} {C : Type 𝓛} → Cocone S C → Typeω
  is-pushoutωᵈ {𝓛} {C} Cc = ∀ {𝓜} {Q : C → Type 𝓜} → is-equiv (construct-coconeᵈ Cc {Q})
}
% ```

\subtree[stt-0018]{
\taxon{theorem}
\title{Uniqueness of pushouts}
\meta{assumes}{Univalence}

\p{Pushouts, like all universal constructions, are unique if they exist. We will show 
that the type of cocones that are pushouts is a subsingleton}

\proof{

% ```agda
\agda{
-- module _ {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) where
--   pushouts-unique : ∀ {𝓛} → is-subsingleton (Σ[ X ∶ Type 𝓛 ] Σ[ C ∶ Cocone S X ] is-pushout S C)
--   pushouts-unique = {!!}
}
% ```

}
}

% ```agda
\agda{
has-pushouts : ∀ 𝓤 → Type (lsuc 𝓤)
has-pushouts 𝓤 = ∀ (S : Span 𝓤 𝓤 𝓤)
                  → Σ[ P ∶ Type 𝓤 ] Σ[ C ∶ Cocone S P ]
                       is-pushout S C

record large-pushout {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) : Typeω where
  field
    Pushout : Type (𝓤 ⊔ 𝓥 ⊔ 𝓦)
    cocone : Cocone S Pushout
    has-is-pushoutᵈ : is-pushoutωᵈ S cocone

  open Cocone cocone public renaming (p to ι₁ ; q to ι₂)

  Dependent←cocone : ∀ {𝓠} {Q : Type 𝓠} →
                      Cocone S Q → CoconeD S cocone λ _ → Q
  Dependent←cocone (mk-cocone p q eq) = mk-coconeD p q
                    λ c → tr-constant (filler c) _ ∙ eq c

  has-is-pushout : is-pushout S cocone
  has-is-pushout {Q = Q} = is-equiv←qiso (f , (η , ε)) where

    f : Cocone S _ → Pushout → _
    f cc = is-equiv.bwd has-is-pushoutᵈ (Dependent←cocone cc)

    η : f ∘ (construct-cocone S cocone) ~ id
    η = {!is-equiv.η has-is-pushoutᵈ !}

    ε : (construct-cocone S cocone) ∘ f ~ id
    ε = {!!}

global-pushouts : Typeω
global-pushouts = ∀ {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) → large-pushout S

}
% ```
