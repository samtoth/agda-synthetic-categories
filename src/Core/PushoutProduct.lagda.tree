\title{Pushout product}
\taxon{Module}
\date{2026-01-08}
\author{samueltoth}

\import{stt-macros}

%```agda
\agda{
module Core.PushoutProduct where

open import Foundations.Prelude
open import Foundations.TypeFamilies
open import ufAxioms

open import Core.Arrow
open import Core.CanonicalPushouts
open import Core.PushoutSums
}
%```

\subtree[stt-00BS]{
\title{Pushout product}
\taxon{Definition}

\p{The pushout product is, in a sense, dual to the [pullback power](stt-004D).
Given a pair of maps #{f : A \to B} and #{g : C \to D}, we construct a square of both
orders of mapping from #{A \times C} to #{B \times D}, one component
at a time. The pushout product, written #{f \hat{\otimes} g}, is the cogap
map of this square.}

%```agda
\agda{
Product-hom
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
    â†’ Arrow-map (f âŠ—1 C) (f âŠ—1 D)
Product-hom f g .Arrow-map.top = _ 1âŠ— g
Product-hom f g .Arrow-map.bot = _ 1âŠ— g
Product-hom f g .Arrow-map.comm = ~refl

pushout-product
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
    â†’ Pushout (f âŠ—1 C) (A 1âŠ— g) â†’ B Ã— D
pushout-product f g = cogap (Coconeâ†Arrow-map (Product-hom f g) .snd)

infixl 41 _â–¡_
_â–¡_ = pushout-product
}
%```
}


\subtree{
\taxon{Definition}
\title{The pushout-product family}

%```agda
\agda{
pushout-productá¶ 
  : {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 : Level}
  â†’ Fam ğ“¤1 ğ“¤2
  â†’ Fam ğ“¤3 ğ“¤4
  â†’ Fam (ğ“¤1 âŠ” ğ“¤3) (ğ“¤2 âŠ” ğ“¤4)
pushout-productá¶  F G = Î£Ì‚á¶  F (Famâ†’DepFam F G)

infixl 41 _â–¡á¶ _
_â–¡á¶ _ = pushout-productá¶ 
}
%```
}
