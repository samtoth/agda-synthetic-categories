\date{2025-07-30}
\title{Coequalisers}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
module Core.Coequalisers where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Postwhisker
open import Core.PushoutEquiv
open import Ergonomics.Representation
}
%```

\subtree[stt-009M]{
\title{Coequalisers}
\taxon{Definition}

\p{Given a pair of maps #{f,g : A \to B}, we define a \em{cofork} under
#{f} and #{g} at a particular type #{C} to be a map #{h : B \to C}
together with an homotopy #{hf \sim hg}. Given a particular cofork
centred at #{C}, we can define a map #{Q^C \to \rm{cofork}_{f,g}(Q)}
for each type #{Q}. The given cofork is said to be a \em{coequaliser}
if the aforementioned cofork-map is an equivalence.}

%```agda
\agda{
Cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ (C : Type ğ“¦) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Cofork {B = B} f g C = Î£[ p âˆ¶ (B â†’ C) ] (p âˆ˜ f ~ p âˆ˜ g)

cofork-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
         â†’ {f g : A â†’ B} â†’ {C : Type ğ“¦}
         â†’ Cofork f g C â†’ âˆ€ {ğ“ } {Q : Type ğ“ }
         â†’ (C â†’ Q) â†’ Cofork f g Q
cofork-map (p , H) f = (f âˆ˜ p , f â—‚ H)

is-coeq : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
            {f g : A â†’ B} {C : Type ğ“¦}
          â†’ Cofork f g C â†’ TypeÏ‰
is-coeq f = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-equiv (cofork-map f {ğ“ } {Q})
}
%```
}

\subtree[stt-009N]{
\taxon{Theorem}
\title{Coequalisers are pushouts}

\p{Given a pair of maps #{f,g : A \to B} we can define a span
#{B \xleftarrow{[id,f]} B + A \xrightarrow{[id,g]} B} and show the
following:}

\ul{
\li{There is an equivalence between coforks over #{f,g} and
[cocones](stt-0016) over the induced span.}
\li{A cofork is a coequaliser iff the corresponding cocone is a
pushout}
\li{We can construct canonical coequalisers via
[canonical pushouts](Core.CanonicalPushouts)}
}
}

%```agda
\agda{
Coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
Coeq {_} {_} {A} {B} f g
  = Pushout l r  module Coeq where
  l : B âŠ A â†’ B
  l (inl x) = x
  l (inr x) = f x

  r : B âŠ A â†’ B
  r (inl x) = x
  r (inr x) = g x

  span : Span _ _ _
  span = mk-span _ l r

{-#Â DISPLAY Pushout (Coeq.l f g) (Coeq.r f g) = Coeq f g #-}

coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ Cofork f g (Coeq f g)
coeq f g = (Î¹â‚‚ , Î» x â†’ sym (glue (inl (f x))) âˆ™ glue (inr x))

Î¹-coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
         â†’ {f g : A â†’ B}
         â†’ B â†’ Coeq f g
Î¹-coeq = coeq _ _ .fst

glue-coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
            â†’ {f g : A â†’ B}
            â†’ Î¹-coeq âˆ˜ f ~ Î¹-coeq âˆ˜ g
glue-coeq = coeq _ _ .snd


coconeâ†cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Cofork f g C â†’ Cocone (Coeq.span f g) C
coconeâ†cofork {f = f} {g} (p , H) = mk-cocone p p (âŠ-ind (~refl , H))

coforkâ†cocone : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Cocone (Coeq.span f g) C â†’ Cofork f g C
coforkâ†cocone {f = f} {g} (mk-cocone p q filler)
  = p , Î» a â†’ filler (inr a) âˆ™ sym (filler (inl (g a)))

coconeâ‰ƒfork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Cofork f g C â‰ƒ Cocone (Coeq.span f g) C
coconeâ‰ƒfork {B = B} {f} {g}{C}
  = Cofork f g C
      â‰ƒâŸ¨âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] (p âˆ˜ f ~ p âˆ˜ g))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» _ â†’ Î£-ï¼singl') eâ»Â¹ âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] ((p ï¼ q) Ã— (p âˆ˜ f ~ q âˆ˜ g)))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ Î£-ap-â‰ƒ-fst funextâ‰ƒ)) âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] ((p ~ q) Ã— (p âˆ˜ f ~ q âˆ˜ g)))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ âŠ-UPâ‰ƒ global-funext)) âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] (p âˆ˜ Coeq.l f g ~ q âˆ˜ Coeq.r f g))
      â‰ƒâŸ¨ cocone-reprâ‰ƒ eâ»Â¹ âŸ©
    Cocone (Coeq.span f g) C â‰ƒâˆ

coconeâ†fork-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
                â†’ is-equiv (coconeâ†cofork {f = f} {g} {C})
coconeâ†fork-is-equiv = coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv

coeq-is-coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                 {f g : A â†’ B} â†’ is-coeq (coeq f g)
coeq-is-coeq {f = f} {g} {Q = Q}
  = 3-for-2~ (H ~â»Â¹)
             (coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv)
             (Pushout-is-pushoutÏ‰) where
  H : coconeâ†cofork âˆ˜ cofork-map (coeq f g) {Q = Q}
    ~ cocone-map (Coeq.span f g) pushout
  H f = Cocone-pathâ†’ _ _ (funextâ†’ (f â—‚ (glue ~â»Â¹) â–¸ inl)) refl Î» where
    (inl x) â†’ sym ( ap (_âˆ™ ap f (glue (inl x))) (ap-sym f (glue (inl x)))
                   âˆ™ âˆ™-sym' (ap f (glue _)))
    (inr x) â†’ âˆ™-reflr _ âˆ™ ap-âˆ™ f (sym (glue _)) (glue (inr x))


coeq-rec : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Type ğ“¦}
           â†’ Cofork f g C
           â†’ Coeq f g â†’ C
coeq-rec = is-equiv.bwd coeq-is-coeq

coeq-rec-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
      {f g : A â†’ B} {C : Type ğ“¦}
    â†’ is-equiv (coeq-rec {f = f}{g}{C})
coeq-rec-is-equiv
  = is-equiv-âˆ˜ pushout-rec-is-equiv coconeâ†fork-is-equiv


module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B}
         {C : Type ğ“¦} (cf : Cofork f g C) where
  private
    H : âˆ€ {ğ“ }{Q : Type ğ“ }
      â†’ cocone-map (Coeq.span f g) (coconeâ†cofork cf) {Q}
      ~ coconeâ†cofork âˆ˜ cofork-map cf
    H f = Cocone-pathâ†’ _ _ refl refl (âŠ-ind (~refl , (~âˆ™-reflr _)))

  is-coeqâ†is-pushout : is-pushoutÏ‰ (Coeq.span f g) (coconeâ†cofork cf)
                       â†’ is-coeq cf
  is-coeqâ†is-pushout po = 3-for-2~ H (coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv) po

  is-pushoutâ†is-coeq : is-coeq cf
                     â†’ is-pushoutÏ‰ (Coeq.span f g) (coconeâ†cofork cf)
  is-pushoutâ†is-coeq coe
    = is-equiv~âˆ˜ H (coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv) coe

cogap-is-equivâ†is-coeq
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B} {C : Type ğ“¦}
      {cf : Cofork f g C} â†’ is-coeq cf â†’ is-equiv (coeq-rec cf)
cogap-is-equivâ†is-coeq {cf = cf} ce
  = cogap-is-equivâ†is-pushout (coconeâ†cofork cf)
                              (is-pushoutâ†is-coeq cf ce)

is-coeqâ†cogap-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B} {C : Type ğ“¦}
      {cf : Cofork f g C} â†’ is-equiv (coeq-rec cf) â†’ is-coeq cf
is-coeqâ†cogap-is-equiv {cf = cf} ce
  = is-coeqâ†is-pushout cf (is-pushoutâ†cogap _ ce)
}
%```

\subtree[stt-009O]{
\title{Induction for coequalisers}
\taxon{Theorem}

\p{Coequalisers satisfy an induction principal: given maps
#{f,g : A \to B}, and a family of types #{P} over the coequaliser
of #{f} and #{g}, we can give a section #{\Pi_{(a : \rm{Coeq}_{f,g})} P(a)}
by giving a section #{p : \Pi_{(b:B)}(P(\iota(b)))} and for each #{a},
a dependent identification #{p(f(a)) =_P^{gl} p(g(a))}. This data
is called a dependent cofork or \code{CoforkP} in code.}

%```agda
\agda{
CoforkP : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
          (f g : A â†’ B) (C : Coeq f g â†’ Type ğ“¦)
        â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
CoforkP {A = A} {B} f g C
  =  Î£[ p âˆ¶ ((b : B) â†’  C (Î¹â‚‚ b))]
      (âˆ€ a â†’ IdP (ap C (coeq f g .snd a)) (p (f a)) (p (g a)))

coconeâ†coforkP : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
              â†’ CoforkP f g C
              â†’ CoconeD (Coeq.span f g) (coconeâ†cofork (coeq f g)) C
coconeâ†coforkP {f = f} {g} (p , H)
  = mk-coconeD p p (âŠ-ind (~refl , H))

unquoteDecl coconeD-reprâ‰… coconeD-reprâ‰ƒ
  = make-record-repr coconeD-reprâ‰… coconeD-reprâ‰ƒ (quote CoconeD)

coconeâ‰ƒforkP : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
              â†’ CoforkP f g C
              â‰ƒ CoconeD (Coeq.span f g) (coconeâ†cofork (coeq f g)) C
coconeâ‰ƒforkP {B = B} {f} {g}{C}
  = CoforkP f g C
      â‰ƒâŸ¨âŸ©
    (Î£[ p âˆ¶ (Î  B (C âˆ˜ Î¹â‚‚))] (p âˆ˜ f ~[ (C â—‚ (coeq f g .snd)) ] p âˆ˜ g))
      â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» p â†’ Î£-ï¼singl') eâ»Â¹ âŸ©
    (Î£[ p âˆ¶ (Î  B (C âˆ˜ Î¹â‚‚))] Î£[ q âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] ((p ï¼ q) Ã— (p âˆ˜ f ~[ C â—‚ (coeq f g .snd) ] q âˆ˜ g)))
      â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ Î£-ap-â‰ƒ-fst funextâ‰ƒ))  âŸ©
    (Î£[ p âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] Î£[ q âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] ((p ~ q) Ã— (p âˆ˜ f ~[ C â—‚ (coeq f g .snd) ] q âˆ˜ g)))
      â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ âŠ-UPâ‰ƒ global-funext)) âŸ©
    (Î£[ p âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] Î£[ q âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] (p âˆ˜ Coeq.l f g ~[ (C â—‚ âŠ-ind (~refl , coeq f g .snd)) ] q âˆ˜ Coeq.r f g))
      â‰ƒâŸ¨ coconeD-reprâ‰ƒ eâ»Â¹ âŸ©
    CoconeD (Coeq.span f g) _ C â‰ƒâˆ

coconeâ†coforkP-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
      {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
    â†’ is-equiv (coconeâ†coforkP {f = f} {g} {C})
coconeâ†coforkP-is-equiv = coconeâ‰ƒforkP ._â‰ƒ_.has-is-eqv

coforkP-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
              {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
            â†’ Î  _ C â†’ CoforkP f g C
coforkP-map {C = C} f = (f âˆ˜ Î¹â‚‚ , f â—‚áµˆ coeq _ _ .snd)

coeq-is-coeqáµˆ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
           â†’ is-equiv (coforkP-map {C = C})
coeq-is-coeqáµˆ {f = f}{g}{Q}
  = 3-for-2~ (H ~â»Â¹) coconeâ†coforkP-is-equiv coeq-is-po where
  H : coconeâ†coforkP âˆ˜ coforkP-map {C = Q}
    ~ coconeáµˆ-map (Coeq.span f g) (coconeâ†cofork (coeq f g))  {Q = Q}
  H f = from-coconeáµˆ-path (record {
      pï¼ = refl
    ; qï¼ = refl
    ; fillerï¼ = funextâ†’ (âŠ-ind (~refl , ~refl)) })

  lem : coconeâ†cofork (coeq f g) ï¼ pushout
  lem = Cocone-pathâ†’ _ _ (funextâ†’ (Î» b â†’ sym (glue (inl b)))) refl
          (âŠ-ind ((Î» b â†’ sym (âˆ™-sym' (glue (inl b)))) , Î» a â†’ âˆ™-reflr _))

  coeq-is-po : is-pushoutÏ‰áµˆ (Coeq.span f g) (coconeâ†cofork (coeq f g))
  coeq-is-po {ğ“œ} = tr (Î» x â†’ âˆ€ {Q : Coeq f g â†’ Type ğ“œ} â†’ is-equiv (coconeáµˆ-map (Coeq.span f g) x {Q}))
                       (sym lem) Pushout-is-pushoutÏ‰áµˆ

coeq-ind : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
           â†’ CoforkP f g C
           â†’ (x : Coeq f g) â†’ C x
coeq-ind = is-equiv.bwd coeq-is-coeqáµˆ

{-# DISPLAY is-equiv.bwd coeq-is-coeqáµˆ x = coeq-ind x #-}
}
%```
}

\subtree[stt-009D]{
\title{Adjusting coequalizers by equivalences}

\p{We mirror the results in \ref{stt-0083} about pushouts.

Given a pair of maps #{f g : A \to B} and an equivalence #{e : A' \to A},
we show that a cofork coequalises #{(f,g)} iff it coequalises
#{(fe,ge)}.}

%```agda
\agda{

precomp-cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                   (f g : A â†’ B)
                   (h : A' â†’ A) {D : Type ğ“›}
                 â†’ Cofork f g D
                 â†’ Cofork (f âˆ˜ h) (g âˆ˜ h) D
precomp-cofork _ _ h = total-map Î» f â†’ _â–¸ h


precomp-cofork-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
      (f g : A â†’ B) {h : A' â†’ A} â†’ is-equiv h
    â†’ {D : Type ğ“›} â†’ is-equiv (precomp-cofork f g h {D})
precomp-cofork-is-equiv f g heq {D}
  = is-total-equivâ†is-fibrewise-equiv Î» a â†’ postwhisker-equiv-is-equiv heq

precomp-cofork-is-coeq
 : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
     {f g : A â†’ B}
     {h : A' â†’ A} â†’ is-equiv h
   â†’ {D : Type ğ“›}
   â†’ {cf : Cofork f g D}
   â†’ is-coeq cf
   â†’ is-coeq (precomp-cofork _ _ h cf)
precomp-cofork-is-coeq {f = f}{g}{h} heq {D} {cf} coeq
  = is-equiv-âˆ˜ (precomp-cofork-is-equiv _ _ heq) coeq


precomp-coeqâ‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                  {f g : A â†’ B} {h : A' â†’ A} â†’ is-equiv h
                â†’ Coeq (f âˆ˜ h) (g âˆ˜ h) â‰ƒ Coeq f g
precomp-coeqâ‰ƒ {f = f}{g}{h} heq
  = mkâ‰ƒ map (cogap-is-equivâ†is-coeq
              (precomp-cofork-is-coeq heq coeq-is-coeq)) where
  map : Coeq (f âˆ˜ h) (g âˆ˜ h) â†’ Coeq f g
  map = coeq-rec (precomp-cofork f g h (coeq _ _))
}
%```

\p{We dualise this to postcomposing coforks.}

%```agda
\agda{
postcomp-cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
                   (f g : A â†’ B)
                   (h : B â†’ B') {D : Type ğ“›}
                 â†’ Cofork (h âˆ˜ f) (h âˆ˜ g) D
                 â†’ Cofork f g D
postcomp-cofork f g h = total-map-fst (_âˆ˜ h)

postcomp-cofork-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
      (f g : A â†’ B) {h : B â†’ B'} â†’ (heq : is-equiv h)
    â†’ {D : Type ğ“›} â†’ is-equiv (postcomp-cofork f g h {D})
postcomp-cofork-is-equiv f g {h} heq {D}
  = total-is-equivâ†fst-is-equiv (postcomp-equiv heq)

postcomp-cofork-is-coeq
 : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
     {f g : A â†’ B} {h : B â†’ B'} â†’ is-equiv h
   â†’ {D : Type ğ“›}
   â†’ {cf : Cofork (h âˆ˜ f) (h âˆ˜ g) D}
   â†’ is-coeq cf
   â†’ is-coeq (postcomp-cofork _ _ h cf)
postcomp-cofork-is-coeq {f = f}{g}{h} heq {D} {cf} coeq
  = is-equiv-âˆ˜ (postcomp-cofork-is-equiv _ _ heq) coeq

postcomp-coeqâ‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
                  {f g : A â†’ B} {h : B â†’ B'} â†’ is-equiv h
                â†’ Coeq f g â‰ƒ Coeq (h âˆ˜ f) (h âˆ˜ g)
postcomp-coeqâ‰ƒ {f = f}{g}{h} heq
  = mkâ‰ƒ map (cogap-is-equivâ†is-coeq
              (postcomp-cofork-is-coeq heq coeq-is-coeq)) where
  map : Coeq f g â†’ Coeq (h âˆ˜ f) (h âˆ˜ g)
  map = coeq-rec (postcomp-cofork f g h (coeq _ _))
}
%```
}

\subtree[stt-009J]{
\title{Coequalisers of homotopic maps}
\taxon{Lemma}

\p{Given maps #{f,g,f',g' : A \to B} if #{f ~ f'} and #{g ~ g'} then
the coequaliser of #{f} and #{g} is equivalent to the coequalisers of
#{f'} and #{g'}.}

%```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f g h k : A â†’ B}
         (H : f ~ h) (K : g ~ k) where
  Coeqâ‰ƒâ†homotopy : Coeq h k â‰ƒ Coeq f g
  Coeqâ‰ƒâ†homotopy = Pushoutâ‰ƒâ†homotopy (âŠ-ind (~refl , H))
                                     (âŠ-ind (~refl , K))

precomp-coeqâ‰ƒ~ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                  {f g : A â†’ B} {h : A' â†’ A} (heq : is-equiv h)
                  {f' g' : A' â†’ B} (H : f âˆ˜ h ~ f') (K : g âˆ˜ h ~ g')
                â†’ Coeq f' g' â‰ƒ Coeq f g
precomp-coeqâ‰ƒ~ {f = f}{g}{h} heq {f'}{g'} H K
  = Coeq f' g'           â‰ƒâŸ¨ Coeqâ‰ƒâ†homotopy H K âŸ©
    Coeq (f âˆ˜ h) (g âˆ˜ h) â‰ƒâŸ¨ precomp-coeqâ‰ƒ heq âŸ©
    Coeq f g â‰ƒâˆ

postcomp-coeqâ‰ƒ~ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
                  {f g : A â†’ B} {h : B â†’ B'} (heq : is-equiv h)
                  {f' g' : A â†’ B'} (H : f' ~ h âˆ˜ f) (K : g' ~ h âˆ˜ g)
                â†’ Coeq f g â‰ƒ Coeq f' g'
postcomp-coeqâ‰ƒ~ {f = f}{g}{h} heq {f'}{g'} H K
  = Coeq f g             â‰ƒâŸ¨ postcomp-coeqâ‰ƒ heq âŸ©
    Coeq (h âˆ˜ f) (h âˆ˜ g) â‰ƒâŸ¨ Coeqâ‰ƒâ†homotopy H K âŸ©
    Coeq f' g' â‰ƒâˆ
}
%```
}
