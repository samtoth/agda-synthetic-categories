\date{2025-02-19}
\title{Identity types}
\import{stt-macros}
\taxon{module}
\meta{module}{\startverb Foundations.Identity \stopverb}

% ```agda
\agda{
module Foundations.Identity where

open import Foundations.Universes
}% ```

\subtree[identity-def]{
\taxon{definition}

\meta{defines}{\startverb ["Id"] \stopverb}

\title{Id}

\p{
For any type #{A : \cal{U}}, and pair of terms #{a,b : A}, we can define a type #{a = b : \cal{U}} generated by the term #{\textrm{refl}_a : a = a}. If the type of the identity is not obvious from context we write #{a =_A b}.
}


% ```agda
\agda{
data Id {𝓤} (A : Type 𝓤) (a : A) : A → Type 𝓤 where
  refl : Id A a a


{-# BUILTIN EQUALITY Id #-}
{-# BUILTIN REWRITE Id #-}

}
% ```
}

\subtree[identity-notation]{
\taxon{notation}
\meta{defines}{\startverb ["_=_"] \stopverb}

\p{We defined the identity type to be called \code{Id A a b}, but for convenience, we also define an infix notation: \code{a ＝ b}.
Note that this uses the unicode equals symbol!
}

% ```agda
\agda{
infix 6 _＝_
_＝_ : ∀ {𝓤} {A : Type 𝓤} → A → A → Type 𝓤
a ＝ b = Id _ a b
{-# DISPLAY Id _ a b = a ＝ b #-}

}
% ```
}


\subtree[stt-0005]{
\taxon{theorem}
\title{Identity induction}

\meta{defines}{\startverb ["J","coe","ap","tr","tr-constant"] \stopverb}

\p{ Identity induction, or the J-rule, states that for a fixed value #{a}, and given a family of types #{P} over a singleton, it is enough to
give a term at #{P(a,\refl_a)} to get a term #{P(b,p)} for any #{(b,p) : \Sigma_{b : A} a = b}.}


% ```agda
\agda{
J : ∀ {𝓤 𝓥} {A : Type 𝓤} {a : A} (P : (x : A) → a ＝ x → Type 𝓥)
   → P a refl → ∀ {b} → (p : a ＝ b) → P b p
J P prfl refl = prfl

coe : ∀ {𝓤} {A : Type 𝓤} {B : Type 𝓤} → A ＝ B → A → B
coe refl a = a

ap : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} → (f : A → B) → {a b : A} → a ＝ b → f a ＝ f b
ap f refl = refl

tr : ∀ {𝓤 𝓥} {A : Type 𝓤} (P : A → Type 𝓥) → ∀ {a b} → a ＝ b → P a → P b
tr P p pa = coe (ap P p) pa
{-# NOINLINE tr #-}

tr-constant : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {a b : B} → (p : a ＝ b) → (a : A) → tr (λ _ → A) p a ＝ a
tr-constant refl a = refl

}
% ```

}

\subtree[stt-000B]{
\title{Groupoid structure of the universe}
\meta{defines}{\startverb
["sym","sym-sym","trans"
, "_∙_", "∙-refll", "∙-reflr"
, "∙-assoc", "∙-sym", "∙-sym'"
, "-∙_", "_∙-", "coe-postcomp＝", "coe-precomp＝"
, "pre-post-comp", "∙-diff-zero'"
]
\stopverb
}

\p{The J-rule allows us to exhibit the universe as a groupoid with the identity type as the homs.}

  \ul{
    \li{Given #{x =_A y}, we can define a term of type #{y =_A x}}
    \li{Given #{x = y}, and #{y = z}, we have a term #{x = z}}
    \li{There is always a term #{x = x}}
  }
% ```agda
\agda{

sym : ∀ {𝓤} {A : Type 𝓤} {x y : A} → x ＝ y → y ＝ x
sym refl = refl

sym-sym : ∀ {𝓤} {A : Type 𝓤} {x y : A} {p : x ＝ y} → sym (sym p) ＝ p
sym-sym {p = refl} = refl

-- {-# REWRITE  sym-sym #-} -- is not confluent

trans : ∀ {𝓤} {A : Type 𝓤} {x y z : A} → x ＝ y → y ＝ z → x ＝ z
trans refl q = q

_∙_ = trans
infixr 20 _∙_
{-# DISPLAY trans = _∙_ #-}

-∙_ : ∀ {𝓤} {A : Type 𝓤} {x y z : A} → y ＝ z → (x ＝ y) ＝ (x ＝ z)
-∙ p = ap (_ ＝_) p
{-# NOINLINE -∙_ #-}

_∙- : ∀ {𝓤} {A : Type 𝓤} {x y z : A} → y ＝ x → (y ＝ z) ＝ (x ＝ z)
p ∙- = ap (_＝ _) p
{-# NOINLINE _∙- #-}

∙-refll : ∀ {𝓤} {A : Type 𝓤} {x y : A} → (p : x ＝ y) → refl ∙ p ＝ p
∙-refll p = refl

∙-reflr : ∀ {𝓤} {A : Type 𝓤} {x y : A} → (p : x ＝ y) → p ∙ refl ＝ p
∙-reflr refl = refl

∙-assoc : ∀ {𝓤} {A : Type 𝓤} {x y z w : A} (p : x ＝ y) (q : y ＝ z) (r : z ＝ w) → (p ∙ q) ∙ r ＝ p ∙ q ∙ r
∙-assoc refl q r = refl

∙-sym : ∀ {𝓤} {A : Type 𝓤} {x y : A} (p : x ＝ y) → p ∙ sym p ＝ refl
∙-sym refl = refl

∙-sym' : ∀ {𝓤} {A : Type 𝓤} {x y : A} (p : x ＝ y) → sym p ∙ p ＝ refl
∙-sym' refl = refl

∙-diff-zero' : ∀ {𝓤} {A : Type 𝓤} {x y : A} {p q : x ＝ y} → p ＝ q → sym p ∙ q ＝ refl
∙-diff-zero' {p = p} refl = ∙-sym' p

coe-precomp＝ : ∀ {𝓤} {A : Type 𝓤} {x y z : A}
               →  (p : x ＝ y) (q : y ＝ z)
               → coe (-∙ q) p ＝ p ∙ q
coe-precomp＝ p refl = sym (∙-reflr p)

coe-postcomp＝ : ∀ {𝓤} {A : Type 𝓤} {x y z : A}
               → (p : y ＝ x) (q : y ＝ z)
               → coe (p ∙-) q ＝ sym p ∙ q
coe-postcomp＝ refl q = refl

coe-postcomp＝' : ∀ {𝓤} {A : Type 𝓤} {x y z : A}
               → (p : x ＝ y) (q : y ＝ z)
               → coe (sym p ∙-) q ＝ p ∙ q
coe-postcomp＝' refl q = refl

pre-post-comp : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {x y : A}
                 {p : x ＝ y} {f g : A → B}
               → ap (λ z → f z ＝ g z) p ＝ (ap f p ∙-) ∙ (-∙ ap g p)
pre-post-comp {p = refl} = refl

∙-symsym : ∀ {𝓤} {A : Type 𝓤} {x y z : A} (p : x ＝ y) (q : y ＝ z)
           → sym (p ∙ q) ＝ sym q ∙ sym p
∙-symsym refl refl = refl

coe∙coe : ∀ {𝓤} {A B C : Type 𝓤} (P : A ＝ B) (Q : B ＝ C)
          → ∀ a
          → coe Q (coe P a) ＝ coe (P ∙ Q) a
coe∙coe refl refl a = refl

tr∙tr : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥} → ∀ {a b c} (p : a ＝ b) (q : b ＝ c)
      (b : P a)
      → tr P q (tr P p b) ＝ tr P (p ∙ q) b
tr∙tr refl refl b = refl

tr∙tr-sym : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥} → ∀ {a b} (p : a ＝ b)
            → (b : P a)
            → tr P (sym p) (tr P p b) ＝ b
tr∙tr-sym refl b = refl

tr∙tr-sym' : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥} → ∀ {a b} (p : a ＝ b)
            → (b : P b)
            → tr P p (tr P (sym p) b) ＝ b
tr∙tr-sym' refl b = refl

tr-transpose : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥} → ∀ {a b} (p : a ＝ b)
               → (x : P a) → (y : P b)
               → tr P p x ＝ y → x ＝ tr P (sym p) y
tr-transpose refl x y p = p

tr-refl : ∀ {𝓤 𝓥} {A : Type 𝓤} {P : A → Type 𝓥}
          → ∀ {a} (p : a ＝ a)
              (x : P a)
            → p ＝ refl
            → x ＝ tr P p x
tr-refl p x refl = refl
}
% ```
}

\subtree[stt-000C]{
\taxon{notation}
\title{Equation combinators}
\meta{defines}{\startverb
["＝⟨⟩-syntax", "_＝⟨⟩_", "_∎"]
\stopverb
}

% ```agda
\agda{
＝⟨⟩-syntax : ∀ {𝓤} {A : Type 𝓤} (x : A) {y z} → y ＝ z → x ＝ y → x ＝ z
＝⟨⟩-syntax x q p = p ∙ q

infixr 2 ＝⟨⟩-syntax
syntax ＝⟨⟩-syntax x q p = x ＝⟨ p ⟩ q

_＝⟨⟩_ : ∀ {𝓤} {A : Type 𝓤} (x : A) {y : A} → x ＝ y → x ＝ y
x ＝⟨⟩ p = p

_∎ : ∀ {ℓ} {A : Type ℓ} (x : A) → x ＝ x
x ∎ = refl

infixr 2 _＝⟨⟩_ 
infix  3 _∎
}
% ```
}
