\title{The pushout join}
\taxon{Module}
\date{2026-01-12}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.PushoutJoin
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Data.Bool

open import Core.Orthogonal
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.PushoutProduct
open import Core.FunctorialPullback
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.CoSlice
open import Core.Slice
open import Core.Cube
open import Core.ArrowEquiv
open import Core.ArrowRetract

open import Ergonomics.Notations.Orthogonality
open Core.Orthogonal.notation
open import Ergonomics.Extensionality
open import Ergonomics.Representation
open import Ergonomics.Auto

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.NaturalTransformation Î”Â¹ I I-distr
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.JoinSlice Î”Â¹ I I-distr
}
%```

\subtree[tot-000B]{
\taxon{Definition}
\title{Pushout joins}

\p{Just as we could [extend the product bifunctor to an operation on
arrows](stt-00BS), we can do the same for the [directed join](stt-00CW)
bifunctor. Given maps #{f : A \to B} and #{g : C \to D}, we define
#{f \hat{rtimes} g} to be the cogap map of the following square.}

\quiver{
\begin{tikzcd}
	{A \rtimes C} && {A \rtimes D} \\
	& \bullet \\
	{B \rtimes C} && {B \rtimes D}
	\arrow["{A \rtimes g}", from=1-1, to=1-3]
	\arrow["{f\rtimes C}"', from=1-1, to=3-1]
	\arrow[from=1-3, to=2-2]
	\arrow["{f \rtimes D}", from=1-3, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=2-2, to=1-1]
	\arrow["{f \hat{\rtimes}g}", from=2-2, to=3-3]
	\arrow[from=3-1, to=2-2]
	\arrow["{B \rtimes g}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{We also note that this map can be considered a map in the slice over #{D}.}

%```agda
\agda{
Join-square
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (g : X â†’ Y)
    â†’ Arrow-map (f â‹‰â‚ id {A = X}) (f â‹‰â‚ id {A = Y})
Join-square f g .Arrow-map.top = id â‹‰â‚ g
Join-square f g .Arrow-map.bot = id â‹‰â‚ g
Join-square f g .Arrow-map.comm = (â‹‰â‚-âˆ˜ id f g id ~â»Â¹) ~âˆ™ â‹‰â‚-âˆ˜ f id id g

Pushout-join
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (g : X â†’ Y)
    â†’ Pushoutâ‚€ (Coconeâ†Arrow-map (Join-square f g) .fst) â†’ B â‹‰ Y
Pushout-join f g = cogap-mapâ†square (Join-square f g)

Pushout-join-coslice
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (g : X â†’ Y)
    â†’ Coslice-map {X = Pushoutâ‚€ (Coconeâ†Arrow-map (Join-square f g) .fst)}
                  (Î¹â‚‚ âˆ˜ â†‘-Î¹â‚‚)
                  {Y = B â‹‰ Y} â†‘-Î¹â‚‚
Pushout-join-coslice f g .fst = Pushout-join f g
Pushout-join-coslice f g .snd = ~refl
}
%```
}

\subtree[tot-000C]{
\title{Pullback Slices}


%```agda
\agda{
extend-slice-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§} {P : Type ğ“¤} {Q : Type ğ“¥} {A : Type ğ“¦} {B : Type ğ“§}
      (p : P â†’ A) (q : Q â†’ A) (f : A â†’ B)
    â†’ Slice-map p q â†’ Slice-map (f âˆ˜ p) (f âˆ˜ q)
extend-slice-map p q f = total-map (Î» _ â†’ f â—‚_)

slice-square
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ} {p : K â†’ A}
       {S : Type ğ“} {q : S â†’ A} (g : Slice-map p q)
    â†’ Arrow-map (precompose-slice q f) (precompose-slice p f)
slice-square f {p = p} {q = q} G .Arrow-map.top
  = slice-map-slice p q G
slice-square f {p = p} {q = q} G .Arrow-map.bot
  = slice-map-slice (f âˆ˜ p) (f âˆ˜ q) (extend-slice-map p q f G)
slice-square f G .Arrow-map.comm a
  = Î£-pathâ†’ (refl , (funextâ†’
      (Î» k â†’ Hom-extâ†’ (~refl , ap-âˆ™ f _ refl , ap-âˆ™ f _ (G .snd k)))))

pullback-slice
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ} {p : K â†’ A}
       {S : Type ğ“} {q : S â†’ A} (g : Slice-map p q)
    â†’ Slice A q
    â†’ Pullback (slice-map-slice (f âˆ˜ p) (f âˆ˜ q) (extend-slice-map _ q f g))
               (precompose-slice p f)
pullback-slice f g = gap-mapâ†square (slice-square f g)

slice-hom
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ}
       {S : Type ğ“} {q : S â†’ A} (t : K â†’ S)
     â†’ Arrow-map (precompose-slice q f) (precompose-slice (q âˆ˜ t) f)
slice-hom f t .Arrow-map.top = postcompose-slice _ t
slice-hom f t .Arrow-map.bot = postcompose-slice _ t
slice-hom f t .Arrow-map.comm a = refl

pullback-slice'
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
       {K : Type ğ“œ}
       {S : Type ğ“} (q : S â†’ A) (t : K â†’ S)
    â†’ Slice A q â†’ Pullback (postcompose-slice (f âˆ˜ q) t)
                           (precompose-slice (q âˆ˜ t) f)
pullback-slice' f q t = gap-mapâ†square (slice-hom f t)

hom-fam-as-slice : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’
  âˆ€ x â†’ Arrow-map (pullback-slice (! {A = A}) {p = Â¡_} {q = Î» (_ : ğŸ™) â†’ x}
                                  (Â¡_ , (Î» ())))
                  (fst {B = (Î» y â†’ Hom A y x)})
hom-fam-as-slice x .Arrow-map.top (a , b) = a , b tt
hom-fam-as-slice x .Arrow-map.bot (a , b , p) = b .fst
hom-fam-as-slice x .Arrow-map.comm = ~refl
}
%```
}

%```agda
\agda{
module L[x] = Lattice I[x]

-- power-hom-coslice
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
--       {A : Type ğ“¤} {B : Type ğ“¥} (p : Y â†’ A) (q : Y â†’ B) (F : Coslice-map p q)
--       {C : Type ğ“¦} {D : Type ğ“œ} (r : Y â†’ C) (s : Y â†’ D) (G : Coslice-map r s)
--     â†’ Arrow-map (Coslice-map-postcompose r F) (Coslice-map-postcompose s F)
-- power-hom-coslice p q F r s G .Arrow-map.top = Coslice-map-precompose q G
-- power-hom-coslice p q F r s G .Arrow-map.bot = Coslice-map-precompose p G
-- power-hom-coslice p q F r s G .Arrow-map.comm x
--   = Î£-pathâ†’ (refl , (funextâ†’ (Î» a â†’ ap (_âˆ™ G .snd a) (ap-âˆ™ (G .fst) _ (x .snd a)
--                   âˆ™ ap (_âˆ™ ap (G .fst) _)
--                          (sym (ap-âˆ˜ (G .fst) (x .fst) (F .snd a))))
--                   âˆ™ âˆ™-assoc _ (ap (G .fst) (x .snd a)) (G .snd a))))

-- pullback-coslice-power
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
--       {A : Type ğ“¤} {B : Type ğ“¥} (p : Y â†’ A) (q : Y â†’ B) (F : Coslice-map p q)
--       {C : Type ğ“¦} {D : Type ğ“œ} (r : Y â†’ C) (s : Y â†’ D) (G : Coslice-map r s)
--     â†’ Coslice-map q r
--     â†’ Pullback (Coslice-map-precompose p G) (Coslice-map-postcompose s F)
-- pullback-coslice-power p q F r s G
--   = gap-mapâ†square (power-hom-coslice p q F r s G)


-- Pullback3
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {D : Type ğ“œ}
--       (f : A â†’ D) (g : B â†’ D) (h : C â†’ D) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ)
-- Pullback3 {A = A}{B}{C} f g h = Î£[ a âˆ¶ A ] Î£[ b âˆ¶ B ] Î£[ c âˆ¶ C ]
--                                  ((f a ï¼ g b) Ã— (g b ï¼ h c))

-- Pullback3â†Pullback-lassoc
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {D : Type ğ“œ}
--       (f : A â†’ D) (g : B â†’ D) (h : C â†’ D)
--     â†’ Pullback {B = Pullback f g} (g âˆ˜ pb.Ï€â‚‚) h â†’ Pullback3 f g h
-- Pullback3â†Pullback-lassoc f g h ((a , b , p) , c , q) = (a , b , c , p , q)

-- Pullback3â†Pullback-rassoc
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {D : Type ğ“œ}
--       (f : A â†’ D) (g : B â†’ D) (h : C â†’ D)
--     â†’ Pullback {C = Pullback g h} f (g âˆ˜ pb.Ï€â‚) â†’ Pullback3 f g h
-- Pullback3â†Pullback-rassoc f g h (a , (b , c , q) , p) = (a , b , c , p , q)

-- Pullbackâ†Cone
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {Q : Type ğ“œ}
--       {f : A â†’ B} {g : C â†’ B}
--     â†’ Cone (mk-cospan B f g) Q â†’ Pullback (precomp Q f) (precomp Q g)
-- Pullbackâ†Cone (mk-cone i j filler) = (i , j , funextâ†’ filler)

-- Coneâ†Pullback
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {Q : Type ğ“œ}
--       {f : A â†’ B} {g : C â†’ B}
--     â†’ Pullback (precomp Q f) (precomp Q g) â†’ Cone (mk-cospan B f g) Q
-- Coneâ†Pullback (i , j , H) = mk-cone i j (happly H)

-- Coconeâ†Pullback
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {Q : Type ğ“œ}
--       {f : B â†’ A} {g : B â†’ C}
--     â†’ Pullback (postcomp Q f) (postcomp Q g) â†’ Cocone (mk-span B f g) Q
-- Coconeâ†Pullback = {!!}

-- Coslice-pushout
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {X : Type ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
--       {p : X â†’ A} {q : X â†’ B} {r : X â†’ C}
--       (F : Coslice-map p q) (G : Coslice-map p r)
--     â†’ X â†’ Pushout (F .fst) (G .fst)
-- Coslice-pushout {r = r} F G x = Î¹â‚‚ (r x)

-- Coslice-pushout-Î¹â‚
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {X : Type ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
--       {p : X â†’ A} {q : X â†’ B} {r : X â†’ C}
--       {F : Coslice-map p q} {G : Coslice-map p r}
--     â†’ Coslice-map q (Coslice-pushout F G)
-- Coslice-pushout-Î¹â‚ .fst = Î¹â‚
-- Coslice-pushout-Î¹â‚ {p = p}{F = F} {G} .snd
--   = (Î¹â‚ â—‚ F .snd ~â»Â¹) ~âˆ™ glue â–¸ _ ~âˆ™ Î¹â‚‚ â—‚ G .snd

-- Coslice-pushout-Î¹â‚‚
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {X : Type ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
--       {p : X â†’ A} {q : X â†’ B} {r : X â†’ C}
--       {F : Coslice-map p q} {G : Coslice-map p r}
--     â†’ Coslice-map r (Coslice-pushout F G)
-- Coslice-pushout-Î¹â‚‚ .fst = Î¹â‚‚
-- Coslice-pushout-Î¹â‚‚ .snd = ~refl

-- -- This should actually be Coslice map, but we need to define coslice
-- -- exponentials and pullbacks etc.
-- Coslice-pushout-UP
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {X : Type ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
--       {p : X â†’ A} {q : X â†’ B} {r : X â†’ C}
--       (F : Coslice-map p q) (G : Coslice-map p r)
--       {Q : Type ğ“ } (i : X â†’ Q)
--     â†’ Coslice-map (Coslice-pushout F G) i
--     â†’ Pullback {B = Coslice-map q i} {C = Coslice-map r i}
--                (Coslice-map-postcompose i F)
--                (Coslice-map-postcompose i G)
-- Coslice-pushout-UP {p = p}{q}{r} F G i H
--   = ( Coslice-map-âˆ˜ q _ i H (Coslice-pushout-Î¹â‚ {F = F}{G})
--     , Coslice-map-âˆ˜ r _ i H (Coslice-pushout-Î¹â‚‚ {F = F}{G})
--     , Î£-pathâ†’ (funextâ†’ (H .fst â—‚ glue) , funextâ†’ Î» a â†’ {!!})) where
--   module C = Cocone (cocone-map _ pushout (H .fst))

-- Coslice-pushout-UPâ‰ƒ
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {X : Type ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
--       {p : X â†’ A} {q : X â†’ B} {r : X â†’ C}
--       (F : Coslice-map p q) (G : Coslice-map p r)
--       {Q : Type ğ“ } (i : X â†’ Q)
--     â†’ is-equiv (Coslice-pushout-UP F G i)
-- Coslice-pushout-UPâ‰ƒ = {!!}

-- adjointness-fwd
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {S : Type ğ“¦} {T : Type ğ“œ}
--       {X : Type ğ“§} {Y : Type ğ“¨}
--       (u : A â†’ B) (s : S â†’ T) (t : T â†’ X) (f : X â†’ Y)
--     â†’ Arrow-map (pullback-power u (pullback-slice' f t s))
--                 (pullback-coslice-power _ _ (Pushout-join-coslice u s)
--                                              t _ (f , ~refl))
-- adjointness-fwd u s t f .Arrow-map.top = adj' t
-- adjointness-fwd {A = A} {B}{S}{T}{X}{Y} u s t f .Arrow-map.bot
--   = {!!} âˆ˜ {!!} âˆ˜ map âˆ˜ pullbackâ†arrow where
--   map : Pullback {B = A â†’ Slice _ t}
--                  {C = B â†’ Pullback (postcompose-slice (f âˆ˜ t) s) (precompose-slice (t âˆ˜ s) f)}
--                  (precomp _ (pullback-slice' f t s))
--                  (postcomp _ u)
--       â†’ Pullback {B = A â†’ Slice _ t}
--                  {C = Pullback (precomp B (postcompose-slice (f âˆ˜ t) s))
--                                (precomp B (precompose-slice (t âˆ˜ s) f))}
--                  (precomp _ (pullback-slice' f t s))
--                  (postcomp _ u âˆ˜ gap âˆ˜ Coneâ†Pullback)
--   map = total-map (Î» a â†’ total-map-fst (Pullbackâ†Cone âˆ˜ cone-map _ (pullback _ _)))

--   map3 : Pullback {B = A â†’ Slice _ t}
--                  {C = Pullback (precomp B (postcompose-slice (f âˆ˜ t) s))
--                                (precomp B (precompose-slice (t âˆ˜ s) f))}
--                  (precomp _ (pullback-slice' f t s))
--                  (postcomp _ u âˆ˜ gap âˆ˜ Coneâ†Pullback)
--        â†’ Pullback {B = Coslice-map {X = A â‹‰ T} â†‘-Î¹â‚‚ t}
--                   {C = Pullback {B = Coslice-map {X = B â‹‰ S} â†‘-Î¹â‚‚ s}
--                                 {C = Coslice-map {X = B â‹‰ T} â†‘-Î¹â‚‚ (f âˆ˜ t)}
--                                 {!!}
--                                 {!Coslice-map-precompose!}}
--                   (Coslice-map-precompose â†‘-Î¹â‚‚ (f , ~refl))
--                   (Î» a â†’ Coslice-map-âˆ˜ _ _ _ {!!} {!!})
--   map3 = {!!}

--   map2
--    : Pullback {B = Coslice-map (Î¹â‚‚ âˆ˜ â†‘-Î¹â‚‚) t}
--               (Coslice-map-precompose (Î¹â‚‚ âˆ˜ â†‘-Î¹â‚‚) (f , ~refl))
--               (Coslice-map-postcompose (f âˆ˜ t) (Pushout-join-coslice u s))
--    â†’ Pullback {B = Pullback {!Coslice!}
--                             {!Coslice-map-postcompose ? ?!}}
--                ({!!} âˆ˜ is-equiv.bwd (Coslice-pushout-UPâ‰ƒ _ _ _))
--                (Coslice-map-postcompose (f âˆ˜ t) (Pushout-join-coslice u s))
--   map2 = total-map-fst (Coslice-pushout-UP _ _ _)


--   -- map2
--   --   : Pullback {B = A â†’ Slice _ t}
--   --              {C = Cone (Coneâ†Arrow-map (slice-hom f {q = t} s) .fst) B}
--   --              (precomp _ (pullback-slice' f t s))
--   --              (postcomp _ u âˆ˜ gap)
--   --   â†’ Pullback

-- adjointness-fwd u s t f .Arrow-map.comm = {!!}

-- adjointness
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {S : Type ğ“¦} {T : Type ğ“œ}
--       {X : Type ğ“§} {Y : Type ğ“¨}
--       (u : A â†’ B) (s : S â†’ T) (t : T â†’ X) (f : X â†’ Y)
--     â†’ is-Arrow-equiv (adjointness-fwd u s t f)
-- adjointness u s t f .fst = adj'-is-equiv t
-- adjointness u s t f .snd = {!!}

-- test
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
--       {A : Type ğ“¤} {B : Type ğ“¥} (p : Y â†’ A) (q : Y â†’ B) (F : Coslice-map p q)
--       {C : Type ğ“¦} {D : Type ğ“œ} (r : Y â†’ C) (s : Y â†’ D) (G : Coslice-map r s)
--     â†’ Arrow-map (pullback-coslice-power _ _ F _ _ G) (pullback-power (F .fst) (G .fst))
-- test _ _ F _ _ G .Arrow-map.top = fst
-- test _ _ F _ _ G .Arrow-map.bot (a , b , p)
--   = mk-amap (fst a) (fst b) (sym âˆ˜ happly (ap fst p))
-- test _ _ F _ _ G .Arrow-map.comm a
--   = Arrow-map-pathâ†’ (~refl , ~refl , Î»
--      a â†’ âˆ™-reflr _ âˆ™ ap (Î» x â†’ sym (happly x a) ) Î£-path-ap-fst)

-- -- test-eq
-- --   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
-- --       {A : Type ğ“¤} {B : Type ğ“¥} (p : Y â†’ A) (q : Y â†’ B) (F : Coslice-map p q)
-- --       {C : Type ğ“¦} {D : Type ğ“œ} (r : Y â†’ C) (s : Y â†’ D) (G : Coslice-map r s)
-- --     â†’ is-equiv (pullback-coslice-power _ _ F _ _ G)
-- --     â†’ is-equiv (pullback-power (F .fst) (G .fst))
-- -- test-eq p q F r s G e = is-equivâ†qiso ((fst âˆ˜ bwd âˆ˜ {!!}) , {!!}) where
-- --   open is-equiv e

-- perp-cond1
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {S : Type ğ“¦} {T : Type ğ“œ}
--       {X : Type ğ“§} {Y : Type ğ“¨}
--       (u : A â†’ B) (s : S â†’ T)  (f : X â†’ Y) (t : T â†’ X)
--     â†’ (u âŠ¥ pullback-slice' f t s)
--     â‡” is-equiv (pullback-power u (pullback-slice' f t s))
-- perp-cond1 u s f t .fst = pb-power-is-equivâ†orthogonal
-- perp-cond1 u s f t .snd = orthogonalâ†pb-power-is-equiv

-- fibre-pb-coslice-power
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
--       {A : Type ğ“¤} {B : Type ğ“¥} {p : Y â†’ A} {q : Y â†’ B} (F : Coslice-map p q)
--       {C : Type ğ“¦} {D : Type ğ“œ} {r : Y â†’ C} {s : Y â†’ D} (G : Coslice-map r s)
--     â†’ âˆ€ a â†’ fibre (pullback-coslice-power _ _ F _ _ G) a
--     â‰ƒ Î£[ F âˆ¶ Coslice-map q r ] ğŸ™
-- fibre-pb-coslice-power {p = p} {q} F {r = r} {s} G a@(T , B , fil)
--   = fibre (pullback-coslice-power _ _ F _ _ G) a â‰ƒâŸ¨âŸ©
--     (Î£[ L âˆ¶ Coslice-map q r ] (pullback-coslice-power _ _  F _ _ G L ï¼ a))
--       â‰ƒâŸ¨ {!!} âŸ©
--     Î£ (Coslice-map q r) (Î» Fâ‚ â†’ ğŸ™) â‰ƒâˆ

-- coslice-lift
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“¨} {Y : Type ğ“¨}
--       {A : Type ğ“¤} {B : Type ğ“¥} (p : Y â†’ A) (q : Y â†’ B) (F : Coslice-map p q)
--       {C : Type ğ“¦} {D : Type ğ“œ} (r : Y â†’ C) (s : Y â†’ D) (G : Coslice-map r s)
--     â†’ (âˆ€ (F : Arrow-map (F .fst) (G .fst)) â†’ is-singleton (Lift F))
--     â†’ is-equiv (pullback-coslice-power _ _ F _ _ G)
-- coslice-lift p q F r s G eq = is-equivâ†is-contr-map Î»
--  a â†’ {!!}

-- perp-cond2
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {S : Type ğ“¦} {T : Type ğ“œ}
--       {X : Type ğ“§} {Y : Type ğ“¨}
--       (u : A â†’ B) (s : S â†’ T) (f : X â†’ Y)
--     â†’ (are-orthogonal (Pushout-join u s) f)
--     â‡” (âˆ€ t â†’ is-equiv (pullback-coslice-power _ _ (Pushout-join-coslice u s)
--                                               t _ (f , ~refl)))
-- perp-cond2 u s f .fst orth t = {!!} where
--   amap : Arrow-map (pullback-coslice-power _ _ (Pushout-join-coslice u s)
--                                           t _ (f , ~refl))
--                    (gap-mapâ†square (power-hom (Pushout-join u s) f))
--   amap .Arrow-map.top k = k .fst
--   amap .Arrow-map.bot = {!!}
--   amap .Arrow-map.comm = {!!}

-- perp-cond2 u s v .snd eq = {!!}

-- perp-cond
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {S : Type ğ“¦} {T : Type ğ“œ}
--       {X : Type ğ“§} {Y : Type ğ“¨}
--       (u : A â†’ B) (s : S â†’ T)  (f : X â†’ Y)
--     â†’ (Pushout-join u s âŠ¥ f) â‡” (âˆ€ (t : T â†’ X) â†’ are-orthogonal u (pullback-slice' f t s))
-- perp-cond u s f = perp-cond2 u s f
--                 âˆ™â‡” (precomp-Î -â‡” (Î» t â†’ perp-cond1 u s f t
--                                 âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv
--                                     (adjointness-fwd u s t f)
--                                     (adjointness u s t f)) â‡”â»Â¹)

}
%```
