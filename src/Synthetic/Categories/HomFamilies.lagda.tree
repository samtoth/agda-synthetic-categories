\title{Hom families}
\taxon{Module}
\author{samueltoth}
\date{2025-12-09}

\import{stt-macros}


\subtree[tot-000R]{
\title{Idea}


}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.HomFamilies
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Data.Bool

open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CoSlice
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection
open import Core.CanonicalPushouts

-- For simpâ†strong-segal
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.FunctorialPullback
open import Core.Postwhisker

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open import Ergonomics.Auto
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.JoinSlice Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Homotopies Î”Â¹ I I-distr
}
%```



\subtree[tot-0002]{
\title{Unstraightening hom families}
\taxon{Remark}

\p{The unstraightening of the family #{\Hom(x,-)} is #{X_{x/} \to X}. Thus
representable families are covariant iff #{X_{x/} \to X} are all left fibrations.}


%```agda
\agda{
hom-fam-is-covâ‡”is-left-fibration
  : âˆ€ {ğ“¤} {X : Type ğ“¤} x
  â†’ is-covariant (Î» a â†’ Hom X x a)
  â‡” is-left-fibration {A = Coslice X (Î» (_ : ğŸ™) â†’ x)} fst
hom-fam-is-covâ‡”is-left-fibration x
  = is-covariantâ‡”is-left-fibration (Î» a â†’ Hom _ x a)
  âˆ™â‡” right-orthogonal-iffâ†equiv (Î» _ â†’ i0) amap amap-eq where
  amap : Arrow-map (fst {B = Î» c â†’ (i : ğŸ™) â†’ Hom _ x c})
                   (fst {B = Î» a â†’ Hom _ x a})
  amap .Arrow-map.top = total-map (Î» a â†’ ev tt)
  amap .Arrow-map.bot = id
  amap .Arrow-map.comm = ~refl

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = is-total-equivâ†is-fibrewise-equiv (Î» a â†’ unit-ev-is-equiv)
  amap-eq .snd = id-is-equiv
}
%```
}

\subtree[tot-0006]{
\taxon{Definition}

\p{We call a type \em{strongly} Segal if it is local with respect to the map
#{\Lambda^2_1 \to 1 \rtimes \Delta^1}.
}

%```agda
\agda{
weird-horn-inclusion : Î›[2,1] â†’ ğŸ™ â‹‰ Î”Â¹
weird-horn-inclusion = cogap (mk-cocone (â†‘-hom (tt , i0) .HomP.hom) â†‘-Î¹â‚‚
                             Î» a â†’ glue (Î´Î”Â¹-1 , tt , i0))

weird-horn-inclusionâˆ™ : Coslice-map (Î» (_ : ğŸ™) â†’ Î¹â‚ i0) Î» _ â†’ â†‘-Î¹â‚ tt
weird-horn-inclusionâˆ™ = (weird-horn-inclusion , Î» _ â†’ glue (Î´Î”Â¹-0 , tt , i0))

is-strongly-segal : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-strongly-segal A = is-local (Î» (_ : ğŸ™) â†’ weird-horn-inclusion) A
}
%```
}

\subtree[tot-0007]{
\title{Strongly Segal types are Segal}
\taxon{Lemma}

\p{Any [strongly Segal](tot-0006) type is [Segal](stt-00AI).}

\proof{
\p{We give a retraction #{\Delta^2 \hookrightarrow 1 \rtimes \Delta^1},
   which furthermore preserves the inner horn inclusion.
   (Note the retraction #{\Delta^2 \hookrightarrow \square^2} in \ref{stt-00C7}
   factors through this map.)}
}

%```agda
\agda{
retract-weird : ğŸ™ â‹‰ Î”Â¹ â†’ Î”Â²
retract-weird
  = cogap (mk-cocone
            (Î» {(i , tt , j) â†’ (i , i âˆ§ j) â¦ƒ âˆ§-â‰¤-eliml auto! â¦„})
            âŠ[ (Î» _ â†’ (i0 , i0)) , (i1 ,_) ]
            Î» { (mk-lift true  , tt , b) â†’ Î”Â²-ext (refl , âˆ§-commÂ âˆ™ 1-top)
              ; (mk-lift false , tt , b) â†’ Î”Â²-ext (refl , 0-init) })

retract-weird-resp-horn
  : retract-weird âˆ˜ weird-horn-inclusion ~ Î›[2,1]-incl
retract-weird-resp-horn = pushout-ind _
  (mk-coconeD
    (Î» l â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ 0-init))
    (Î» r â†’ refl)
    (Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _))

section-weird : Î”Â² â†’ ğŸ™ â‹‰ Î”Â¹
section-weird a = Î¹â‚ (Poly.Î”Â².s a , tt , Poly.Î”Â².t a)

section-weird-resp-horn
  : section-weird âˆ˜ Î›[2,1]-incl ~ weird-horn-inclusion
section-weird-resp-horn = pushout-rec-unique _ _
  ~refl
  (Î» a â†’ glue (Î´Î”Â¹-1 , tt , a))
  Î» a â†’ ap (_âˆ™ glue (Î´Î”Â¹-1 , tt , i0))
         ( ap-âˆ˜ section-weird Î›[2,1]-incl (glue a)
         âˆ™ ap (ap section-weird) (pushout-rec-apÎ² _)
         âˆ™ lem) where
  lem : ap (section-weird) Î”Â²-refl ï¼ refl
  lem = ap-âˆ˜ Î¹â‚ (Î» where (i , j) â†’ (i , tt , j)) Î”Â²-refl
      âˆ™ ap (ap Î¹â‚) (is-propâ†is-truncated
                     (Trunc.Ã—âˆˆS car-is-set (Trunc.Ã—âˆˆS Trunc.ğŸ™âˆˆS car-is-set) _ _)
                     _ _)

sec-weird-is-sec : retract-weird âˆ˜ section-weird ~ id
sec-weird-is-sec (a , b) = Î”Â²-ext (refl , (âˆ§-comm âˆ™ auto!))

strongly-segal-type-is-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (weird-horn-inclusion âŠ¥ A)
    â†’ is-precategory A
strongly-segal-type-is-segal orth tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-retract Î›[2,1]-incl weird-horn-inclusion
        (mk-amap id section-weird section-weird-resp-horn)
        ((mk-amap id retract-weird retract-weird-resp-horn) ,
          (~refl , ((Î» (i , j) â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ auto!))
          , Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)))
        !
        (is-orthogonalâ‡”orthogonal-! .snd orth))
}
%```
}

\subtree[tot-0008]{
\title{Orthogonality from equivalence of postcomposition maps}
\taxon{Lemma}

\p{Given a map #{f} in the [coslice](stt-0062) #{p \to_X q}, postcomposition
at every map #{X \to Y} is an equivalence iff #{f} is left orthogonal to #{Y}.
}

%```agda
\agda{
coslice-orth-lemma
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
      {p : X â†’ A} {q : X â†’ B} (f : Coslice-map p q)
    â†’ (f .fst âŠ¥ Y)
    â‡” (âˆ€ (x : X â†’ Y) â†’ is-equiv (Coslice-map-postcompose x f))
coslice-orth-lemma {A = A}{B}{X}{Y}{p}{q} (f , H)
  = topâ‡”bot-is-equivâ†Arrow-equiv (amap (funextâ†’ H)) eq âˆ™â‡” fibrewiseâ‡”total-is-equiv where

  add-singleton : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q) (g : Q â†’ Y)
                  â†’ Î£[ x âˆ¶ (X â†’ Y) ] Î£[ f' âˆ¶ (Q â†’ Y) ] (f' âˆ˜ p ~ x)
  add-singleton f g = (g âˆ˜ f , g , ~refl)

  add-singleton-eq : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q)
                     â†’ quasi-iso (add-singleton p)
  add-singleton-eq p .fst (a , f , H) = f
  add-singleton-eq p .snd .fst x = refl
  add-singleton-eq p .snd .snd (a , f , H)
    = funext-rec
        (Î» H â†’ ((f âˆ˜ p) , (f , ~refl)) ï¼ (a , (f , H)))
        (Î» where refl â†’ refl)
        H

  amap : âˆ€ (H : f âˆ˜ p ï¼ q)
         â†’ Arrow-map (postcomp Y f)
                     (total-map (Î» a â†’ Coslice-map-postcompose a (f , happly H)))
  amap H .Arrow-map.top = add-singleton q
  amap H .Arrow-map.bot = add-singleton p
  amap refl .Arrow-map.comm x = refl

  eq : is-Arrow-equiv (amap (funextâ†’ H))
  eq .fst = is-equivâ†qiso (add-singleton-eq q)
  eq .snd = is-equivâ†qiso (add-singleton-eq p)

}
%```
}

\subtree[tot-0005]{
\taxon{Therem}
\title{Covariance of representable families}

\p{We show that a type #{A} is [strongly Segal](tot-0006) iff the family
#{\Hom(-,x)} is covariant for each #{x}.}

\proof{
We will show that every #{A_{/x} \to A} is a left fibration iff A is right
orthogonal to the map #{\Lambda^2_1 \to 1 \rtimes \Delta^1}.

\p{First we give an equivalence of arrows:}

\quiver{
\begin{tikzcd}
	{1\rtimes \Delta^1 \to_\bullet A} && {{A_{x/}}^{\Delta^1}} \\
	\\
	{\Lambda^2_1 \to_\bullet A} && {A^{\Delta^1} \times_A A_{x/}}
	\arrow["\sim", from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow["\sim"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{The top equivalence is given by the [join-coslice adjunction](tot-0001), and
the bottom via the universal property of the horn.}


\p{Now we use \ref{tot-0008} to finish the proof.}
}

\closedScope{
\subtree[tot-000A]{
\title{The bottom equivalence}
%```agda
\agda{
char-coslice-lift : âˆ€ {ğ“¤} {A : Type ğ“¤} x
      â†’ Arrow-map (Î» (_ : ğŸ™) â†’ i0) {C = Coslice A (Î» (_ : ğŸ™) â†’ x)} (fst) â†’
      Coslice-map {X = Î›[2,1]} (Î» _ â†’ Î¹â‚ i0) (Î» (_ : ğŸ™) â†’ x)
char-coslice-lift x (mk-amap top bot comm)
  = cogap (mk-cocone (top tt .snd tt .HomP.hom)
                     bot
                     (Î» c â†’ top tt .snd tt .HomP.hom1 âˆ™ sym (comm c)))
  , Î» _ â†’ HomP.hom0 (top tt .snd tt)

opaque
  char-coslice-lift-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} x
    â†’ is-equiv (char-coslice-lift {A = A} x)
  char-coslice-lift-is-equiv x = is-equivâ†qiso qiso where
    qiso : quasi-iso (char-coslice-lift x)
    qiso .fst (a , b) = mk-amap (Î» _ â†’ _ , (Î» _ â†’ mk-hom (a âˆ˜ Î¹â‚) (b tt) refl))
                                (a âˆ˜ Î¹â‚‚)
                                (ap a âˆ˜ sym âˆ˜ glue)
    qiso .snd .fst (mk-amap top bot comm)
      = let pth = ( top tt .snd tt .HomP.hom1
                  , Î» i â†’ ~refl , ((Square-degen-vert _ _ refl) , (Square-flatten-hor refl)))
        in Arrow-map-pathâ†’
          ( (Î» a â†’ Coslice-pathâ†’ pth)
          , (~refl , Î» _ â†’ ap (_âˆ™ ap fst (Coslice-pathâ†’ pth)) (ap-sym _ (glue tt) âˆ™ ap sym (pushout-rec-apÎ² tt))
                         âˆ™ ap (sym (HomP.hom1 (top tt .snd tt) âˆ™ sym (comm tt)) âˆ™_)
                              (Coslice-path-ap-fst pth)
                         âˆ™ ap (_âˆ™ top tt .snd tt .HomP.hom1) (âˆ™-symsym _ (sym (comm tt)))
                         âˆ™ âˆ™.cancell _  (âˆ™-sym' (HomP.hom1 (top tt .snd tt)))
                                        {f = sym (sym (comm tt))}
                         âˆ™ sym-sym ))
    qiso .snd .snd (a , p)
      = ext! ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
                      (Î» _ â†’ âˆ™-reflr _ âˆ™ sym (ap sym (ap-sym a _) âˆ™ sym-sym))
             , ~refl)
}
%```
}
}

%```agda
\agda{
coslice-is-leftâ‡”strongly-inner-coslice
  : âˆ€ {ğ“¤} {A : Type ğ“¤} x
  â†’ is-left-fibration {A = Coslice A (Î» (_ : ğŸ™) â†’ x)} fst
  â‡” (is-equiv (Coslice-map-postcompose (Î» (_ : ğŸ™) â†’ x) weird-horn-inclusionâˆ™))
coslice-is-leftâ‡”strongly-inner-coslice x
  = (orthogonalâ‡”pb-power-is-equiv â‡”â»Â¹)
  âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv amap amap-eq where
  amap : Arrow-map (pullback-power (Î» _ â†’ i0) (Î» r â†’ fst r))
                   (Coslice-map-postcompose (Î» _ â†’ x) weird-horn-inclusionâˆ™)
  amap .Arrow-map.top = joinâ†coslice-map (Î» _ â†’ x)
  amap .Arrow-map.bot = char-coslice-lift x
  amap .Arrow-map.comm f = ext!
    ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
          (Î» a â†’ ap (_âˆ™ refl) ( ap-âˆ˜ _ _ (glue a)
                              âˆ™ ap (ap (pushout-rec _)) (pushout-rec-apÎ² a)
                              âˆ™ pushout-rec-apÎ² _))
    , Î» _ â†’ âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _)

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = joinâ†coslice-map-is-equiv (Î» _ â†’ x)
  amap-eq .snd = char-coslice-lift-is-equiv x


hom-fam-is-covâ‡”is-strongly-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (âˆ€ x â†’ is-covariant (Î» a â†’ Hom A x a))
    â‡” is-strongly-segal A
hom-fam-is-covâ‡”is-strongly-segal {ğ“¤}{A}
  =  precomp-Î -â‡” (Î»
       x â†’  hom-fam-is-covâ‡”is-left-fibration x
         âˆ™â‡” coslice-is-leftâ‡”strongly-inner-coslice x)
  âˆ™â‡” logicalâ†equiv (postcomp-Î -â‰ƒ _ unit-UPâ‰ƒ)
  âˆ™â‡” (coslice-orth-lemma (weird-horn-inclusionâˆ™) â‡”â»Â¹)
  âˆ™â‡” logicalâ†equiv {ğ“¥ = ğ“˜ âŠ” ğ“¤} (unit-UPâ‰ƒ eâ»Â¹)
}
%```
}

\subtree[tot-000F]{
\taxon{Lemma}
\title{Precategories are strongly Segal}

\p{A [simplicial type]() is [segal]() iff it is [strongly Segal]().}

%```agda
\agda{

is-segal-equiv
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
    â†’ (f : A â†’ B) â†’ TypeÏ‰
is-segal-equiv f
  = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-precategory Q â†’ is-equiv (postcomp Q f)

is-segal-equiv-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {f : B â†’ C} {g : A â†’ B} â†’ is-segal-equiv f
    â†’ is-segal-equiv g â†’ is-segal-equiv (f âˆ˜ g)
is-segal-equiv-âˆ˜ sf sg qpc = is-equiv-âˆ˜ (sg qpc) (sf qpc)

â§…-degen-top : Type ğ“˜
â§…-degen-top = Pushout {A = Î”Â¹} {B = â§…} (Î¹â‚‚ âˆ˜ (_, i0)) !

â§…-â–¡-degen-incl : â§…-degen-top â†’ ğŸ™ â‹‰ Î”Â¹
â§…-â–¡-degen-incl = Pushoutâ‚
  (mk-span-map
    ((Î» a â†’ (a .snd , tt , a .fst)) âˆ˜ â§…-incl)
    (Î» i â†’ (Î´Î”Â¹-0 , tt , i))
    inl
    ~refl
    ~refl)


â§…-degenâ†Î”Â² : Î”Â² â†’ â§…-degen-top
â§…-degenâ†Î”Â² = Î¹â‚ âˆ˜ Î¹â‚‚

Î”Â²â†â§… : â§… â†’ Î”Â²
Î”Â²â†â§… = cogap (mk-cocone id id ~refl)

â§…-degenâ†Î”Â²-is-segal-equiv : is-segal-equiv â§…-degenâ†Î”Â²
â§…-degenâ†Î”Â²-is-segal-equiv {Q = Q} qpc
  = is-equivâ†Arrow-equiv {F = amap} {!!} tgt-map-is-equiv where
  tgt-map : Î£[ f âˆ¶ (Î”Â² â†’ Q)]
              Î£[ k âˆ¶ Hom Q (f ((i0 , i0) â¦ƒ â‰¤-refl â¦„)) (f ((i1 , i1) â¦ƒ â‰¤-refl â¦„)) ]
                (Î»hom (f âˆ˜ Î”Â²-diagonal) ~â–µ k)
          â†’ (Î”Â² â†’ Q)
  tgt-map = fst

  tgt-map-is-equiv : is-equiv tgt-map
  tgt-map-is-equiv = singleton-fst-is-equiv
                        (Î» f â†’ SingS-is-single â¦ƒ Hom-homotopy-IdS qpc â¦„
                               (Î»hom (f âˆ˜ Î”Â²-diagonal)))

  top-map : Î£ (Î”Â² â†’ Q)
          (Î» f â†’
             Î£ (Hom Q (f _) (f _))
             (Î» k â†’ Î»hom (f âˆ˜ Î”Â²-diagonal) ~â–µ k)) â†’
          â§…-degen-top â†’ Q
  top-map (f , g , H) = cogap
    (mk-cocone
      (cogap (mk-cocone (H .fst) f {!H .snd!}))
      (Î» _ â†’ f (i0 , i0)) {!ap Î¹â‚‚ (H .snd!})

  amap : Arrow-map tgt-map (postcomp Q â§…-degenâ†Î”Â²)
  amap .Arrow-map.top = top-map
  amap .Arrow-map.bot = id
  amap .Arrow-map.comm = ~refl




degen-squareâ†square : â–¡^ 2 â†’ ğŸ™ â‹‰ Î”Â¹
degen-squareâ†square (i , j) = Î¹â‚ (i , tt , j)

opaque
  coslice-as-pushout-lem
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“ } {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : B â†’ A) (f' : B â†’ A') (g : B â†’ C) â†’ (F : Coslice-map f f')
        {Q : Type ğ“ }
      â†’ (âˆ€ (q : C â†’ Q) â†’ is-equiv (Coslice-map-postcompose (q âˆ˜ g) F))
      â†’ is-equiv (postcomp Q (Pushoutâ‚ {S = mk-span _ f g}
                               (mk-span-map (F .fst) id id (F .snd) ~refl)))
  coslice-as-pushout-lem {A = A}{A'}{C = C} f f' g F {Q} coslice
    = is-equivâ†Arrow-equivâ»Â¹
        {F = amap}
        ( is-equiv-âˆ˜ (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv) Pushout-is-pushoutÏ‰
        , is-equiv-âˆ˜ (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv) Pushout-is-pushoutÏ‰)
        (is-total-equivâ†is-fibrewise-equiv
          Î» q â†’  is-equivâ†Arrow-equiv
                 {F = hom q}
                 ( is-total-equivâ†is-fibrewise-equiv
                     (Î» a â†’ is-equiv-âˆ˜ sym-is-equiv (is-equivâ»Â¹ global-funext))
                 , is-total-equivâ†is-fibrewise-equiv
                     (Î» a â†’ is-equiv-âˆ˜ sym-is-equiv (is-equivâ»Â¹ global-funext)))
                 (coslice q) ) where
    amap : Arrow-map (postcomp Q (Pushoutâ‚ {S = mk-span _ f g}
                               (mk-span-map (F .fst) id id (F .snd) ~refl)))
                     (Pullbackâ‚ {S = mk-cospan _  (postcomp Q g) (postcomp Q f')}
                                 {T = mk-cospan _ (postcomp Q g) (postcomp Q f)}
                       (mk-cospan-map id id (postcomp Q (F .fst))
                                      ~refl (Î» h â†’ funextâ†’ (ap h âˆ˜ sym âˆ˜ F .snd))))
    amap .Arrow-map.top = postcomp-coconeâ‰ƒpb ._â‰ƒ_.fwd âˆ˜ cocone-map _ pushout
    amap .Arrow-map.bot = postcomp-coconeâ‰ƒpb ._â‰ƒ_.fwd âˆ˜ cocone-map _ pushout
    amap .Arrow-map.comm a = pullback-pathâ†’
      ( refl
      , refl
      , sym (âˆ™-reflr _
        âˆ™ ap (funextâ†’)
          (funextâ†’ (Î» b â†’ ap sym (ap-âˆ˜ a _ (glue b)
                                 âˆ™ ap (ap a) (pushout-rec-apÎ² b
                                 âˆ™ ap (ap Î¹â‚ (F .snd b) âˆ™_) (âˆ™-reflr _)))))
          âˆ™ sym (ap (_âˆ™ funextâ†’ (ap (a âˆ˜ Î¹â‚) âˆ˜ sym âˆ˜ F .snd))
                    (ap-id (funextâ†’ (sym âˆ˜ ap a âˆ˜ glue)))
          âˆ™ sym (funext-âˆ™ (sym âˆ˜ ap a âˆ˜ glue) (ap (a âˆ˜ Î¹â‚) âˆ˜ sym âˆ˜ F .snd))
          âˆ™ ap funextâ†’ (funextâ†’ (Î» b
              â†’ ap (sym (ap a (glue b)) âˆ™_)
                   (ap-sym (a âˆ˜ Î¹â‚) (F .snd b) âˆ™ ap sym (ap-âˆ˜ a Î¹â‚ (F .snd b)))
                   âˆ™ sym (âˆ™-symsym (ap a (ap Î¹â‚ (F .snd b))) (ap a (glue b)))
                   âˆ™ ap sym (sym (ap-âˆ™ a (ap Î¹â‚ (F .snd b)) (glue b))))))))

    hom : âˆ€ (q : C â†’ Q)
          â†’ Arrow-map {A = Coslice-map f' (q âˆ˜ g)}
                      {B = Coslice-map f (q âˆ˜ g)}
                      (Coslice-map-postcompose (q âˆ˜ g) F)
                      {C = Î£[ x âˆ¶ (A' â†’ Q) ] (postcomp Q g q ï¼ postcomp Q f' x)}
                      {D = Î£[ x âˆ¶ (A â†’ Q) ] (postcomp Q g q ï¼ postcomp Q f x)}
                      (Î» G â†’
                          postcomp Q (F .fst) (G .fst)
                        , ap id (G .snd) âˆ™ funextâ†’ (ap (G .fst) âˆ˜ sym âˆ˜ F .snd))
    hom q .Arrow-map.top = total-map (Î» a â†’ sym âˆ˜ funextâ†’)
    hom q .Arrow-map.bot = total-map (Î» a â†’ sym âˆ˜ funextâ†’)
    hom q .Arrow-map.comm (x , p)
      = ext! (~refl , (sym (apâ‚‚ _âˆ™_
                             (ap-id (sym (funextâ†’ p)))
                             (ap funextâ†’ (funextâ†’ Î» b â†’ ap-sym x (F .snd b))
                               âˆ™ funext-sym _)
                      âˆ™ sym (âˆ™-symsym _ (funextâ†’ p))
                      âˆ™ ap sym (sym (funext-âˆ™ _ _)))))

â§…-â–¡-degen-incl'
  : Pushout {B = â§…} (Î¹â‚‚ âˆ˜ (_, i0)) ! â†’ Pushout {B = â–¡^ 2} (_, i0) !
â§…-â–¡-degen-incl'
  = Pushoutâ‚ (mk-span-map â§…-incl id id ~refl ~refl)

is-based-triangulated'
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’  â§…-incl âŠ¥ A â†’ â§…-â–¡-degen-incl' âŠ¥ A
is-based-triangulated' {A = A} ttA
  =  coslice-as-pushout-lem _ _ ! map (lem âˆ˜ ev tt)  where
  -- A map colim(â§… â† Î”Â¹ â†’ ğŸ™) â†’ colim(â–¡ â† Î”Â¹ â†’ ğŸ™)
  -- is equivalently a map in the coslice under Î”Â¹ from â§… â†’ â–¡
  map : Coslice-map {A = Î”Â¹} (Î¹â‚‚ âˆ˜ (_, i0)) (_, i0)
  map .fst = â§…-incl
  map .snd = ~refl

  lem : âˆ€ x â†’ is-equiv (Coslice-map-postcompose (Î» _ â†’ x) map)
  lem x = coslice-orth-lemma map .fst ttA (Î» _ â†’ x)

opaque
  is-based-triangulated
    : âˆ€ {ğ“¤} {A : Type ğ“¤}
      â†’  â§…-incl âŠ¥ A â†’ â§…-â–¡-degen-incl âŠ¥ A
  is-based-triangulated {A = A} ttA
    = is-equiv~âˆ˜ (Î» g â†’ funextâ†’ Î» aÂ â†’ ap g (sym (H a)))
                 btta' (postcomp-equiv (is-equivâ†qiso test-is-eqv))  where
    btta' : â§…-â–¡-degen-incl' âŠ¥ A
    btta' = is-based-triangulated' ttA

    test : Pushout {B = â–¡^ 2} (_, i0) ! â†’ ğŸ™ â‹‰ Î”Â¹
    test = Pushoutâ‚
      (mk-span-map
        (Î» (i , j) â†’ (j , tt , i))
        (Î» i â†’ Î´Î”Â¹-0 , tt , i)
        inl
        ~refl
        ~refl)

    H : test âˆ˜ â§…-â–¡-degen-incl' ~ â§…-â–¡-degen-incl
    H = pushout-ind _
      (mk-coconeD
        ~refl ~refl
        (Î» i â†’ IdP-funcâ†Square (glue i) refl refl
                 (Square-degen-hor _ _
                   (sym (pushout-rec-apÎ² i
                    âˆ™ âˆ™-reflr _
                    âˆ™ sym (ap-âˆ˜ test â§…-â–¡-degen-incl' (glue i)
                          âˆ™ ap (ap test) (pushout-rec-apÎ² i âˆ™ âˆ™-reflr _)
                          âˆ™ pushout-rec-apÎ² _
                          âˆ™ âˆ™-reflr _))))))

    test-is-eqv : quasi-iso test
    test-is-eqv .fst = â†‘-rec (mk-right-cocone Î¹â‚‚ (Î¹â‚ âˆ˜ (_, i1))
                               Î» where (_ , i) â†’ mk-hom (Î¹â‚ âˆ˜ (i ,_))
                                                        (glue i)
                                                        refl)
    test-is-eqv .snd .fst = pushout-ind _
      (mk-coconeD ~refl ~refl
        (Î» i â†’ IdP-funcâ†Square
                   {f = (test-is-eqv .fst âˆ˜ test)} {id} (glue i) refl refl
                   (Square-degen-hor _ _
                     (ap-âˆ˜ (test-is-eqv .fst) test (glue i)
                     âˆ™ ap (ap (test-is-eqv .fst)) (pushout-rec-apÎ² _ âˆ™ âˆ™-reflr _)
                     âˆ™ pushout-rec-apÎ² _ âˆ™ sym (ap-id (glue i))))))
    test-is-eqv .snd .snd = pushout-ind _
      (mk-coconeD ~refl (âŠ-ind (~refl , (Î» i â†’ glue (Î´Î”Â¹-1 , tt , i))))
        Î» where (mk-lift true , _ , i)
                  â†’ IdP-funcâ†Square (glue (Î´Î”Â¹-1 , tt , i)) refl (glue (Î´Î”Â¹-1 , tt , i))
                      (coe
                        (Square-functorial-bot (sym (ap-id (glue (Î´Î”Â¹-1 , _ , i)))))
                        (Square-flatten-vert (sym (ap-âˆ˜ test (test-is-eqv .fst) (glue _)
                        âˆ™ ap (ap test) (pushout-rec-apÎ² _)))))
                (mk-lift false , _ , i)
                  â†’ IdP-funcâ†Square (glue (Î´Î”Â¹-0 , tt , i)) refl refl
                      (Square-degen-hor _ _
                        (ap-âˆ˜ test (test-is-eqv .fst) (glue (Î´Î”Â¹-0 , tt , i))
                        âˆ™ ap (ap test) (pushout-rec-apÎ² _) âˆ™ pushout-rec-apÎ² _
                        âˆ™ âˆ™-reflr _ âˆ™ sym (ap-id (glue _)))))

is-strongly-segalâ†is-precategory
  : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-simplicial A â†’ is-precategory A
    â†’ is-strongly-segal A
is-strongly-segalâ†is-precategory {A = A} asimp apc tt
  = is-equiv~âˆ˜ H
      (is-equiv-âˆ˜ (apc tt) (â§…-degenâ†Î”Â²-is-segal-equiv apc))
      (is-based-triangulated (simp-is-triangulated asimp tt)) where
  H : postcomp A weird-horn-inclusion ~
      (postcomp A Î›[2,1]-incl âˆ˜ postcomp A â§…-degenâ†Î”Â²) âˆ˜
      postcomp A â§…-â–¡-degen-incl
  H f = ap (f âˆ˜_) (funextâ†’ (sym âˆ˜ pushout-rec-unique _ _ {!!} {!!} {!!}))


}
%```
}
