\date{2025-11-24}
\title{Covariant families}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Covariant
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Core.Orthogonal
open import Core.Arrow
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
}
%```



\subtree[stt-00AY]{
\taxon{definition}
\title{Covariant families}

%```agda
\agda{
is-left : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-left = is-local (Î» (_ _ : ğŸ™) â†’ i0)

is-groupoid : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
is-groupoid = is-null (Î» (_ : ğŸ™) â†’ Î”Â¹)

module Grpd where
  Grpd-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
  Grpd-SubU = Null-SubU (Î» (_ : ğŸ™) â†’ Î”Â¹) _

  Grpd-GSU : GSU (_âŠ” ğ“˜)
  Grpd-GSU = Null-GSU (Î» (_ : ğŸ™) â†’ Î”Â¹)

  Grpd-is-globally-reflective
    : is-globally-reflective Grpd-GSU
  Grpd-is-globally-reflective = Null-globally-reflective

  open GRSUInduction Grpd-is-globally-reflective
                     Null-globally-Î£-closed public

  open GSU Grpd-GSU public renaming (S-equiv to is-simplicialâ†equiv)

  open GPiClosure Grpd-is-globally-reflective public

  open is-globally-reflective Grpd-is-globally-reflective

  Î£-is-groupoid = Null-globally-Î£-closed

is-groupoidâ†is-left : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-left A â†’ is-groupoid A
is-groupoidâ†is-left {_}{A} il x
  = is-equiv~âˆ˜ lem (is-equivâ»Â¹ (il x))
                   unit-const-is-equiv where
  open is-equiv (il x)

  lem : const A Î”Â¹ ~ bwd âˆ˜ const A ğŸ™
  lem = il x â—‚eqv ((Îµ â–¸ const A ğŸ™) ~â»Â¹)


is-leftâ†is-groupoid : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-groupoid A â†’ is-left A
is-leftâ†is-groupoid {_} {A} gp x
  =  is-equiv~âˆ˜ H unit-const-is-equiv (is-equivâ»Â¹ (gp x)) where
  open is-equiv (gp x)

  H : postcomp A (Î» (_ : ğŸ™) â†’ i0) ~ const A ğŸ™ âˆ˜ bwd
  H = ((const A ğŸ™ â—‚ Î·) ~â»Â¹) â–¸eqv (gp x)


is-covariant : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
               â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-covariant {A = A} B
    = âˆ€ (x : Î”Â¹ â†’ A) (xâ‚€ : B (x i0))
      â†’ is-singleton (Î£[ xâ‚ âˆ¶ B (x i1)] HomP (B âˆ˜ x) xâ‚€ xâ‚)

tr-cov : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
       â†’ is-covariant P â†’ (h : Î”Â¹ â†’ A) â†’ P (h i0) â†’ P (h i1)
tr-cov cov h = fst âˆ˜ centre âˆ˜ cov h
}
%```
}


\subtree[stt-00AV]{
\title{Left fibrations}
\taxon{Definition}

%```agda
\agda{
is-left-fibration : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B)
                    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“˜)
is-left-fibration f = (Î» (_ : ğŸ™) â†’ i0) âŠ¥ f
}
%```
}


\subtree[stt-00AW]{
\taxon{lemma}

\p{Given some family #{B : A \to \UU}, an arrow #{f} in #{A} and a point over the
base #{x_0 : B(f(0))}, the type of dependent homs over #{f} based an #{x_0} is
equivalent to the type of lifts of the following square:}


\quiver{
\begin{tikzcd}
	1 && {\tilde{B}} \\
	\\
	{\Delta^1} && A
	\arrow["{x_0}", from=1-1, to=1-3]
	\arrow["0"', from=1-1, to=3-1]
	\arrow["\pi", from=1-3, to=3-3]
	\arrow["f"', from=3-1, to=3-3]
\end{tikzcd}
}


%```agda
\agda{
lifts-of-based-arrow : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
          (f : Î”Â¹ â†’ A) (xâ‚€ : B (f i0))
        â†’ let F = mk-amap {f = Î» (_ : ğŸ™) â†’ i0} {f' = fst {B = B}}
                          (Î» _ â†’ f i0 , xâ‚€) f ~refl
        in Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€)
        â‰ƒ Lift F
lifts-of-based-arrow {A = A} {B} f xâ‚€ = eqv where
  F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
  F = mk-amap (Î» _ â†’ f i0 , xâ‚€) f ~refl

  open Arrow-map F
  open HomP
}
%```

\closedScope{
\subtree[stt-00AX]{
\title{Details}
%```agda
\agda{
  by-contracting-singletons : (Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
            ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚)))
          â‰… (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
  by-contracting-singletons ._â‰…_.fwd (_ , h , p , refl) = (h , p)
  by-contracting-singletons ._â‰…_.fwd-iso .fst (h , p) = (h i1 , h , p , refl)
  by-contracting-singletons ._â‰…_.fwd-iso .snd .fst (_ , h , p , refl) = refl
  by-contracting-singletons ._â‰…_.fwd-iso .snd .snd = ~refl

  because-pi-types-are-extensions
    : (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
       â‰ƒ
      (Î£[ (f , p) âˆ¶ fibre (precomp Î”Â¹ (Î» r â†’ fst r)) f ]
       (tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€))
  because-pi-types-are-extensions
    = Î£-ap-â‰ƒ-fst
        {B = Î» where (f , p) â†’ tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€}
        (mkâ‰ƒ (extensionâ†Î  {B = B} f) (extensionâ†Î -is-equiv f))

  by-funext
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ï¼ f) ]
          (tr B (happly H i0) (snd (f' i0)) ï¼ xâ‚€)
    â‰ƒ Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
  by-funext
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ-fst
                {B = Î» H â†’ tr B (H i0) (snd (f' i0)) ï¼ xâ‚€}
                funextâ‰ƒ)

  inserting-singleton
    :   Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
     â‰ƒ  Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
          (K1 ï¼ H i0)
  inserting-singleton
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» H â†’ Î£-singl
                  {B = Î» (K , _) â†’ tr B K (snd (f' i0)) ï¼ xâ‚€ }
                  Sing-is-singleton
                  (H i0 , refl) eâ»Â¹
                âˆ™â‰ƒ Î£-assoc âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ Ã—-swap âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» _ â†’ symâ‰ƒ) )))

  by-characterising-Î£-path
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
      â‰ƒ
        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
           (K1 ï¼ H i0)
  by-characterising-Î£-path
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» H â†’ Î£-ap-â‰ƒ-fst
                {B = Î» (K , _) â†’ K ï¼ H i0}
                (  Î£-path {x = f' i0} {y = _ , xâ‚€} eâ»Â¹)
                âˆ™â‰ƒ Î£-assoc))


  by-UP-of-unit
    :  Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
        Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
      â‰ƒ
       Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
  by-UP-of-unit
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
                (Î» H â†’ Î£-ap-â‰ƒ-fst {B = Î» K â†’ ap fst K ï¼ H i0} (unit-UPâ‰ƒ) eâ»Â¹
                       âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» K â†’ unit-UPâ‰ƒ eâ»Â¹))
               âˆ™â‰ƒ Î£-comm)

  postcomposing-reflr-is-equiv
    : Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
      â‰ƒ
      Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
         Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0) ~âˆ™ ~refl )
  postcomposing-reflr-is-equiv
    = Î£-ap-â‰ƒ
       (Î» f' â†’ Î£-ap-â‰ƒ
         (Î» K â†’ Î£-ap-â‰ƒ (Î» H â†’ ~reflrâ‰ƒ {f = const _ _ (f i0)} _ _)))
}
%```
}
}

\proof{
%```agda
\agda{
  opaque
    eqv : Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒ Lift F
    eqv
      = Î£ (B (f i1)) (HomP (B âˆ˜ f) xâ‚€) â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» _ â†’ HomP-reprâ‰ƒ) âŸ©

        Î£[ xâ‚ âˆ¶  (B (f i1)) ] Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)]
          ((h i0 ï¼ xâ‚€) Ã— (h i1 ï¼ xâ‚))
                                       â‰ƒâŸ¨ equivâ†qiso by-contracting-singletons âŸ©

        (Î£[ h âˆ¶ Î  Î”Â¹ (B âˆ˜ f)] (h i0 ï¼ xâ‚€))
                                       â‰ƒâŸ¨ because-pi-types-are-extensions âŸ©

        (Î£[ (f , p) âˆ¶ fibre (precomp Î”Â¹ (Î» r â†’ fst r)) f ]
         (tr B (happly p i0) (snd (f i0)) ï¼ xâ‚€))
                                       â‰ƒâŸ¨ Î£-assoc âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ï¼ f) ]
            (tr B (happly H i0) (snd (f' i0)) ï¼ xâ‚€)
                                       â‰ƒâŸ¨ by-funext âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
            (tr B (H i0) (snd (f' i0)) ï¼ xâ‚€)
                                       â‰ƒâŸ¨ inserting-singleton âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K1 âˆ¶ fst (f' i0) ï¼ _ ] Î£[ K2 âˆ¶ IdP (ap B K1) (snd (f' i0)) xâ‚€ ]
            (K1 ï¼ H i0)
                                       â‰ƒâŸ¨ by-characterising-Î£-path eâ»Â¹ âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ]
          Î£[ K âˆ¶ f' i0 ï¼ (_ , xâ‚€) ] (ap fst K ï¼ H i0)
                                       â‰ƒâŸ¨ by-UP-of-unit âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
           Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0))
                                       â‰ƒâŸ¨ postcomposing-reflr-is-equiv âŸ©

        Î£[ f' âˆ¶ (Î”Â¹ â†’ Î£ A B) ] Î£[ K âˆ¶ f' âˆ˜ const _ _ i0 ~ const _ _ (_ , xâ‚€) ]
           Î£[ H âˆ¶ (fst âˆ˜ f' ~ f) ] (fst â—‚ K ~ (H â–¸ const _ _ i0) ~âˆ™ ~refl )
                                       â‰ƒâŸ¨ Lift-reprâ‰ƒ F eâ»Â¹ âŸ©

        Lift F                         â‰ƒâˆ
}
%```
}
}

\subtree[stt-00AR]{
\title{Covariant families straighten to left fibrations}
\taxon{Corollary}

\p{We show that some family #{P : A \to \UU} is [covariant](stt-00AO) iff the map
#{\pi : \tilde{P} \to A} is a [left fibration](stt-00AV).}

%```agda
\agda{
is-covariantâ‡”is-left-fibration
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
    â†’ is-covariant B â‡” is-left-fibration (fst {B = B})
is-covariantâ‡”is-left-fibration {A = A} B
  = (fwd , bwd) where
  opaque
    arrow-map-snd : (F : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B}))
                    â†’ B (F .Arrow-map.bot i0)
    arrow-map-snd (mk-amap top bot comm) = tr B (sym (comm tt)) (top tt .snd)

    Î£â†arrow-map : Arrow-map (Î» (_ : ğŸ™) â†’ i0) (fst {B = B})
                â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (B (f i0))
    Î£â†arrow-map F = F .bot , arrow-map-snd F where open Arrow-map

    fwd : is-covariant B â†’ is-left-fibration (fst {B = B})
    fwd cov a@(mk-amap top bot comm)
      = is-singleâ†equiv-to-single
          ( lifts-of-based-arrow bot (tr B (sym (comm tt)) (snd (top tt)))
          âˆ™â‰ƒ coeâ‰ƒ (ap Lift
              (Arrow-map-pathâ†’
                ((Î» aâ‚ â†’ Î£-pathâ†’ ((comm tt)
                                 , trâˆ™tr-sym' (comm tt) (snd (top tt))))
                , (~refl , (Î» _ â†’ Î£-path-ap-fst))))))
          (cov bot (arrow-map-snd a))

    bwd : is-left-fibration (fst {B = B}) â†’ is-covariant B
    bwd lfib f xâ‚€ = is-singleâ†equiv-to-single
         (lifts-of-based-arrow f xâ‚€  eâ»Â¹)
         (lfib (mk-amap (Î» _ â†’ (f i0 , xâ‚€)) f ~refl))
}
%```
}

\subtree[stt-00AS]{
\title{There is a universe of amazingly covariant types}
\taxon{Cosntruction}

\p{Assuming that the interval is [tiny](Synthetic.Tiny), there is a universe of
\em{amazingly covariant types}, which weakly classify the left fibrations.
We denote it #{\mathcal{s}}.}

\proof{
\p{Since being covariant is equivalent to being a left fibration, it is stable
under base change, and so is a [relative notion of fibrancy](stt-00AO). By the machinery
developed for [amazing right adjoints](stt-00AA) we can construct a universe.
}
}

%```agda
\agda{
module UCov where
  open import Synthetic.Tiny Î”Â¹

  is-covariant-is-relative : is-relative is-covariant
  is-covariant-is-relative {A = A} P = (fwd , bwd) where
    fwd : is-covariant P â†’ (x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)
    fwd cov f h = cov (f âˆ˜ h)

    bwd : ((x : Î”Â¹ â†’ A) â†’ is-covariant (P âˆ˜ x)) â†’ is-covariant P
    bwd cov h xâ‚€ = cov h id xâ‚€

  open AFib is-covariant is-covariant-is-relative public
    renaming (is-afib to is-acov;
              UFib to ğ“¢;
              UFibâˆ™ to ğ“¢âˆ™;
              F-Ï€-is-fib to ğ“¢-Ï€-is-covariant)
}
%```
}

\subtree[stt-00AU]{
\title{The objects of #{\mathcal{S}} are groupoids}
\taxon{Theorem}

\p{If #{A :^\flat \UU} is a groupoid, then #{A} is amazing covariant and so
factors through #{\mathcal{S}}.}

%```agda
\agda{
  groupoids-in-ğ“¢ : âˆ€ {@â™­ ğ“¤} (@â™­ A : Type ğ“¤) â†’ @â™­ is-groupoid A â†’ is-acov A
  groupoids-in-ğ“¢ A gpd
    = Îµâ™­ (liftFib .fst
           (modâ™­ (is-covariantâ‡”is-left-fibration
                   (Î» _ â†’ A) .snd
                     (is-orthogonalâ‡”orthogonal-! .snd
                       (is-leftâ†is-groupoid
                         (Null-globally-Î£-closed
                           (Grpd.ğŸ™âˆˆS)
                           (Î» _ â†’ gpd)) tt))))) tt
}
%```
}


\subtree[stt-00AT]{
\title{#{\mathcal{S}} is directed univalent}
\taxon{Theorem}

\p{We show that #{\mathcal{S}} is directed univalent. That is, arrows in
#{\mathcal{S}} correspond exactly to pairs of groupoids, together with a function
between them.}

%```agda
\agda{
  tr-ğ“¢ : âˆ€ {@â™­ ğ“¤} â†’ (f : Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ fst (f i0) â†’ fst (f i1)
  tr-ğ“¢ = tr-cov {P = fst} ğ“¢-Ï€-is-covariant

  duaâ†’ : âˆ€ {@â™­ ğ“¤} â†’ (Î”Â¹ â†’ ğ“¢ ğ“¤) â†’ Î£[ A âˆ¶ ğ“¢ ğ“¤ ] Î£[ B âˆ¶ ğ“¢ ğ“¤ ] (fst A â†’ fst B)
  duaâ†’ h = (h i0 , h i1 , tr-ğ“¢ h)
}
%```
}
