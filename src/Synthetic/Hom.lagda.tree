\date{2025-09-11}
\title{Synthetic Hom Types}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
open import Foundations.Prelude

module Synthetic.Hom {ğ“˜} (I : Type ğ“˜) (i0 i1 : I) where

open import Foundations.IdentitySystem

open import Ergonomics.Representation
open import Ergonomics.Extensionality
}
%```

\subtree[stt-00A9]{
\title{Hom types}
\taxon{Definition}

\p{For any bi-pointed type #{I}, we can define the type of synthetic
homomorphisms, which are just (possibly-dependent) functions with specified
end-points.}

\remark{
\p{In this generality, there is not a lot of motivation to call these types
\strong{hom} types. They admit identity homs, but in general not composition.
The idea is that this module will be instantiated with an interval for which
certain types have a notion of fibrancy, and for those fibrant types, the hom
type will deserve it's name.}
}

%```agda
\agda{
record HomP {ğ“¤} (A : I â†’ Type ğ“¤) (a : A i0) (b : A i1) : Type (ğ“¤ âŠ” ğ“˜) where
  constructor mk-hom
  field
    hom  : Î  I A
    hom0 : hom i0 ï¼ a
    hom1 : hom i1 ï¼ b


unquoteDecl HomP-reprâ‰… HomP-reprâ‰ƒ
  = make-record-repr HomP-reprâ‰… HomP-reprâ‰ƒ (quote HomP)

Î»hom : âˆ€ {ğ“¤} {A : I â†’ Type ğ“¤} (f : Î  I A) â†’ HomP A (f i0) (f i1)
Î»hom f = mk-hom f refl refl

Hom : âˆ€ {ğ“¤} (A : Type ğ“¤) (a b : A) â†’ Type (ğ“¤ âŠ” ğ“˜)
Hom A a b = HomP (Î» _ â†’ A) a b

{-# NOINLINE Hom #-}

idH : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ (a : A) â†’ Hom A a a
idH a = Î»hom Î» _ â†’ a


0â‰¤1 : Hom I i0 i1
0â‰¤1 .HomP.hom = id
0â‰¤1 .HomP.hom0 = refl
0â‰¤1 .HomP.hom1 = refl
}
%```

\remark{
\p{Unlike in [Cubical Agda](https://agda.readthedocs.io/en/latest/language/cubical.html)
or the [Rzk proof assistant](https://rzk-lang.github.io/rzk/en/latest/),
these hom types do not require their endpoints to be definitionally equal, but only
equal up to a path. It is possible to simulate the \em{definitional} path types
with an indexed-inductive type but this pushes Agda's elaboration beyond what it
is really designed for, and the usability suffers.
}

}
}

\subtree[stt-00AN]{
\title{Extensionality for homs}
\taxon{Theorem}

\p{A homorphism #{\Hom_A(x,y)} constist of the data of a map #{C^{\Delta^2}}
together with a pair of identifications. To define a path in #{\Hom_A(x,y)}
between #{f} and #{g}, we need a homotopy #{H} of the underlying maps, but also
coherence data: #{H_{0} \sim g_0 \sim f_0} for #{i = 0,1}.}

%```agda
\agda{
Hom-path : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (f g : Hom A x y)
           â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom-path (mk-hom f p q) (mk-hom g r s)
  = Î£[ H âˆ¶ f ~ g ] ((H i0 âˆ™ r ï¼ p) Ã— (H i1 âˆ™ s ï¼ q))

opaque
  Hom-path-is-torsorial : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (f : Hom A x y)
                       â†’ is-singleton (Î£[ g âˆ¶ Hom A x y ] Hom-path f g)
  Hom-path-is-torsorial f
    = is-singleâ†equiv-to-single (Î£-ap-â‰ƒ-fst (HomP-reprâ‰ƒ eâ»Â¹))
        (is-singleton-structureâ†parts
          (SingS-is-single (f .HomP.hom))
          (f .HomP.hom , ~refl)
          (is-singleton-structureâ†parts
            Sing'-is-singleton
            (_ , refl)
            Sing'-is-singleton))

Hom-path-refl
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y} {f : Hom A x y} â†’ Hom-path f f
Hom-path-refl = (~refl , refl , refl)

instance
  IdS-Hom : âˆ€ {ğ“¤}{A : Type ğ“¤} {x y : A} â†’ Identity-system (Hom A x y) (ğ“˜ âŠ” ğ“¤)
  IdS-Hom .Identity-system.IdS = Hom-path
  IdS-Hom .Identity-system.IdSâ†Id refl = Hom-path-refl
  IdS-Hom .Identity-system.has-is-ids f
    = fundamental-Id (Hom-path f) (Hom-path-is-torsorial f) _


Hom-extâ†’ : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} {f g : Hom A x y}
          â†’ Hom-path f g â†’ f ï¼ g
Hom-extâ†’ = ext!

adjust-hom : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y x' y'} (p : x ï¼ x') (q : y ï¼ y')
             â†’ Hom A x y â†’ Hom A x' y'
adjust-hom p q (mk-hom fh f0 f1) = mk-hom fh (f0 âˆ™ p) (f1 âˆ™ q)

adjust-hom-is-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y x' y' : A} (p : x ï¼ x') (q : y ï¼ y')
  â†’ is-equiv (adjust-hom p q)
adjust-hom-is-equiv refl refl
  = homotopy-is-equiv (Î» _ â†’ Hom-extâ†’ (~refl , âˆ™-reflr _ , âˆ™-reflr _))
                      id-is-equiv

Hom-pathP
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z w : A} (p : x ï¼ z) (q : y ï¼ w)
      (f : Hom A x y) (g : Hom A z w) â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom-pathP p q (mk-hom f f0 f1) (mk-hom g g0 g1)
  = Î£[ H âˆ¶ (f ~ g) ] (Square (H i0) p f0 g0 Ã— Square (H i1) q f1 g1)

Hom-pathâ†pathP
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y  : A}
      {f g : Hom A x y} â†’ Hom-pathP refl refl f g â†’ Hom-path f g
Hom-pathâ†pathP (H , K , R)
  = (H , un-square K âˆ™ âˆ™-reflr _ , un-square R âˆ™ âˆ™-reflr _)

Hom-pathPâ†path
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y  : A}
      {f g : Hom A x y} â†’ Hom-path f g â†’ Hom-pathP refl refl f g
Hom-pathPâ†path (H , K , R)
  = (H , mk-square (K âˆ™ sym (âˆ™-reflr _)) , mk-square (R âˆ™ sym (âˆ™-reflr _)))

Hom-pathPâ‰…path
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y  : A}
      {f g : Hom A x y} â†’ Hom-path f g â‰… Hom-pathP refl refl f g
Hom-pathPâ‰…path ._â‰…_.fwd = Hom-pathPâ†path
Hom-pathPâ‰…path ._â‰…_.fwd-iso .fst = Hom-pathâ†pathP
Hom-pathPâ‰…path ._â‰…_.fwd-iso .snd .fst (H , p , q)
  = Î£-pathâ†’ (refl , Ã—-pathâ†’
      ( ap (_âˆ™ âˆ™-reflr _) (un-mk-square (p âˆ™ sym (âˆ™-reflr _)))
        âˆ™ (âˆ™-assoc p _ _) âˆ™ ap (p âˆ™_) (âˆ™-sym' (âˆ™-reflr _)) âˆ™ âˆ™-reflr _
      , ap (_âˆ™ âˆ™-reflr _) (un-mk-square (q âˆ™ sym (âˆ™-reflr _)))
        âˆ™ (âˆ™-assoc q _ _) âˆ™ ap (q âˆ™_) (âˆ™-sym' (âˆ™-reflr _)) âˆ™ âˆ™-reflr _))
Hom-pathPâ‰…path ._â‰…_.fwd-iso .snd .snd (J , p , q)
  = Î£-pathâ†’ (refl , Ã—-pathâ†’
     ( ap mk-square (âˆ™-assoc (un-square p) _ _
       âˆ™ ap (un-square p âˆ™_) (âˆ™-sym (âˆ™-reflr _)) âˆ™ âˆ™-reflr _) âˆ™ mk-un-square p
     , ap mk-square (âˆ™-assoc (un-square q) _ _
       âˆ™ ap (un-square q âˆ™_) (âˆ™-sym (âˆ™-reflr _)) âˆ™ âˆ™-reflr _) âˆ™ mk-un-square q))

Hom-pathPâ‰ƒpath
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y  : A}
      {f g : Hom A x y} â†’ Hom-path f g â‰ƒ Hom-pathP refl refl f g
Hom-pathPâ‰ƒpath = equivâ†qiso Hom-pathPâ‰…path

Hom-pathP-is-torsorial
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A}
      {f : Hom A x y} â†’ is-singleton (Î£ _ (Hom-pathP refl refl f))
Hom-pathP-is-torsorial
  = is-singleâ†equiv-to-single (Î£-ap-â‰ƒ (Î» _ â†’ Hom-pathPâ‰ƒpath))
      (Hom-path-is-torsorial _)

Hom-pathP-refl
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} {f : Hom A x y} â†’ Hom-pathP refl refl f f
Hom-pathP-refl = Hom-pathPâ†path Hom-path-refl

Hom-extPâ†’
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z w : A} (p : x ï¼ z) (q : y ï¼ w)
    â†’ {f : Hom A x y} {g : Hom A z w}
    â†’ Hom-pathP p q f g â†’ IdP (apâ‚‚ (Hom A) p q) f g
Hom-extPâ†’ refl refl = Hom-extâ†’ âˆ˜ Hom-pathâ†pathP

Hom-IdSP
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A}
    â†’ Identity-system (Hom A x y) (ğ“˜ âŠ” ğ“¤)
Hom-IdSP .Identity-system.IdS = Hom-pathP refl refl
Hom-IdSP .Identity-system.IdSâ†Id refl = Hom-pathP-refl
Hom-IdSP .Identity-system.has-is-ids a
  = fundamental-Id _ Hom-pathP-is-torsorial _
}
%```
}

\subtree[stt-00CE]{
\title{Functions are functors}

%```agda
\agda{
ap-hom : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) {x y}
       â†’ Hom A x y â†’ Hom B (f x) (f y)
ap-hom f (mk-hom hom hom0 hom1) = mk-hom (f âˆ˜ hom) (ap f hom0) (ap f hom1)
}
%```
}
