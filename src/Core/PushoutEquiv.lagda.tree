\date{2025-07-30}
\title{Pushouts of equivalent types}
\taxon{module}
\meta{module}{Core.PushoutEquiv}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
module Core.PushoutEquiv where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Postwhisker
open import Core.Arrow
open import Core.CocartesianSquare

open import Ergonomics.Extensionality
}
%```

\subtree[stt-009C]{
\title{Pushouts of homotopic maps are equivalent}
\taxon{lemma}
\date{2025-08}

\p{Given a diagram as follows (with homotopies #{H : f \sim f'} and
#{K : g \sim g'} witnessing the commutativity): }

\quiver{
\begin{tikzcd}
	&& {S'} \\
	A && S && B
	\arrow["{f'}"', from=1-3, to=2-1]
	\arrow[equals, from=1-3, to=2-3]
	\arrow["{g'}", from=1-3, to=2-5]
	\arrow["f", from=2-3, to=2-1]
	\arrow["g"', from=2-3, to=2-5]
\end{tikzcd}
}

\p{
We have that a cocone is a pushout of #{S} iff it is a pushout of
#{S'}.
}


\proof{
\p{We first note that cocones over #{S} are equivalent to cocones over
#{S'}. Then the statement follows by applying the 3-for-2 property
on the following diagram:}

\quiver{
\begin{tikzcd}
	{X^Q} && {\rm{cocone}(S',Q)} \\
	\\
	& {\rm{cocone}(S,Q)}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-2]
	\arrow["\sim"', from=3-2, to=1-3]
\end{tikzcd}
}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         {f f' : A â†’ B} {g g' : A â†’ C} (H : f ~ f') (K : g ~ g')
         where
  private
    S = mk-span _ f g
    S' = mk-span _ f' g'

  open Span

  Coconeâ‰ƒâ†homotopy : âˆ€ {ğ“ } {Q : Type ğ“ } â†’ Cocone S Q â‰ƒ Cocone S' Q
  Coconeâ‰ƒâ†homotopy {_} {Q}
    = Cocone S _  â‰ƒâŸ¨ cocone-reprâ‰ƒ âŸ©
      (Î£[ p âˆ¶ (B â†’ Q)] Î£[ q âˆ¶ (C â†’ Q)] (p âˆ˜ f ~ q âˆ˜ g))
                  â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ mkâ‰ƒ _
                      (is-equiv-âˆ˜ (~âˆ™-is-equiv (p â—‚ (H ~â»Â¹)))
                      (~âˆ™-is-equiv' (q â—‚ K))))) âŸ©
      ((Î£[ p âˆ¶ (B â†’ Q)] Î£[ q âˆ¶ (C â†’ Q)] (p âˆ˜ f' ~ q âˆ˜ g')))
                  â‰ƒâŸ¨ cocone-reprâ‰ƒ eâ»Â¹ âŸ©
      Cocone S' _ â‰ƒâˆ

  Cocone-mapâ†homotopy : âˆ€ {ğ“ } {Q : Type ğ“ } â†’ Cocone S Q â†’ Cocone S' Q
  Cocone-mapâ†homotopy cc = mk-cocone p q ((p â—‚ (H ~â»Â¹)) ~âˆ™ filler ~âˆ™ q â—‚ K)
    where open Cocone cc


  is-pushoutâ†homotopy
    : âˆ€ {ğ“œ} {X : Type ğ“œ} (cc : Cocone S X)
      â†’ is-pushoutÏ‰ S cc â†’ is-pushoutÏ‰ S' (Cocone-mapâ†homotopy cc)
  is-pushoutâ†homotopy cc po {ğ“ }{Q}
    = is-equiv~âˆ˜ comm
                 (Coconeâ‰ƒâ†homotopy ._â‰ƒ_.has-is-eqv)
                 (po {ğ“ }{Q}) where
    comm : cocone-map S' (Cocone-mapâ†homotopy cc) ~
            Cocone-mapâ†homotopy âˆ˜ cocone-map S cc
    comm f = Cocone-pathâ†’ _ _ refl refl (
      Cocone.filler (cocone-map S' (Cocone-mapâ†homotopy cc) f) ~âˆ™ ~refl
                  ~âŸ¨ ~âˆ™-reflr _ âŸ©
      Cocone.filler (cocone-map S' (Cocone-mapâ†homotopy cc) f)
                  ~âŸ¨âŸ©
      f â—‚ ((p â—‚ (H ~â»Â¹)) ~âˆ™ filler ~âˆ™ q â—‚ K)
                  ~âŸ¨ â—‚âˆ™âˆ™ f (p â—‚ (H ~â»Â¹)) filler (q â—‚ K) âŸ©
      (f â—‚ (p â—‚ (H ~â»Â¹))) ~âˆ™ f â—‚ filler ~âˆ™ f â—‚ q â—‚ K
                  ~âŸ¨ (â—‚âˆ˜ f p (H ~â»Â¹) ~â»Â¹) âŸ©~âˆ™âŸ¨ ~refl âŸ©~âˆ™âŸ¨ (â—‚âˆ˜ f q K ~â»Â¹) âŸ©
      (f âˆ˜ p â—‚ (H ~â»Â¹)) ~âˆ™ f â—‚ filler ~âˆ™ f âˆ˜ q â—‚ K ~âˆ) where open Cocone cc

  Pushoutâ‰ƒâ†homotopy : Pushout f' g' â‰ƒ Pushout f g
  Pushoutâ‰ƒâ†homotopy = mkâ‰ƒ (cogap (Cocone-mapâ†homotopy pushout))
                          (cogap-is-equivâ†is-pushout _
                           (is-pushoutâ†homotopy _ Pushout-is-pushoutÏ‰))
}
%```
}


\subtree[stt-0083]{
\date{2025-07-30}
\title{Adjusting Pushouts by equivalences}
\taxon{lemma}

\p{Given #{A \simeq B}, a pushout under #{C \xleftarrow{} B
\xrightarrow{} D}, gives rise to a pushout under the induced span #{C
\xleftarrow{} A \xrightarrow{} D}.}

\p{As a corollary, we also have that the canonical pushout of the span
is equivalent to the pushout of the induced span.}

%```agda
\agda{
precomp-span : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“œ} â†’ (S : Span ğ“¤ ğ“¥ ğ“¦)
               â†’ (A â†’ S .Span.Centre) â†’ Span ğ“œ ğ“¥ ğ“¦
precomp-span {A = A} S f = mk-span A (S.left âˆ˜ f) (S.right âˆ˜ f) where
  module S = Span S

precomp-cocone : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {A : Type ğ“œ}  {S : Span ğ“¤ ğ“¥ ğ“¦}
                   (f : A â†’ Span.Centre S) {D : Type ğ“›}
                 â†’ Cocone S D
                 â†’ Cocone (precomp-span S f) D
precomp-cocone f cc
  = mk-cocone p q (filler â–¸ f) where open Cocone cc

precomp-cocone-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {A : Type ğ“œ}  {S : Span ğ“¤ ğ“¥ ğ“¦}
      (f : A â†’ Span.Centre S) {D : Type ğ“›}
    â†’ is-equiv f
    â†’ is-equiv (precomp-cocone {S = S} f {D})
precomp-cocone-is-equiv {S = S} f feq = is-equivâ†qiso qiso where
  module â–¸f {ğ“ }{C : Type ğ“ }{g}{h} =
    is-equiv (postwhisker-equiv-is-equiv feq {C} {g} {h})

  qiso : quasi-iso (precomp-cocone f)
  qiso .fst (mk-cocone p q filler)
    = mk-cocone p q (â–¸f.bwd filler)
  qiso .snd .fst (mk-cocone p q filler)
    = ap (mk-cocone p q) (â–¸f.Î· filler)
  qiso .snd .snd (mk-cocone p q filler)
    = ap (mk-cocone p q) (â–¸f.Îµ filler)


precomp-cocone-is-pushout
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {A : Type ğ“œ}  {S : Span ğ“¤ ğ“¥ ğ“¦}
      (f : A â†’ Span.Centre S) {D : Type ğ“›}
      (feq : is-equiv f)
      {C : Cocone S D}
     â†’ is-pushoutÏ‰ _ C
     â†’ is-pushoutÏ‰ _ (precomp-cocone f C)
precomp-cocone-is-pushout {S = S} f feq {C = C} po
  = is-equiv-âˆ˜ (precomp-cocone-is-equiv f feq) po

Pushout-adjust-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                  {f : S â†’ B} {g : S â†’ C} {S' : Type ğ“œ}
                â†’ (e : S' â‰ƒ S)
                â†’ Pushout (f âˆ˜ e ._â‰ƒ_.fwd) (g âˆ˜ e ._â‰ƒ_.fwd)
                â‰ƒ Pushout f g
Pushout-adjust-equiv {f = f} {g} e = mkâ‰ƒ map map-is-eq where
  module e = _â‰ƒ_ e

  map : Pushout _ _ â†’ Pushout f g
  map = cogap (precomp-cocone e.fwd (pushout {f = f} {g}))

  map-is-eq : is-equiv map
  map-is-eq = cogap-is-equivâ†is-pushout _
                (precomp-cocone-is-pushout
                   e.fwd
                   e.has-is-eqv
                   Pushout-is-pushoutÏ‰)

-- precomp-cocone~ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {S : Span ğ“¤ ğ“¥ ğ“¦}
--                     {S' : Type ğ“œ}
--                     {left' : S' â†’ Span.Left S} {right' : S' â†’ Span.Right S}
--                    (f : S' â†’ Span.Centre S) {D : Type ğ“›}
--                  â†’ left' ~ Span.left S âˆ˜ f
--                  â†’ Span.right S âˆ˜ f ~ right'
--                  â†’ Cocone S D
--                  â†’ Cocone (mk-span S' left' right') D
-- precomp-cocone~ f H K cc
--   = mk-cocone p q (p â—‚ H ~âˆ™ filler â–¸ f ~âˆ™ q â—‚ K ) where open Cocone cc

-- precomp-cocone~-is-equiv
--   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {S : Span ğ“¤ ğ“¥ ğ“¦}
--       {S' : Type ğ“œ}
--       {left' : S' â†’ Span.Left S} {right' : S' â†’ Span.Right S}
--       (f : S' â†’ Span.Centre S) {D : Type ğ“›}
--       (H : left' ~ Span.left S âˆ˜ f)
--       (K : Span.right S âˆ˜ f ~ right')
--     â†’ is-equiv f
--     â†’ is-equiv (precomp-cocone~ {S = S} f {D} H K)
-- precomp-cocone~-is-equiv {S = S} f H K feq = is-equivâ†qiso qiso where
--   module â–¸f {ğ“ }{C : Type ğ“ }{g}{h} =
--     is-equiv (postwhisker-equiv-is-equiv feq {C} {g} {h})

--   qiso : quasi-iso (precomp-cocone~ f H K)
--   qiso .fst (mk-cocone p q filler)
--     = mk-cocone p q (â–¸f.bwd (p â—‚ (H ~â»Â¹) ~âˆ™ filler ~âˆ™ q â—‚ (K ~â»Â¹)))
--   qiso .snd .fst (mk-cocone p q filler)
--     = ap (mk-cocone p q) (funextâ†’ (Î» a â†’ {!!}))
--   qiso .snd .snd (mk-cocone p q filler)
--     = ap (mk-cocone p q) {!!}

Pushout-adjust-equiv~ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                  {f : S â†’ B} {g : S â†’ C} {S' : Type ğ“œ}
                  {f' : S' â†’ B} {g' : S' â†’ C}
                â†’ (e : S' â‰ƒ S)
                â†’ f âˆ˜ e ._â‰ƒ_.fwd ~ f'
                â†’ g âˆ˜ e ._â‰ƒ_.fwd ~ g'
                â†’ Pushout f' g'
                â‰ƒ Pushout f  g
Pushout-adjust-equiv~ {f = f}{g}{S'}{f'}{g'} e H K
  = Pushout f' g' â‰ƒâŸ¨ Pushoutâ‰ƒâ†homotopy H K âŸ©
    Pushout (f âˆ˜ _â‰ƒ_.fwd e) (g âˆ˜ _â‰ƒ_.fwd e)
                  â‰ƒâŸ¨ Pushout-adjust-equiv e âŸ©
    Pushout f g â‰ƒâˆ
}
%```
}

\subtree[stt-009E]{
\title{Extending pullbacks by equivalences}
\taxon{proposition}

\p{Let #{S} be a span #{A \xleftarrow{f} S \xrightarrow{g} B} and #{e}
be an equivalence #{A \to A'}. Then the pushout of #{ef} against #{g}
is equivalent to the pushout of #{f} against #{g}.}
}

\subtree[stt-009F]{
\title{Pushing out equivalences}
\taxon{lemma}

\p{Pushing out an equivalence #{e : A \toeq B} against
any map #{f : A \to C} gives an equivalence #{B \toeq B +^A C}.}

\proof{
This follows immediately from the [analagous theorem for cocartesian
squares](stt-008O)
}

%```agda
\agda{
Î¹â‚‚-is-equivâ†pushout-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Type ğ“¤} {A : Type ğ“¥} {B : Type ğ“¦}
                  {f : S â†’ A} (fe : is-equiv f)
                  (g : S â†’ B) â†’ is-equiv (Î¹â‚‚ {f = f} {g})
Î¹â‚‚-is-equivâ†pushout-equiv {f = f} fe g
 = dom-is-equivâ†cocartesian (mk-amap g Î¹â‚ glue) fe
     (is-cocartesianâ†is-pushout Pushout-is-pushoutÏ‰)

Pushout-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Type ğ“¤} {A : Type ğ“¥} {B : Type ğ“¦}
                  {f : S â†’ A} (fe : is-equiv f) (g : S â†’ B)
                â†’ B â‰ƒ Pushout f g
Pushout-equiv fe g = mkâ‰ƒ _ (Î¹â‚‚-is-equivâ†pushout-equiv fe g)
}
%```
}

\subtree[stt-009G]{
\title{Vertical pasting of pushouts}
\taxon{lemma}

\p{Given squares arranged vertically like so:}

\quiver{
\begin{tikzcd}
	A && C \\
	\\
	{B} && \bullet \\
	\\
	{B'} && \bullet
	\arrow[from=1-1, to=1-3]
	\arrow["g", from=1-1, to=3-1]
	\arrow["fg"', curve={height=12pt}, from=1-1, to=5-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow["f", from=3-1, to=5-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[from=3-3, to=5-3]
	\arrow[from=5-1, to=5-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=5-3, to=3-1]
\end{tikzcd}
}

\p{The result of pushing out the top span followed by the bottom span
is equivalent to pushing out the outer span all at once. In symbols,
#{B' +^B (B +^A + C) \simeq B' +^A C}.}

%```
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
         {C : Type ğ“œ} (f : B â†’ B') (g : A â†’ B) (h : A â†’ C) where

  private
    US : Span ğ“¤ ğ“¥ ğ“œ
    US = mk-span A g h

    LS : Span ğ“¥ ğ“¦  (ğ“¤ âŠ” ğ“¥ âŠ” ğ“œ)
    LS = mk-span B f (Î¹â‚ {f = g} {h})

    TS : Span ğ“¤ ğ“¦ ğ“œ
    TS = mk-span A (f âˆ˜ g) h


    lemma : âˆ€ {ğ“ }{Q : Type ğ“ }(p : B' â†’ Q)
            â†’ (Î£[ cc âˆ¶ Cocone US Q ] (p âˆ˜ f ~ Cocone.p cc))
            â‰ƒ Î£[ q âˆ¶ (C â†’ Q) ] (p âˆ˜ f âˆ˜ g ~ q âˆ˜ h)
    lemma {ğ“ }{Q}p = Î£-ap-â‰ƒ (Î» cc â†’ funextâ‰ƒ eâ»Â¹) âˆ™â‰ƒ equivâ†qiso iso where
      open _â‰…_

      iso : _ â‰… _
      iso .fwd (mk-cocone q r H , K) = r , happly K â–¸ g ~âˆ™ H
      iso .fwd-iso .fst (q , H) = (mk-cocone (p âˆ˜ f) q H) , refl
      iso .fwd-iso .snd .fst cc@(mk-cocone p q filler , refl) = refl
      iso .fwd-iso .snd .snd (p , H) = refl

  extend-cocone : âˆ€ {ğ“ }{Q : Type ğ“ } â†’ Cocone LS Q â‰ƒ Cocone TS Q
  extend-cocone {ğ“ }{Q}
    = Cocone LS _ â‰ƒâŸ¨ cocone-reprâ‰ƒ âŸ©
      Î£[ p âˆ¶ (B' â†’ Q) ]
       Î£[ q âˆ¶ (Pushout g h â†’ Q)] (p âˆ˜ f ~ q âˆ˜ Î¹â‚)
                  â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ-fst (Pushout-UPâ‰ƒ)) âŸ©
      (Î£[ p âˆ¶ (B' â†’ Q) ] Î£[ q âˆ¶ Cocone US Q ] (p âˆ˜ f ~ q .Cocone.p))
                  â‰ƒâŸ¨ Î£-ap-â‰ƒ lemma âŸ©
      (Î£[ p âˆ¶ (B' â†’ Q) ]
        Î£[ q âˆ¶ (C â†’ Q)] (p âˆ˜ f âˆ˜ g ~ q âˆ˜ h))
                  â‰ƒâŸ¨ cocone-reprâ‰ƒ eâ»Â¹ âŸ©
      Cocone TS _ â‰ƒâˆ

  Pushout-vert-âˆ˜ : Pushout (f âˆ˜ g) h â‰ƒ Pushout f (Î¹â‚ {f = g} {h})
  Pushout-vert-âˆ˜ = mkâ‰ƒ map (cogap-is-equivâ†is-pushout cc Î»
    {ğ“ }{Q} â†’ is-equiv~âˆ˜ (H Q)
                        (extend-cocone ._â‰ƒ_.has-is-eqv)
                        (Pushout-is-pushoutÏ‰)) where
    cc = (extend-cocone ._â‰ƒ_.fwd pushout)
    map : Pushout (f âˆ˜ g) h â†’ Pushout f (Î¹â‚ {f = g} {h})
    map = cogap cc

    H : âˆ€ {ğ“ }(Q : Type ğ“ )
        â†’ cocone-map (mk-span A (f âˆ˜ g) h) cc
        ~ _â‰ƒ_.fwd extend-cocone âˆ˜ cocone-map (mk-span B f Î¹â‚) pushout
    H Q f = Cocone-pathâ†’ _ _ refl refl
      ( f â—‚ (glue âˆ˜ g ~âˆ™ Î¹â‚‚ â—‚ glue) ~âˆ™ ~refl
                                   ~âŸ¨ ~âˆ™-reflr _ âŸ©
       f â—‚ (glue â–¸ g ~âˆ™ Î¹â‚‚ â—‚ glue) ~âŸ¨ â—‚âˆ™ f (glue â–¸ g) _ âŸ©
       (f â—‚ glue â–¸ g) ~âˆ™ (f â—‚ Î¹â‚‚ â—‚ glue)
                                   ~âŸ¨ ~refl âŸ©~âˆ™âŸ¨ (â—‚âˆ˜ f Î¹â‚‚ glue ~â»Â¹) âŸ©
       f â—‚ (glue â–¸ g) ~âˆ™ f âˆ˜ Î¹â‚‚ â—‚ glue ~âˆ)
}
%```
}


\subtree[stt-009H]{
\title{proof of \ref{stt-009F}}
\taxon{proof}

\p{
Consider the following diagram:
}
\quiver{
\begin{tikzcd}
	A && C \\
	\\
	{A'} && {A' +^A C} \\
	\\
	{A''} && \bullet \\
	{A''} &&& {A'' +^A C}
	\arrow[from=1-1, to=1-3]
	\arrow["g", from=1-1, to=3-1]
	\arrow["fg"', curve={height=12pt}, from=1-1, to=6-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow["f", from=3-1, to=5-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow["\sim"', from=3-3, to=5-3]
	\arrow[from=3-3, to=6-4]
	\arrow[from=5-1, to=5-3]
	\arrow[equals, from=5-1, to=6-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=5-3, to=3-1]
	\arrow["\sim"', from=5-3, to=6-4]
	\arrow[from=6-1, to=6-4]
\end{tikzcd}
}

\p{By \ref{stt-009G}, the cogap map at the bottom right is an
equivalence, and by \ref{stt-009E}, so is the map opposite #{f}.
Then the 3-for-2 property for equivalences completes our proof.}

%```agda
\agda{

module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
         {C : Type ğ“œ} {f : B â†’ B'} (fe : is-equiv f)
         (g : A â†’ B) (h : A â†’ C) where
  Pushout-vert-extendâ‰ƒ : Pushout g h â‰ƒ Pushout (f âˆ˜ g) h
  Pushout-vert-extendâ‰ƒ = Pushout-equiv fe (Î¹â‚ {f = g} {h})
                      âˆ™â‰ƒ Pushout-vert-âˆ˜ f g h eâ»Â¹

}
%```
}
