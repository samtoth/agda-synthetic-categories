\date{2025-02-21}
\title{Higher Modalities}
\taxon{module}
\meta{module}{\startverb modalities.HigherModalities \stopverb}
\import{stt-macros}

% ```agda
\agda{
module modalities.HigherModality where

open import foundations.Prelude
open import foundations.IdentitySystem
open import ufAxioms
open import ergonomics.Universal
open import ergonomics.Extensionality
}
% ```

\transclude{stt-000G}


% ```agda
\agda{
record HigherModality ğ“¤ : TypeÏ‰ where
  field
    â—‹_    : Type ğ“¤ â†’ Type ğ“¤
    â—‹-Î·   : âˆ€ {A : Type ğ“¤} â†’ A â†’ â—‹ A
    â—‹-ind : âˆ€ {A : Type ğ“¤} (P : â—‹ A â†’ Type ğ“¤)
            â†’ (f : (a : A) â†’ â—‹ P (â—‹-Î· a))
            â†’ (ma : â—‹ A) â†’ â—‹ (P ma)
    â—‹-Î²   : âˆ€ {A : Type ğ“¤} (P : â—‹ A â†’ Type ğ“¤)
            â†’ (f : (a : A) â†’ â—‹ P (â—‹-Î· a))
            â†’ (a : A) â†’ â—‹-ind P f (â—‹-Î· a) ï¼ f a

  is-â—‹-modal : Type ğ“¤ â†’ Type ğ“¤
  is-â—‹-modal A = is-equiv (â—‹-Î· {A = A})

  field
    ï¼-â—‹-is-â—‹-modal : âˆ€ {A : Type ğ“¤} {x y : â—‹ A} â†’ is-â—‹-modal (x ï¼ y)

  opaque
    â—‹-rec : âˆ€ {A : Type ğ“¤} {B : Type ğ“¤} â†’ (A â†’ â—‹ B) â†’ (â—‹ A â†’ â—‹ B)
    â—‹-rec = â—‹-ind (Î» _ â†’ _)

    â—‹-recÎ² :  âˆ€ {A : Type ğ“¤} {B : Type ğ“¤} (f : A â†’ â—‹ B) (a : A)
              â†’ â—‹-rec f (â—‹-Î· a) ï¼ f a
    â—‹-recÎ² = â—‹-Î² (Î» _ â†’ _)

  unmod : âˆ€ {A : Type ğ“¤} (m : is-â—‹-modal A) â†’ â—‹ A â†’ A
  unmod (mk-eqv (g , _) _) = g

  â—‹-map : âˆ€ {A B : Type ğ“¤} â†’ (A â†’ B) â†’ â—‹ A â†’ â—‹ B
  â—‹-map f = â—‹-rec (â—‹-Î· âˆ˜ f)
}
% ```

\subtree{
\taxon{theorem}
\title{#{\bigcirc A} is modal}

% ```agda
\agda{
  â—‹-elim : âˆ€ {A : Type ğ“¤} â†’ â—‹ (â—‹ A) â†’ â—‹ A
  â—‹-elim = â—‹-rec Î» x â†’ x

  â—‹-is-â—‹-modal : âˆ€ {A : Type ğ“¤} â†’ is-â—‹-modal (â—‹ A)
  â—‹-is-â—‹-modal = is-equivâ†qiso the-iso where
    the-iso : quasi-iso â—‹-Î·
    the-iso .fst = â—‹-ind _ id
    the-iso .snd .fst = â—‹-Î² _ id
    the-iso .snd .snd a = unmod
                            ï¼-â—‹-is-â—‹-modal
                            (â—‹-ind (Î» a â†’ (â—‹-Î· (â—‹-ind _ id a)) ï¼ a)
                            (Î» a â†’ â—‹-Î· (ap â—‹-Î· (â—‹-Î² _ _ a))) a)
}
% ```
}

\subtree{
\taxon{lemma}
\title{Equality on modal is modal}

% ```agda
\agda{
  â‰ƒ-â—‹-modal : âˆ€ {A B : Type ğ“¤} â†’ A â‰ƒ B â†’ is-â—‹-modal A â†’ is-â—‹-modal B
  â‰ƒ-â—‹-modal e = tr is-â—‹-modal (ua e)

  ï¼-is-â—‹-modal : âˆ€ {A : Type ğ“¤} â†’ is-â—‹-modal A  â†’ {a b : A}
                â†’ is-â—‹-modal (a ï¼ b)
  ï¼-is-â—‹-modal {A = A} H {a} {b} =
    â‰ƒ-â—‹-modal
      (mkâ‰ƒ (ap â—‹-Î·) (is-embeddingâ†is-equiv H) eâ»Â¹)
      ï¼-â—‹-is-â—‹-modal
}
% ```
}

\subtree{
\taxon{definition}
\title{Modal induction}

% ```agda
\agda{
  opaque
    â—‹-ind' : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤} (P-mod : âˆ€ {a} â†’ is-â—‹-modal (P a))
             â†’ (f : (a : A) â†’ P (â—‹-Î· a)) â†’ (ma : â—‹ A) â†’ P ma
    â—‹-ind' {P = P} is-mod f = (unmod is-mod) âˆ˜ â—‹-ind P (â—‹-Î· âˆ˜ f)

    â—‹-Î²' : âˆ€  {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
           â†’ (P-mod : âˆ€ {a} â†’ is-â—‹-modal (P a))
           â†’ (f : (a : A) â†’ P (â—‹-Î· a)) â†’ (a : A) â†’ â—‹-ind' (Î» {a'} â†’ P-mod {a'}) f (â—‹-Î· a) ï¼ f a
    â—‹-Î²' is-mod f a = ap (unmod is-mod) (â—‹-Î² _ _ a) âˆ™ is-equiv.Î· is-mod (f a)

    â—‹-ind'-qiso : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤} {P-mod : âˆ€ {a} â†’ is-â—‹-modal (P a)}
                   â†’ quasi-iso {A = (a : A) â†’ P (â—‹-Î· a)} {B = (a : â—‹ A) â†’ P a}
                               (â—‹-ind' P-mod)
    â—‹-ind'-qiso .fst = _âˆ˜ â—‹-Î·
    â—‹-ind'-qiso {P-mod = is-mod} .snd .fst f = ext! (â—‹-Î²' is-mod f)
    â—‹-ind'-qiso {P = P} {P-mod = is-mod} .snd .snd f = ext! (â—‹-ind' {P = Î» a â†’ _ ï¼ f a}
                     (Î» {a} â†’  ï¼-is-â—‹-modal is-mod) (â—‹-Î²' is-mod (f âˆ˜ â—‹-Î·)))

    â—‹-ind'-is-equiv : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                       {P-mod : âˆ€ {a} â†’ is-â—‹-modal (P a)}
                   â†’ is-equiv {A = (a : A) â†’ P (â—‹-Î· a)} {B = (a : â—‹ A) â†’ P a}
                               (â—‹-ind' P-mod)
    â—‹-ind'-is-equiv {P-mod = is-mod} = is-equivâ†qiso (â—‹-ind'-qiso {P-mod = is-mod})

}
% ```
}


\subtree{
\taxon{universal property}
% ```agda
\agda{
module _ {ğ“¤} {M : HigherModality ğ“¤} where

  open HigherModality M

  â—‹-ind-qiso : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                 â†’ quasi-iso {A = (a : A) â†’ â—‹ P (â—‹-Î· a)} {B = (a : â—‹ A) â†’ â—‹ (P a)}
                            (â—‹-ind P)
  â—‹-ind-qiso .fst = _âˆ˜ â—‹-Î·
  â—‹-ind-qiso .snd .fst f = ext! (â—‹-Î² _ f)
  â—‹-ind-qiso {A = A} {P = P} .snd .snd f = ext! (â—‹-ind' ï¼-â—‹-is-â—‹-modal (â—‹-Î² _ (f âˆ˜ â—‹-Î·)))

  â—‹-ind-is-equiv : âˆ€ {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                 â†’ is-equiv {A = (a : A) â†’ â—‹ P (â—‹-Î· a)} {B = (a : â—‹ A) â†’ â—‹ P a}
                            (â—‹-ind P)
  â—‹-ind-is-equiv = is-equivâ†qiso â—‹-ind-qiso


  open Universal

  instance
    Universal-â—‹ : âˆ€ {ğ“¦} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¤}
                 â†’ â¦ƒ _ : âˆ€ {a} â†’ is-â—‹-modal (P a) â¦„
                 â†’ â¦ƒ _ : Universal ((a : A) â†’ P (â—‹-Î· a)) ğ“¦ â¦„
                 â†’ Universal ((a : â—‹ A) â†’ P a) ğ“¦
    Universal-â—‹ â¦ƒ mod â¦„ â¦ƒ u â¦„ .Universal.methods = u .methods
    Universal-â—‹ â¦ƒ mod â¦„ â¦ƒ u â¦„ .Universal.from = â—‹-ind' mod âˆ˜ u .from
    Universal-â—‹ â¦ƒ mod â¦„ â¦ƒ u â¦„ .Universal.from-is-equiv
      = is-equiv-âˆ˜ â—‹-ind'-is-equiv (u .from-is-equiv)
}
% ```
}

\subtree{

\title{Instance resolution for is-modal}

% ```agda
\agda{
  instance
    â—‹-Modal : âˆ€ {A : Type ğ“¤} â†’ is-â—‹-modal (â—‹ A)
    â—‹-Modal = â—‹-is-â—‹-modal

    ï¼-Modal : âˆ€ {A : Type ğ“¤} â†’ â¦ƒ is-â—‹-modal A â¦„ â†’ {a b : A}  â†’ is-â—‹-modal (a ï¼ b)
    ï¼-Modal â¦ƒ H â¦„ =  ï¼-is-â—‹-modal H

    Î -Modal : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤} â†’ â¦ƒ _ : âˆ€ {x} â†’ is-â—‹-modal (B x) â¦„ â†’ is-â—‹-modal (âˆ€ x â†’ B x)
    Î -Modal = is-equivâ†qiso (Î» where
            .fst â†’ Î» f a â†’ rec! (Î» f â†’ f a) f
            .snd .fst â†’ Î» f â†’ ext! (Î» a â†’ â—‹-Î²' _ _ _)
            .snd .snd â†’ Î» f â†’ ind! {B = Î» f â†’ â—‹-Î· (Î» x â†’ â—‹-ind' _ (Î» f â†’ f x) f) ï¼ f}
                                   (Î» f â†’ ap â—‹-Î· (funextâ†’ (Î» a â†’ â—‹-Î²' _ _ _))) f)



  â—‹-elim! : âˆ€ {A : Type ğ“¤} â¦ƒ _ : is-â—‹-modal A â¦„
            â†’ â—‹ A â†’ A
  â—‹-elim! = rec! id

  private module test where
    test : âˆ€ {A : Type ğ“¤} â†’ â—‹ â—‹ A â†’ â—‹ A
    test = â—‹-elim!
}
% ```


}

\subtree{
\taxon{theorem}
\title{Higher modalities are #{\Sigma}-closed}

% ```agda
\agda{
  â—‹-Î£-closed : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤}
            â†’ â¦ƒ _ : is-â—‹-modal A â¦„
            â†’ â¦ƒ _ : âˆ€ {x} â†’ is-â—‹-modal (B x) â¦„
            â†’ is-â—‹-modal (Î£ A B)
  â—‹-Î£-closed {A = A} {B = B} = is-equivâ†qiso I where

    f : â—‹ Î£ A B â†’ A
    f = rec! (Î» a _ â†’ a)

    f-Î² : âˆ€ {a : A} {b : B a} â†’ f (â—‹-Î· (a , b)) ï¼ a
    f-Î² = â—‹-Î²' _ _ _

    g : (x : â—‹ Î£ A B) â†’ B (f x)
    g = ind! (Î» a b â†’ tr B (sym f-Î²) b)

    g-Î² : âˆ€ {a : A} {b : B a} â†’ IdP (sym (ap B  f-Î²)) b (g (â—‹-Î· (a , b)))
    g-Î² {a} {b} =  tr (Î» z â†’ IdP z b (g (â—‹-Î· (a , b)))) (ap-sym B f-Î²) (sym (â—‹-Î²' _ _ _))

    I : quasi-iso â—‹-Î·
    I .fst x = f x , g x
    I .snd .fst (a , b) = Î£-pathâ†’ (f-Î² ,  symP' g-Î²  )
    I .snd .snd = ind! Î» a b â†’ ap â—‹-Î· (Î£-pathâ†’ (f-Î² , symP' g-Î²))


  instance
    Modal-Î£ : âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤}
            â†’ â¦ƒ _ : is-â—‹-modal A â¦„
            â†’ â¦ƒ _ : âˆ€ {x} â†’ is-â—‹-modal (B x) â¦„
            â†’ is-â—‹-modal (Î£ A B)
    Modal-Î£ = â—‹-Î£-closed
}
% ```
}


\subtree[stt-0046]{
\date{2025-05-10}
\taxon{definition}
\title{Modal connected types}

\p{Given a higher modality #{\bigcirc}, We call a type #{A} #{\bigcirc}-connected when
the type #{\bigcirc A} is a singleton.}

% ```agda
\agda{
module _ {ğ“¤} {M : HigherModality ğ“¤} where
  open HigherModality M
  is-â—‹-connected : Type ğ“¤ â†’ Type ğ“¤
  is-â—‹-connected A = is-singleton (â—‹ A)
}
% ```
}

% \subtree[stt-0047]{
% \date{2025-05-10}
% \taxon{definition}
% \title{Modal seperated types}

% \p{Given a higher modality #{\bigcirc}, We call a type #{A} #{\bigcirc}-seperated when
% the map #{A \xrightarrow{\eta} \bigcirc A} is a surjection.}

% ```agda
% \agda{
% module _ {M : HigherModality} where
%
%  open HigherModality M
%  is-â—‹-seperated : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
%  is-â—‹-seperated A = is-embedding (â—‹-Î· {_} {A})
% }
% ```

% }
