\date{2025-07-30}
\title{Coequalisers}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
module Core.Coequalisers where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Postwhisker
open import Core.PushoutEquiv
open import Ergonomics.Representation
}
%```

\subtree[stt-009M]{
\title{Coequalisers}
\taxon{Definition}

\p{Given a pair of maps #{f,g : A \to B}, we define a \em{cofork} under
#{f} and #{g} at a particular type #{C} to be a map #{h : B \to C}
together with an homotopy #{hf \sim hg}. Given a particular cofork
centred at #{C}, we can define a map #{Q^C \to \rm{cofork}_{f,g}(Q)}
for each type #{Q}. The given cofork is said to be a \em{coequaliser}
if the aforementioned cofork-map is an equivalence.}

%```agda
\agda{
Cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ (C : Type ğ“¦) â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Cofork {B = B} f g C = Î£[ p âˆ¶ (B â†’ C) ] (p âˆ˜ f ~ p âˆ˜ g)

cofork-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
         â†’ {f g : A â†’ B} â†’ {C : Type ğ“¦}
         â†’ Cofork f g C â†’ âˆ€ {ğ“ } {Q : Type ğ“ }
         â†’ (C â†’ Q) â†’ Cofork f g Q
cofork-map (p , H) f = (f âˆ˜ p , f â—‚ H)

is-coeq : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
            {f g : A â†’ B} {C : Type ğ“¦}
          â†’ Cofork f g C â†’ TypeÏ‰
is-coeq f = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-equiv (cofork-map f {ğ“ } {Q})
}
%```
}

\subtree[stt-009N]{
\taxon{Theorem}
\title{Coequalisers are pushouts}

\p{Given a pair of maps #{f,g : A \to B} we can define a span
#{B \xleftarrow{[id,f]} B + A \xrightarrow{[id,g]} B} and show the
following:}

\ul{
\li{There is an equivalence between coforks over #{f,g} and
[cocones](stt-0016) over the induced span.}
\li{A cofork is a coequaliser iff the corresponding cocone is a
pushout}
\li{We can construct canonical coequalisers via
[canonical pushouts](Core.CanonicalPushouts)}
}
}

%```agda
\agda{
Coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
Coeq {_} {_} {A} {B} f g
  = Pushout l r  module Coeq where
  l : B âŠ A â†’ B
  l (inl x) = x
  l (inr x) = f x

  r : B âŠ A â†’ B
  r (inl x) = x
  r (inr x) = g x

  span : Span _ _ _
  span = mk-span _ l r

{-# DISPLAY Pushout (Coeq.l f g) (Coeq.r f g) = Coeq f g #-}

coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
       â†’ (f g : A â†’ B) â†’ Cofork f g (Coeq f g)
coeq f g = (Î¹â‚‚ , Î» x â†’ sym (glue (inl (f x))) âˆ™ glue (inr x))

Î¹-coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
         â†’ {f g : A â†’ B}
         â†’ B â†’ Coeq f g
Î¹-coeq = coeq _ _ .fst

glue-coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
            â†’ {f g : A â†’ B}
            â†’ Î¹-coeq âˆ˜ f ~ Î¹-coeq âˆ˜ g
glue-coeq = coeq _ _ .snd


coconeâ†cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Cofork f g C â†’ Cocone (Coeq.span f g) C
coconeâ†cofork {f = f} {g} (p , H) = mk-cocone p p (âŠ-ind (~refl , H))

coforkâ†cocone : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Cocone (Coeq.span f g) C â†’ Cofork f g C
coforkâ†cocone {f = f} {g} (mk-cocone p q filler)
  = p , Î» a â†’ filler (inr a) âˆ™ sym (filler (inl (g a)))

coconeâ‰ƒfork : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
              â†’ Cofork f g C â‰ƒ Cocone (Coeq.span f g) C
coconeâ‰ƒfork {B = B} {f} {g}{C}
  = Cofork f g C
      â‰ƒâŸ¨âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] (p âˆ˜ f ~ p âˆ˜ g))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» _ â†’ Î£-ï¼singl') eâ»Â¹ âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] ((p ï¼ q) Ã— (p âˆ˜ f ~ q âˆ˜ g)))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ Î£-ap-â‰ƒ-fst funextâ‰ƒ)) âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] ((p ~ q) Ã— (p âˆ˜ f ~ q âˆ˜ g)))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ âŠ-UPâ‰ƒ global-funext)) âŸ©
    (Î£[ p âˆ¶ (B â†’ C)] Î£[ q âˆ¶ (B â†’ C)] (p âˆ˜ Coeq.l f g ~ q âˆ˜ Coeq.r f g))
      â‰ƒâŸ¨ cocone-reprâ‰ƒ eâ»Â¹ âŸ©
    Cocone (Coeq.span f g) C â‰ƒâˆ

coconeâ†fork-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Type ğ“¦}
                â†’ is-equiv (coconeâ†cofork {f = f} {g} {C})
coconeâ†fork-is-equiv = coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv

coeq-is-coeq : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                 {f g : A â†’ B} â†’ is-coeq (coeq f g)
coeq-is-coeq {f = f} {g} {Q = Q}
  = 3-for-2~ (H ~â»Â¹)
             (coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv)
             (Pushout-is-pushoutÏ‰) where
  H : coconeâ†cofork âˆ˜ cofork-map (coeq f g) {Q = Q}
    ~ cocone-map (Coeq.span f g) pushout
  H f = Cocone-pathâ†’ _ _ (funextâ†’ (f â—‚ (glue ~â»Â¹) â–¸ inl)) refl Î» where
    (inl x) â†’ sym ( ap (_âˆ™ ap f (glue (inl x))) (ap-sym f (glue (inl x)))
                   âˆ™ âˆ™-sym' (ap f (glue _)))
    (inr x) â†’ âˆ™-reflr _ âˆ™ ap-âˆ™ f (sym (glue _)) (glue (inr x))


coeq-rec : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Type ğ“¦}
           â†’ Cofork f g C
           â†’ Coeq f g â†’ C
coeq-rec = is-equiv.bwd coeq-is-coeq

coeq-recÎ² : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Type ğ“¦}
           â†’ (C : Cofork f g C)
           â†’ coeq-rec C âˆ˜ Î¹-coeq ~ (fst C)
coeq-recÎ² c = happly (ap fst (snd (is-equiv.retract-bwd coeq-is-coeq) c))

coeq-rec-apÎ² :  âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
            â†’ {f g : A â†’ B} {C : Type ğ“¦}
            â†’ {c : Cofork f g C}
            â†’ (âˆ€ x â†’ ap (coeq-rec c) (glue-coeq x) ï¼ c .snd x  )
coeq-rec-apÎ² {f = f} {c = c} x =
  ap (pushout-rec _ ) (sym (glue (inl (f x))) âˆ™ glue (inr x))
    ï¼âŸ¨ ap-âˆ™ (pushout-rec _) (sym (glue (inl (f x)))) (glue (inr x)) âŸ©
  ap (pushout-rec cocone-data) (sym (glue (inl (f x)))) âˆ™ ap (pushout-rec cocone-data) (glue (inr x))
    ï¼âŸ¨  ap (_âˆ™ ap (pushout-rec cocone-data) (glue (inr x))) (ap-sym (pushout-rec cocone-data) (glue (inl (f x))))âŸ©
  sym (ap (pushout-rec cocone-data) (glue (inl (f x)))) âˆ™ ap (pushout-rec cocone-data) (glue (inr x))
    ï¼âŸ¨  ap (_âˆ™ ap (pushout-rec cocone-data) (glue (inr x))) (ap sym (pushout-rec-apÎ² (inl (f x)))) âŸ©
  ap (pushout-rec cocone-data) (glue (inr x))
    ï¼âŸ¨ pushout-rec-apÎ² (inr x) âŸ©
  (c .snd x) âˆ where
    cocone-data =  (_â‰…_.fwd-iso cocone-reprâ‰… .fst
        (c .fst , c .fst , âŠ-ind ((Î» a â†’ refl) , c .snd)))

coeq-rec-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
      {f g : A â†’ B} {C : Type ğ“¦}
    â†’ is-equiv (coeq-rec {f = f}{g}{C})
coeq-rec-is-equiv
  = is-equiv-âˆ˜ pushout-rec-is-equiv coconeâ†fork-is-equiv


module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B}
         {C : Type ğ“¦} (cf : Cofork f g C) where
  private
    H : âˆ€ {ğ“ }{Q : Type ğ“ }
      â†’ cocone-map (Coeq.span f g) (coconeâ†cofork cf) {Q}
      ~ coconeâ†cofork âˆ˜ cofork-map cf
    H f = Cocone-pathâ†’ _ _ refl refl (âŠ-ind (~refl , (~âˆ™-reflr _)))

  is-coeqâ†is-pushout : is-pushoutÏ‰ (Coeq.span f g) (coconeâ†cofork cf)
                       â†’ is-coeq cf
  is-coeqâ†is-pushout po = 3-for-2~ H (coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv) po

  is-pushoutâ†is-coeq : is-coeq cf
                     â†’ is-pushoutÏ‰ (Coeq.span f g) (coconeâ†cofork cf)
  is-pushoutâ†is-coeq coe
    = is-equiv~âˆ˜ H (coconeâ‰ƒfork ._â‰ƒ_.has-is-eqv) coe

cogap-is-equivâ†is-coeq
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B} {C : Type ğ“¦}
      {cf : Cofork f g C} â†’ is-coeq cf â†’ is-equiv (coeq-rec cf)
cogap-is-equivâ†is-coeq {cf = cf} ce
  = cogap-is-equivâ†is-pushout (coconeâ†cofork cf)
                              (is-pushoutâ†is-coeq cf ce)

is-coeqâ†cogap-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B} {C : Type ğ“¦}
      {cf : Cofork f g C} â†’ is-equiv (coeq-rec cf) â†’ is-coeq cf
is-coeqâ†cogap-is-equiv {cf = cf} ce
  = is-coeqâ†is-pushout cf (is-pushoutâ†cogap _ ce)
}
%```

\subtree[stt-009O]{
\title{Induction for coequalisers}
\taxon{Theorem}

\p{Coequalisers satisfy an induction principal: given maps
#{f,g : A \to B}, and a family of types #{P} over the coequaliser
of #{f} and #{g}, we can give a section #{\Pi_{(a : \rm{Coeq}_{f,g})} P(a)}
by giving a section #{p : \Pi_{(b:B)}(P(\iota(b)))} and for each #{a},
a dependent identification #{p(f(a)) =_P^{gl} p(g(a))}. This data
is called a dependent cofork or \code{Coforkáµˆ} in code.}

%```agda
\agda{
Coforkáµˆ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
          (f g : A â†’ B) (C : Coeq f g â†’ Type ğ“¦)
        â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Coforkáµˆ {A = A} {B} f g C
  =  Î£[ p âˆ¶ ((b : B) â†’  C (Î¹â‚‚ b))]
      (âˆ€ a â†’ Idáµˆ (ap C (coeq f g .snd a)) (p (f a)) (p (g a)))

coconeâ†coforkáµˆ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
              â†’ Coforkáµˆ f g C
              â†’ Coconeáµˆ (Coeq.span f g) (coconeâ†cofork (coeq f g)) C
coconeâ†coforkáµˆ {f = f} {g} (p , H)
  = mk-coconeáµˆ p p (âŠ-ind (~refl , H))

coconeâ‰ƒforkáµˆ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
              â†’ Coforkáµˆ f g C
              â‰ƒ Coconeáµˆ (Coeq.span f g) (coconeâ†cofork (coeq f g)) C
coconeâ‰ƒforkáµˆ {B = B} {f} {g}{C}
  = Coforkáµˆ f g C
      â‰ƒâŸ¨âŸ©
    (Î£[ p âˆ¶ (Î  B (C âˆ˜ Î¹â‚‚))] (p âˆ˜ f ~[ (C â—‚ (coeq f g .snd)) ] p âˆ˜ g))
      â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» p â†’ Î£-ï¼singl') eâ»Â¹ âŸ©
    (Î£[ p âˆ¶ (Î  B (C âˆ˜ Î¹â‚‚))] Î£[ q âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] ((p ï¼ q) Ã— (p âˆ˜ f ~[ C â—‚ (coeq f g .snd) ] q âˆ˜ g)))
      â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ Î£-ap-â‰ƒ-fst funextâ‰ƒ))  âŸ©
    (Î£[ p âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] Î£[ q âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] ((p ~ q) Ã— (p âˆ˜ f ~[ C â—‚ (coeq f g .snd) ] q âˆ˜ g)))
      â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» p â†’ Î£-ap-â‰ƒ (Î» q â†’ âŠ-UPâ‰ƒ global-funext)) âŸ©
    (Î£[ p âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] Î£[ q âˆ¶ Î  B (C âˆ˜ Î¹â‚‚)] (p âˆ˜ Coeq.l f g ~[ (C â—‚ âŠ-ind (~refl , coeq f g .snd)) ] q âˆ˜ Coeq.r f g))
      â‰ƒâŸ¨ coconeD-reprâ‰ƒ eâ»Â¹ âŸ©
    Coconeáµˆ (Coeq.span f g) _ C â‰ƒâˆ

coconeâ†coforkáµˆ-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
      {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
    â†’ is-equiv (coconeâ†coforkáµˆ {f = f} {g} {C})
coconeâ†coforkáµˆ-is-equiv = coconeâ‰ƒforkáµˆ ._â‰ƒ_.has-is-eqv

coforkáµˆ-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
              {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
            â†’ Î  _ C â†’ Coforkáµˆ f g C
coforkáµˆ-map {C = C} f = (f âˆ˜ Î¹â‚‚ , f â—‚áµˆ coeq _ _ .snd)

coeq-is-coeqáµˆ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
           â†’ is-equiv (coforkáµˆ-map {C = C})
coeq-is-coeqáµˆ {f = f}{g}{Q}
  = 3-for-2~ (H ~â»Â¹) coconeâ†coforkáµˆ-is-equiv coeq-is-po where
  H : coconeâ†coforkáµˆ âˆ˜ coforkáµˆ-map {C = Q}
    ~ coconeáµˆ-map (Coeq.span f g) (coconeâ†cofork (coeq f g))  {Q = Q}
  H f = from-coconeáµˆ-path (record {
      pï¼ = refl
    ; qï¼ = refl
    ; fillerï¼ = funextâ†’ (âŠ-ind (~refl , ~refl)) })

  lem : coconeâ†cofork (coeq f g) ï¼ pushout
  lem = Cocone-pathâ†’ _ _ (funextâ†’ (Î» b â†’ sym (glue (inl b)))) refl
          (âŠ-ind ((Î» b â†’ sym (âˆ™-sym' (glue (inl b)))) , Î» a â†’ âˆ™-reflr _))

  coeq-is-po : is-pushoutÏ‰áµˆ (Coeq.span f g) (coconeâ†cofork (coeq f g))
  coeq-is-po {ğ“œ} = tr (Î» x â†’ âˆ€ {Q : Coeq f g â†’ Type ğ“œ} â†’ is-equiv (coconeáµˆ-map (Coeq.span f g) x {Q}))
                       (sym lem) Pushout-is-pushoutÏ‰áµˆ

coeq-ind : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
           â†’ Coforkáµˆ f g C
           â†’ (x : Coeq f g) â†’ C x
coeq-ind = is-equiv.bwd coeq-is-coeqáµˆ

coeq-indÎ² : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
             {f g : A â†’ B} {C : Coeq f g â†’ Type ğ“¦}
           â†’ (c : Coforkáµˆ f g C)
           â†’ coeq-ind c âˆ˜ Î¹-coeq ~ fst c
coeq-indÎ² c = happly (ap fst (snd (is-equiv.retract-bwd coeq-is-coeqáµˆ) c))




{-# DISPLAY is-equiv.bwd coeq-is-coeqáµˆ x = coeq-ind x #-}
}
%```
}

\subtree[stt-00D4]{
\date{2025-12-14}
\author{markwilliams}
\title{Bi-recursion principle for coequalisers}

\p{We prove a Bi-recursion principle for maps out of two coequalisers.
  Given #{f_1, g_1 : A_1 \to B_1} and #{f_2, g_2 : A_2 \to B_2},
  the data of a map out of both coequalisers is given by a \em{bicofork}.
  Explicitly we have a map #{c : B_1 \to B_2 \to C} with paths #{c(f_1(a), b) = c(g_1(a), b)} and #{c(b, f_2(a)) = c(b, g_2(a)) }.
  Further these paths must satisfy the coherence that for all #{a_1 : A_1}, #{a_2 : A_2} that the following square must commute.
  \quiver{\begin{tikzcd}
    {c(f_1(a_1), f_2(a_2))} & {c(g_1(a_1), f_2(a_2))} \\
    {c(f_1(a_1), g_2(a_2))} & {c(g_1(a_1), g_2(a_2))}
      \arrow[equals, from=1-1, to=1-2]
      \arrow[equals, from=1-1, to=2-1]
      \arrow[equals, from=1-2, to=2-2]
      \arrow[equals, from=2-1, to=2-2]
    \end{tikzcd}}
  This ensures the two maps form a cofork under #{A_1 \rightrightarrows B_1} into the type #{\mathrm{coeq}(f_2, g_2) \to C}.
}



%```agda
\agda{
module _  {ğ“¤â‚ ğ“¤â‚‚ ğ“¥â‚ ğ“¥â‚‚ ğ“¦} {Aâ‚ : Type ğ“¤â‚} {Aâ‚‚ : Type ğ“¤â‚‚} {Bâ‚ : Type ğ“¥â‚} {Bâ‚‚ : Type ğ“¥â‚‚} where

  BiCofork : (fâ‚ gâ‚ : Aâ‚ â†’ Bâ‚) (fâ‚‚ gâ‚‚ : Aâ‚‚ â†’ Bâ‚‚) (C : Type ğ“¦) â†’ Type (ğ“¤â‚ âŠ” ğ“¤â‚‚ âŠ” ğ“¥â‚ âŠ” ğ“¥â‚‚ âŠ” ğ“¦)
  BiCofork fâ‚ gâ‚ fâ‚‚ gâ‚‚ C =
    Î£[ c âˆ¶ (Bâ‚ â†’ Bâ‚‚ â†’ C) ]
    Î£[ H âˆ¶ (âˆ€ a b â†’ c (fâ‚ a) b ï¼ c (gâ‚ a) b) ]
    Î£[ K âˆ¶ (âˆ€ b a â†’ c b (fâ‚‚ a) ï¼ c b (gâ‚‚ a)) ]
    âˆ€ aâ‚ aâ‚‚ â†’ Square (K (fâ‚ aâ‚) aâ‚‚) (K (gâ‚ aâ‚) aâ‚‚) (H aâ‚ (fâ‚‚ aâ‚‚)) (H aâ‚ (gâ‚‚ aâ‚‚))


  inner-Coforkâ†BiCofork : {fâ‚ gâ‚ : Aâ‚ â†’ Bâ‚} {fâ‚‚ gâ‚‚ : Aâ‚‚ â†’ Bâ‚‚} {C : Type ğ“¦}
                        â†’ BiCofork fâ‚ gâ‚ fâ‚‚ gâ‚‚ C
                        â†’ (bâ‚ : Bâ‚) â†’ Cofork fâ‚‚ gâ‚‚ C
  inner-Coforkâ†BiCofork  (c , (H , (K , S))) bâ‚ = c bâ‚ ,  K bâ‚

  Coforkâ†BiCofork :  {fâ‚ gâ‚ : Aâ‚ â†’ Bâ‚} {fâ‚‚ gâ‚‚ : Aâ‚‚ â†’ Bâ‚‚} {C : Type ğ“¦}
                  â†’ BiCofork fâ‚ gâ‚ fâ‚‚ gâ‚‚ C
                  â†’ Cofork fâ‚ gâ‚ ((Coeq fâ‚‚ gâ‚‚) â†’ C)
  Coforkâ†BiCofork {fâ‚ = fâ‚} {gâ‚} {fâ‚‚} {gâ‚‚} (c , (H , (K , S)))
    = (Î» bâ‚ â†’ coeq-rec (inner-Coforkâ†BiCofork (c , (H , (K , S))) bâ‚)) ,
         Î» aâ‚ â†’ funextâ†’ (coeq-ind ((H aâ‚)
                        , Î» aâ‚‚ â†’ Idáµˆ-funcâ†Square
                           {f = coeq-rec (c (fâ‚ aâ‚) , K (fâ‚ aâ‚))}
                           {g = coeq-rec (c (gâ‚ aâ‚) , K (gâ‚ aâ‚))}
                           (coeq fâ‚‚ gâ‚‚ .snd aâ‚‚) (H aâ‚ (fâ‚‚ aâ‚‚)) (H aâ‚ (gâ‚‚ aâ‚‚))
                             (coe (sym (ap (Î» x â†’ Square x _ (H aâ‚ (fâ‚‚ aâ‚‚)) (H aâ‚ (gâ‚‚ aâ‚‚))) (coeq-rec-apÎ² _)
                                       âˆ™ ap (Î» x â†’ Square _ x (H aâ‚ (fâ‚‚ aâ‚‚)) (H aâ‚ (gâ‚‚ aâ‚‚))) (coeq-rec-apÎ² _)))
                                  (S aâ‚ aâ‚‚))))

  coeq-recâ‚‚ : {fâ‚ gâ‚ : Aâ‚ â†’ Bâ‚} {fâ‚‚ gâ‚‚ : Aâ‚‚ â†’ Bâ‚‚} {C : Type ğ“¦}
            â†’ BiCofork fâ‚ gâ‚ fâ‚‚ gâ‚‚ C â†’ Coeq fâ‚ gâ‚ â†’ Coeq fâ‚‚ gâ‚‚ â†’ C
  coeq-recâ‚‚ = coeq-rec âˆ˜ Coforkâ†BiCofork

  coeq-recâ‚‚Î² : {fâ‚ gâ‚ : Aâ‚ â†’ Bâ‚} {fâ‚‚ gâ‚‚ : Aâ‚‚ â†’ Bâ‚‚} {C : Type ğ“¦}
               â†’ (BC : BiCofork fâ‚ gâ‚ fâ‚‚ gâ‚‚ C)
               â†’ âˆ€ bâ‚ bâ‚‚ â†’ coeq-recâ‚‚ BC (Î¹-coeq bâ‚) (Î¹-coeq bâ‚‚) ï¼ (fst BC) bâ‚ bâ‚‚
  coeq-recâ‚‚Î² BC bâ‚ bâ‚‚ =
    coeq-recâ‚‚ BC (Î¹-coeq bâ‚) (Î¹-coeq bâ‚‚)                  ï¼âŸ¨  happly (coeq-recÎ² (Coforkâ†BiCofork BC) bâ‚) (Î¹-coeq bâ‚‚) âŸ©
    coeq-rec (inner-Coforkâ†BiCofork BC bâ‚ )  (Î¹-coeq bâ‚‚)  ï¼âŸ¨  coeq-recÎ² (inner-Coforkâ†BiCofork BC bâ‚) bâ‚‚ âŸ©
      (fst BC) bâ‚ bâ‚‚ âˆ
}
%```
}

\subtree[stt-009D]{
\title{Adjusting coequalizers by equivalences}

\p{We mirror the results in \ref{stt-0083} about pushouts.

Given a pair of maps #{f g : A \to B} and an equivalence #{e : A' \to A},
we show that a cofork coequalises #{(f,g)} iff it coequalises
#{(fe,ge)}.}

%```agda
\agda{
postcomp-cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                   (f g : A â†’ B)
                   (h : A' â†’ A) {D : Type ğ“›}
                 â†’ Cofork f g D
                 â†’ Cofork (f âˆ˜ h) (g âˆ˜ h) D
postcomp-cofork _ _ h = total-map Î» f â†’ _â–¸ h


postcomp-cofork-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
      (f g : A â†’ B) {h : A' â†’ A} â†’ is-equiv h
    â†’ {D : Type ğ“›} â†’ is-equiv (postcomp-cofork f g h {D})
postcomp-cofork-is-equiv f g heq {D}
  = is-total-equivâ†is-fibrewise-equiv Î» a â†’ prewhisker-equiv-is-equiv heq

postcomp-cofork-is-coeq
 : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
     {f g : A â†’ B}
     {h : A' â†’ A} â†’ is-equiv h
   â†’ {D : Type ğ“›}
   â†’ {cf : Cofork f g D}
   â†’ is-coeq cf
   â†’ is-coeq (postcomp-cofork _ _ h cf)
postcomp-cofork-is-coeq {f = f}{g}{h} heq {D} {cf} coeq
  = is-equiv-âˆ˜ (postcomp-cofork-is-equiv _ _ heq) coeq


postcomp-coeqâ‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                  {f g : A â†’ B} {h : A' â†’ A} â†’ is-equiv h
                â†’ Coeq (f âˆ˜ h) (g âˆ˜ h) â‰ƒ Coeq f g
postcomp-coeqâ‰ƒ {f = f}{g}{h} heq
  = mkâ‰ƒ map (cogap-is-equivâ†is-coeq
              (postcomp-cofork-is-coeq heq coeq-is-coeq)) where
  map : Coeq (f âˆ˜ h) (g âˆ˜ h) â†’ Coeq f g
  map = coeq-rec (postcomp-cofork f g h (coeq _ _))
}
%```

\p{We dualise this to precomposing coforks.}

%```agda
\agda{
precomp-cofork : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
                   (f g : A â†’ B)
                   (h : B â†’ B') {D : Type ğ“›}
                 â†’ Cofork (h âˆ˜ f) (h âˆ˜ g) D
                 â†’ Cofork f g D
precomp-cofork f g h = total-map-fst (_âˆ˜ h)

precomp-cofork-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
      (f g : A â†’ B) {h : B â†’ B'} â†’ (heq : is-equiv h)
    â†’ {D : Type ğ“›} â†’ is-equiv (precomp-cofork f g h {D})
precomp-cofork-is-equiv f g {h} heq {D}
  = total-is-equivâ†fst-is-equiv (precomp-equiv heq)

precomp-cofork-is-coeq
 : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
     {f g : A â†’ B} {h : B â†’ B'} â†’ is-equiv h
   â†’ {D : Type ğ“›}
   â†’ {cf : Cofork (h âˆ˜ f) (h âˆ˜ g) D}
   â†’ is-coeq cf
   â†’ is-coeq (precomp-cofork _ _ h cf)
precomp-cofork-is-coeq {f = f}{g}{h} heq {D} {cf} coeq
  = is-equiv-âˆ˜ (precomp-cofork-is-equiv _ _ heq) coeq

precomp-coeqâ‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
                  {f g : A â†’ B} {h : B â†’ B'} â†’ is-equiv h
                â†’ Coeq f g â‰ƒ Coeq (h âˆ˜ f) (h âˆ˜ g)
precomp-coeqâ‰ƒ {f = f}{g}{h} heq
  = mkâ‰ƒ map (cogap-is-equivâ†is-coeq
              (precomp-cofork-is-coeq heq coeq-is-coeq)) where
  map : Coeq f g â†’ Coeq (h âˆ˜ f) (h âˆ˜ g)
  map = coeq-rec (precomp-cofork f g h (coeq _ _))
}
%```
}

\subtree[stt-009J]{
\title{Coequalisers of homotopic maps}
\taxon{Lemma}

\p{Given maps #{f,g,f',g' : A \to B} if #{f ~ f'} and #{g ~ g'} then
the coequaliser of #{f} and #{g} is equivalent to the coequalisers of
#{f'} and #{g'}.}

%```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f g h k : A â†’ B}
         (H : f ~ h) (K : g ~ k) where
  Coeqâ‰ƒâ†homotopy : Coeq h k â‰ƒ Coeq f g
  Coeqâ‰ƒâ†homotopy = Pushoutâ‰ƒâ†homotopy (âŠ-ind (~refl , H))
                                     (âŠ-ind (~refl , K))

postcomp-coeqâ‰ƒ~ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A' : Type ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                  {f g : A â†’ B} {h : A' â†’ A} (heq : is-equiv h)
                  {f' g' : A' â†’ B} (H : f âˆ˜ h ~ f') (K : g âˆ˜ h ~ g')
                â†’ Coeq f' g' â‰ƒ Coeq f g
postcomp-coeqâ‰ƒ~ {f = f}{g}{h} heq {f'}{g'} H K
  = Coeq f' g'           â‰ƒâŸ¨ Coeqâ‰ƒâ†homotopy H K âŸ©
    Coeq (f âˆ˜ h) (g âˆ˜ h) â‰ƒâŸ¨ postcomp-coeqâ‰ƒ heq âŸ©
    Coeq f g â‰ƒâˆ

precomp-coeqâ‰ƒ~ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {B' : Type ğ“¦}
                  {f g : A â†’ B} {h : B â†’ B'} (heq : is-equiv h)
                  {f' g' : A â†’ B'} (H : f' ~ h âˆ˜ f) (K : g' ~ h âˆ˜ g)
                â†’ Coeq f g â‰ƒ Coeq f' g'
precomp-coeqâ‰ƒ~ {f = f}{g}{h} heq {f'}{g'} H K
  = Coeq f g             â‰ƒâŸ¨ precomp-coeqâ‰ƒ heq âŸ©
    Coeq (h âˆ˜ f) (h âˆ˜ g) â‰ƒâŸ¨ Coeqâ‰ƒâ†homotopy H K âŸ©
    Coeq f' g' â‰ƒâˆ
}
%```
}
