\date{2025-11-17}
\title{Precategories}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Precategories
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.ModalMaps

open import Core.Join
open import Core.CanonicalPushouts
open import Core.FlatteningPushouts
open import Core.Postwhisker

open import Data.Bool

open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Hom Î”Â¹ i0 i1

open import Ergonomics.Extensionality
}
%```


\subtree[stt-00AI]{
\title{Precategories}
\taxon{Definition}


\p{We say that a type is a \strong{precategory} or that it is a \strong{Segal}
type if it is local with respect to the inclusion of the [#{(2,1)} horn](stt-00AD)
into the 2-simplex. We can use the fact that [being local with respect to some
class of maps forms a global reflective subuniverse](stt-0066) to bootstrap some
useful notions, such as preservation under identity and pi types as well as the
localisation operation. Note that unlike in the case of [simplicial types](stt-00AC)
this subuniverse is neither #{\Sigma}-closed nor lex.}

\p{We call maps which are local to the inner horn inclusion \strong{inner maps}.}

%```agda
\agda{
open Subtype

is-precategory : âˆ€ {ğ“¤} (C : Type ğ“¤) â†’ Type (ğ“¤ âŠ” ğ“˜)
is-precategory = is-local Î» (tt : ğŸ™) â†’ Î›[2,1]-incl

Precats-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Precats-SubU = Local-SubU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl) _

Precats-GSU : GSU (_âŠ” ğ“˜)
Precats-GSU = Local-GSU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

Precats-is-globally-reflective
   : is-globally-reflective Precats-GSU
Precats-is-globally-reflective
  = Local-global-reflectors (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

module Precat where
  open GSU Precats-GSU public renaming (S-equiv to is-precategoryâ†equiv)

  open is-globally-reflective Precats-is-globally-reflective
  open GPiClosure Precats-is-globally-reflective public
    renaming (Î âˆˆS to Î -is-precategory; Ã—âˆˆS to Ã—-is-precategory)

  is-inner : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
  is-inner = is-modal-map Precats-SubU
}
%```
}

\subtree[stt-00AK]{
\title{Composite morphisms}
\taxon{Definition}

\p{Given the data of the boundary of a 2-simplex:}

\quiver{
\begin{tikzcd}
        x && y \\
	\\
	&& z
	\arrow["g", from=1-1, to=1-3]
	\arrow["h"', from=1-1, to=3-3]
	\arrow["f", from=1-3, to=3-3]
\end{tikzcd}
}

\p{We define the type of fillers, written #{\Hom 2(f,g;h)}, which we say witnesses
that #{fg \sim h}.}

%```agda
\agda{
Hom2 : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
         (f : Hom _ y z) (g : Hom _ x y) (h : Hom _ x z)
       â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom2 {A = A} f g h = Ext Î´Î”Â²-incl (make-Î´Î”Â² f g h)
}
%```
}


\subtree[stt-00AL]{
\title{Morphisms have unique composites in a precategory}
\taxon{Theorem}

\p{Given a pair of composable morphisms, we can naturally define a map
#{\Delta^2_1 \to C}. We show that there is a unique 2-simplex that extends
#{f} and #{g}.}


\proof{
\p{[Precategories](stt-00AI) are defined to be those types which are local
with respect to the inclusion #{i : \Lambda^2_1 \hookrightarrow \Delta^2}. The
fibres of #{i^* : (\Delta^2 \to C) \to (\Lambda^2_1 \to C)} are exactly the maps
#{\Delta^2 \to C} which extend the boundary #{f,g}.}
}

%```agda
\agda{
opaque
  precategory-unique-composite : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ is-precategory A
                               â†’ (f : Hom A y z) (g : Hom A x y)
                               â†’ is-singleton (Î£[ H âˆ¶ (Î”Â² â†’ A)]
                                                 (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g))
  precategory-unique-composite Apc f g
    = is-contr-mapâ†is-equiv (Apc tt) (make-horn f g)



private
  ext-Î›[2,1]â‰ƒ
    : âˆ€ {ğ“¤} {A : Type ğ“¤} (fg : Î›[2,1] â†’ A)
    â†’ Ext Î´Î”Â²â†Î›[2,1] {Î» _ â†’ A} fg â‰ƒ Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1))
  ext-Î›[2,1]â‰ƒ {_} {A} fg
    = Ext Î´Î”Â²â†Î›[2,1] fg â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» cc â†’ pushout-rec cc âˆ˜ Î¹â‚ ï¼ fg}
                                      Pushout-UPâ‰ƒ  âŸ©
      Î£[ cc âˆ¶ Cocone _ A ] (cc .Cocone.p ï¼ fg)
                        â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» cr â†’ cr .fst ï¼ fg} cocone-reprâ‰ƒ âŸ©
      _ â‰ƒâŸ¨ remove-singleton-structure Sing'-is-singleton (fg , refl) âŸ©
      Î£[ h âˆ¶ (Î”Â¹ â†’ A) ]
          (fg âˆ˜ Î´Î›[2,1]-incl ~ h âˆ˜ Î´Î”Â¹-incl)
                        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î´Î”Â¹-UP eâ»Â¹ âˆ™â‰ƒ (symâ‰ƒ Ã—â‰ƒ symâ‰ƒ)) âŸ©
      _                 â‰ƒâŸ¨ HomP-reprâ‰ƒ eâ»Â¹ âŸ©
      Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1)) â‰ƒâˆ

ext-Î›[2,1]
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (fg : Î›[2,1] â†’ A)
    â†’ Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1)) â†’ Ext Î´Î”Â²â†Î›[2,1] {Î» _ â†’ A} fg
ext-Î›[2,1] {A = A} fg
  = total-map-fst cogap âˆ˜ map1 module ext-Î›[2,1] where
  map1 : Hom A _ _ â†’ Î£[ cc âˆ¶ Cocone (mk-span Î´Î”Â¹ Î´Î›[2,1]-incl Î´Î”Â¹-incl) _ ]
                        (cc .Cocone.p ï¼ fg)
  map1 h@(mk-hom hh h0 h1) = (mk-cocone fg hh (Î´Î”Â¹-UPâ†’ (sym h0 , sym h1)) , refl)

  map1' : Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1))
        â†’ Î£[ cc âˆ¶ Cocone (mk-span Î´Î”Â¹ Î´Î›[2,1]-incl Î´Î”Â¹-incl) _ ]
                        (cc .Cocone.p ï¼ fg)
  map1' = total-map-fst (_â‰ƒ_.bwd cocone-reprâ‰ƒ )
        âˆ˜ _â‰ƒ_.bwd (remove-singleton-structure Sing'-is-singleton (_ , refl))
        âˆ˜ total-map (Î» x â†’ Î´Î”Â¹-UPâ†’ âˆ˜ (sym âŠ— sym))
        âˆ˜ HomP-reprâ‰ƒ ._â‰ƒ_.fwd

  map1-is-equiv : is-equiv map1
  map1-is-equiv
    = is-equiv-âˆ˜
        (total-is-equivâ†fst-is-equiv
          (is-equivâ»Â¹ (_â‰ƒ_.has-is-eqv cocone-reprâ‰ƒ)))
        (is-equiv-âˆ˜
          (is-equivâ»Â¹ (_â‰ƒ_.has-is-eqv
            (remove-singleton-structure Sing'-is-singleton (_ , refl))))
          (is-equiv-âˆ˜
            (is-total-equivâ†is-fibrewise-equiv
              (Î» a â†’ is-equiv-âˆ˜ (Î´Î”Â¹-UP ._â‰ƒ_.has-is-eqv)
                                (âŠ—-is-equiv sym-is-equiv sym-is-equiv)))
            (HomP-reprâ‰ƒ ._â‰ƒ_.has-is-eqv)))

ext-Î›[2,1]-is-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (fg : Î›[2,1] â†’ A)
    â†’ is-equiv (ext-Î›[2,1] fg)
ext-Î›[2,1]-is-equiv fg
  = is-equiv-âˆ˜
      (total-is-equivâ†fst-is-equiv pushout-rec-is-equiv)
      (ext-Î›[2,1].map1-is-equiv fg)

adjust-hom : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y x' y'} (p : Id (A Ã— A) (x , y) (x' , y'))
             â†’ Hom A x y â†’ Hom A x' y'
adjust-hom p (mk-hom fh f0 f1) = mk-hom fh (f0 âˆ™ ap fst p) (f1 âˆ™ ap snd p)

adjust-hom-is-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y x' y'} (p : Id (A Ã— A) (x , y) (x' , y'))
  â†’ is-equiv (adjust-hom p)
adjust-hom-is-equiv refl
  = homotopy-is-equiv (Î» _ â†’ Hom-extâ†’ (~refl , âˆ™-reflr _ , âˆ™-reflr _))
                      id-is-equiv

make-Î´Î”Â²-is-extension
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      (h : Hom A x z) â†’ make-Î´Î”Â² f g h âˆ˜ Î´Î”Â²â†Î›[2,1] ï¼ make-horn f g
make-Î´Î”Â²-is-extension f g h = refl

ext-mk-horn : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
             â†’ Hom A x z â†’ Ext Î´Î”Â²â†Î›[2,1] {Î» _ â†’ A} (make-horn f g)
ext-mk-horn {_} {A} f g h = (make-Î´Î”Â² f g h , make-Î´Î”Â²-is-extension f g h)

opaque
  ext-mk-horn-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      â†’ is-equiv (ext-mk-horn f g)
  ext-mk-horn-is-equiv f g
    = homotopy-is-equiv
       (Î» where
          h@(mk-hom hh refl refl) â†’ fibre-pathâ†’ (funextâ†’ (pushout-rec-unique _ _ ~refl ~refl
                               (~âˆ™-reflr _ ~âˆ™ pushout-rec-apÎ²
                               ~âˆ™ Î´Î”Â¹-UPâ†’ ( ap sym Ã—-path-ap-fst âˆ™ sym-sym âˆ™ sym (âˆ™-reflr _)
                                          , ap sym Ã—-path-ap-snd âˆ™ sym-sym âˆ™ sym (âˆ™-reflr _))))
                       , âˆ™-reflr _ âˆ™  sym (commutes-postwhisker-funext _) âˆ™ funext-refl))
       (is-equiv-âˆ˜ (ext-Î›[2,1]-is-equiv (make-horn f g))
                   (adjust-hom-is-equiv
                     (Ã—-pathâ†’ (sym (g .HomP.hom0) , sym (f .HomP.hom1)))))

compositeâ†horn-extension
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
    â†’ Î£[ H âˆ¶ (Î”Â² â†’ A)] (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g)
    â†’ Î£[ h âˆ¶ Hom A x z ] (Hom2 f g h)
compositeâ†horn-extension {A = A} {x} {y} {z} f g
  = total-map-fst (is-equiv.bwd (ext-mk-horn-is-equiv f g))
  âˆ˜ total-map (Î» a â†’ tr (Ext Î´Î”Â²-incl)
                        (sym (ap fst (is-equiv.Îµ (ext-mk-horn-is-equiv f g) a))))
  âˆ˜ Ext-compose Î´Î”Â²-incl Î´Î”Â²â†Î›[2,1] (make-horn f g) ._â‰ƒ_.fwd

opaque
  compositeâ†horn-extension-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      â†’ is-equiv (compositeâ†horn-extension f g)
  compositeâ†horn-extension-is-equiv f g
    = is-equiv-âˆ˜
       (total-is-equivâ†fst-is-equiv (is-equivâ»Â¹ (ext-mk-horn-is-equiv f g)))
       (is-equiv-âˆ˜
         (is-total-equivâ†is-fibrewise-equiv (Î» a â†’
           tr-is-equiv {B = Ext Î´Î”Â²-incl}
             (sym (ap fst (is-equiv.Îµ (ext-mk-horn-is-equiv f g) a)))))
         (Ext-compose _ _ (make-horn f g) ._â‰ƒ_.has-is-eqv))

Î”Â²-UP-inv : âˆ€ {ğ“¤} {A : Type ğ“¤}
        â†’ (Î”Â² â†’ A)
        â†’ Î£[ g âˆ¶ (Î”Â¹ â†’ A) ]
           Î£[ z âˆ¶ A ] Î£[ f âˆ¶ Hom A (g i1) z ]
             Î£[ h âˆ¶ Hom A (g i0) z ] Hom2 f (Î»hom g) h
Î”Â²-UP-inv H = (H âˆ˜ (_, i0)
           , (H (i1 , i1))
           , mk-hom (H âˆ˜ (i1 ,_)) (ap H Î”Â²-refl) (ap H Î”Â²-refl)
           , mk-hom (H âˆ˜ Î”Â²-diagonal) (ap H Î”Â²-refl) refl
           , (H , funextâ†’ (pushout-rec-unique _ _
                   (pushout-ind _
                     (mk-coconeD ~refl ~refl Î» _
                      â†’ IdP-funcâ†Square (glue tt) refl refl
                          (âˆ™-reflr _
                          âˆ™ ap-âˆ˜ H _ (glue tt)
                          âˆ™ ap (ap H) (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _) âˆ™ ap-sym _ _ âˆ™ sym (pushout-rec-apÎ² tt))))
                   ~refl
               Î» { (mk-lift true) â†’ âˆ™-reflr _ âˆ™ ap-âˆ˜ H _ (glue Î´Î”Â¹-1)
                                    âˆ™ ap (ap H) (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
                                    âˆ™ sym (âˆ™-reflr _)
               ; (mk-lift false) â†’ âˆ™-reflr _
                                   âˆ™ ap-âˆ˜ H _ (glue Î´Î”Â¹-0)
                                   âˆ™ ap (ap H) (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
                                   âˆ™ ap-sym _ _ })))

-- Î”Â²-UPâ†’ : âˆ€ {ğ“¤} {A : Type ğ“¤}
--         â†’ Î£[ g âˆ¶ (Î”Â¹ â†’ A) ]
--            Î£[ z âˆ¶ A ] Î£[ f âˆ¶ Hom A (g i1) z ]
--              Î£[ h âˆ¶ Hom A (g i0) z ] Hom2 f (Î»hom g) h
--         â†’ (Î”Â² â†’ A)
-- Î”Â²-UPâ†’ (g , z , f , h , K) = K .fst

-- Î”Â²-UP-is-equiv : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-equiv (Î”Â²-UPâ†’ {A = A})
-- Î”Â²-UP-is-equiv = {!!}


_âˆ˜[_]_ :  âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ Hom A y z â†’ is-precategory A
          â†’ Hom A x y â†’ Hom A x z
f âˆ˜[ apc ] g = fst (compositeâ†horn-extension f g
                    (centre (precategory-unique-composite apc f g)))

âˆ˜[_]-is-composite
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} {f : Hom A y z} {g : Hom A x y}
    â†’ (apc : is-precategory A) â†’ Hom2 f g (f âˆ˜[ apc ] g)
âˆ˜[_]-is-composite {f = f} {g} apc
  = snd (compositeâ†horn-extension _ _
          (centre (precategory-unique-composite apc f g)))

opaque
  unique-composite : âˆ€ {ğ“¤} {A : Type ğ“¤} (apc : is-precategory A)
                       {x y z} (f : Hom A y z) (g : Hom A x y)
                    â†’ (h : Hom A x z) â†’ Hom2 f g h â†’ h ï¼ (f âˆ˜[ apc ] g)
  unique-composite apc f g h K
    = sym (ap fst
             ((is-singleâ†equiv-to-single
                (mkâ‰ƒ (compositeâ†horn-extension f g)
                     (compositeâ†horn-extension-is-equiv f g))
                (precategory-unique-composite apc f g)) .central (h , K)))
}
%```
}
