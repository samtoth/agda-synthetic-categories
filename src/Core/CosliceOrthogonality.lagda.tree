\title{Orthogonality of Coslice maps}
\taxon{Module}
\author{samueltoth}
\date{2026-02-02}
\import{stt-macros}

%```agda
\agda{
module Core.CosliceOrthogonality where

open import Foundations.Prelude
open import ufAxioms

open import Core.CoSlice
open import Core.CanonicalPushouts
open import Core.Orthogonal
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.SpanMap
open import Core.FunctorialPushout
open import Core.FunctorialPullback

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open Core.Orthogonal.notation
}
%```


\subtree[tot-000L]{
\title{Orthogonality with respect to coslice maps}
\taxon{Definition}

\p{Given a map in the coslice #{f : p \to_X q}, and some element #{x} in the
coslice under #{X}, we say that #{f} is orthogonal to #{x} (or #{f \perp x})
when coslice postcomposition by #{f} at #{x} is an equivalence.}

%```agda
\agda{
are-orthogonal-coslice
  : âˆ€ {ğ“§ ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“§} {A : Type ğ“¤} {B : Type ğ“¥} {p : X â†’ A} {q : X â†’ B}
      {Y : Type ğ“¦}
    â†’ (F : Coslice-map p q) â†’ (X â†’ Y) â†’ Type (ğ“§ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
are-orthogonal-coslice F k = is-equiv (Coslice-map-postcompose k F)

instance
  Orthogonal-coslice-notation
    : âˆ€ {ğ“§ ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“§} {A : Type ğ“¤} {B : Type ğ“¥} {p : X â†’ A} {q : X â†’ B}
        {Y : Type ğ“¦}
      â†’ Orthogonality (Coslice-map p q) (X â†’ Y)
  Orthogonal-coslice-notation {ğ“§} {ğ“¤} {ğ“¥} {ğ“¦}.Orthogonality.ğ“¦
    = ğ“§ âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦
  Orthogonal-coslice-notation .Orthogonality._âŠ¥_ = are-orthogonal-coslice
}
%```
}


\subtree[tot-0008]{
\title{Coslice orthogonality is orthogonaliy of the underlying map}
\taxon{Lemma}

\p{Given a map #{f} in the [coslice](stt-0062) #{p \to_X q}, #{f} is orthogonal
to every map #{X \to Y} iff #{f} is left orthogonal to #{Y}.
}

%```agda
\agda{
coslice-orthogonality
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
      {p : X â†’ A} {q : X â†’ B} (f : Coslice-map p q)
    â†’ (f .fst âŠ¥ Y)
    â‡” (âˆ€ (x : X â†’ Y) â†’ f âŠ¥ x)
coslice-orthogonality {A = A}{B}{X}{Y}{p}{q} (f , H)
  = topâ‡”bot-is-equivâ†Arrow-equiv (amap (funextâ†’ H)) eq âˆ™â‡” fibrewiseâ‡”total-is-equiv where

  add-singleton : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q) (g : Q â†’ Y)
                  â†’ Î£[ x âˆ¶ (X â†’ Y) ] Î£[ f' âˆ¶ (Q â†’ Y) ] (f' âˆ˜ p ~ x)
  add-singleton f g = (g âˆ˜ f , g , ~refl)

  add-singleton-eq : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q)
                     â†’ quasi-iso (add-singleton p)
  add-singleton-eq p .fst (a , f , H) = f
  add-singleton-eq p .snd .fst x = refl
  add-singleton-eq p .snd .snd (a , f , H)
    = funext-rec
        (Î» H â†’ ((f âˆ˜ p) , (f , ~refl)) ï¼ (a , (f , H)))
        (Î» where refl â†’ refl)
        H

  amap : âˆ€ (H : f âˆ˜ p ï¼ q)
         â†’ Arrow-map (postcomp Y f)
                     (total-map (Î» a â†’ Coslice-map-postcompose a (f , happly H)))
  amap H .Arrow-map.top = add-singleton q
  amap H .Arrow-map.bot = add-singleton p
  amap refl .Arrow-map.comm x = refl

  eq : is-Arrow-equiv (amap (funextâ†’ H))
  eq .fst = is-equivâ†qiso (add-singleton-eq q)
  eq .snd = is-equivâ†qiso (add-singleton-eq p)
}
%```
}

\subtree[tot-000M]{
\taxon{Lemma}

\p{Given a diagram as follows:}

\quiver{
\begin{tikzcd}
	A \\
	&& B && C \\
	{A'}
	\arrow["F"', from=1-1, to=3-1]
	\arrow["f"', from=2-3, to=1-1]
	\arrow["g", from=2-3, to=2-5]
	\arrow["{f'}", from=2-3, to=3-1]
\end{tikzcd}
}

\p{We can take the pushout of the top span, and the bottom span, and by
functoriality, the coslice map #{F} gives us a map of pushouts. We give an
equivalence of arrows between postcomposition of the pushout map and
the map between the pullbacks associated to the corresponding postcomposition
cospans. As an easy corrolary we get the result that #{F} is orthogonal
to #{qg} for all maps #{q : C \to Q} iff the pushout map induced by
#{F} is orthogonal to #{Q}.}

%```agda
\agda{
pushout-arrow-UP
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“ } {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : B â†’ A) (f' : B â†’ A') (g : B â†’ C) â†’ (F : Coslice-map f f')
        {Q : Type ğ“ }
      â†’ Arrow-map
         (postcomp Q (Pushoutâ‚ {S = mk-span _ f g}
                     (mk-span-map (F .fst) id id (F .snd) ~refl)))
         (Pullbackâ‚ {S = mk-cospan _  (postcomp Q g) (postcomp Q f')}
                    {T = mk-cospan _ (postcomp Q g) (postcomp Q f)}
                    (mk-cospan-map id id (postcomp Q (F .fst))
                                   ~refl (Î» h â†’ funextâ†’ (ap h âˆ˜ sym âˆ˜ F .snd))))
pushout-arrow-UP f f' g F .Arrow-map.top
  = postcomp-coconeâ‰ƒpb ._â‰ƒ_.fwd âˆ˜ cocone-map _ pushout
pushout-arrow-UP f f' g F .Arrow-map.bot
  = postcomp-coconeâ‰ƒpb ._â‰ƒ_.fwd âˆ˜ cocone-map _ pushout
pushout-arrow-UP f f' g F .Arrow-map.comm a = pullback-pathâ†’
  ( refl
  , refl
  , sym (âˆ™-reflr _
    âˆ™ ap (funextâ†’)
      (funextâ†’ (Î» b â†’ ap sym (ap-âˆ˜ a _ (glue b)
                             âˆ™ ap (ap a) (pushout-rec-apÎ² b
                             âˆ™ ap (ap Î¹â‚ (F .snd b) âˆ™_) (âˆ™-reflr _)))))
      âˆ™ sym (ap (_âˆ™ funextâ†’ (ap (a âˆ˜ Î¹â‚) âˆ˜ sym âˆ˜ F .snd))
                (ap-id (funextâ†’ (sym âˆ˜ ap a âˆ˜ glue)))
      âˆ™ sym (funext-âˆ™ (sym âˆ˜ ap a âˆ˜ glue) (ap (a âˆ˜ Î¹â‚) âˆ˜ sym âˆ˜ F .snd))
      âˆ™ ap funextâ†’ (funextâ†’ (Î» b
          â†’ ap (sym (ap a (glue b)) âˆ™_)
               (ap-sym (a âˆ˜ Î¹â‚) (F .snd b) âˆ™ ap sym (ap-âˆ˜ a Î¹â‚ (F .snd b)))
               âˆ™ sym (âˆ™-symsym (ap a (ap Î¹â‚ (F .snd b))) (ap a (glue b)))
               âˆ™ ap sym (sym (ap-âˆ™ a (ap Î¹â‚ (F .snd b)) (glue b))))))))

pushout-arrow-UP-is-equiv
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“ } {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        (f : B â†’ A) (f' : B â†’ A') (g : B â†’ C) â†’ (F : Coslice-map f f')
        {Q : Type ğ“ }
      â†’ is-Arrow-equiv (pushout-arrow-UP f f' g F {Q})
pushout-arrow-UP-is-equiv f f' g F .fst
  = is-equiv-âˆ˜ (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv) Pushout-is-pushoutÏ‰
pushout-arrow-UP-is-equiv f f' g F .snd
  = is-equiv-âˆ˜ (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv) Pushout-is-pushoutÏ‰

opaque
  left-orthogonal-pushoutâ‚
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“ } {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : B â†’ A} {f' : B â†’ A'} {g : B â†’ C} â†’ (F : Coslice-map f f')
        {Q : Type ğ“ }
      â†’ ((Pushoutâ‚ {S = mk-span _ f g}
          (mk-span-map (F .fst) id id (F .snd) ~refl)) âŠ¥ Q)
      â‡” (âˆ€ (q : C â†’ Q) â†’ F âŠ¥ (q âˆ˜ g))
  left-orthogonal-pushoutâ‚ {A = A}{A'}{C = C} {f} {f'} {g} F {Q}
    = topâ‡”bot-is-equivâ†Arrow-equiv
        (pushout-arrow-UP f f' g F)
        (pushout-arrow-UP-is-equiv f f' g F)
        âˆ™â‡” fibrewiseâ‡”total-is-equiv
        âˆ™â‡” (precomp-Î -â‡”
             Î» q â†’ topâ‡”bot-is-equivâ†Arrow-equiv
                    (hom q)
                    ( is-total-equivâ†is-fibrewise-equiv
                        (Î» a â†’ is-equiv-âˆ˜ sym-is-equiv (is-equivâ»Â¹ global-funext))
                    , is-total-equivâ†is-fibrewise-equiv
                        (Î» a â†’ is-equiv-âˆ˜ sym-is-equiv (is-equivâ»Â¹ global-funext)))
                    â‡”â»Â¹)  where

    hom : âˆ€ (q : C â†’ Q)
          â†’ Arrow-map {A = Coslice-map f' (q âˆ˜ g)}
                      {B = Coslice-map f (q âˆ˜ g)}
                      (Coslice-map-postcompose (q âˆ˜ g) F)
                      {C = Î£[ x âˆ¶ (A' â†’ Q) ] (postcomp Q g q ï¼ postcomp Q f' x)}
                      {D = Î£[ x âˆ¶ (A â†’ Q) ] (postcomp Q g q ï¼ postcomp Q f x)}
                      (Î» G â†’
                          postcomp Q (F .fst) (G .fst)
                        , ap id (G .snd) âˆ™ funextâ†’ (ap (G .fst) âˆ˜ sym âˆ˜ F .snd))
    hom q .Arrow-map.top = total-map (Î» a â†’ sym âˆ˜ funextâ†’)
    hom q .Arrow-map.bot = total-map (Î» a â†’ sym âˆ˜ funextâ†’)
    hom q .Arrow-map.comm (x , p)
      = ext! (~refl , (sym (apâ‚‚ _âˆ™_
                             (ap-id (sym (funextâ†’ p)))
                             (ap funextâ†’ (funextâ†’ Î» b â†’ ap-sym x (F .snd b))
                               âˆ™ funext-sym _)
                      âˆ™ sym (âˆ™-symsym _ (funextâ†’ p))
                      âˆ™ ap sym (sym (funext-âˆ™ _ _)))))
}
%```
}
