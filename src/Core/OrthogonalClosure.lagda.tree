\title{Closure properties of orthogonal maps}
\taxon{Module}
\date{2025-12}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.OrthogonalClosure where

open import Foundations.Prelude

open import ufAxioms

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.ArrowRetract
open import Core.Orthogonal
open import Core.Cube
open import Core.PullbackPower
open import Core.Postwhisker
open import Core.CocartesianSquare
open import Core.PushoutSum
open import Core.CoSlice
open import Core.FunctorialPushout
open import Core.SpanMap

open notation
open import Ergonomics.Notations.Orthogonality
}
%```


\subtree[stt-00BU]{
\title{Being right orthogonal is preserved under pullback and equivalence}
\taxon{Lemma}
\date{2025-11-26}

\p{Given a [cartesian square](stt-003V) between maps #{g} and #{h}, then if
#{f \perp h}, #{f \perp g}.}


\proof{
\p{Consider the following [cube](stt-00B2):}

\quiver{
\begin{tikzcd}[cramped]
	& {C^Y} && {C^X} \\
	{A^Y} && {A^X} \\
	& {D^Y} && {D^X} \\
	{B^Y} && {B^X}
	\arrow[from=1-2, to=1-4]
	\arrow["{h_*}"'{pos=0.6}, from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow["{g_*}"', from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow["{f^*}"{pos=0.3}, from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow["{f^*}"', from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

\p{The left and right faces are cartesian since [precomposing a cartesian square
gives a cartesian square](stt-003R), then by our assumption the back square is
cartesian, [so the front square is cartesian](stt-00B3).}
}

%```agda
\agda{
power-hom-cubeâ†right-arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (g : X â†’ Y)
      {C : Type ğ“} {D : Type ğ“›} (g' : C â†’ D)
      (F : Arrow-map g g')
    â†’ Cube (power-hom f g) (power-hom f g')
power-hom-cubeâ†right-arrow-map f g g' F .Cube.left = postcomp-square F _
power-hom-cubeâ†right-arrow-map f g g' F .Cube.right = postcomp-square F _
power-hom-cubeâ†right-arrow-map f g g' F .Cube.comm .fst = ~refl
power-hom-cubeâ†right-arrow-map f g g' F .Cube.comm .snd .fst = ~refl
power-hom-cubeâ†right-arrow-map f g g' F .Cube.comm .snd .snd a
    = âˆ™-reflr _ âˆ™ âˆ™-reflr _ âˆ™ sym (commutes-prewhisker-funext _)

orthogonalâ†pullback
  : âˆ€ {ğ“¤ ğ“¥ ğ“ ğ“‘ ğ“’ ğ““} {X : Type ğ“¤} {Y : Type ğ“¥} (f : X â†’ Y)
      {A : Type ğ“} {B : Type ğ“‘} {C : Type ğ“’} {D : Type ğ““}
      {g : A â†’ B} {h : C â†’ D}
    â†’ (F : Arrow-map g h) â†’ is-cartesian F
    â†’ are-orthogonal f h â†’ are-orthogonal f g
orthogonalâ†pullback {X = X} {Y} f {A} {g = g}{h} F cart orth
  = orthogonalâ†is-cartesian
     (front-cartesianâ†cartesian-cube
       (power-hom f g) (power-hom f h)
       (power-hom-cubeâ†right-arrow-map _ _ _ F)
       (postcomp-cartesian F cart)
       (postcomp-cartesian F cart)
       (is-cartesianâ†orthogonal orth))
}
%```


\p{Similarly, if #{F : g \to h} is an equivalence, then
#{f \perp g \iff f \perp h}.}

%```agda
\agda{
right-orthogonalâ†equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“ ğ“‘ ğ“’ ğ““} {X : Type ğ“¤} {Y : Type ğ“¥} (f : X â†’ Y)
      {A : Type ğ“} {B : Type ğ“‘} {C : Type ğ“’} {D : Type ğ““}
      {g : A â†’ B} {h : C â†’ D}
    â†’ (F : Arrow-map g h) â†’ is-Arrow-equiv F
    â†’ are-orthogonal f h â†’ are-orthogonal f g
right-orthogonalâ†equiv f F Fe o
  = orthogonalâ†is-cartesian
      (front-cartesianâ†equiv-cube
        (power-hom-cubeâ†right-arrow-map f _ _ F)
        (postcomp-square-is-equiv F Fe , postcomp-square-is-equiv F Fe)
        (is-cartesianâ†orthogonal o))


right-orthogonalâ†equiv'
  : âˆ€ {ğ“¤ ğ“¥ ğ“ ğ“‘ ğ“’ ğ““} {X : Type ğ“¤} {Y : Type ğ“¥} (f : X â†’ Y)
      {A : Type ğ“} {B : Type ğ“‘} {C : Type ğ“’} {D : Type ğ““}
      {g : A â†’ B} {h : C â†’ D}
    â†’ (F : Arrow-map g h) â†’ is-Arrow-equiv F
    â†’ are-orthogonal f g â†’ are-orthogonal f h
right-orthogonalâ†equiv' f F Fe o
  = orthogonalâ†is-cartesian
      (back-cartesianâ†equiv-cube
        (power-hom-cubeâ†right-arrow-map f _ _ F)
        (postcomp-square-is-equiv F Fe , postcomp-square-is-equiv F Fe)
        (is-cartesianâ†orthogonal o))

right-orthogonal-iffâ†equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“ ğ“‘ ğ“’ ğ““} {X : Type ğ“¤} {Y : Type ğ“¥} (f : X â†’ Y)
      {A : Type ğ“} {B : Type ğ“‘} {C : Type ğ“’} {D : Type ğ““}
      {g : A â†’ B} {h : C â†’ D}
    â†’ (F : Arrow-map g h) â†’ is-Arrow-equiv F
    â†’ are-orthogonal f h â‡” are-orthogonal f g
right-orthogonal-iffâ†equiv f F Fe
  = (right-orthogonalâ†equiv f F Fe , right-orthogonalâ†equiv' f F Fe)
}
%```
}

\subtree[stt-00BW]{
\title{Right orthogonal maps are left cancellative}
\taxon{Lemma}

%```agda
\agda{
right-orthogonal-âˆ˜
  : âˆ€ {ğ“§ ğ“¨ ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“§} {Y : Type ğ“¨} (f : X â†’ Y)
      {A : Type ğ“¤}{B : Type ğ“¥} {C : Type ğ“¦}
      {g : B â†’ C} {h : A â†’ B}
    â†’ f âŠ¥ g â†’ f âŠ¥ h â†’ f âŠ¥ g âˆ˜ h
right-orthogonal-âˆ˜ h fg fh
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian _
        (compose-cartesian
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fg))
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fh))))

right-orthogonal-left-cancel
  : âˆ€ {ğ“§ ğ“¨ ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“§} {Y : Type ğ“¨} (f : X â†’ Y)
      {A : Type ğ“¤}{B : Type ğ“¥} {C : Type ğ“¦}
      {g : B â†’ C} {h : A â†’ B}
    â†’ f âŠ¥ g â†’ f âŠ¥ g âˆ˜ h â†’ f âŠ¥ h
right-orthogonal-left-cancel f fg fgh
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian _
        (3-for-2-cartesian
          Arrow-map-path-refl
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fgh))
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fg))))
}
%```
}

\subtree[stt-00BV]{
\title{Closure properties of left orthogonal maps}
\taxon{Theorem}

\subtree[stt-00C0]{
\p{In general, left orthogonal maps are closed under 'colimit' like operations.
Suppose any map labeled with an #{f} is left orthogonal to #{h}, then:}

\ol{
\li{#{f \times f' \perp h}}
\li{#{g \circ f \perp h} iff #{g \perp h}}
\li{#{\Sigma_{i}f_i \perp h}}
\li{If there is a cocartesian square #{f \to g}, then #{g \perp h}}
\li{If #{g} is a retract of #{f}, then #{g \perp h}}
\li{For \strong{any} #{g}, the pushout product #{f \pushprod g \perp h}}
}
}

%```agda
\agda{
power-hom-cubeâ†arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (f' : X â†’ Y)
      (F : Arrow-map f f')
      {C : Type ğ“} {D : Type ğ“›} (g : C â†’ D)
    â†’ Cube (rotate-square (power-hom f' g)) (rotate-square (power-hom f g))
power-hom-cubeâ†arrow-map f f' F g .Cube.left = precomp-square F _
power-hom-cubeâ†arrow-map f f' F g .Cube.right = precomp-square F _
power-hom-cubeâ†arrow-map f f' F g .Cube.comm .fst = ~refl
power-hom-cubeâ†arrow-map f f' F g .Cube.comm .snd .fst = ~refl
power-hom-cubeâ†arrow-map f f' F g .Cube.comm .snd .snd k
  = âˆ™-reflr _ âˆ™ âˆ™-reflr _
  âˆ™ sym (commutes-postwhisker-funext {h = g} _)
  âˆ™ ap funextâ†’ (funextâ†’ (â—‚âˆ˜ g k _ ~â»Â¹))

left-orthogonal-retract
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (f' : X â†’ Y)
      (F : Arrow-map f f') (R : retract-arrow-map F)
      {C : Type ğ“} {D : Type ğ“›} (g : C â†’ D)
      â†’ (f' âŠ¥ g) â†’ (f âŠ¥ g)
left-orthogonal-retract {A = A}{B} f f' F ret {C}{D} h f'h
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian _
        (retract-is-cartesian cube cube-ret
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal f'h)))) where
  cube : Cube (rotate-square (power-hom f h)) (rotate-square (power-hom f' h))
  cube = power-hom-cubeâ†arrow-map _ _ (ret .fst) h

  cube-ret : 1-coherent-retract-cube cube
  cube-ret .fst = power-hom-cubeâ†arrow-map _ _ F h
  cube-ret .snd .fst x = funextâ†’ (x â—‚ ret .snd .snd .fst)
  cube-ret .snd .snd
    = (ret-left .snd .fst
    ,  ret-right .snd .fst
    ,  ret-right .fst
    ,  (Î» f â†’ sym (ap-âˆ˜  (h âˆ˜_) (f âˆ˜_) (funextâ†’ (ret .snd .fst))))
    ,  Î» a â†’ sym
              (âˆ™-assoc
                (ap (_âˆ˜ Arrow-map.top F) (funextâ†’ (a â—‚ _)))
                (funextâ†’ ( a âˆ˜ Arrow-map.bot (ret .fst) â—‚ (Arrow-map.comm F ~â»Â¹)))
                ((precomp D f â—‚ ret-right .fst) a))
              âˆ™ ret-right .snd .snd a âˆ™ âˆ™-reflr _) where
    ret-left : Arrow-map-path
                (paste-squares (precomp-retract-square F ret .fst)
                               (precomp-square (ret .fst) C))
                id-square
    ret-left = retract-arrow-map-is-retract
                         (precomp-square (ret .fst) C)
                         (precomp-retract-square F ret)


    ret-right : Arrow-map-path
                (paste-squares (precomp-retract-square F ret .fst)
                               (precomp-square (ret .fst) D))
                id-square
    ret-right = retract-arrow-map-is-retract
                         (precomp-square (ret .fst) D)
                         (precomp-retract-square F ret)

left-orthogonal-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (f' : X â†’ Y)
      (F : Arrow-map f f') â†’ is-Arrow-equiv F
    â†’ {C : Type ğ“} {D : Type ğ“›} (g : C â†’ D)
    â†’ f âŠ¥ g â†’ f' âŠ¥ g
left-orthogonal-equiv f f' F Feq g fperp
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian _
        (front-cartesianâ†equiv-cube (power-hom-cubeâ†arrow-map _ _ F g)
          (precomp-square-is-equiv F Feq , precomp-square-is-equiv F Feq)
          (rotate-is-cartesian _ (is-cartesianâ†orthogonal fperp))))

left-orthogonal-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“} {B : Type ğ“¤} {C : Type ğ“¥} (f : B â†’ C)
      {A : Type ğ“¦} (g : A â†’ B)
      {X : Type ğ“œ} {Y : Type ğ“} (h : X â†’ Y)
    â†’ (f âŠ¥ h) â†’ (g âŠ¥ h) â†’ (f âˆ˜ g) âŠ¥ h
left-orthogonal-âˆ˜ f g h fh gh
  = orthogonalâ†is-cartesian
      (compose-cartesian
        (is-cartesianâ†orthogonal gh)
        (is-cartesianâ†orthogonal fh))

is-anodyne-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {f : B â†’ C} {g : A â†’ B}
      {X : Type ğ“§} {Y : Type ğ“¨} (h : X â†’ Y)
    â†’ is-anodyne f h â†’ is-anodyne g h â†’ is-anodyne (f âˆ˜ g) h
is-anodyne-âˆ˜ h fia gia k ko
  =  left-orthogonal-âˆ˜ _ _ _ (fia k ko) (gia k ko)

left-orthogonal-right-cancel
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“} {B : Type ğ“¤} {C : Type ğ“¥} {f : B â†’ C}
      {A : Type ğ“¦} {g : A â†’ B}
      {X : Type ğ“œ} {Y : Type ğ“} {h : X â†’ Y}
    â†’ (g âŠ¥ h) â†’ (f âˆ˜ g) âŠ¥ h â†’ (f âŠ¥ h)
left-orthogonal-right-cancel gh fgh
  = orthogonalâ†is-cartesian
      (3-for-2-cartesian
         Arrow-map-path-refl
         (is-cartesianâ†orthogonal fgh)
         (is-cartesianâ†orthogonal gh))

is-anodyne-right-cancel
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {f : B â†’ C} {g : A â†’ B}
      {X : Type ğ“§} {Y : Type ğ“¨} (h : X â†’ Y)
    â†’ is-anodyne (f âˆ˜ g) h â†’ is-anodyne g h â†’ is-anodyne f h
is-anodyne-right-cancel h fgia gia k ko
  = left-orthogonal-right-cancel (gia k ko) (fgia k ko)


left-orthogonal-homotopy
  : âˆ€ {ğ“¤ ğ“¥ ğ“œ ğ“} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B}
      {X : Type ğ“œ} {Y : Type ğ“} (h : X â†’ Y)
      (H : f ~ g)
    â†’ (f âŠ¥ h) â†’ (g âŠ¥ h)
left-orthogonal-homotopy h = funext-rec _ Î» where refl â†’ id

is-anodyne-homotopy
  : âˆ€ {ğ“¤ ğ“¥ ğ“§ ğ“¨} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B}
      {X : Type ğ“§} {Y : Type ğ“¨} (h : X â†’ Y)
    â†’ f ~ g
    â†’ is-anodyne f h â†’ is-anodyne g h
is-anodyne-homotopy h H fia k o = left-orthogonal-homotopy k H (fia k o)

left-orthogonal-Î£
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“} {A : Type ğ“¤}
      {B : A â†’ Type ğ“¥} {C : A â†’ Type ğ“¦} (f : âˆ€ a â†’ B a â†’ C a)
      {X : Type ğ“œ} {Y : Type ğ“} (g : X â†’ Y)
      â†’ (âˆ€ a â†’ f a âŠ¥ g) â†’ (total-map f) âŠ¥ g
left-orthogonal-Î£ {A = A} {B} {C} f {Y = Y} g fg
  = orthogonalâ†is-cartesian
      (front-cartesianâ†equiv-cube
        cube
        cube-is-equiv
        (Î -square-is-cartesian _ (is-cartesianâ†orthogonal âˆ˜ fg))) where
  cube : Cube (power-hom (total-map f) g) (Î -square (Î» i â†’ power-hom (f i) g))
  cube .Cube.left .Arrow-map.top = curry
  cube .Cube.left .Arrow-map.bot = curry
  cube .Cube.left .Arrow-map.comm = ~refl
  cube .Cube.right .Arrow-map.top = curry
  cube .Cube.right .Arrow-map.bot = curry
  cube .Cube.right .Arrow-map.comm = ~refl
  cube .Cube.comm .fst = ~refl
  cube .Cube.comm .snd .fst = ~refl
  cube .Cube.comm .snd .snd a = âˆ™-reflr _ âˆ™ funext-refl

  cube-is-equiv : is-Cube-equiv cube
  cube-is-equiv .fst .fst = curry-is-equiv
  cube-is-equiv .fst .snd = curry-is-equiv
  cube-is-equiv .snd .fst = curry-is-equiv
  cube-is-equiv .snd .snd = curry-is-equiv


left-orthogonal-Ã—
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“¦} {Y : Type ğ“œ} (f' : X â†’ Y)
      {C : Type ğ“} {D : Type ğ“›} (g : C â†’ D)
      â†’ (f âŠ¥ g) â†’ (f' âŠ¥ g) â†’ (f âŠ— f') âŠ¥ g
left-orthogonal-Ã— {ğ“¤} {ğ“¥}{ğ“¦}{ğ“œ}{ğ“}{ğ“›}{A} {B} f {X} {Y} g h fh gh
  = left-orthogonal-âˆ˜ (f âŠ— id) (id âŠ— g) h
      (left-orthogonal-retract (f âŠ— id) (id âŠ— f)
        (mk-amap (Ã—-swap ._â‰ƒ_.fwd) (Ã—-swap ._â‰ƒ_.fwd) ~refl)
        ( mk-amap (Ã—-swap ._â‰ƒ_.fwd) (Ã—-swap ._â‰ƒ_.fwd) ~refl
        , ~refl
        , ~refl
        , ~refl)
        h
        (left-orthogonal-Î£ (Î» _ â†’ f) h (Î» _ â†’ fh)))
      (left-orthogonal-Î£ (Î» _ â†’ g) h Î» _ â†’ gh )

idâŠ¥_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (f : B â†’ C)
       â†’ id{A = A} âŠ¥ f
idâŠ¥ f = orthogonalâ†precomp-Î  (Î» _ â†’ id-is-equiv)

left-orthogonal-pushout
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
      (F : Arrow-map f g)
    â†’ is-cocartesianÏ‰ F
    â†’ {C : Type ğ“} {D : Type ğ“›} (h : C â†’ D)
    â†’ (f âŠ¥ h) â†’ (g âŠ¥ h)
left-orthogonal-pushout {f = f} {g = g} F cocart h fh
  = orthogonalâ†is-cartesian
      (rotate-is-cartesian
        _
        (front-cartesianâ†cartesian-cube
        _ _ the-cube
        (cocart _)
        (cocart _)
        (rotate-is-cartesian _ (is-cartesianâ†orthogonal fh)))) where

  the-cube : Cube (rotate-square (power-hom g h)) (rotate-square (power-hom f h))
  the-cube .Cube.left = precomp-square F _
  the-cube .Cube.right = precomp-square F _
  the-cube .Cube.comm .fst = ~refl
  the-cube .Cube.comm .snd .fst = ~refl
  the-cube .Cube.comm .snd .snd k
    = âˆ™-reflr _ âˆ™ âˆ™-reflr _
    âˆ™ sym (commutes-postwhisker-funext {h = h} (ap k âˆ˜ sym âˆ˜ Arrow-map.comm F))
    âˆ™ ap funextâ†’ (funextâ†’ (Î» a â†’ sym (ap-âˆ˜ h k _)))

left-orthogonal-pushout-product
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“} {Y : Type ğ“›} (h : X â†’ Y)
  â†’ f âŠ¥ h
  â†’ {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
  â†’ pushout-product f g âŠ¥ h
left-orthogonal-pushout-product f h fh g
  = left-orthogonal-right-cancel
      (left-orthogonal-pushout _
        (Pushout-square-is-cocartesian (mk-span _ (f âŠ—1 _) (_ 1âŠ— g)))
        h (left-orthogonal-Ã— f id h fh (idâŠ¥ h)))
      (left-orthogonal-Ã— f id h fh (idâŠ¥ h))

left-orthogonal-pushout-product'
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ ğ“›}
      {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
      {X : Type ğ“} {Y : Type ğ“›} (h : X â†’ Y)
  â†’ f âŠ¥ h
  â†’ {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
  â†’ pushout-product g f âŠ¥ h
left-orthogonal-pushout-product' f h fh g
  = left-orthogonal-right-cancel {g = Î¹â‚}
      (left-orthogonal-pushout _
        (rotate-square-is-cocartesian _ (Pushout-square-is-cocartesian _))
        h
        (left-orthogonal-Ã— id f h (idâŠ¥ h) fh))
      (left-orthogonal-Ã— id f h (idâŠ¥ h) fh)
}
%```
}


\subtree[stt-00E7]{
\title{Left orthogonal maps are closed under functorial action of the pushout}
\taxon{Lemma}

\p{Consider spans #{A_i \xleftarrow{f_i} B \xrightarrow{g} C} for #{i \in \{1,2\}}.
Given a coslice map #{F : f_0 \to_B f_1}, we have an action on pushouts
#{A_0 +^B C \to A_1 +^B C}. If #{F \perp k}, then #{F +^B C \perp k}.}

\proof{
\p{We can arrange these maps into squares as follows:}

\quiver{
\begin{tikzcd}
	B && C \\
	\\
	{A_0} && {A_0+^BC} \\
	\\
	{A_1} && {A_1+^B C}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow[from=3-1, to=5-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[from=3-3, to=5-3]
	\arrow[from=5-1, to=5-3]
\end{tikzcd}
}

\p{The total square and top square is cocartesian, so by pushout pasting, we have
that the bottom square is cocartesian. So the result follows from the fact that
cocartesian squares preserve left orthogonal maps.}

\p{We have a similar result for the action on the right hand side of a pushout.}
}

%```agda
\agda{
module Pushout-functorial-left
         {ğ“¤ ğ“¤' ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
         {f : B â†’ A} {f' : B â†’ A'} (F : Coslice-map f f') (g : B â†’ C) where

  left-span-map : Span-map (mk-span _ f g) (mk-span _ f' g)
  left-span-map = (mk-span-map (F .fst) id id (F .snd) ~refl)

  Pushoutâ‚-left : Pushout f g â†’ Pushout f' g
  Pushoutâ‚-left = Pushoutâ‚ (mk-span-map (F .fst) id id (F .snd) ~refl)

  top-square : Arrow-map f Î¹â‚‚
  top-square = Pushout-square (mk-span _ f g)

  bot-square : Arrow-map (F .fst) Pushoutâ‚-left
  bot-square .Arrow-map.top = Î¹â‚
  bot-square .Arrow-map.bot = Î¹â‚
  bot-square .Arrow-map.comm = ~refl

  total-square' : Arrow-map (F .fst âˆ˜ f) Î¹â‚‚
  total-square' = Pushout-square (mk-span _ (F .fst âˆ˜ f) g)

  _ : Pushoutâ‚-left âˆ˜ Î¹â‚‚ ~ Î¹â‚‚
  _ = ~refl

open Pushout-functorial-left public using (Pushoutâ‚-left)
open Pushout-functorial-left hiding (Pushoutâ‚-left)

private
  total-square-comp
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : B â†’ A} (F : A â†’ A') (g : B â†’ C)
      â†’ Arrow-map (F âˆ˜ f) (Î¹â‚‚ {f = F âˆ˜ f} {g = g})
  total-square-comp F g
    = rotate-square
        (paste-squares
          (rotate-square (bot-square (F , ~refl) g))
          (rotate-square (top-square (F , ~refl) g)))

  total-square-comp-is-total
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : B â†’ A} (F : A â†’ A') (g : B â†’ C)
      â†’ Arrow-map-path (total-square-comp {f = f} F g)
                       (total-square' (F , ~refl) g)
  total-square-comp-is-total F g .fst = ~refl
  total-square-comp-is-total F g .snd .fst = ~refl
  total-square-comp-is-total F g .snd .snd a
    = âˆ™-reflr _ âˆ™ âˆ™-symsym _ refl
    âˆ™ ap sym (ap-sym _ (glue a) âˆ™ ap sym (pushout-rec-apÎ² a))
    âˆ™ sym-sym âˆ™ âˆ™-reflr _

opaque
  total-square-comp-is-cocartesian
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : B â†’ A} (F : A â†’ A') (g : B â†’ C)
      â†’ is-cocartesianÏ‰ (total-square-comp {f = f} F g)
  total-square-comp-is-cocartesian F g
    = tr (Î» p â†’ is-cocartesian p _)
         {a = total-square' (F , ~refl) g}
         {b = total-square-comp F g}
         (sym (Arrow-map-pathâ†’ (total-square-comp-is-total F g)))
         (Pushout-square-is-cocartesian _)

opaque
  left-orthogonal-pushoutâ‚-left
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : B â†’ A} {f' : B â†’ A'} (F : Coslice-map f f') (g : B â†’ C)
      â†’ âˆ€ {ğ“œ ğ“} {U : Type ğ“œ} {V : Type ğ“} (k : U â†’ V)
      â†’ F .fst âŠ¥ k
      â†’ Pushoutâ‚-left F g âŠ¥ k
  left-orthogonal-pushoutâ‚-left (F , p) g k Fk
    = funext-rec
        (Î» H â†’ Pushoutâ‚-left (F , H) g âŠ¥ k)
        (Î» where refl â†’ left-orthogonal-pushout
                          (bot-square (F , ~refl) g)
                          (rotate-square-is-cocartesian
                            (rotate-square (bot-square (F , ~refl) g))
                            (cocartesian-square-cancel
                              {F = rotate-square (bot-square (F , ~refl) g)}
                              {G = rotate-square (top-square (F , ~refl) g)}
                              (Pushout-square'-is-cocartesian (mk-span _ _ g))
                              (unrotate-square-is-cocartesian _
                                (total-square-comp-is-cocartesian F g))))
                          k
                          Fk)
        p

module Pushout-functorial-right
         {ğ“¤ ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤}  {B : Type ğ“¥} {C : Type ğ“¦} {C' : Type ğ“¦'}
         (f : B â†’ A) {g : B â†’ C} {g' : B â†’ C'} (G : Coslice-map g g') where

  right-span-map : Span-map (mk-span _ f g) (mk-span _ f g')
  right-span-map = (mk-span-map id id (G .fst) ~refl (G .snd))

  Pushoutâ‚-right : Pushout f g â†’ Pushout f g'
  Pushoutâ‚-right = Pushoutâ‚ right-span-map

  left-square : Arrow-map f Î¹â‚‚
  left-square = Pushout-square (mk-span _ f g)

  right-square : Arrow-map (Î¹â‚‚ {g = g}) (Î¹â‚‚ {g = g'})
  right-square .Arrow-map.top = G .fst
  right-square .Arrow-map.bot = Pushoutâ‚-right
  right-square .Arrow-map.comm = ~refl

  total-square'' : Arrow-map f (Î¹â‚‚ {g = g'})
  total-square'' = Pushout-square (mk-span _ f g')


open Pushout-functorial-right public using (Pushoutâ‚-right)
open Pushout-functorial-right hiding (Pushoutâ‚-right)

private
  total-square'-comp-is-total
      : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤}  {B : Type ğ“¥} {C : Type ğ“¦} {C' : Type ğ“¦'}
           (f : B â†’ A) {g : B â†’ C} (G : C â†’ C')
      â†’ Arrow-map-path
          (paste-squares (right-square f {g = g} (G , ~refl))
                         (left-square f (G , ~refl)))
          (total-square'' f (G , ~refl))
  total-square'-comp-is-total f G .fst = ~refl
  total-square'-comp-is-total f G .snd .fst = ~refl
  total-square'-comp-is-total f G .snd .snd a
    = âˆ™-reflr _Â âˆ™ âˆ™-reflr _ âˆ™ pushout-rec-apÎ² a âˆ™ âˆ™-reflr _

  opaque
    total-square'-comp-is-cocartesian
      : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤}  {B : Type ğ“¥} {C : Type ğ“¦} {C' : Type ğ“¦'}
           (f : B â†’ A) {g : B â†’ C} (G : C â†’ C')
        â†’ is-cocartesianÏ‰ (paste-squares (right-square f {g = g} (G , ~refl))
                                         (left-square f (G , ~refl)))
    total-square'-comp-is-cocartesian f G
      = tr (Î» p â†’ is-cocartesian p _)
           {a = total-square'' f (G , ~refl)}
           {b = _}
           (sym (Arrow-map-pathâ†’ (total-square'-comp-is-total f G)))
           (Pushout-square-is-cocartesian _)
opaque
  left-orthogonal-pushoutâ‚-right
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤}  {B : Type ğ“¥} {C : Type ğ“¦} {C' : Type ğ“¦'}
         (f : B â†’ A) {g : B â†’ C} {g' : B â†’ C'} (G : Coslice-map g g')
         {ğ“œ ğ“} {U : Type ğ“œ} {V : Type ğ“} (k : U â†’ V)
      â†’ G .fst âŠ¥ k
      â†’ Pushoutâ‚-right f G âŠ¥ k
  left-orthogonal-pushoutâ‚-right f G@(Gg , p)
    = left-orthogonal-pushout
        (rotate-square (right-square f G))
        (rotate-square-is-cocartesian (right-square f G)
          (cocartesian-square-cancel
             {F = right-square f G}
             {G = left-square f G}
             (Pushout-square-is-cocartesian _)
             (funext-rec
               (Î» H â†’ is-cocartesian
                        (paste-squares
                          (right-square f (Gg , H))
                          (left-square f (Gg , H))) _)
               (Î» where refl â†’ total-square'-comp-is-cocartesian f Gg)
               p)))


private
  outer-span-map
      : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥}
          {C : Type ğ“¦} {C' : Type ğ“¦'}
          {f : B â†’ A} {f' : B â†’ A'} (F : Coslice-map f f')
          {g : B â†’ C} {g' : B â†’ C'} (G : Coslice-map g g')
        â†’ Span-map (mk-span _ f g) (mk-span _ f' g')
  outer-span-map F G .Span-map.hâ‚ = F .fst
  outer-span-map F G .Span-map.hâ‚‚ = id
  outer-span-map F G .Span-map.hâ‚ƒ = G .fst
  outer-span-map F G .Span-map.H = F .snd
  outer-span-map F G .Span-map.K = G .snd

Pushoutâ‚-left-right
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥}
        {C : Type ğ“¦} {C' : Type ğ“¦'}
        {f : B â†’ A} {f' : B â†’ A'} (F : Coslice-map f f')
        {g : B â†’ C} {g' : B â†’ C'} (G : Coslice-map g g')
      â†’ Pushoutâ‚€ (mk-span B f g) â†’ Pushoutâ‚€ (mk-span B f' g')
Pushoutâ‚-left-right F G = Pushoutâ‚ (outer-span-map F G)

Pushoutâ‚-leftâˆ˜right
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥}
        {C : Type ğ“¦} {C' : Type ğ“¦'}
        {f : B â†’ A} {f' : B â†’ A'} (F : Coslice-map f f')
        {g : B â†’ C} {g' : B â†’ C'} (G : Coslice-map g g')
      â†’ Span-map-homotopy
          (compose-span-map (left-span-map F g') (right-span-map f G))
          (outer-span-map F G)
Pushoutâ‚-leftâˆ˜right F G .fst = ~refl
Pushoutâ‚-leftâˆ˜right F G .snd .fst = ~refl
Pushoutâ‚-leftâˆ˜right F G .snd .snd .fst = ~refl
Pushoutâ‚-leftâˆ˜right F G .snd .snd .snd .fst = ~âˆ™-reflr _ ~â»Â¹
Pushoutâ‚-leftâˆ˜right F G .snd .snd .snd .snd a = ap (_âˆ™ refl) (ap-id (snd G a))

opaque
  left-orthogonal-pushoutâ‚
    : âˆ€ {ğ“¤ ğ“¤' ğ“¥ ğ“¦ ğ“¦'} {A : Type ğ“¤} {A' : Type ğ“¤'} {B : Type ğ“¥}
        {C : Type ğ“¦} {C' : Type ğ“¦'}
        {f : B â†’ A} {f' : B â†’ A'} (F : Coslice-map f f')
        {g : B â†’ C} {g' : B â†’ C'} (G : Coslice-map g g')
        {ğ“œ ğ“} {U : Type ğ“œ} {V : Type ğ“} (k : U â†’ V)
      â†’ F .fst âŠ¥ k
      â†’ G .fst âŠ¥ k
      â†’ Pushoutâ‚-left-right F G âŠ¥ k
  left-orthogonal-pushoutâ‚ F G k Fk Gk
    = left-orthogonal-homotopy k
        (Pushout-âˆ˜ (left-span-map F _) (right-span-map _ G)
        ~âˆ™ happly (ap Pushoutâ‚ (Span-map-funextâ†’ (Pushoutâ‚-leftâˆ˜right F G))))
        (left-orthogonal-âˆ˜ _ _ k
            (left-orthogonal-pushoutâ‚-left F _ k Fk)
            (left-orthogonal-pushoutâ‚-right _ G k Gk))
}
%```
}
