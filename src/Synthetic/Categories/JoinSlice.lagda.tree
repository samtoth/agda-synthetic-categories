\title{The join slice adjunction}
\taxon{Module}
\date{2026-01-22}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.JoinSlice
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Core.CoSlice

open import Ergonomics.Extensionality

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
}
%```


\subtree[stt-00D5]{
\title{The join slice adjunction}
\taxon{Theorem}

\p{We can view the partially appied [directed join](stt-00CW) as a functor
#{- \rtimes B : \Type \to \Type_{B/}} into the [coslice category of
types](Core.CoSlice). It turns out this functor has a right adjoint given by the
[slice construction](stt-00C4), where we define a functor #{\Type_{B/} \to
\Type} which takes a map #{p : B \to C} to the type #{C_{/p}}.}

\proof{
\p{By a short calculation:}

##{
\begin{align*}

A \to C_{/p} &\simeq \Sigma_{f : C^A} \Pi_{a,b} \Hom(f(a), p(b)) \\
             &\simeq \Sigma_{f : C^A} \Sigma_{g : C^B}
                       (\Pi_{a,b}\Hom(f(a),g(b))) \times g \sim p \\
             &\simeq \Sigma_{f : C^{A \rtimes B}} f \iota_2 \sim p \\
             &\simeq A \rtimes B \to_{/B} p
\end{align*}
}
}

%```agda
\agda{
joinâ†slice-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
      â†’ (A â†’ Slice C p) â†’ Coslice-map {X = A â‹‰ B} â†‘-Î¹â‚‚ p
joinâ†slice-map p f = ( â†‘-rec (mk-right-cocone (fst âˆ˜ f) p (uncurry (snd âˆ˜ f)))
           , ~refl)

sliceâ†join-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
      â†’ Coslice-map {X = A â‹‰ B} â†‘-Î¹â‚‚ p â†’ (A â†’ Slice C p)
sliceâ†join-map p F a
  = ( F .fst (â†‘-Î¹â‚ a)
    , Î» b â†’ adjust-hom refl (F .snd b) (ap-hom (F .fst) (â†‘-hom (a , b))))

slice-join-Î· : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
      â†’ sliceâ†join-map {A = A} p âˆ˜ joinâ†slice-map p ~ id
slice-join-Î· p f = funextâ†’ (Î»
  a â†’ Î£-pathâ†’ (refl , funextâ†’ (Î»
   b â†’ Hom-extâ†’
         ( ~refl
         , (sym (âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _))
         , sym (âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _)))))


opaque
  joinâŠ£slice : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
       â†’ (A â†’ Slice C p) â‰ƒ Coslice-map {X = A â‹‰ B} â†‘-Î¹â‚‚ p
  joinâŠ£slice {A = A} {B} {C} p
    = (A â†’ Slice C p) â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ _ _ âŸ©
      Î£[ f âˆ¶ (A â†’ C)] (âˆ€ (a : A) (b : B) â†’ Hom C (f a) (p b))
         â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» f â†’ uncurryâ‰ƒ) âŸ©
      Î£[ f âˆ¶ (A â†’ C)] (âˆ€ ((a , b) : A Ã— B) â†’ Hom C (f a) (p b))
         â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» x â†’ âˆ€ ab â†’ Hom C (x .fst .fst (ab .fst)) (x .fst .snd (ab .snd))}
             (Î£-singleton (Î» f â†’ SingS-is-single' p) eâ»Â¹ âˆ™â‰ƒ Î£-assoc eâ»Â¹)
            âˆ™â‰ƒ (Î£-assoc âˆ™â‰ƒ (Î£-ap-â‰ƒ (Î» _ â†’ Ã—-swap) âˆ™â‰ƒ Î£-assoc eâ»Â¹
            âˆ™â‰ƒ (Î£-ap-â‰ƒ-fst Î£-assoc))) âŸ©
      Î£[ f âˆ¶ (Î£[ f âˆ¶ (A â†’ C)] Î£[ g âˆ¶ (B â†’ C)] (âˆ€ x â†’ Hom C (f (fst x)) (g (snd x)))) ]
        (f .snd .fst ~ p) â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst (Right-cocone-reprâ‰ƒ eâ»Â¹) âŸ©
      Î£[ f âˆ¶ Right-cocone (mk-span (A Ã— B) fst snd) C ] (f .Right-cocone.j ~ p)
         â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst (â†‘-UP eâ»Â¹) âŸ©
      Î£[ f âˆ¶ (A â‹‰ B â†’ C)] (f âˆ˜ â†‘-Î¹â‚‚ ~ p) â‰ƒâŸ¨âŸ©
      Coslice-map â†‘-Î¹â‚‚ p   â‰ƒâˆ

  joinâ†slice-map-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
                â†’ is-equiv (joinâ†slice-map {A = A} p)
  joinâ†slice-map-is-equiv p = joinâŠ£slice p ._â‰ƒ_.has-is-eqv

  -- The inverse of adjâ‰ƒ is not this map, but we can use 3-for-2
  sliceâ†join-map-is-equiv
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
      â†’ is-equiv (sliceâ†join-map {A = A} p)
  sliceâ†join-map-is-equiv p
    = 3-for-2~' {f = sliceâ†join-map p}
       ((slice-join-Î· p) ~â»Â¹)
       (joinâ†slice-map-is-equiv p)
       id-is-equiv

}
%```

\p{Dually, we have a join-coslice adjunction.}

%```agda
\agda{
joinâ†coslice-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
    â†’ (A â†’ Coslice C p) â†’ Coslice-map {X = B â‹‰ A} â†‘-Î¹â‚ p
joinâ†coslice-map p f
  = (â†‘-rec (mk-right-cocone p (fst âˆ˜ f) (uncurry (snd âˆ˜ f) âˆ˜ Ã—-swapâ†’)) , ~refl)

cosliceâ†join-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
    â†’ Coslice-map {X = B â‹‰ A} â†‘-Î¹â‚ p â†’ (A â†’ Coslice C p)
cosliceâ†join-map p f a
  = ( f .fst (â†‘-Î¹â‚‚ a)
    , Î» b â†’ adjust-hom (f .snd b) refl (ap-hom (f .fst) (â†‘-hom (b , a))))

joinâŠ£coslice-Î·
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
    â†’ cosliceâ†join-map {A = A} p âˆ˜ joinâ†coslice-map p ~ id
joinâŠ£coslice-Î· p f
  = funextâ†’ Î» a â†’ Î£-pathâ†’ (refl , (funextâ†’ (Î»
       b â†’ Hom-extâ†’
             (~refl
             , sym (âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _)
             , sym (âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _)))))

joinâŠ£coslice-Îµ
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
    â†’ joinâ†coslice-map p âˆ˜ cosliceâ†join-map {A = A} p ~ id
joinâŠ£coslice-Îµ p f = ext!
  (sym âˆ˜ â†‘-rec-unique ( f .snd , ~refl , Î» a â†’ ~refl
                      , coe (Square-squeeze-topr (ap (f .fst) (glue (_ , a))))
                           (mk-square refl)
                      , Square-degen-vert _ _ (sym (âˆ™-reflr _)))
  , âˆ™-sym' âˆ˜ f .snd)

joinâŠ£coslice
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
    â†’ Coslice-map {X = B â‹‰ A} â†‘-Î¹â‚ p â‰ƒ (A â†’ Coslice C p)
joinâŠ£coslice p = equivâ†qiso
  (mk-iso
    (cosliceâ†join-map p)
    ( joinâ†coslice-map p
    , joinâŠ£coslice-Îµ p
    , joinâŠ£coslice-Î· p))


joinâ†coslice-map-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} (p : B â†’ C)
    â†’ is-equiv (joinâ†coslice-map {A = A} p)
joinâ†coslice-map-is-equiv p = is-equivâ»Â¹ (joinâŠ£coslice p ._â‰ƒ_.has-is-eqv)
}
%```
}
