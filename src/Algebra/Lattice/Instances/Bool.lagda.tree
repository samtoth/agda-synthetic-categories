\date{2025-10-22}
\title{The lattice of Booleans}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Algebra.Lattice.Instances.Bool where

open import Foundations.Prelude
open import ufAxioms

open import Algebra.Lattice
open import Modalities.Instances.Truncation
open import Data.Bool
}
%```


\subtree[stt-109R]{
\title{The lattice of booleans}
\taxon{Example}

%```agda
\agda{
Bool-Lattice : Lattice Bool
Bool-Lattice .Lattice.0l = false
Bool-Lattice .Lattice.1l = true
Bool-Lattice .Lattice._‚àß_ = _&_
Bool-Lattice .Lattice._‚à®_ = _||_
Bool-Lattice .Lattice.str-is-lattice = l where
  l : is-lattice false true _&_ _||_
  l .is-lattice.car-is-set = is-truncated‚Üêis-set Bool-is-set
  l .is-lattice.‚àß-assoc {true} {true} {true} = refl
  l .is-lattice.‚àß-assoc {true} {true} {false} = refl
  l .is-lattice.‚àß-assoc {true} {false} = refl
  l .is-lattice.‚àß-assoc {false} = refl
  l .is-lattice.‚à®-assoc {true} = refl
  l .is-lattice.‚à®-assoc {false} {true} = refl
  l .is-lattice.‚à®-assoc {false} {false} {true} = refl
  l .is-lattice.‚à®-assoc {false} {false} {false} = refl
  l .is-lattice.‚àß-comm {true} {true} = refl
  l .is-lattice.‚àß-comm {false} {true} = refl
  l .is-lattice.‚àß-comm {true} {false} = refl
  l .is-lattice.‚àß-comm {false} {false} = refl
  l .is-lattice.‚à®-comm {true} {true} = refl
  l .is-lattice.‚à®-comm {true} {false} = refl
  l .is-lattice.‚à®-comm {false} {true} = refl
  l .is-lattice.‚à®-comm {false} {false} = refl
  l .is-lattice.‚à®-‚àß-abs {true} = refl
  l .is-lattice.‚à®-‚àß-abs {false} = refl
  l .is-lattice.‚àß-‚à®-abs {true} = refl
  l .is-lattice.‚àß-‚à®-abs {false} = refl
  l .is-lattice.0-bottom {true} = refl
  l .is-lattice.0-bottom {false} = refl
  l .is-lattice.1-top {true} = refl
  l .is-lattice.1-top {false} = refl

Bool-distributive : is-distributive Bool-Lattice
Bool-distributive .is-distributive.has-is-distrib {true} {y} {z} = refl
Bool-distributive .is-distributive.has-is-distrib {false} {false} {z} = refl
Bool-distributive .is-distributive.has-is-distrib {false} {true} {true} = refl
Bool-distributive .is-distributive.has-is-distrib {false} {true} {false} = refl

Bool-initial : ‚àÄ {ùì§} {A : Type ùì§} (M : Lattice A)
             ‚Üí is-singleton (Œ£ (Bool ‚Üí A) (is-lattice-hom Bool-Lattice M))
Bool-initial {_} {A} M = mk-singl (Œπ , lem) unique where
  open Lattice M
  open is-lattice-hom

  Œπ : Bool ‚Üí A
  Œπ true = 1l
  Œπ false = 0l

  lem : is-lattice-hom Bool-Lattice M Œπ
  lem .pres-‚à® {true} {y} = sym (‚à®-comm ‚àô 1-coinit)
  lem .pres-‚à® {false} {true} = sym 1-coinit
  lem .pres-‚à® {false} {false} = sym 0-bottom
  lem .pres-‚àß {true} {true} = sym 1-top
  lem .pres-‚àß {true} {false} = sym (‚àß-comm ‚àô 0-init)
  lem .pres-‚àß {false} {y} = sym 0-init
  lem .pres-0 = refl
  lem .pres-1 = refl

  unique : (x : Œ£ (Bool ‚Üí A) (is-lattice-hom Bool-Lattice M)) ‚Üí
           (Œπ , lem) Ôºù x
  unique (f , p) = Œ£-path‚Üí (funext‚Üí H , is-lattice-hom-is-prop _ _ _ _ p) where
    H : Œπ ~ f
    H true = sym (p .pres-1)
    H false = sym (p .pres-0)
}
%```
}
