\date{2025-08-01}
\title{Descent for pushouts}
\taxon{module}
\meta{module}{Core.PushoutDescent}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.PushoutDescent where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CartesianStraightening
open import Ergonomics.Representation
open import Ergonomics.Marker
}
%```

\subtree[stt-008D]{
\title{Flattening lemma for pushouts}
\taxon{theorem}

\p{The flattening theorem essentially states that for a family #{P}
over a pushout #{A \times_C B}, the total type #{\tilde{P}} is
equivalent to the pushout of total types: #{\Sigma_A P
+_{\Sigma_C P} \Sigma_B P}.}

\proof{
\p{Given a span #{S : A \leftarrow B \rightarrow C} and a family #{P}
over the pushout of #{S}, we can define the total span #{\Sigma_{S}P}.
We first note that for some arbitrary type #{Q}, dependent cones over
#{S} at #{p \mapsto P(p) \to Q} are equivalent to cones over
#{\Sigma_{S} P} at #{Q} - this is analogous to [currying
functions](Foundations.PiProperties).  We then construct the following
square:
}

\quiver{
\begin{tikzcd}
	{\Pi_{p : A+^C B} Q^{P(p)}} && {Q^{\Sigma_{p : A+^CB} P(p)}} \\
	\\
	{\rm{cocone}^d(S,p \mapsto Q^{P(p)})} && {\rm{cocone}(\Sigma_S P,Q)}
	\arrow["{\rm{curry}}", from=1-1, to=1-3]
	\arrow["{\rm{cocone}^d}"', from=1-1, to=3-1]
	\arrow["{\rm{cocone}}", from=1-3, to=3-3]
	\arrow["{\rm{curry}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{Since, currying (functions or cocones) and the dependent cocone
map are equivalences, then so is the cocone map on the right.}

}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         (f : A â†’ B) (g : A â†’ C) where
  total-span : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
               â†’ Span _ _ _
  total-span P .Span.Centre = Î£ A (P âˆ˜ Î¹â‚‚ âˆ˜ g)
  total-span P .Span.Left = Î£ B (P âˆ˜ Î¹â‚)
  total-span P .Span.left (a , b) = (f a , tr P (sym (glue a)) b)
  total-span P .Span.Right = Î£ C (P âˆ˜ Î¹â‚‚)
  total-span P .Span.right = total-map-fst g

  total-cocone : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                 â†’ Cocone (total-span P) (Î£ (Pushout f g) P)
  total-cocone P .Cocone.p = total-map-fst Î¹â‚
  total-cocone P .Cocone.q = total-map-fst Î¹â‚‚
  total-cocone P .Cocone.filler (a , b)
    = Î£-pathâ†’ ( glue a , trâˆ™tr-sym' (glue a) b)

  total-is-pushout : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                     â†’ is-pushoutÏ‰ (total-span P) (total-cocone P)
  total-is-pushout P {ğ“ } {Q} = eqv where
    module S' = Span (total-span P)

    Q' : Pushout f g â†’ Type _
    Q' x = P x â†’ Q

    lem2 : âˆ€ {a b} (p : a ï¼ b) {x} {f : P a â†’ Q}
           â†’ (tr Q' p f) x ï¼ f (tr P (sym p) x)
    lem2 refl = refl

    curry-cocone
      : Cocone (total-span P) Q â†’ CoconeD _ pushout Q'
    curry-cocone (mk-cocone p q filler) = mk-coconeD (curry p) (curry q) Î»
      a â†’ funextâ†’ Î» b â†’ lem2 (glue a) âˆ™ curry filler a b

    H : Arrow-map (cocone-map _ (total-cocone P) {Q})
                  (coconeáµˆ-map (mk-span _ f g) pushout {Q'})
    H .Arrow-map.top = curry
    H .Arrow-map.bot = curry-cocone
    H .Arrow-map.comm h
      = ap (mk-coconeD (Î» a b â†’ h (Î¹â‚ a , b)) (Î» a b â†’ h (Î¹â‚‚ a , b)))
           (funextâ†’ Î» a â†’ J {a = Î¹â‚ (f a)} (Î» z G â†’
                 funextâ†’ (Î» b â†’ lem2 G âˆ™ ap h (Î£-pathâ†’ (G , trâˆ™tr-sym' G b)))
               ï¼ apáµˆ (curry h) G)
           funext-refl
           {Î¹â‚‚ (g a)} (glue a))

    curry-cocone-is-equiv : quasi-iso curry-cocone
    curry-cocone-is-equiv .fst (mk-coconeD p q filler)
      = mk-cocone (uncurry p) (uncurry q)
          Î» where (a , b) â†’ sym (lem2 (glue a)) âˆ™ happly (filler a) b
    curry-cocone-is-equiv .snd .fst (mk-cocone p q filler)
      = Cocone-pathâ†’ _  _ (funextâ†’ ~refl) (funextâ†’ ~refl)
          Î» a â†’ âˆ™-reflr _ âˆ™ sym'âˆ™ (lem2 (glue (fst a))) (filler a)
    curry-cocone-is-equiv .snd .snd (mk-coconeD p q filler)
      = ap (mk-coconeD p q) (funextâ†’ Î»
         a â†’   ap funextâ†’ (funextâ†’ (Î» b â†’ symâˆ™ (lem2 (glue a))
                                            (happly (filler a) b)))
             âˆ™ _â‰ƒ_.Î· funextâ‰ƒ (filler a))

    arr-eq : is-Arrow-equiv H
    arr-eq .fst = curry-is-equiv
    arr-eq .snd = is-equivâ†qiso curry-cocone-is-equiv

    eqv : is-equiv (cocone-map _ (total-cocone P))
    eqv = is-equivâ†Arrow-equivâ»Â¹ {F = H} arr-eq Pushout-is-pushoutÏ‰áµˆ
}
%```
}

\subtree[stt-008S]{
\title{Fibres of the cogap map}
\taxon{corollary}

\p{As a consequence of the [flattening lemma](stt-008D), we can give a
nice characterisation of fibres of [cogap maps](stt-004G). }

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“œ}
                (C : Cocone S X) where
  open Span S

  Fibre-family : âˆ€ x â†’ Pushout left right â†’ Type ğ“œ
  Fibre-family x p = cogap C p ï¼ x

  cogap-fibre
    : âˆ€ x â†’ fibre (cogap C) x
    â‰ƒ Pushout (total-span _ _ (Fibre-family x) .Span.left)
              (total-span _ _ (Fibre-family x) .Span.right)
  cogap-fibre x = mkâ‰ƒ _
    (is-equivâ»Â¹
      (cogap-is-equivâ†is-pushout _
        (total-is-pushout _ _ (Fibre-family x))))
}
%```
}

\p{Before introducing the main descent theorem, we need some auxiliary
definitions.}



\subtree[stt-008O]{
\date{2025-08-03}
\title{Pulling back squares}
\taxon{construction}

\p{Given span #{S}, and a cocone over #{S} centred at #{X}, we can
\em{'pull this square back'} along any map #{X' \to X}, to obtain a
span #{S'}, a cocone over #{S'} at #{X'} as well as a cartesian map
of spans #{S' \to S}.
}

%```agda
\agda{
module SquarePB {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {S : Span ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“œ}
                (C : Cocone S X) {X' : Type ğ“›} (f : X' â†’ X)
                where
  open Span S
  open Cocone C

  S' : Span (ğ“¤ âŠ” ğ“¥ âŠ” ğ“œ âŠ” ğ“›) (ğ“¥ âŠ” ğ“œ âŠ” ğ“›) (ğ“¦ âŠ” ğ“œ âŠ” ğ“›)
  S' .Span.Centre = Pullback {B = Pullback p f} fst left
  S' .Span.Left = Pullback p f
  S' .Span.left  = fst
  S' .Span.Right = Pullback q f
  S' .Span.right ((r , x , H) , c , K) = (right c  , x , sym (sym H âˆ™ ap p K âˆ™ filler c) )

  C' : Cocone S' X'
  C' .Cocone.p = pb.Ï€â‚‚
  C' .Cocone.q = pb.Ï€â‚‚
  C' .Cocone.filler _ = refl

  proj : Span-map S' S
  proj .Span-map.hâ‚ = pb.Ï€â‚
  proj .Span-map.hâ‚‚ = pb.Ï€â‚‚
  proj .Span-map.hâ‚ƒ = pb.Ï€â‚
  proj .Span-map.H  = pb.filler
  proj .Span-map.K _ = refl

  front-left : Arrow-map pb.Ï€â‚ f
  front-left = mk-amap pb.Ï€â‚‚ p pb.filler

  front-right : Arrow-map pb.Ï€â‚ f
  front-right = mk-amap pb.Ï€â‚‚ q pb.filler

  front-right-is-cart : is-cartesian (front-right)
  front-right-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  front-left-is-cart : is-cartesian front-left
  front-left-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  amap-lâ†“-is-cart : is-cartesian (Span-map.amap-lâ†“ proj)
  amap-lâ†“-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  amap-l-is-cart : is-cartesian (Span-map.amap-l proj)
  amap-l-is-cart = rotate-is-cartesian _ amap-lâ†“-is-cart

  square~ : Arrow-map-path
              (paste-squares front-left (Span-map.amap-l proj))
              (paste-squares front-right (Span-map.amap-r proj))
  square~ .fst = ~refl
  square~ .snd .fst = filler
  square~ .snd .snd ((l , x' , H) , c , refl)
    = âˆ™-reflr _
    âˆ™ sym (ap (filler c âˆ™_) (âˆ™-symsym (sym H) (filler c))
          âˆ™ symâˆ™ (filler c) (sym (sym H))
          âˆ™ sym-sym)

  proj-is-cartesian : is-cartesian-span-map proj
  proj-is-cartesian .fst = amap-l-is-cart
  proj-is-cartesian .snd = 3-for-2-cartesian square~
    (compose-cartesian front-left-is-cart amap-l-is-cart)
    front-right-is-cart

}
%```
}




\subtree[stt-008L]{
\date{2025-08-03}
\title{Descent for pushouts}
\taxon{theorem}

\p{In the following, let #{S} be a span and #{C} be a cocone over #{S}
centred at #{X}.}

\p{Descent for pushouts states that if this cocone is a pushout, then
the map that takes a type #{X'} and a map #{X' \to X} to a cartesian
map over #{S} is an equivalence.}


%```agda
\agda{
module _ {ğ“¤} {Sp : Span ğ“¤ ğ“¤ ğ“¤} {X : Type ğ“¤}
         (C : Cocone Sp X) (C-po : is-pushoutÏ‰ _ C) where

  cart-map : (Î£[ X' âˆ¶ Type ğ“¤ ] (X' â†’ X)) â†’ Cart Sp ğ“¤ ğ“¤ ğ“¤
  cart-map (X' , f) = mk-cart S' proj proj-is-cartesian where
    open SquarePB C f


--   descent-pushout : is-equiv cart-map
--   descent-pushout =  is-equivâ†Arrow-equiv {F = amap} amap-eqv (C-po)
--     where

--     cmap : âˆ€ (P : X â†’ Type ğ“¤)
--            â†’ Cart-map {ğ“¤} {ğ“¤} {ğ“¤} {Sp} {ğ“¤} {ğ“¤}
--                       ((cartâ†cocone âˆ˜ cocone-map Sp C) P)
--                       ((cart-map âˆ˜ unstraighten) P)
--     cmap P = mk-cart-map
--       (mk-span-map (pbâ‰ƒ ._â‰ƒ_.fwd)
--                    (centreâ‰ƒ ._â‰ƒ_.fwd)
--                    (pbâ‰ƒ ._â‰ƒ_.fwd)
--                    comm1 comm2)
--       ~refl
--       ~refl
--       ~refl module cmap where
--       open Span Sp renaming (Centre to S;
--                              left to f;
--                              right to g;
--                              Left to A;
--                              Right to B) using ()
--       open Cocone C

--       pbâ‰ƒ : âˆ€ {A X : Type ğ“¤} {P : X â†’ Type ğ“¤} {f : A â†’ X}
--               â†’ (Î£[ a âˆ¶ A ] P (f a)) â‰ƒ Pullback f (fst {B = P})
--       pbâ‰ƒ {A}{X}{P}{p} = Î£-ap-â‰ƒ Î» a â†’
--           (P (p a))
--               â‰ƒâŸ¨ Î£-ï¼singl' eâ»Â¹ âŸ©
--           (Î£[ x âˆ¶ X ] ((p a ï¼ x) Ã— P x))
--               â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» aâ‚ â†’ Ã—-swap) âŸ©
--           (Î£[ x âˆ¶ X ] Î£[ px âˆ¶ P x ] (p a ï¼ x))
--             â‰ƒâŸ¨ Î£-assoc eâ»Â¹ âŸ©
--           (Î£[ xp âˆ¶ Î£ X P ] (p a ï¼ fst xp)) â‰ƒâˆ

--       centreâ‰ƒ :  Î£ S (P âˆ˜ q âˆ˜ g)
--                 â‰ƒ Pullback {B = Pullback p (fst {B = P})} (fst) f
--       centreâ‰ƒ
--         = Î£ S (P âˆ˜ q âˆ˜ g)            â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» s â†’ coeâ‰ƒ (sym (ap P (filler s))))   âŸ©
--           (Î£[ s âˆ¶ S ] (P (p (f s)))) â‰ƒâŸ¨ pbâ‰ƒ âŸ©
--           Pullback (p âˆ˜ f) fst       â‰ƒâŸ¨ pbâ‰ƒ âŸ©
--           Pullback f fst             â‰ƒâŸ¨ pullback-swap âŸ©
--           Pullback fst f             â‰ƒâˆ

--       comm1 : _â‰ƒ_.fwd pbâ‰ƒ âˆ˜ Span.left ((cartâ†cocone âˆ˜ cocone-map Sp C) P .Cart.S') ~
--                Span.left ((cart-map âˆ˜ unstraighten) P .Cart.S') âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ
--       comm1 = ~refl

--       comm2 : _â‰ƒ_.fwd pbâ‰ƒ âˆ˜ Span.right ((cartâ†cocone âˆ˜ cocone-map Sp C) P .Cart.S') ~
--                Span.right ((cart-map âˆ˜ unstraighten) P .Cart.S') âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ
--       comm2 (s , p) = Î£-pathâ†’ (refl
--                       , Î£-pathâ†’ ((Î£-pathâ†’ (sym (filler s) , ap (Î» P â†’ coe P p) (ap-sym P _)))
--                       , IdP-funcâ†Square {f = Î» _ â†’ q (g s)} {g = fst} _ refl _
--                          (ap (_âˆ™ sym (filler s)) (ap-const _)
--                           âˆ™ sym (Î£-path-ap-fst))))

--     cmap-is-equiv : âˆ€ (P : X â†’ Type ğ“¤)
--                     â†’ Cart-map-is-equiv (cmap P)
--     cmap-is-equiv P
--       = ( pbâ‰ƒ P .has-is-eqv
--         , centreâ‰ƒ P .has-is-eqv
--         , pbâ‰ƒ P .has-is-eqv) where
--       open cmap
--       open _â‰ƒ_

--     -- opaque
--     --   commutes : âˆ€ (P : X â†’ Type ğ“¤)
--     --            â†’ (cartâ†cocone âˆ˜ cocone-map Sp C) P ï¼ (cart-map âˆ˜ unstraighten) P
--     --   commutes P = Cart-uaâ†’ (cmap P) (cmap-is-equiv P)

--     amap : Arrow-map (cocone-map _ C) cart-map
--     amap = mk-amap unstraighten cartâ†cocone {!!}

-- -- Î» P â†’ Cart-uaâ†’ {ğ“¤} {ğ“¤} {ğ“¤}
-- --                     {S = Sp} {cartâ†cocone (cocone-map Sp C P)}
-- --                     {cart-map (unstraighten P)}
-- --                     (cmap P)
-- --                     (cmap-is-equiv P)


--     amap-eqv : is-Arrow-equiv amap
--     amap-eqv .fst = is-equivâ»Â¹ straighten-is-equiv
--     amap-eqv .snd = cartâ†cocone-is-equiv
}
%```
}
