\date{2025-02-22}
\title{Coherent Isomorphism}
\taxon{Module}

\import{stt-macros}

% ```agda
\agda{
module Foundations.CoherentIsomorphism where

open import Foundations.Universes
open import Foundations.QuasiIsomorphism
open import Foundations.Sigma
open import Foundations.Functions
open import Foundations.FunctionInverses
open import Foundations.Homotopy
open import Foundations.Identity
open import Foundations.PathReasoning
}
% ```

\p{We can upgrade [quasi isomorphism](QuasiIsomorphism.lagda) into a [correct notion of equivalence](st-????) by adding an extra coherence condition, that makes it into a proposition. }

\subtree[stt-000K]{
\taxon{Remark}
\title{Half adjoint equivalence}

\p{The defintion of a quasi isomorphism involves:}

\ul{
\li{#{f : A \to B}}
\li{#{g : B \to A}}
\li{#{\eta : f \circ g = \id}}
\li{#{\varepsilon : \id = g \circ f}}
}

\p{The names #{\eta} and #{\varepsilon} remind us that this looks like the data of an adjunction. But we are missing the laws, often called the zig-zag laws. One of which state that the following 2-cell contracts to the identity:
}

\quiver{
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJBIl0sWzIsMiwiQiJdLFs0LDAsIkEiXSxbNiwyLCJCIl0sWzAsMSwiZiIsMl0sWzEsMiwiZyIsMl0sWzIsMywiZiIsMl0sWzAsMiwiXFxpZCIsMCx7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJcXGlkIiwyLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFswLDIsIiIsMCx7Im9mZnNldCI6LTEsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCIiLDAseyJvZmZzZXQiOi0xLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzcsMSwiXFx2YXJlcHNpbG9uIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjMwfX1dLFsyLDgsIlxcZXRhIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfX1dXQ==
\begin{tikzcd}
	A &&&& A \\
	\\
	&& B &&&& B
	\arrow[""{name=0, anchor=center, inner sep=0}, no head, from=1-1, to=1-5]
	\arrow["\id", shift left, no head, from=1-1, to=1-5]
	\arrow["f"', from=1-1, to=3-3]
	\arrow["f"', from=1-5, to=3-7]
	\arrow["g"', from=3-3, to=1-5]
	\arrow[""{name=1, anchor=center, inner sep=0}, "\id"', no head, from=3-3, to=3-7]
	\arrow[shift left, no head, from=3-3, to=3-7]
	\arrow["\varepsilon", shorten <=7pt, shorten >=11pt, Rightarrow, from=0, to=3-3]
	\arrow["\eta", shorten <=7pt, shorten >=7pt, Rightarrow, from=1-5, to=1]
\end{tikzcd}
}

\p{In symbols, this is: #{f \cdot \varepsilon \circ \eta \cdot f = \id} (where #{\cdot} denotes horizontal composition and #{\circ} denotes vertical composition).}
}

\p{Note that in our formalisation #{\varepsilon} is a 2-cell in the opposite direction, but since all 2-cells are invertible, this makes no difference to the definition and makes the formalization slightly smoother.}

\subtree[stt-001R]{
\taxon{Definition}
\title{Coherence data for [quasi isomorphisms](Foundations.QuasiIsomorphism)}

% ```agda
\agda{
qiso-coh : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ quasi-iso f â†’ Type (ğ“¤ âŠ” ğ“¥)
qiso-coh {f = f} (g , Îµ , Î·) = f â—‚ Îµ ~ Î· â–¸ f
}
% ```
}

\subtree[stt-001U]{
\taxon{Definition}
\title{Equivalences}


\p{Of the many equivalent notions of equivelences in HoTT, we will single out coherent isomorphisms as the default one in the library.}

% ```agda
\agda{
record is-equiv {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) : Type (ğ“¤ âŠ” ğ“¥) where
  constructor mk-eqv
  field
    qiso     : quasi-iso f
    coherent : qiso-coh qiso

  has-qiso : A â‰… B
  has-qiso = mk-iso f qiso

  open _â‰…_ has-qiso public hiding (fwd)

  Îµ : f âˆ˜ bwd ~ id
  Îµ x = section-fwd .snd x

  Îµâ»Â¹ : id ~ f âˆ˜ bwd
  Îµâ»Â¹ = Îµ ~â»Â¹

  Î· : bwd âˆ˜ f ~ id
  Î· x = retract-fwd .snd x

  Î·â»Â¹ : id ~ bwd âˆ˜ f
  Î·â»Â¹ = Î· ~â»Â¹

  cohâ»Â¹ :  (f â—‚ Î·â»Â¹) ~ (Îµâ»Â¹ â–¸ f)
  cohâ»Â¹ a = ap-sym f (Î· a) âˆ™ ap sym (coherent a)

  swizzle-bwd
    : âˆ€ {ğ“¦} {C : Type ğ“¦}
        (g : C â†’ B) (h : C â†’ A)
      â†’ g ~ f âˆ˜ h â†’ bwd âˆ˜ g ~ h
  swizzle-bwd g h K = bwd â—‚ K ~âˆ™  Î· â–¸ h
}
% ```

\p{We also define the packaged version of an equivalence together with the proof of it being an equivalence}

% ```agda
\agda{
infix 7 _â‰ƒ_
record _â‰ƒ_ {ğ“¤ ğ“¥} (A : Type ğ“¤) (B : Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  constructor mkâ‰ƒ
  field
    fwd : A â†’ B
    has-is-eqv : is-equiv fwd

  open is-equiv has-is-eqv public


qisoâ†is-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ is-equiv f â†’ quasi-iso f
qisoâ†is-equiv = is-equiv.qiso

qisoâ†equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰ƒ B â†’ A â‰… B
qisoâ†equiv (mkâ‰ƒ _ has-is-eqv) = has-qiso where open is-equiv has-is-eqv

}
% ```
}



\subtree[stt-000J]{
\taxon{Theorem}
\title{Quasi isomorphisms are coherent}
% HoTT book. 4.2.3

\p{Every quasi-isomorphism can be upgraded to a coherent isomorphism.}

\proof{
\p{Since we (are soon to) know that being an equivalence is a proposition, and that quasi isomorphisms aren't equivalent to equivalences,
we know that whatever the map is, it cannot be a section of the obvious map #{\textrm{is-equiv}(f) \to \textrm{is-qiso}(f)}, and so as a
result we know we will have to be a bit clever about how we choose the 2-cells of our coherent isomorphism.}

\p{The proof goes through by cooking up a 2-cell #{\varepsilon} that makes the coherence go through trivially.
Working backwards, we need an #{\varepsilon '} such that #{\varepsilon' f = \eta f}. }


\quiver{
% https://q.uiver.app/#q=WzAsNSxbMCwwLCJmZ2YiXSxbNiwwLCJmIl0sWzEsMiwiZmdmZ2YiXSxbNCwxLCJmZ2YiXSxbNSwzLCJmZ2YiXSxbMCwxLCJmXFxldGEiXSxbMCwyLCJcXHZhcmVwc2lsb25eey0xfSBmZ2YiLDJdLFsyLDMsIlxcdmFyZXBzaWxvbiBmZ2YiXSxbMywxLCJmXFxldGEiLDJdLFswLDMsIiIsMSx7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzIsNCwiZmdmIFxcZXRhIiwwLHsiY3VydmUiOi0xfV0sWzQsMSwiXFx2YXJlcHNpbG9uIGYiLDIseyJjdXJ2ZSI6M31dLFs0LDMsIklJIiwyLHsic2hvcnRlbiI6eyJzb3VyY2UiOjMwLCJ0YXJnZXQiOjIwfSwibGV2ZWwiOjJ9XSxbMiw0LCJmXFxldGFfe2dmfSIsMix7ImN1cnZlIjoyfV0sWzIsOSwiSSIsMix7InNob3J0ZW4iOnsic291cmNlIjozMCwidGFyZ2V0IjozMH19XSxbMTMsMTAsIklJSSIsMix7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH19XV0=
\begin{tikzcd}
	fgf &&&&&& f \\
	&&&& fgf \\
	& fgfgf \\
	&&&&& fgf
	\arrow["{f\eta}", from=1-1, to=1-7]
	\arrow[""{name=0, anchor=center, inner sep=0}, equals, from=1-1, to=2-5]
	\arrow["{\varepsilon^{-1} fgf}"', from=1-1, to=3-2]
	\arrow["{f\eta}"', from=2-5, to=1-7]
	\arrow["{\varepsilon fgf}", from=3-2, to=2-5]
	\arrow[""{name=1, anchor=center, inner sep=0}, "{fgf \eta}", from=3-2, to=4-6]
	\arrow[""{name=2, anchor=center, inner sep=0}, "{f\eta gf}"', bend right,from=3-2, to=4-6]
	\arrow["{\varepsilon f}"', bend right, from=4-6, to=1-7]
	\arrow["2", shorten <=11pt, shorten >=8pt, Rightarrow, from=4-6, to=2-5]
	\arrow["1"', shorten <=11pt, shorten >=11pt, Rightarrow, from=3-2, to=0]
	\arrow["3"', shorten <=2pt, shorten >=2pt, Rightarrow, from=2, to=1]
\end{tikzcd}
}


\p{
Consider the above diagram, and in particular note that the lower boundary is given by morphisms of the form #{\alpha f} for some alpha.
By taking the horizontal composition of these #{\alpha}'s gives us our desired #{\epsilon' := \varepsilon^{-1} fg \cdot f \eta g \cdot \varepsilon}. It satisfies the necessary equations by the vertical composite of the cells: 
}

\ol{
\li{Trivially follws from paths forming groupoids.}
\li{The naturality of homotopies.}
\li{\citet{2.4.3}{HoTT} [[stt-001O]]}
}

% ```agda
\agda{
is-equivâ†qiso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ quasi-iso f â†’ is-equiv f
is-equivâ†qiso {f = f} (g , Î· , Îµ) = mk-eqv (g , Î· , Îµ') coh where opaque
  Îµ' : f âˆ˜ g ~ id
  Îµ' = (Îµ ~â»Â¹) â–¸ f â–¸ g ~âˆ™
       f â—‚ Î· â–¸ g       ~âˆ™
       Îµ

  lem3 : g â—‚ f â—‚ Î· ~ Î· â–¸ g â–¸ f
  lem3 x = sym (ap-âˆ˜ g f (Î· x)) âˆ™ n where
    n : (g âˆ˜ f â—‚ Î·) x ï¼ (Î· â–¸ g â–¸ f) x
    n = sym (homotopy-inverse (g âˆ˜ f) Î· x)

  lem2 : Îµ â–¸ f â–¸ g â–¸ f ~âˆ™ f â—‚ Î· ~ f â—‚ g â—‚ f â—‚ Î· ~âˆ™ Îµ â–¸ f
  lem2 x = I âˆ™ ap (_âˆ™ (Îµ (f x))) (ap-âˆ˜ f g (ap f (Î· x))) where
    I : Îµ (f (g (f x))) âˆ™ (ap f (Î· x)) ï¼
         ap (Î» z â†’ (f âˆ˜ g) z) (ap f (Î· x)) âˆ™ Îµ (f x)
    I = ap (_ âˆ™_) (sym (ap-id (ap f (Î· x)))) âˆ™
        homotopy-natural Îµ {f (g (f x))} (ap f (Î· x)) 

  lem1 : f â—‚ Î· ~
           ((Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ Îµ â–¸ f â–¸ g â–¸ f ~âˆ™ f â—‚ Î·)
  lem1 a = âˆ™.insertr _ {h = Îµ (f (g (f a)))} {i = sym (Îµ (f (g (f a))))} (âˆ™-sym' (Îµ (f (g (f a))))) {_} {ap f (Î· a)}


  coh : qiso-coh (g , Î· , Îµ')
  coh =   (f â—‚ Î·)                                       ~âŸ¨ lem1 âŸ©
          (Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ Îµ â–¸ f â–¸ g â–¸ f ~âˆ™ f â—‚ Î· ~âŸ¨ ~refl {f = Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹} âŸ©~âˆ™âŸ¨ lem2 âŸ©
          (Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ f â—‚ g â—‚ f â—‚ Î· ~âˆ™ Îµ â–¸ f ~âŸ¨ ~refl {f = Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹} âŸ©~âˆ™âŸ¨ f âŸ©~â—‚âŸ¨ lem3 âŸ©~âˆ™âŸ¨ ~refl {f = Îµ â–¸ f} âŸ©
          (Îµ â–¸ f â–¸ g â–¸ f ~â»Â¹) ~âˆ™ f â—‚ Î· â–¸ g â–¸ f ~âˆ™ Îµ â–¸ f ~âŸ¨âŸ©
           Îµ' â–¸ f                                       ~âˆ

equivâ†qiso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰… B â†’ A â‰ƒ B
equivâ†qiso (mk-iso fwd fwd-iso) = mkâ‰ƒ fwd (is-equivâ†qiso fwd-iso)

â‰ƒ-repâ‰…  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â‰ƒ B) â‰… Î£ (A â†’ B) is-equiv
â‰ƒ-repâ‰… ._â‰…_.fwd (mkâ‰ƒ f e) = f , e
â‰ƒ-repâ‰… ._â‰…_.fwd-iso .fst (f , e) = mkâ‰ƒ f e
â‰ƒ-repâ‰… ._â‰…_.fwd-iso .snd .fst _ = refl
â‰ƒ-repâ‰… ._â‰…_.fwd-iso .snd .snd _ = refl

â‰ƒ-rep : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â‰ƒ B) â‰ƒ Î£ (A â†’ B) is-equiv
â‰ƒ-rep = equivâ†qiso â‰ƒ-repâ‰…
}
% ```


}
}



\subtree[stt-005T]{
\date{2025-06-19}
\title{Assuming the codomain to construct an equivalence}
\taxon{Theorem}
  \p{To show that a function is an equialence,
  it suffices show that it is an equivalence assuming a point
  in the codomain.}

%```agda
\agda{
is-equivâ†is-equiv-if-cod
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
      {B : Type ğ“¥}
      {f : A â†’ B}
     â†’ (B â†’ is-equiv f)
     â†’ is-equiv f
is-equivâ†is-equiv-if-cod {f = f} feqb
  = is-equivâ†qiso
      ( (Î» b â†’ bwd (feqb b) b)
      , (Î» a â†’ Î· (feqb (f a)) a)
      , Î» b â†’ Îµ (feqb b) b ) where open is-equiv
}
%```
}


\subtree[stt-001T]{
\title{Equivalences form an #{\infty}-groupoid over types}

% ```agda
\agda{
id-is-equiv : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-equiv (id {A = A})
id-is-equiv =  (mk-eqv (id , ~refl , ~refl) ~refl)

idequiv : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â‰ƒ A
idequiv = mkâ‰ƒ id id-is-equiv

is-equiv-âˆ˜ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                  {f : B â†’ C} {g : A â†’ B} â†’
                  is-equiv f â†’ is-equiv g
                  â†’ is-equiv (f âˆ˜ g)
is-equiv-âˆ˜ f g = is-equivâ†qiso (comp-has-qiso (qisoâ†is-equiv g) (qisoâ†is-equiv f))

equiv-comp : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
             â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ C
equiv-comp (mkâ‰ƒ f e) (mkâ‰ƒ g e') = mkâ‰ƒ (g âˆ˜ f) (is-equiv-âˆ˜ e' e)

is-equivâ»Â¹ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
             â†’ (e : is-equiv f) â†’ is-equiv (is-equiv.bwd e)
is-equivâ»Â¹ {f = f} (mk-eqv e _) = is-equivâ†qiso (f , e .snd .snd , e .snd .fst)

equivâ†Id : âˆ€ {ğ“¤} {A B : Type ğ“¤} â†’ A ï¼ B â†’ A â‰ƒ B
equivâ†Id refl = idequiv

fwd-equivâ†Id : âˆ€ {ğ“¤} {A B : Type ğ“¤} (p : A ï¼ B)
               â†’ _â‰ƒ_.fwd (equivâ†Id p) ï¼ coe p
fwd-equivâ†Id refl = refl

coe-is-equiv : âˆ€ {ğ“¤} {A B : Type ğ“¤} (p : A ï¼ B)
               â†’ is-equiv (coe p)
coe-is-equiv refl = id-is-equiv

coeâ‰ƒ : âˆ€ {ğ“¤} {A B : Type ğ“¤} (p : A ï¼ B) â†’ A â‰ƒ B
coeâ‰ƒ p = mkâ‰ƒ (coe p) (coe-is-equiv p)
}
% ```
}

\subtree[stt-001S]{
\taxon{Notation}

\title{Reasoning combinators for equivalences}

% ```agda
\agda{
_âˆ™â‰ƒ_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
             â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ C
_âˆ™â‰ƒ_ = equiv-comp

infixl 29 _âˆ™â‰ƒ_

_eâ»Â¹ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰ƒ B â†’ B â‰ƒ A
(mkâ‰ƒ f e)  eâ»Â¹ = mkâ‰ƒ (is-equiv.bwd e) (is-equivâ»Â¹ e)

â‰ƒâŸ¨âŸ©-syntax : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (A : Type ğ“¤) {B : Type ğ“¥} {C : Type ğ“¦}
           â†’ B â‰ƒ C â†’ A â‰ƒ B â†’ A â‰ƒ C
â‰ƒâŸ¨âŸ©-syntax A g f = equiv-comp f g


_â‰ƒâŸ¨âŸ©_ : âˆ€ {ğ“¤ ğ“¥} (A : Type ğ“¤) {B : Type ğ“¥} â†’ A â‰ƒ B â†’ A â‰ƒ B
x â‰ƒâŸ¨âŸ© xâ‰ƒy = xâ‰ƒy

_â‰ƒâˆ : âˆ€ {â„“} (A : Type â„“) â†’ A â‰ƒ A
x â‰ƒâˆ = idequiv

infix 31 _eâ»Â¹

infixr 2 â‰ƒâŸ¨âŸ©-syntax _â‰ƒâŸ¨âŸ©_
infix  3 _â‰ƒâˆ

syntax â‰ƒâŸ¨âŸ©-syntax x q p = x â‰ƒâŸ¨ p âŸ© q

}
% ```
}
