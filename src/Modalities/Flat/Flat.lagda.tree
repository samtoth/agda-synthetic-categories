\date{2025-06-06}
\title{The Flat Modalitiy}
\taxon{module}
\meta{module}{\startverb Modalities.Flat.Flat \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Modalities.Flat.Flat where

open import Foundations.Prelude
}

\subtree[stt-004Z]{
\title{The Flat type operator}
\taxon{Definition}

\p{Given a crisp type #{A}, we can form the type #{\modflat{A}}. In agda flat
we can encode this with an inductive datatype generated by a crisp elements
of #{A}. We also note the corresponding induction principal for the inductive
type.}

\agda{
data ⟨♭|_⟩ {@♭ 𝓤} (@♭ A : Type 𝓤) : Type 𝓤 where
  mod♭ : (@♭ _ : A) → ⟨♭| A ⟩

♭-ind : ∀ {@♭ 𝓤} {𝓥} {@♭ A : Type 𝓤} (B : ⟨♭| A ⟩ → Type 𝓥)
          → ((@♭ x : A) → B (mod♭ x))
          → (x : ⟨♭| A ⟩) → B x
♭-ind B f (mod♭ x) = f x
}
%```
}



\subtree[stt-0051]{
\taxon{theroem}
\title{Flat is a Functor}

\p{Using the rules of [modal type theory](stt-0050) and #{\flat}-induction,
we can define operations making #{\modflat{-}} into a comonad.}

\p{To get a feel for how to reason informally about modal type theory, we
give the definition making #{\modflat{-}} into a functor informally
(in pain-staking detail), and compare it to the agda definition:}

\p{Given crisp types #{A :^\flat \UU} and #{B :^\flat \UV}, and a function
#{f :^\flat A \to B}, we can define a function #{\modflat{A} \to \modflat{B}}.
By crisp induction, it surfices to define a function
#{(a :^\flat A) \to \modflat{B}}. Then by #{\flat}-intro, we can assume a
crisp #{a :^\flat A} and give a crisp term of type #{B}, but now both #{f} and
#{a} were assumed crisp and so #{f(a) :^\flat B}, and we are done.
 }

%```agda
\agda{
♭-map : ∀ {@♭ 𝓤 𝓥} {@♭ A : Type 𝓤} {@♭ B : Type 𝓥}
        → (@♭ f : A → B) → ⟨♭| A ⟩ → ⟨♭| B ⟩
♭-map f (mod♭ x) = mod♭ (f x)

♭-id : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤}
        → ♭-map {A = A} id ~ id
♭-id (mod♭ x) = refl

♭-∘ : ∀ {@♭ 𝓤 𝓥 𝓦} {@♭ A : Type 𝓤} {@♭ B : Type 𝓥} {@♭ C : Type 𝓦}
        → (@♭ f : B → C) (@♭ g : A → B)
        → ♭-map (f ∘ g) ~ ♭-map f ∘ ♭-map g
♭-∘ f g (mod♭ x) = refl
}
%```

}

\subtree[stt-0052]{
\taxon{theorem}
\title{Flat is a comonad}

\p{Similarly, we can define the counit and comultiplication functions that
make #{\modflat{-}} into a comonad.}

%```agda
\agda{
ε : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} → ⟨♭| A ⟩ → A
ε (mod♭ x) = x

⟨♭♭|_⟩ : ∀ {@♭ 𝓤} → (@♭ _ : Type 𝓤) → Type 𝓤
⟨♭♭| A ⟩ = ⟨♭| ⟨♭| A ⟩ ⟩

comult : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} → ⟨♭| A ⟩ → ⟨♭♭| A ⟩
comult (mod♭ x) = mod♭ (mod♭ x)

}
%```
}

\subtree[stt-0054]{
\title{Flat is an idempotent comonad}
\taxon{theorem}

\p{We show that \code{comult} is an equivalence.}

%```agda
\agda{

μ : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤}
    → ⟨♭♭| A ⟩ → ⟨♭| A ⟩
μ (mod♭ x) = x

comult-is-equiv : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤}
                  → is-equiv (comult {A = A})
comult-is-equiv = is-equiv←qiso lem where
  lem : quasi-iso comult
  lem .fst = μ
  lem .snd .fst (mod♭ x) = refl
  lem .snd .snd (mod♭ (mod♭ x)) = refl

♭-idem : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤}
         → ⟨♭♭| A ⟩ ≃ ⟨♭| A ⟩
♭-idem = mk≃ μ (is-equiv⁻¹ comult-is-equiv)
}
%```
}

\subtree[stt-0053]{
\title{Flat commutes with #{\Sigma} and #{1}}
\taxon{theorem}

\p{First we show that #{\flat} commutes with #{1}, or in other words
#{\modflat{1}} is a [singleton](stt-0006). Similarly we can show that
#{\modflat{-}} preserves all singletons.}

%```agda
\agda{
♭𝟙-is-single : is-singleton ⟨♭| 𝟙 ⟩
♭𝟙-is-single = mk-singl (mod♭ tt) λ where (mod♭ tt) → refl

-- ♭-is-single : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤}
--               → @♭ is-singleton A → is-singleton ⟨♭| A ⟩
-- ♭-is-single (mk-singl c p) = mk-singl (mod♭ c) λ where
--   (mod♭ x) → mod♭＝ (mod♭ (p x))
}
%```

\p{Given a crisp type #{A},
and a family of types #{B} crisply over #{A}, we can define the
dependant flat-sum, written #{\Sigma_{a :^\flat A} B(a)}. Defined
as #{\Sigma_{x : \modflat{A}}\flat\textrm{-rec}(\_,B,x)}.}

\agda{
Σ♭ : ∀ {@♭ 𝓤 𝓥} (@♭ A : Type 𝓤) (B : @♭ A → Type 𝓥)
     → Type (𝓤 ⊔ 𝓥)
Σ♭ A B = Σ ⟨♭| A ⟩ (♭-ind _ B)

syntax Σ♭ A (λ x → B) = Σ[♭ x ∶ A ] B
}

\p{We now show #{\flat} commutes with #{\Sigma} in the sense that
#{\Sigma_{a :^\flat A} \modflat{B(a)}} is equivalent to
#{\modflat{\Sigma_{a : A}B(a)}}}

%```agda
\agda{
♭-Σ : ∀ {@♭ 𝓤 𝓥} {@♭ A : Type 𝓤} (@♭ B : A → Type 𝓥)
      → Σ[♭ x ∶ A ] ⟨♭| B x ⟩
      → ⟨♭| Σ A B ⟩
♭-Σ B (mod♭ a , mod♭ b) = mod♭ (a , b)

♭-Σ' : ∀ {@♭ 𝓤 𝓥} {@♭ A : Type 𝓤} (@♭ B : A → Type 𝓥)
      → ⟨♭| Σ A B ⟩
      → Σ[♭ x ∶ A ] ⟨♭| B x ⟩
♭-Σ' B (mod♭ (a , b)) = (mod♭ a , mod♭ b)

♭-commΣ : ∀ {@♭ 𝓤 𝓥} {@♭ A : Type 𝓤} (@♭ B : A → Type 𝓥)
                 → (Σ[♭ x ∶ A ] ⟨♭| B x ⟩) ≃ ⟨♭| Σ A B ⟩
♭-commΣ P = equiv←qiso qiso where
  qiso : (Σ[♭ x ∶ _ ] ⟨♭| P x ⟩) ≅ ⟨♭| Σ _ P ⟩
  qiso ._≅_.fwd = ♭-Σ P
  qiso ._≅_.fwd-iso .fst = ♭-Σ' P
  qiso ._≅_.fwd-iso .snd .fst (mod♭ a , mod♭ b) = refl
  qiso ._≅_.fwd-iso .snd .snd (mod♭ (a , b))    = refl
}
%```
}

\subtree[stt-0055]{
% \title{Flat is lex}
\taxon{construction}

\p{There is an obvious map
#{\mod_{\flat}(a) = \mod_{\flat}(b) \to \modflat{a = b}} that sends
#{\refl} to #{\mod_{\flat}(\refl)}.
}

%```agda
\agda{
unmod♭＝ : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} {@♭ a b : A}
       → mod♭ a ＝ mod♭ b
       → ⟨♭| a ＝ b ⟩
unmod♭＝ refl = mod♭ refl
}
%```
}

\subtree[stt-0057]{
\taxon{definition}
\title{Crisp Identity Induction}
\date{2025-06-10}

\p{We can define an induction principal for crisp identity types. }

%```agda
\agda{
J♭ : ∀ {@♭ 𝓤 𝓥} {@♭ A : Type 𝓤} {@♭ a : A}
       (P : (@♭ b : A) → (p : a ＝ b) → Type 𝓥)
     → P a refl
     → {@♭ b : A} → (@♭ p : a ＝ b)
     → P b p
J♭ P pr refl = pr

_ : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} {@♭ a b : A}
       → mod♭ a ＝ mod♭ b
       → ⟨♭| a ＝ b ⟩
_ = λ p → J (λ where (mod♭ x) p' → ⟨♭| _ ＝ x ⟩) (mod♭ refl) p

}
%```
\p{We sometimes call the above construction the weak crisp induction principal
in contrast with the following stronger induction principal:
}
%```agda
\agda{
J-crisp-ind : ∀ (@♭ 𝓤 𝓥 : Level) → Type (lsuc (𝓤 ⊔ 𝓥))
J-crisp-ind 𝓤 𝓥 = ∀ {@♭ A : Type 𝓤} {@♭ a : A}
                     (@♭ P : (@♭ b : A) → (@♭ p : a ＝ b) → Type 𝓥)
                    → @♭ P a refl
                    → {@♭ b : A} → (@♭ p : a ＝ b)
                    → P b p
}
%```

\p{Unlike the weak induction principal, the full crisp induction principal is
not derivable in base MTT. \citek{DG21}}

}

\subtree[stt-0056]{
\title{Crisp Induction implies Flat is lex}
\taxon{theorem}
\p{We can define a retraction of the function
#{\mod_{\flat}(a) = \mod_{\flat}(b) \to \modflat{a = b}} defined in
\ref{stt-0055} by using weak crisp identity induction.}

%```agda
\agda{
mod♭＝ : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} {@♭ a b : A}
       → ⟨♭| a ＝ b ⟩
       → mod♭ a ＝ mod♭ b
mod♭＝ (mod♭ refl) = refl

_ : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} {@♭ a b : A}
       → ⟨♭| a ＝ b ⟩
       → mod♭ a ＝ mod♭ b
_ = λ { (mod♭ p) → J♭ (λ b' p₁ → _ ＝ mod♭ b') refl p }

unmod♭＝-retraction : ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} {@♭ a b : A}
                   → retract-witness (unmod♭＝ {a = a} {b}) mod♭＝
unmod♭＝-retraction refl = refl
}
%```

\p{A modality is lex when it preserves identity types, i.e. \code{mod♭＝} is
an equivalence. Whilst we have given a retraction, it is not possible to show
that the map is a section. To see the issue, we carefully construct the
motive over which we perform induction:}

\p{For a crisp type #{A}, and #{a,b} a pair of crisp elements of #{A}, we need
to show that for all #{p :^\flat a = b},
#{\textrm{unmod}_{\flat}(\mod_{\flat}(p)) = p}. To apply induction, we
need to give a motive of type #{M : \Pi_{(y :^\flat A)} \Pi_{(p : a = y)} \UU},
such that #{M(b,p) \equiv (\textrm{unmod}_{\flat}(\mod_{\flat}(p)) = p)}. But
this is already ill-typed for a general #{p} as #{\mod_{\flat}} requires a crisp
identification.}

\p{The above argument gives a syntactic heuristic for why weak crisp induction
does not suffice, but in an [unpublished note](DG21), Gratzer shows that
strong crisp induction is independent of MTT. One sufficient condition for a
modality to have strong crisp induction is that it has a right adjoint. This
will be the case in most modalities of interest at least in this formalisation,
in particular in \em{spacial type theory} as introduced in
\citek{shulmanRealCohesive2017}.}

%```agda
\agda{
unmod♭＝-section : ∀ {@♭ 𝓜} {@♭ A : Type 𝓜}
    → J-crisp-ind 𝓜 𝓜
    → {@♭ a b : A}
    → section-witness (unmod♭＝ {a = a} {b}) mod♭＝
unmod♭＝-section j (mod♭ p)
  = j (λ _ p' → unmod♭＝ (mod♭＝ (mod♭ p')) ＝ (mod♭ p')) refl p

♭-lex :  ∀ {@♭ 𝓤} {@♭ A : Type 𝓤} {@♭ a b : A}
       → J-crisp-ind 𝓤 𝓤 → ⟨♭| a ＝ b ⟩ ≃ (mod♭ a ＝ mod♭ b)
♭-lex {A = A}{a}{b} j = equiv←qiso qiso where
  qiso : ⟨♭| _ ＝ _ ⟩ ≅ (mod♭ _ ＝ mod♭ _)
  qiso ._≅_.fwd = mod♭＝
  qiso ._≅_.fwd-iso .fst = unmod♭＝
  qiso ._≅_.fwd-iso .snd .fst = unmod♭＝-section j
  qiso ._≅_.fwd-iso .snd .snd = unmod♭＝-retraction
}
%```
}

\subtree[stt-0058]{
\taxon{theorem}
\title{Lex modalities preserve pullbacks}

\p{There are numerous ways to define the crisp pullback. Given crisp types
#{A,B} and #{C}, and crisp maps #{f :^\flat A \to C} and #{g :^\flat B \to C},
we define the following notions of crisp pullbacks:}

\ol{
\li{The type #{\modflat{A \times_C B}} (using the [standard pullback](stt-003J)
)}
\li{The type #{A \times_{C}^{\flat} B}, which we define as
  #{\Sigma_{(a :^\flat A)}\Sigma_{(b :^\flat B)} \modflat{f(a) = g(b)}}
using [modal dependant sums](stt-0053)}
\li{The type #{\modflat{A} \times_{\modflat{C}} \modflat{B}} where the maps are given by
the [functorial action of #{\flat}](stt-0051)}
}

\p{We can immediately see that (1) and (2) are equivalent:}


%```agda
\agda{
Pullback♭ : ∀ {@♭ 𝓤 𝓥 𝓦} {@♭ A : Type 𝓤} {@♭ B : Type 𝓥}
               {@♭ C : Type 𝓦}
               (@♭ f : A → C) (@♭ g : B → C)
             → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦)
Pullback♭ {A = A} {B} {C} f g = Σ[♭ x ∶ A ] Σ[♭ y ∶ B ] ⟨♭| f x ＝ g y ⟩


♭-pb : ∀ {@♭ 𝓤 𝓥 𝓦} {@♭ A : Type 𝓤} {@♭ B : Type 𝓥}
              {@♭ C : Type 𝓦}
              {@♭ f : A → C} {@♭ g : B → C}
            → Pullback♭ f g → ⟨♭| Pullback f g ⟩
♭-pb (mod♭ a , mod♭ b , mod♭ p) = mod♭ (a , b , p)

♭-pb' : ∀  {@♭ 𝓤 𝓥 𝓦} {@♭ A : Type 𝓤} {@♭ B : Type 𝓥}
              {@♭ C : Type 𝓦}
              {@♭ f : A → C} {@♭ g : B → C}
            → ⟨♭| Pullback f g ⟩ → Pullback♭ f g
♭-pb' (mod♭ (a , b , p)) = (mod♭ a , mod♭ b , mod♭ p)


♭-pres-pb : ∀ {@♭ 𝓤 𝓥 𝓦} {@♭ A : Type 𝓤} {@♭ B : Type 𝓥}
              {@♭ C : Type 𝓦}
              {@♭ f : A → C} {@♭ g : B → C}
            → Pullback♭ f g ≃ ⟨♭| Pullback f g ⟩
♭-pres-pb {f = f}{g} = equiv←qiso qiso where
  qiso : Pullback♭ f g ≅ ⟨♭| Pullback f g ⟩
  qiso ._≅_.fwd = ♭-pb
  qiso ._≅_.fwd-iso .fst = ♭-pb'
  qiso ._≅_.fwd-iso .snd .fst (mod♭ a , mod♭ b , mod♭ p) = refl
  qiso ._≅_.fwd-iso .snd .snd (mod♭ x) = refl
}
%```

\p{If we have that #{\flat} is a lex modality, then (1),(2) and (3) are
    all equivalent.}

%```agda
\agda{
♭-pb3 : ∀ {@♭ 𝓤 𝓥 𝓦} {@♭ A : Type 𝓤} {@♭ B : Type 𝓥}
         {@♭ C : Type 𝓦}
         (@♭ f : A → C) (@♭ g : B → C)
       → J-crisp-ind 𝓦 𝓦
       → Pullback (♭-map f) (♭-map g) ≃ Pullback♭ f g
♭-pb3 f g j = equiv←qiso lem where
  lem : Pullback (♭-map f) (♭-map g) ≅ Pullback♭ f g
  lem ._≅_.fwd (mod♭ a , mod♭ b , p) = (mod♭ a , mod♭ b , unmod♭＝ p)
  lem ._≅_.fwd-iso .fst (mod♭ a , mod♭ b , p) = (mod♭ a , mod♭ b , mod♭＝ p)
  lem ._≅_.fwd-iso .snd .fst (mod♭ a , mod♭ b , p)
    = Σ-path→ (refl , Σ-path→ (refl , _≃_.ε (♭-lex j) p))
  lem ._≅_.fwd-iso .snd .snd (mod♭ a , mod♭ b , p)
    = Σ-path→ (refl , (Σ-path→ (refl , _≃_.η (♭-lex j) p)))
}
%```
}
