\title{Yoneda}
\date{2026-02-10}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
{-#Â OPTIONS --lossy-unification #-}
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Yoneda
        {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I) where

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import ufAxioms

open import Core.CoSlice
open import Core.Arrow
open import Core.PullbackPower
open import Core.Orthogonal

open import Ergonomics.Extensionality

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.JoinSlice Î”Â¹ I I-distr
open import Synthetic.Categories.Homotopies Î”Â¹ I I-distr
open import Synthetic.Categories.HomFamilies Î”Â¹ I I-distr
}
%```


%```agda
\agda{
is-initial : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ Type (ğ“˜ âŠ” ğ“¤)
is-initial a = âˆ€ b â†’ is-singleton (Hom _ a b)

ev-init-is-equiv
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {a : A}
    â†’ is-covariant P
    â†’ is-initial a
    â†’ is-equiv (ev {B = P} a)
ev-init-is-equiv {a = a} Pc ai = is-equivâ†qiso
  ( (Î» x' a' â†’ tr-cov-hom Pc (ai a' .centre) x')
  , (Î» x' â†’ funextâ†’ Î» a' â†’ ap fst (is-covariant-homâ†is-covariant _ Pc
                                    (ai a' .centre) (x' a) .central
                                    (x' a' , ap-hom-over x' (ai a' .centre))))
  , Î» a' â†’ ap fst (is-covariant-homâ†is-covariant _ Pc (ai a .centre) a' .central
             (a' ,  tr (Î» p â†’ Hom-over p a' a') (sym (ai a .central (idH a)))
                       (idH _))))

opaque
  rec-init
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {a : A}
      â†’ is-covariant P
      â†’ is-initial a
      â†’ P a â†’ âˆ€ x â†’ P x
  rec-init Pc ai p0 = is-equiv.bwd (ev-init-is-equiv Pc ai) p0

  rec-init-Î²
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {a : A}
        (Pc : is-covariant P)
        (ai : is-initial a)
      â†’ (p : P a) â†’ rec-init Pc ai p a ï¼ p
  rec-init-Î² {a = a} Pc ai p = is-equiv.Îµ (ev-init-is-equiv Pc ai) p


YonedaJ
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a}
      (P : (x : A) â†’ Hom _ a x â†’ Type ğ“¥)
    â†’ is-covariant (uncurry P)
    â†’ (init : is-initial {A = Î£ A (Hom _ a)} (a , idH a))
    â†’ P a (idH a)
    â†’ âˆ€ x (f : Hom _ a x) â†’ P x f
YonedaJ P cov init p x f = rec-init {P = uncurry P} cov init p (x , f)

YonedaJ-id
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a}
      (P : (x : A) â†’ Hom _ a x â†’ Type ğ“¥)
      (Pc : is-covariant (uncurry P))
      (init : is-initial {A = Î£ A (Hom _ a)} (a , idH a))
    â†’ (p0 : P a (idH a))
    â†’ YonedaJ P Pc init p0 a (idH a) ï¼ p0
YonedaJ-id P = rec-init-Î²

is-initialâ†slice-proj-is-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤} a
    â†’ is-equiv (Î» ((f , _) : Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (f i0 ï¼ a)) â†’ f i1)
    â†’ is-initial a
is-initialâ†slice-proj-is-equiv a eq b
  = is-singleâ†equiv-to-single
      (Î£-assoc âˆ™â‰ƒ HomP-reprâ‰ƒ eâ»Â¹)
      (is-contr-mapâ†is-equiv eq b)

coslice-init
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) (Asimp : is-simplicial A) a
    â†’ is-initial {A = Coslice A (const _ ğŸ™ a)} (a , Î» _ â†’ idH a)
coslice-init {A = A} As Asi a
  = is-initialâ†slice-proj-is-equiv _ proj-is-equiv where
  lemma
    : (Î£[ sq âˆ¶ ((i j : Î”Â¹) â†’ A)] Î£[ p âˆ¶ (âˆ€ i â†’ sq i i0 ï¼ a)]
          Î£[ q âˆ¶ (âˆ€ j â†’ sq i0 j ï¼ a)] (p i0 ï¼ q i0))
    â†’ Î£[ sl âˆ¶ (Î”Â¹ â†’ Coslice A (const _ ğŸ™ a))] (sl i0 ï¼ (a , Î» _ â†’ idH a))
  lemma (sq , p , q , H) .fst i .fst = _
  lemma (sq , p , q , H) .fst i .snd _ .HomP.hom j = sq i j
  lemma (sq , p , q , H) .fst i .snd _ .HomP.hom0 = p i
  lemma (sq , p , q , H) .fst i .snd _ .HomP.hom1 = refl
  lemma (sq , p , q , H) .snd = Coslice-pathâ†’
    ((q i1) ,
    (Î» i â†’ q , mk-square (ap (_âˆ™ refl) (sym H)) , Square-degen-hor _ _ refl)
    )

  lemma-eq : (Î£[ sq âˆ¶ ((i j : Î”Â¹) â†’ A)] Î£[ p âˆ¶ (âˆ€ i â†’ sq i i0 ï¼ a)]
               Î£[ q âˆ¶ (âˆ€ j â†’ sq i0 j ï¼ a)] (p i0 ï¼ q i0))
           â‰ƒ Î£[ sl âˆ¶ (Î”Â¹ â†’ Coslice A (const _ ğŸ™ a))] (sl i0 ï¼ (a , Î» _ â†’ idH a))
  lemma-eq
    = ((Î£[ sq âˆ¶ ((i j : Î”Â¹) â†’ A)] Î£[ p âˆ¶ (âˆ€ i â†’ sq i i0 ï¼ a)]
         Î£[ q âˆ¶ (âˆ€ j â†’ sq i0 j ï¼ a)] (p i0 ï¼ q i0)))
           â‰ƒâŸ¨ Î£-assoc eâ»Â¹
          âˆ™â‰ƒ Î£-ap-â‰ƒ-fst {B = Î» sq â†’  Î£[ q âˆ¶ (âˆ€ j â†’ sq i0 .snd tt .HomP.hom j ï¼ a)]
                                       (sq i0 .snd tt .HomP.hom0 ï¼ q i0) }
              ((Î£-Î -swapâ‰ƒ _ Î» _ sq â†’ sq i0 ï¼ a) eâ»Â¹
               âˆ™â‰ƒ precomp-Î -â‰ƒ (Î» i â†’ Coslice-object-reprâ‰ƒ a eâ»Â¹)) âŸ©
      ((Î£[ sl âˆ¶ ((i : Î”Â¹) â†’ (Coslice A (const _ ğŸ™ a)))]
         Î£[ q âˆ¶ (âˆ€ j â†’ sl i0 .snd tt .HomP.hom j ï¼ a)]
           (sl i0 .snd tt .HomP.hom0 ï¼ q i0)))
            â‰ƒâŸ¨ Î£-ap-â‰ƒ II âŸ©
      (Î£[ sl âˆ¶ (Î”Â¹ â†’ Coslice A (const _ ğŸ™ a))]
        Î£[ sl01 âˆ¶ (sl i0 .fst ï¼ a)]
          (âˆ€ _ â†’ Hom-pathP refl sl01 (sl i0 .snd tt) (idH a)))
            â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» sl â†’  mkâ‰ƒ _ (Coslice-path-is-equiv {x = sl i0}) ) âŸ©
      (Î£[ sl âˆ¶ (Î”Â¹ â†’ Coslice A (const _ ğŸ™ a))] (sl i0 ï¼ (a , Î» _ â†’ idH a))) â‰ƒâˆ where

      II-map : (w : A) (sl : Hom A a w)
         â†’ Î£[ q âˆ¶ (âˆ€ j â†’ sl .HomP.hom j ï¼ a)]
             (sl .HomP.hom0 ï¼ q i0)
         â†’ Î£[ sl01 âˆ¶ (w ï¼ a)]
             (âˆ€ _ â†’ Hom-pathP refl sl01 sl (idH a))
      II-map w x (p , coh) .fst = sym (x .HomP.hom1) âˆ™ p i1
      II-map w x (p , coh) .snd tt .fst = p
      II-map w x (p , coh) .snd tt .snd .fst = mk-square (ap (_âˆ™ refl) (sym coh))
      II-map w x@(mk-hom _ _ refl) (p , coh) .snd tt .snd .snd
        = Square-degen-hor _ _ refl

      II-inv : (w : A) (sl : Hom A a w)
         â†’ Î£[ sl01 âˆ¶ (w ï¼ a)]
             (âˆ€ _ â†’ Hom-pathP refl sl01 sl (idH a))
         â†’ Î£[ q âˆ¶ (âˆ€ j â†’ sl .HomP.hom j ï¼ a)]
             (sl .HomP.hom0 ï¼ q i0)
      II-inv w x (a , b) .fst = b tt .fst
      II-inv w x (a , b) .snd
          = unap-equiv {f = _âˆ™ refl} (âˆ™-is-equiv' _)
                       (sym (un-square (b tt .snd .fst)))


      qiso : âˆ€ a x â†’ quasi-iso (II-map a x)
      qiso w x .fst = II-inv w x
      qiso w x .snd .fst (a , b) = Î£-pathâ†’ (refl
        , (unap-equiv (âˆ™-is-equiv' _) (sym _)
               ï¼âŸ¨ ap (unap-equiv (âˆ™-is-equiv' _))
                      (ap sym (un-mk-square (ap (_âˆ™ refl) (sym b)))
                      âˆ™ sym (ap-sym (_âˆ™ refl) (sym b))
                      âˆ™ ap (ap (_âˆ™ refl)) sym-sym) âŸ©
           unap-equiv (âˆ™-is-equiv' _) (ap (_âˆ™ refl) b)
             ï¼âŸ¨ unap-ap-equiv _ b âŸ©
           b âˆ))
      qiso w x .snd .snd (refl , t)
         = let path = Idâ†IdS {a = x} {b = idH _} (Hom-pathâ†pathP (t tt))
           in tr (Î» p â†’ II-map w x (qiso w x .fst (refl , Î» _ â†’ p)) ï¼ (refl , Î» _ â†’ p))
                 (Hom-pathPâ†path (IdSâ†Id â¦ƒ IdS-Hom â¦„ path) ï¼âŸ¨âŸ©
                 (Hom-pathPâ†path (IdSâ†Id â¦ƒ IdS-Hom â¦„
                                 (Idâ†IdS {a = x} (Hom-pathâ†pathP (t tt)))))
                                               ï¼âŸ¨ ap Hom-pathPâ†path
                                                      (IdSâ†Idâ†IdS â¦ƒ IdS-Hom â¦„
                                                        (Hom-pathâ†pathP (t tt))) âŸ©
                 (Hom-pathPâ†path (Hom-pathâ†pathP (t tt)))
                                               ï¼âŸ¨ _â‰ƒ_.Îµ Hom-pathPâ‰ƒpath (t tt)  âŸ©
                 t tt âˆ)
                 (help x path) where
           opaque
             unfolding Square
             III : Square-degen-hor {a = a} refl refl refl ï¼ mk-square refl
             III = refl
             IV : II-map w (idH w)
                   (qiso w (idH w) .fst
                    (refl ,
                     (Î» _ â†’ Hom-pathPâ†path (Identity-system.IdSâ†Id IdS-Hom refl))))
                   .snd tt .snd .fst
                   ï¼
                   mk-square
                   (Identity-system.IdSâ†Id IdS-Hom {a = idH w} refl .snd .fst âˆ™
                    sym (âˆ™-reflr (HomP.hom0 (idH w))))
             IV = ap (ap (_âˆ™ refl)) (ap sym (unap-refl (âˆ™-is-equiv' refl)))
                  âˆ™ refl


           help : âˆ€ (x' : Hom A w w) â†’ (p : x' ï¼ idH w)
                â†’ II-map w x' (qiso w x' .fst (refl , Î» _ â†’ Hom-pathPâ†path (IdSâ†Id p)))
                ï¼ (refl , Î» _ â†’ Hom-pathPâ†path (IdSâ†Id p))
           help x' refl = Î£-pathâ†’ (refl , (funextâ†’
             (Î» aâ‚ â†’ Î£-pathâ†’ (refl , (Ã—-pathâ†’ (IV , III))))))

      II : (sl : Î”Â¹ â†’ Coslice A (const A ğŸ™ a))
         â†’ Î£[ q âˆ¶ (âˆ€ j â†’ sl i0 .snd tt .HomP.hom j ï¼ a)]
             (sl i0 .snd tt .HomP.hom0 ï¼ q i0)
         â‰ƒ Î£[ sl01 âˆ¶ (sl i0 .fst ï¼ a)]
             (âˆ€ _ â†’ Hom-pathP refl sl01 (sl i0 .snd tt) (idH a))
      II x ._â‰ƒ_.fwd = II-map (x i0 .fst) (x i0 .snd tt)
      II x ._â‰ƒ_.has-is-eqv = is-equivâ†qiso (qiso (x i0 .fst) (x i0 .snd tt))

  H : _â‰ƒ_.fwd lemma-eq ~ lemma
  H = ~refl

  mirror-aut
    : (Î£[ sq âˆ¶ ((i j : Î”Â¹) â†’ A)] Î£[ p âˆ¶ (âˆ€ i â†’ sq i i0 ï¼ a)]
          Î£[ q âˆ¶ (âˆ€ j â†’ sq i0 j ï¼ a)] (p i0 ï¼ q i0))
    â†’ (Î£[ sq âˆ¶ ((i j : Î”Â¹) â†’ A)] Î£[ p âˆ¶ (âˆ€ i â†’ sq i i0 ï¼ a)]
          Î£[ q âˆ¶ (âˆ€ j â†’ sq i0 j ï¼ a)] (p i0 ï¼ q i0))
  mirror-aut (sq , p , q , coh) .fst i j = sq j i
  mirror-aut (sq , p , q , coh) .snd .fst = q
  mirror-aut (sq , p , q , coh) .snd .snd .fst = p
  mirror-aut (sq , p , q , coh) .snd .snd .snd = sym coh

  mirror-aut-invol : mirror-aut âˆ˜ mirror-aut ~ id
  mirror-aut-invol (sq , p , q , coh)
    = Î£-pathâ†’ (refl , Î£-pathâ†’ (refl , Î£-pathâ†’ (refl , sym-sym)))

  mirror-aut-is-equiv : is-equiv mirror-aut
  mirror-aut-is-equiv = is-equivâ†qiso
    ( mirror-aut
    , mirror-aut-invol
    , mirror-aut-invol)

  proj : Î£[ f âˆ¶ (Î”Â¹ â†’ Coslice A (const _ ğŸ™ a)) ] (f i0 ï¼ (a , Î» _ â†’ idH a))
       â†’ Coslice A (const _ ğŸ™ a)
  proj (f , _) = f i1

  factor1 : Î£[ f âˆ¶ (Î”Â¹ â†’ Coslice A (const _ ğŸ™ a)) ] (f i0 ï¼ (a , Î» _ â†’ idH a))
        â†’ Î£[ x âˆ¶ Arrow-map (const _ ğŸ™ i0) {C = Coslice A (const _ _ a)} fst ]
            (Arrow-map.top x tt ï¼ (a , (Î» _ â†’ idH a)))
  factor1 = total-map-fst (pullback-power (const _ ğŸ™ i0) fst)
                        {B = Î» x â†’ Arrow-map.top x tt ï¼ (a , Î» _ â†’ idH a)}

  factor2
    : Î£[ x âˆ¶ Arrow-map (const _ ğŸ™ i0) {C = Coslice A (const _ ğŸ™ a)} fst ]
            (Arrow-map.top x tt ï¼ (a , (Î» _ â†’ idH a)))
    â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)]
        Î£[ g âˆ¶ (Î£ (Coslice A (const _ ğŸ™ a)) (_ï¼ (_ , Î» _ â†’ idH a)))]
         (f i0 ï¼ g .fst .fst)
  factor2 (mk-amap f g h , p) = (g , (f tt , p) , h tt)

  factor2-qiso : quasi-iso factor2
  factor2-qiso .fst (g , (f , p) , h)
    = (mk-amap (Î» _ â†’ f) g Î» _ â†’ h) , p
  factor2-qiso .snd .fst (mk-amap f g h , p) = refl
  factor2-qiso .snd .snd (g , (f , p) , h) = refl

  factor3 : Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (f i0 ï¼ a)
        â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)]
            Î£[ g âˆ¶ (Î£ (Coslice A (const _ ğŸ™ a)) (_ï¼ (_ , Î» _ â†’ idH a)))]
             (f i0 ï¼ g .fst .fst)
  factor3 (f , p) = (f , ((a , Î» _ â†’ idH a) , refl) , p)

  factor3-inv
    : Î£[ f âˆ¶ (Î”Â¹ â†’ A)]
        Î£[ g âˆ¶ (Î£ (Coslice A (const _ ğŸ™ a)) (_ï¼ (_ , Î» _ â†’ idH a)))]
         (f i0 ï¼ g .fst .fst)
    â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (f i0 ï¼ a)
  factor3-inv (f , p , q) = (f , q âˆ™ ap fst (p .snd))

  factor3-qiso : quasi-iso factor3-inv
  factor3-qiso .fst = factor3
  factor3-qiso .snd .fst (f , ((g , k) , refl) , h)
    = Î£-pathâ†’ (refl , (Î£-pathâ†’ (refl , (âˆ™-reflr _))))
  factor3-qiso .snd .snd (f , p) = Î£-pathâ†’ (refl , âˆ™-reflr _)

  factor4 : Coslice A (const _ ğŸ™ a) â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] (f i0 ï¼ a)
  factor4 = Coslice-object-reprâ‰ƒ a ._â‰ƒ_.fwd

  factorisation : factor4 âˆ˜ proj âˆ˜ lemma
                ~ factor3-inv âˆ˜ factor2 âˆ˜ factor1 âˆ˜ lemma âˆ˜ mirror-aut
  factorisation (sq , p , q , coh) = fibre-pathâ†’ (refl , Coslice-path-ap-fst _)

  opaque
    proj-is-equiv : is-equiv proj
    proj-is-equiv = 3-for-2 {f = factor4}
      (Coslice-object-reprâ‰ƒ a ._â‰ƒ_.has-is-eqv)
      (3-for-2~' {f = factor4 âˆ˜ proj} {g = lemma}
        (factorisation ~â»Â¹)
        (lemma-eq ._â‰ƒ_.has-is-eqv)
        (is-equiv-âˆ˜ {f = factor3-inv}
          (is-equivâ†qiso factor3-qiso)
          (is-equiv-âˆ˜ {f = factor2}
            (is-equivâ†qiso factor2-qiso)
            (is-equiv-âˆ˜ {f = factor1}
              (total-is-equivâ†fst-is-equiv
                (pb-power-is-equivâ†orthogonal
                  (coslice-is-leftâ‡”is-precategory Asi .fst As a)))
              (is-equiv-âˆ˜ {f = lemma}
                (lemma-eq ._â‰ƒ_.has-is-eqv)
                mirror-aut-is-equiv)))))



precat-idr : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) {x y}
             â†’ (f : Hom A x y) â†’ (f âˆ˜[ As ] idH _) ï¼ f
precat-idr As f = sym (unique-composite As f (idH _)
  f
  (refl~â–µ f))

-- precat-idl : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) {x y}
--               â†’ (f : Hom A x y) â†’ idH _ âˆ˜[ As ] f ï¼ f
-- precat-idl As {x} {y} = YonedaJ
--   (Î» _ f â†’ idH _ âˆ˜[ As ] f ï¼ f)
--   {!!}
--   (coslice-init As {!!} x)
--   (precat-idr As (idH x)) y

-- precat-assoc
--   : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A)
--       {x y z w} (f : Hom _ z w) (g : Hom _ y z) (h : Hom _ x y)
--     â†’ (f âˆ˜[ As ] g) âˆ˜[ As ] h ï¼ (f âˆ˜[ As ] (g âˆ˜[ As ] h))
-- precat-assoc As {z = z}{w} f g h = YonedaJ
--   (Î» _ f â†’ (f âˆ˜[ As ] g) âˆ˜[ As ] h ï¼ f âˆ˜[ As ] (g âˆ˜[ As ] h))
--   {!!}
--   (coslice-init As {!!} z)
--   (ap (_âˆ˜[ As ] h) (precat-idl As g) âˆ™ sym (precat-idl As (g âˆ˜[ As ] h))) w f
}
%```
