\date{2025-02-19}
\title{Identity types}
\import{stt-macros}
\taxon{module}
\meta{module}{\startverb Foundations.Identity \stopverb}

% ```agda
\agda{
module Foundations.Identity where

open import Foundations.Universes
}% ```

\subtree[identity-def]{
\taxon{definition}

\meta{defines}{\startverb ["Id"] \stopverb}

\title{Id}

\p{
For any type #{A : \cal{U}}, and pair of terms #{a,b : A}, we can define a type #{a = b : \cal{U}} generated by the term #{\textrm{refl}_a : a = a}. If the type of the identity is not obvious from context we write #{a =_A b}.
}


% ```agda
\agda{
data Id {ğ“¤} (A : Type ğ“¤) (a : A) : A â†’ Type ğ“¤ where
  refl : Id A a a


{-# BUILTIN EQUALITY Id #-}
{-# BUILTIN REWRITE Id #-}

}
% ```
}

\subtree[identity-notation]{
\taxon{notation}
\meta{defines}{\startverb ["_=_"] \stopverb}

\p{We defined the identity type to be called \code{Id A a b}, but for convenience, we also define an infix notation: \code{a ï¼ b}.
Note that this uses the unicode equals symbol!
}

% ```agda
\agda{
infix 6 _ï¼_
_ï¼_ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ A â†’ Type ğ“¤
a ï¼ b = Id _ a b
{-# DISPLAY Id _ a b = a ï¼ b #-}

}
% ```
}


\subtree[stt-0005]{
\taxon{theorem}
\title{Identity induction}

\meta{defines}{\startverb ["J","coe","ap","tr","tr-constant"] \stopverb}

\p{ Identity induction, or the J-rule, states that for a fixed value #{a}, and given a family of types #{P} over a singleton, it is enough to
give a term at #{P(a,\refl_a)} to get a term #{P(b,p)} for any #{(b,p) : \Sigma_{b : A} a = b}.}


% ```agda
\agda{
J : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a : A} (P : (x : A) â†’ a ï¼ x â†’ Type ğ“¥)
   â†’ P a refl â†’ âˆ€ {b} â†’ (p : a ï¼ b) â†’ P b p
J P prfl refl = prfl

coe : âˆ€ {ğ“¤} {A : Type ğ“¤} {B : Type ğ“¤} â†’ A ï¼ B â†’ A â†’ B
coe refl a = a

ap : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (f : A â†’ B) â†’ {a b : A} â†’ a ï¼ b â†’ f a ï¼ f b
ap f refl = refl

tr : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) â†’ âˆ€ {a b} â†’ a ï¼ b â†’ P a â†’ P b
tr P p pa = coe (ap P p) pa
{-# NOINLINE tr #-}

tr-constant : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a b : B} â†’ (p : a ï¼ b) â†’ (a : A) â†’ tr (Î» _ â†’ A) p a ï¼ a
tr-constant refl a = refl

}
% ```

}

\subtree[stt-000B]{
\title{Groupoid structure of the universe}
\meta{defines}{\startverb
["sym","sym-sym","trans"
, "_âˆ™_", "âˆ™-refll", "âˆ™-reflr"
, "âˆ™-assoc", "âˆ™-sym", "âˆ™-sym'"
, "-âˆ™_", "_âˆ™-", "coe-postcompï¼", "coe-precompï¼"
, "pre-post-comp", "âˆ™-diff-zero'"
]
\stopverb
}

\p{The J-rule allows us to exhibit the universe as a groupoid with the identity type as the homs.}

  \ul{
    \li{Given #{x =_A y}, we can define a term of type #{y =_A x}}
    \li{Given #{x = y}, and #{y = z}, we have a term #{x = z}}
    \li{There is always a term #{x = x}}
  }
% ```agda
\agda{

sym : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} â†’ x ï¼ y â†’ y ï¼ x
sym refl = refl

sym-sym : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} {p : x ï¼ y} â†’ sym (sym p) ï¼ p
sym-sym {p = refl} = refl

-- {-#Â REWRITE  sym-sym #-} -- is not confluent

trans : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A} â†’ x ï¼ y â†’ y ï¼ z â†’ x ï¼ z
trans refl q = q

_âˆ™_ = trans
infixr 20 _âˆ™_
{-# DISPLAY trans = _âˆ™_ #-}

-âˆ™_ : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A} â†’ y ï¼ z â†’ (x ï¼ y) ï¼ (x ï¼ z)
-âˆ™ p = ap (_ ï¼_) p
{-# NOINLINE -âˆ™_ #-}

_âˆ™- : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A} â†’ y ï¼ x â†’ (y ï¼ z) ï¼ (x ï¼ z)
p âˆ™- = ap (_ï¼ _) p
{-# NOINLINE _âˆ™- #-}

âˆ™-refll : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} â†’ (p : x ï¼ y) â†’ refl âˆ™ p ï¼ p
âˆ™-refll p = refl

âˆ™-reflr : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} â†’ (p : x ï¼ y) â†’ p âˆ™ refl ï¼ p
âˆ™-reflr refl = refl

âˆ™-assoc : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z w : A} (p : x ï¼ y) (q : y ï¼ z) (r : z ï¼ w) â†’ (p âˆ™ q) âˆ™ r ï¼ p âˆ™ q âˆ™ r
âˆ™-assoc refl q r = refl

âˆ™-sym : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (p : x ï¼ y) â†’ p âˆ™ sym p ï¼ refl
âˆ™-sym refl = refl

âˆ™-sym' : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (p : x ï¼ y) â†’ sym p âˆ™ p ï¼ refl
âˆ™-sym' refl = refl

âˆ™-diff-zero' : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} {p q : x ï¼ y} â†’ p ï¼ q â†’ sym p âˆ™ q ï¼ refl
âˆ™-diff-zero' {p = p} refl = âˆ™-sym' p

coe-precompï¼ : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
               â†’  (p : x ï¼ y) (q : y ï¼ z)
               â†’ coe (-âˆ™ q) p ï¼ p âˆ™ q
coe-precompï¼ p refl = sym (âˆ™-reflr p)

coe-postcompï¼ : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
               â†’ (p : y ï¼ x) (q : y ï¼ z)
               â†’ coe (p âˆ™-) q ï¼ sym p âˆ™ q
coe-postcompï¼ refl q = refl

coe-postcompï¼' : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
               â†’ (p : x ï¼ y) (q : y ï¼ z)
               â†’ coe (sym p âˆ™-) q ï¼ p âˆ™ q
coe-postcompï¼' refl q = refl

pre-post-comp : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y : A}
                 {p : x ï¼ y} {f g : A â†’ B}
               â†’ ap (Î» z â†’ f z ï¼ g z) p ï¼ (ap f p âˆ™-) âˆ™ (-âˆ™ ap g p)
pre-post-comp {p = refl} = refl

âˆ™-symsym : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A} (p : x ï¼ y) (q : y ï¼ z)
           â†’ sym (p âˆ™ q) ï¼ sym q âˆ™ sym p
âˆ™-symsym refl refl = refl

coeâˆ™coe : âˆ€ {ğ“¤} {A B C : Type ğ“¤} (P : A ï¼ B) (Q : B ï¼ C)
          â†’ âˆ€ a
          â†’ coe Q (coe P a) ï¼ coe (P âˆ™ Q) a
coeâˆ™coe refl refl a = refl

trâˆ™tr : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} â†’ âˆ€ {a b c} (p : a ï¼ b) (q : b ï¼ c)
      (b : P a)
      â†’ tr P q (tr P p b) ï¼ tr P (p âˆ™ q) b
trâˆ™tr refl refl b = refl

trâˆ™tr-sym : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} â†’ âˆ€ {a b} (p : a ï¼ b)
            â†’ (b : P a)
            â†’ tr P (sym p) (tr P p b) ï¼ b
trâˆ™tr-sym refl b = refl

trâˆ™tr-sym' : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} â†’ âˆ€ {a b} (p : a ï¼ b)
            â†’ (b : P b)
            â†’ tr P p (tr P (sym p) b) ï¼ b
trâˆ™tr-sym' refl b = refl

tr-transpose : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} â†’ âˆ€ {a b} (p : a ï¼ b)
               â†’ (x : P a) â†’ (y : P b)
               â†’ tr P p x ï¼ y â†’ x ï¼ tr P (sym p) y
tr-transpose refl x y p = p

tr-refl : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥}
          â†’ âˆ€ {a} (p : a ï¼ a)
              (x : P a)
            â†’ p ï¼ refl
            â†’ x ï¼ tr P p x
tr-refl p x refl = refl
}
% ```
}

\subtree[stt-000C]{
\taxon{notation}
\title{Equation combinators}
\meta{defines}{\startverb
["ï¼âŸ¨âŸ©-syntax", "_ï¼âŸ¨âŸ©_", "_âˆ"]
\stopverb
}

% ```agda
\agda{
ï¼âŸ¨âŸ©-syntax : âˆ€ {ğ“¤} {A : Type ğ“¤} (x : A) {y z} â†’ y ï¼ z â†’ x ï¼ y â†’ x ï¼ z
ï¼âŸ¨âŸ©-syntax x q p = p âˆ™ q

infixr 2 ï¼âŸ¨âŸ©-syntax
syntax ï¼âŸ¨âŸ©-syntax x q p = x ï¼âŸ¨ p âŸ© q

_ï¼âŸ¨âŸ©_ : âˆ€ {ğ“¤} {A : Type ğ“¤} (x : A) {y : A} â†’ x ï¼ y â†’ x ï¼ y
x ï¼âŸ¨âŸ© p = p

_âˆ : âˆ€ {â„“} {A : Type â„“} (x : A) â†’ x ï¼ x
x âˆ = refl

infixr 2 _ï¼âŸ¨âŸ©_ 
infix  3 _âˆ
}
% ```
}
