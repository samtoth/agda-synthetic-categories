\date{2025-04-18}
\taxon{Module}
\title{Equivalences of pre(post)-composed functions}
\author{samueltoth}
\import{stt-macros}


% ```agda
\agda{
open import Foundations.FunExt

module Foundations.CompositionEquiv (FE : FunExt-global) where

open import Foundations.Universes
open import Foundations.QuasiIsomorphism
open import Foundations.CoherentIsomorphism
open import Foundations.Singleton
open import Foundations.Functions
open import Foundations.Sigma
open import Foundations.Identity
open import Foundations.Homotopy
open import Foundations.FunctionInverses
open import Foundations.FunExt
open import Foundations.EquivContrFibre
open import Foundations.DependentIdentity
}
% ```



\subtree[stt-000O]{
\taxon{Lemma}

% HoTT 4.2.8 \citet{4.2.8}{HoTT}

\p{If #{f} has a quasi-inverse, then so do ##{f \circ {-} : (A \to B) \to (A \to C)} ##{{-} \circ f : (B \to C) \to (A \to C)}}

\proof{
% ```agda
\agda{
postcomp-ret : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
             â†’ retract f â†’ retract (postcomp C f)
postcomp-ret (g , r) = (g âˆ˜_ , Î» h â†’ WithFunExtÏ‰.funextâ†’ FE (r â–¸ h))

postcomp-qinv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
             â†’ quasi-iso f â†’ quasi-iso {B = C â†’ B} (f âˆ˜_)
postcomp-qinv {f = f} (g , ret , sec) = (g âˆ˜_) , retâˆ˜ , secâˆ˜ where
  secâˆ˜ : section-witness (_âˆ˜_ f) (g âˆ˜_)
  secâˆ˜ h  = WithFunExtÏ‰.funextâ†’ FE (sec â–¸ h)

  retâˆ˜ : retract-witness (_âˆ˜_ f) (g âˆ˜_)
  retâˆ˜ h = WithFunExtÏ‰.funextâ†’ FE (ret â–¸ h)

postcomp-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                  {f : A â†’ B} {C : Type ğ“¦}
                â†’ is-equiv f â†’ is-equiv {B = C â†’ B} (f âˆ˜_)
postcomp-equiv eq = is-equivâ†qiso (postcomp-qinv (qisoâ†is-equiv eq))

postcomp-â‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} (e : A â‰ƒ B) {X : Type ğ“¦}
                â†’ (X â†’ A) â‰ƒ (X â†’ B)
postcomp-â‰ƒ (mkâ‰ƒ f e) = mkâ‰ƒ (f âˆ˜_) (postcomp-equiv e)

postcomp-Î -qinv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {C : Type ğ“¦}
                        {A : C â†’ Type ğ“¤} {B : C â†’ Type ğ“¥}
                        {f : âˆ€ {c} â†’ A c â†’ B c}
                      â†’ (âˆ€ {q} â†’ quasi-iso (f {q}))
                      â†’ quasi-iso {A = âˆ€ c â†’ A c} {B = âˆ€ c â†’ B c} (f âˆ˜_)
postcomp-Î -qinv {f = f} eq = (Î» g c â†’ eq .fst (g c)) , ret , sec where
   ret : retract-witness (Î» g a â†’ f (g a)) (Î» g c â†’ eq .fst (g c))
   ret f = WithFunExtÏ‰.funextâ†’ FE (Î» c â†’ eq .snd .fst (f c))

   sec : section-witness  (Î» g a â†’ f (g a)) (Î» g c â†’ eq .fst (g c))
   sec g = WithFunExtÏ‰.funextâ†’ FE (Î» c â†’ eq .snd .snd (g c))

postcomp-Î -equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {C : Type ğ“¦}
                    {A : C â†’ Type ğ“¤} {B : C â†’ Type ğ“¥}
                    {f : âˆ€ {c} â†’ A c â†’ B c}
                  â†’ (âˆ€ {q} â†’ is-equiv (f {q}))
                  â†’ is-equiv {A = âˆ€ c â†’ A c} {B = âˆ€ c â†’ B c} (f âˆ˜_)
postcomp-Î -equiv eq = is-equivâ†qiso (postcomp-Î -qinv (qisoâ†is-equiv eq))

postcomp-Î -â‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {C : Type ğ“¦}
                {A : C â†’ Type ğ“¤} {B : C â†’ Type ğ“¥}
              â†’ (âˆ€ c â†’ A c â‰ƒ B c)
              â†’ Î  C A â‰ƒ Î  C B
postcomp-Î -â‰ƒ peq = mkâ‰ƒ _ (postcomp-Î -equiv Î» {a} â†’ peq a ._â‰ƒ_.has-is-eqv)

postcomp-Î -â‡” : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {C : Type ğ“¦}
                {A : C â†’ Type ğ“¤} {B : C â†’ Type ğ“¥}
              â†’ (âˆ€ c â†’ A c â‡” B c)
              â†’ Î  C A â‡” Î  C B
postcomp-Î -â‡” f .fst = postcomp-Î  (fst âˆ˜ f)
postcomp-Î -â‡” f .snd = postcomp-Î  (snd âˆ˜ f)

precomp-qinv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
             â†’ quasi-iso f â†’ quasi-iso {B = A â†’ C} (_âˆ˜ f)
precomp-qinv {f = f} (g , Î· , Îµ) = (_âˆ˜ g) , Î·âˆ˜ , Îµâˆ˜ where
  Î·âˆ˜ : retract-witness (_âˆ˜ f) (_âˆ˜ g)
  Î·âˆ˜ h = WithFunExtÏ‰.funextâ†’ FE (h â—‚ Îµ)

  Îµâˆ˜ : section-witness (_âˆ˜ f) (_âˆ˜ g)
  Îµâˆ˜ h = WithFunExtÏ‰.funextâ†’ FE (h â—‚ Î·)

precomp-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} {C : Type ğ“¦}
                â†’ is-equiv f â†’ is-equiv {B = A â†’ C} (_âˆ˜ f)
precomp-equiv eq = is-equivâ†qiso (precomp-qinv (qisoâ†is-equiv eq))


precomp-â‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} (e : A â‰ƒ B) {C : Type ğ“¦}
                â†’ (B â†’ C) â‰ƒ (A â†’ C)
precomp-â‰ƒ (mkâ‰ƒ f e) = mkâ‰ƒ (_âˆ˜ f) (precomp-equiv e)

precomp-Î -qiso
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : B â†’ Type ğ“¦}
      {f : A â†’ B}
    â†’ is-equiv f
    â†’ quasi-iso (precomp-Î  C f)
precomp-Î -qiso {C = C} {f} (mk-eqv (g , Î· , Îµ) coh)
  = ((Î» h b â†’ tr C (Îµ b) (h (g b)))
  , (Î» h â†’ WithFunExtÏ‰.funextâ†’ FE Î» b â†’ apáµˆ h (Îµ b))
  , Î» h â†’ WithFunExtÏ‰.funextâ†’ FE Î» a â†’ ap (Î» x â†’ tr C x (h (g (f a)))) (sym (coh a))
                                     âˆ™ sym ( trâˆ˜ C f (Î· a) {h (g (f a))})
                                     âˆ™ apáµˆ h (Î· a))

precomp-Î -is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : B â†’ Type ğ“¦}
      {f : A â†’ B}
    â†’ is-equiv f
    â†’ is-equiv (precomp-Î  C f)
precomp-Î -is-equiv = is-equivâ†qiso âˆ˜ precomp-Î -qiso

precomp-Î -â‰ƒ
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} (C : B â†’ Type ğ“¦)
    â†’ (e : A â‰ƒ B)
    â†’ Î  B C â‰ƒ (Î  A (C âˆ˜ e ._â‰ƒ_.fwd))
precomp-Î -â‰ƒ C (mkâ‰ƒ f e) = mkâ‰ƒ (precomp-Î  C f) (precomp-Î -is-equiv e)
}
% ```
}
}

\subtree[stt-003N]{
\taxon{Theorem}
\title{Equivalences from composition equivalences}

\p{We can extend this to show that the following are equivalent:}

\ul{
\li{#{f : A \to B} is an equivalence}
\li{#{{-} \circ f} is an equivalence}
\li{#{f \circ {-}} is an equivalence}
}

% ```agda
\agda{
is-equivâ†precomp : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (f : A â†’ B)
        â†’ (H : âˆ€ {ğ“¦} {X : Type ğ“¦} â†’ is-equiv {B = A â†’ X} (_âˆ˜ f))
        â†’ is-equiv f
is-equivâ†precomp f H = is-equivâ†qiso iso where
  module e {ğ“¦} {X : Type ğ“¦} = is-equiv (H {ğ“¦} {X})
  open e

  iso : quasi-iso f
  iso .fst = bwd id
  iso .snd .fst = happly (Îµ id)
  iso .snd .snd = happly
    (ap fst (is-propâ†is-single (is-contr-mapâ†is-equiv H f)
      (f âˆ˜ bwd id , ap (f âˆ˜_) (Îµ id)) (id , refl)) )


is-equivâ†postcomp : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (f : A â†’ B)
        â†’ (H : âˆ€ {ğ“¦} {X : Type ğ“¦} â†’ is-equiv {B = X â†’ B} (f âˆ˜_))
        â†’ is-equiv f
is-equivâ†postcomp f H = is-equivâ†qiso iso where
  module e {ğ“¦} {X : Type ğ“¦} = is-equiv (H {ğ“¦} {X})
  open e

  iso : quasi-iso f
  iso .fst = bwd id
  iso .snd .fst = happly
    (ap fst
      (is-propâ†is-single (is-contr-mapâ†is-equiv H f)
                          ((bwd id âˆ˜ f) , ap (_âˆ˜ f) (Îµ id))
                          (id , refl)))
  iso .snd .snd = happly (Îµ id)
}
% ```
}
