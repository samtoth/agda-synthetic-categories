\date{2025-08-01}
\title{Descent for pushouts}
\taxon{module}
\meta{module}{Core.PushoutDescent}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.PushoutDescent where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CartesianStraightening
open import Ergonomics.Representation
open import Ergonomics.Marker
}
%```

\subtree[stt-008D]{
\title{Flattening lemma for pushouts}
\taxon{theorem}

\p{The flattening theorem essentially states that for a family #{P}
over a pushout #{A \times_C B}, the total type #{\tilde{P}} is
equivalent to the pushout of total types: #{\Sigma_A P
+_{\Sigma_C P} \Sigma_B P}.}

\proof{
\p{Given a span #{S : A \leftarrow B \rightarrow C} and a family #{P}
over the pushout of #{S}, we can define the total span #{\Sigma_{S}P}.
We first note that for some arbitrary type #{Q}, dependent cones over
#{S} at #{p \mapsto P(p) \to Q} are equivalent to cones over
#{\Sigma_{S} P} at #{Q} - this is analogous to [currying
functions](Foundations.PiProperties).  We then construct the following
square:
}

\quiver{
\begin{tikzcd}
	{\Pi_{p : A+^C B} Q^{P(p)}} && {Q^{\Sigma_{p : A+^CB} P(p)}} \\
	\\
	{\rm{cocone}^d(S,p \mapsto Q^{P(p)})} && {\rm{cocone}(\Sigma_S P,Q)}
	\arrow["{\rm{curry}}", from=1-1, to=1-3]
	\arrow["{\rm{cocone}^d}"', from=1-1, to=3-1]
	\arrow["{\rm{cocone}}", from=1-3, to=3-3]
	\arrow["{\rm{curry}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{Since, currying (functions or cocones) and the dependent cocone
map are equivalences, then so is the cocone map on the right.}

}

%```agda
\agda{
module _ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {C : Type 𝓦}
         (f : A → B) (g : A → C) where
  total-span : ∀ {𝓜} (P : Pushout f g → Type 𝓜)
               → Span _ _ _
  total-span P .Span.Centre = Σ A (P ∘ ι₂ ∘ g)
  total-span P .Span.Left = Σ B (P ∘ ι₁)
  total-span P .Span.left (a , b) = (f a , tr P (sym (glue a)) b)
  total-span P .Span.Right = Σ C (P ∘ ι₂)
  total-span P .Span.right = total-map-fst g

  total-cocone : ∀ {𝓜} (P : Pushout f g → Type 𝓜)
                 → Cocone (total-span P) (Σ (Pushout f g) P)
  total-cocone P .Cocone.p = total-map-fst ι₁
  total-cocone P .Cocone.q = total-map-fst ι₂
  total-cocone P .Cocone.filler (a , b)
    = Σ-path→ ( glue a , tr∙tr-sym' (glue a) b)

  total-is-pushout : ∀ {𝓜} (P : Pushout f g → Type 𝓜)
                     → is-pushoutω (total-span P) (total-cocone P)
  total-is-pushout P {𝓠} {Q} = eqv where
    module S' = Span (total-span P)

    Q' : Pushout f g → Type _
    Q' x = P x → Q

    lem2 : ∀ {a b} (p : a ＝ b) {x} {f : P a → Q}
           → (tr Q' p f) x ＝ f (tr P (sym p) x)
    lem2 refl = refl

    curry-cocone
      : Cocone (total-span P) Q → CoconeD _ pushout Q'
    curry-cocone (mk-cocone p q filler) = mk-coconeD (curry p) (curry q) λ
      a → funext→ λ b → lem2 (glue a) ∙ curry filler a b

    H : Arrow-map (cocone-map _ (total-cocone P) {Q})
                  (coconeᵈ-map (mk-span _ f g) pushout {Q'})
    H .Arrow-map.top = curry
    H .Arrow-map.bot = curry-cocone
    H .Arrow-map.comm h
      = ap (mk-coconeD (λ a b → h (ι₁ a , b)) (λ a b → h (ι₂ a , b)))
           (funext→ λ a → J {a = ι₁ (f a)} (λ z G →
                 funext→ (λ b → lem2 G ∙ ap h (Σ-path→ (G , tr∙tr-sym' G b)))
               ＝ apᵈ (curry h) G)
           funext-refl
           {ι₂ (g a)} (glue a))

    curry-cocone-is-equiv : quasi-iso curry-cocone
    curry-cocone-is-equiv .fst (mk-coconeD p q filler)
      = mk-cocone (uncurry p) (uncurry q)
          λ where (a , b) → sym (lem2 (glue a)) ∙ happly (filler a) b
    curry-cocone-is-equiv .snd .fst (mk-cocone p q filler)
      = Cocone-path→ _  _ (funext→ ~refl) (funext→ ~refl)
          λ a → ∙-reflr _ ∙ sym'∙ (lem2 (glue (fst a))) (filler a)
    curry-cocone-is-equiv .snd .snd (mk-coconeD p q filler)
      = ap (mk-coconeD p q) (funext→ λ
         a →   ap funext→ (funext→ (λ b → sym∙ (lem2 (glue a))
                                            (happly (filler a) b)))
             ∙ _≃_.η funext≃ (filler a))

    arr-eq : is-Arrow-equiv H
    arr-eq .fst = curry-is-equiv
    arr-eq .snd = is-equiv←qiso curry-cocone-is-equiv

    eqv : is-equiv (cocone-map _ (total-cocone P))
    eqv = is-equiv←Arrow-equiv⁻¹ {F = H} arr-eq Pushout-is-pushoutωᵈ
}
%```
}

\subtree[stt-008S]{
\title{Fibres of the cogap map}
\taxon{corollary}

\p{As a consequence of the [flattening lemma](stt-008D), we can give a
nice characterisation of fibres of [cogap maps](stt-004G). }

%```agda
\agda{
module _ {𝓤 𝓥 𝓦 𝓜} {S : Span 𝓤 𝓥 𝓦} {X : Type 𝓜}
                (C : Cocone S X) where
  open Span S

  Fibre-family : ∀ x → Pushout left right → Type 𝓜
  Fibre-family x p = cogap C p ＝ x

  cogap-fibre
    : ∀ x → fibre (cogap C) x
    ≃ Pushout (total-span _ _ (Fibre-family x) .Span.left)
              (total-span _ _ (Fibre-family x) .Span.right)
  cogap-fibre x = mk≃ _
    (is-equiv⁻¹
      (cogap-is-equiv←is-pushout _
        (total-is-pushout _ _ (Fibre-family x))))
}
%```
}

\p{Before introducing the main descent theorem, we need some auxiliary
definitions.}



\subtree[stt-008O]{
\date{2025-08-03}
\title{Pulling back squares}
\taxon{construction}

\p{Given span #{S}, and a cocone over #{S} centred at #{X}, we can
\em{'pull this square back'} along any map #{X' \to X}, to obtain a
span #{S'}, a cocone over #{S'} at #{X'} as well as a cartesian map
of spans #{S' \to S}.
}

%```agda
\agda{
module SquarePB {𝓤 𝓥 𝓦 𝓜 𝓛} {S : Span 𝓤 𝓥 𝓦} {X : Type 𝓜}
                (C : Cocone S X) {X' : Type 𝓛} (f : X' → X)
                where
  open Span S
  open Cocone C

  S' : Span (𝓤 ⊔ 𝓥 ⊔ 𝓜 ⊔ 𝓛) (𝓥 ⊔ 𝓜 ⊔ 𝓛) (𝓦 ⊔ 𝓜 ⊔ 𝓛)
  S' .Span.Centre = Pullback {B = Pullback p f} fst left
  S' .Span.Left = Pullback p f
  S' .Span.left  = fst
  S' .Span.Right = Pullback q f
  S' .Span.right ((r , x , H) , c , K) = (right c  , x , sym (sym H ∙ ap p K ∙ filler c) )

  C' : Cocone S' X'
  C' .Cocone.p = pb.π₂
  C' .Cocone.q = pb.π₂
  C' .Cocone.filler _ = refl

  proj : Span-map S' S
  proj .Span-map.h₁ = pb.π₁
  proj .Span-map.h₂ = pb.π₂
  proj .Span-map.h₃ = pb.π₁
  proj .Span-map.H  = pb.filler
  proj .Span-map.K _ = refl

  front-left : Arrow-map pb.π₁ f
  front-left = mk-amap pb.π₂ p pb.filler

  front-right : Arrow-map pb.π₁ f
  front-right = mk-amap pb.π₂ q pb.filler

  front-right-is-cart : is-cartesian (front-right)
  front-right-is-cart = is-cartesian←is-pullback _ pullback-is-pullback

  front-left-is-cart : is-cartesian front-left
  front-left-is-cart = is-cartesian←is-pullback _ pullback-is-pullback

  amap-l↓-is-cart : is-cartesian (Span-map.amap-l↓ proj)
  amap-l↓-is-cart = is-cartesian←is-pullback _ pullback-is-pullback

  amap-l-is-cart : is-cartesian (Span-map.amap-l proj)
  amap-l-is-cart = rotate-is-cartesian _ amap-l↓-is-cart

  square~ : Arrow-map-path
              (paste-squares front-left (Span-map.amap-l proj))
              (paste-squares front-right (Span-map.amap-r proj))
  square~ .fst = ~refl
  square~ .snd .fst = filler
  square~ .snd .snd ((l , x' , H) , c , refl)
    = ∙-reflr _
    ∙ sym (ap (filler c ∙_) (∙-symsym (sym H) (filler c))
          ∙ sym∙ (filler c) (sym (sym H))
          ∙ sym-sym)

  proj-is-cartesian : is-cartesian-span-map proj
  proj-is-cartesian .fst = amap-l-is-cart
  proj-is-cartesian .snd = 3-for-2-cartesian square~
    (compose-cartesian front-left-is-cart amap-l-is-cart)
    front-right-is-cart

}
%```
}




\subtree[stt-008L]{
\date{2025-08-03}
\title{Descent for pushouts}
\taxon{theorem}

\p{In the following, let #{S} be a span and #{C} be a cocone over #{S}
centred at #{X}.}

\p{Descent for pushouts states that if this cocone is a pushout, then
the map that takes a type #{X'} and a map #{X' \to X} to a cartesian
map over #{S} is an equivalence.}


%```agda
\agda{
module _ {𝓤} {Sp : Span 𝓤 𝓤 𝓤} {X : Type 𝓤}
         (C : Cocone Sp X) (C-po : is-pushoutω _ C) where

  cart-map : (Σ[ X' ∶ Type 𝓤 ] (X' → X)) → Cart Sp 𝓤 𝓤 𝓤
  cart-map (X' , f) = mk-cart S' proj proj-is-cartesian where
    open SquarePB C f


--   descent-pushout : is-equiv cart-map
--   descent-pushout =  is-equiv←Arrow-equiv {F = amap} amap-eqv (C-po)
--     where

--     cmap : ∀ (P : X → Type 𝓤)
--            → Cart-map {𝓤} {𝓤} {𝓤} {Sp} {𝓤} {𝓤}
--                       ((cart←cocone ∘ cocone-map Sp C) P)
--                       ((cart-map ∘ unstraighten) P)
--     cmap P = mk-cart-map
--       (mk-span-map (pb≃ ._≃_.fwd)
--                    (centre≃ ._≃_.fwd)
--                    (pb≃ ._≃_.fwd)
--                    comm1 comm2)
--       ~refl
--       ~refl
--       ~refl module cmap where
--       open Span Sp renaming (Centre to S;
--                              left to f;
--                              right to g;
--                              Left to A;
--                              Right to B) using ()
--       open Cocone C

--       pb≃ : ∀ {A X : Type 𝓤} {P : X → Type 𝓤} {f : A → X}
--               → (Σ[ a ∶ A ] P (f a)) ≃ Pullback f (fst {B = P})
--       pb≃ {A}{X}{P}{p} = Σ-ap-≃ λ a →
--           (P (p a))
--               ≃⟨ Σ-＝singl' e⁻¹ ⟩
--           (Σ[ x ∶ X ] ((p a ＝ x) × P x))
--               ≃⟨ Σ-ap-≃ (λ a₁ → ×-swap) ⟩
--           (Σ[ x ∶ X ] Σ[ px ∶ P x ] (p a ＝ x))
--             ≃⟨ Σ-assoc e⁻¹ ⟩
--           (Σ[ xp ∶ Σ X P ] (p a ＝ fst xp)) ≃∎

--       centre≃ :  Σ S (P ∘ q ∘ g)
--                 ≃ Pullback {B = Pullback p (fst {B = P})} (fst) f
--       centre≃
--         = Σ S (P ∘ q ∘ g)            ≃⟨ Σ-ap-≃ (λ s → coe≃ (sym (ap P (filler s))))   ⟩
--           (Σ[ s ∶ S ] (P (p (f s)))) ≃⟨ pb≃ ⟩
--           Pullback (p ∘ f) fst       ≃⟨ pb≃ ⟩
--           Pullback f fst             ≃⟨ pullback-swap ⟩
--           Pullback fst f             ≃∎

--       comm1 : _≃_.fwd pb≃ ∘ Span.left ((cart←cocone ∘ cocone-map Sp C) P .Cart.S') ~
--                Span.left ((cart-map ∘ unstraighten) P .Cart.S') ∘ _≃_.fwd centre≃
--       comm1 = ~refl

--       comm2 : _≃_.fwd pb≃ ∘ Span.right ((cart←cocone ∘ cocone-map Sp C) P .Cart.S') ~
--                Span.right ((cart-map ∘ unstraighten) P .Cart.S') ∘ _≃_.fwd centre≃
--       comm2 (s , p) = Σ-path→ (refl
--                       , Σ-path→ ((Σ-path→ (sym (filler s) , ap (λ P → coe P p) (ap-sym P _)))
--                       , IdP-func←Square {f = λ _ → q (g s)} {g = fst} _ refl _
--                          (ap (_∙ sym (filler s)) (ap-const _)
--                           ∙ sym (Σ-path-ap-fst))))

--     cmap-is-equiv : ∀ (P : X → Type 𝓤)
--                     → Cart-map-is-equiv (cmap P)
--     cmap-is-equiv P
--       = ( pb≃ P .has-is-eqv
--         , centre≃ P .has-is-eqv
--         , pb≃ P .has-is-eqv) where
--       open cmap
--       open _≃_

--     -- opaque
--     --   commutes : ∀ (P : X → Type 𝓤)
--     --            → (cart←cocone ∘ cocone-map Sp C) P ＝ (cart-map ∘ unstraighten) P
--     --   commutes P = Cart-ua→ (cmap P) (cmap-is-equiv P)

--     amap : Arrow-map (cocone-map _ C) cart-map
--     amap = mk-amap unstraighten cart←cocone {!!}

-- -- λ P → Cart-ua→ {𝓤} {𝓤} {𝓤}
-- --                     {S = Sp} {cart←cocone (cocone-map Sp C P)}
-- --                     {cart-map (unstraighten P)}
-- --                     (cmap P)
-- --                     (cmap-is-equiv P)


--     amap-eqv : is-Arrow-equiv amap
--     amap-eqv .fst = is-equiv⁻¹ straighten-is-equiv
--     amap-eqv .snd = cart←cocone-is-equiv
}
%```
}
