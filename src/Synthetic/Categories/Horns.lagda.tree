\date{2025-11-17}
\title{Simplicial horns}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Horns
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Core.Join
open import Core.CanonicalPushouts
open import Core.FlatteningPushouts
open import Core.SpanMap

open import Ergonomics.Extensionality

open import Synthetic.Hom Î”Â¹ i0 i1
}
%```


\subtree[stt-00AD]{
\taxon{Definition}
\title{The inner 2 horn}

\p{We define the type #{\Lambda^2_1} by glueing a pair of intervals end to
  end. This type comes with a canonical map into the 2-simplex.}

\quiver{
\begin{tikzcd}[cramped, sep=small]
	1 && {\Delta^1} \\
	\\
	{\Delta^1} && {\Lambda^2_1} \\
	&&& {\Delta^2}
	\arrow["1", from=1-1, to=1-3]
	\arrow["0"', from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[curve={height=-6pt}, from=1-3, to=4-4]
	\arrow[from=3-1, to=3-3]
	\arrow[curve={height=6pt}, from=3-1, to=4-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[dashed, from=3-3, to=4-4]
\end{tikzcd}
}


%```agda
\agda{
open Subtype

Î›[2,1] : Type ğ“˜
Î›[2,1] = Pushout (const _ ğŸ™ i1) (const _ ğŸ™ i0)

Î›[2,1]-Î”Â²-cocone : Cocone (mk-span ğŸ™ (const Î”Â¹ ğŸ™ i1) (const Î”Â¹ ğŸ™ i0)) Î”Â²
Î›[2,1]-Î”Â²-cocone = mk-cocone (Î» i â†’ (i , i0)) (Î» i â†’ i1 , i)
                          Î» _ â†’  Î”Â²-ext (refl , refl)

Î›[2,1]-incl : Î›[2,1] â†’ Î”Â²
Î›[2,1]-incl = cogap Î›[2,1]-Î”Â²-cocone


[2,1]-hom : âˆ€ {ğ“¤} (C : Type ğ“¤) â†’ Type (ğ“¤ âŠ” ğ“˜)
[2,1]-hom C = Î£[ f âˆ¶ (Î”Â¹ â†’ C) ] Î£[ g âˆ¶ (Î”Â¹ â†’ C)] (f i1 ï¼ g i0)

make-horn : âˆ€ {ğ“¤} {C : Type ğ“¤} {x y z} â†’ Hom C y z â†’ Hom C x y â†’ Î›[2,1] â†’ C
make-horn f g = pushout-rec (mk-cocone (g .HomP.hom) (f .HomP.hom)
                              Î» _ â†’ g .HomP.hom1 âˆ™ sym (f .HomP.hom0))

Î”Â²-diagonal : Î”Â¹ â†’ Î”Â²
Î”Â²-diagonal i = i , i
}
%```
}

\subtree[stt-00B8]{
\taxon{Theorem}

\p{The inclusion into the 2 simplex is an embedding and identifies #{\Lambda^2_1}
with the subset of #{\Delta^2} where #{i = 1} or #{j = 0}.}

\proof{
We show that the fibres of the inclusion are equivalent to the join of the
two propositions. This goes via the [flattening lemma for pushouts](stt-008D).
}

%```agda
\agda{
Î›[2,1]Sub : Subtype Î”Â² ğ“˜
Î›[2,1]Sub .family (i , j) = (i0 ï¼ j) * (i1 ï¼ i)
Î›[2,1]Sub .has-is-subtype (i , j)
  = *-is-prop (is-prop-separated _ _) (is-prop-separated _ _)

Î›[2,1]-as-subtype : âˆ€ a â†’ fibre Î›[2,1]-incl a â‰ƒ a âˆˆ Î›[2,1]Sub
Î›[2,1]-as-subtype s =
  fibre Î›[2,1]-incl s â‰ƒâŸ¨ cogap-fibre _ s âŸ©
  Pushout (total-fibre-span .left) (total-fibre-span .right)
    â‰ƒâŸ¨ coeâ‰ƒ (sym (ap (Î» x â†’ Pushout (left x) (right x))
                     (ext! (span-map , span-map-is-equiv)))) âŸ©
  Pushout (intended-span .left) (intended-span .right)
    â‰ƒâŸ¨âŸ©
  (s âˆˆ Î›[2,1]Sub) â‰ƒâˆ where
  open Span

  total-fibre-span : Span ğ“˜ ğ“˜ ğ“˜
  total-fibre-span = total-span (const _ ğŸ™ i1) (const _ ğŸ™ i0)
                                (Fibre-family Î›[2,1]-Î”Â²-cocone s)


  intended-span : Span ğ“˜ ğ“˜ ğ“˜
  intended-span = mk-span ((i0 ï¼ s .Poly.Î”Â².t) Ã— (i1 ï¼ s .Poly.Î”Â².s)) fst snd

  span-map : Span-map intended-span total-fibre-span
  span-map .Span-map.hâ‚ p = (s .Poly.Î”Â².s , Î”Â²-ext (refl , p))
  span-map .Span-map.hâ‚‚ (p , q) = (tt , Î”Â²-ext (q , p))
  span-map .Span-map.hâ‚ƒ q = (s .Poly.Î”Â².t , Î”Â²-ext (q , refl))
  span-map .Span-map.H (p , q) = Î£-pathâ†’ (sym q , is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
  span-map .Span-map.K (p , q) = Î£-pathâ†’ (sym p , is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)


  opaque
    h1-eq : quasi-iso (Span-map.hâ‚ span-map)
    h1-eq .fst (x , p) = ap Poly.Î”Â².t p
    h1-eq .snd .fst p = is-prop-separated i0 _ _ _
    h1-eq .snd .snd (p , q) = Î£-pathâ†’ (ap Poly.Î”Â².s (sym q)
                                      , is-propâ†is-truncated (Î”Â²-is-set _ _)
                                                             _ _)
    h2-eq : quasi-iso (Span-map.hâ‚‚ span-map)
    h2-eq .fst (_ , p) = (ap Poly.Î”Â².t p , ap Poly.Î”Â².s p)
    h2-eq .snd .fst (p , q) = is-prop-Î£ (is-prop-separated _ _)
                                        (Î» _ â†’ is-prop-separated _ _)
                                        _ _
    h2-eq .snd .snd (_ , p) = Î£-pathâ†’ (refl , is-propâ†is-truncated
                                                (Î”Â²-is-set _ _) _ _)

    h3-eq : quasi-iso (Span-map.hâ‚ƒ span-map)
    h3-eq .fst x = ap Poly.Î”Â².s (snd x)
    h3-eq .snd .fst p = is-prop-separated _ _ _ _
    h3-eq .snd .snd (x , p) = Î£-pathâ†’ (sym (ap Poly.Î”Â².t p)
                                      , is-propâ†is-truncated (Î”Â²-is-set _ _)
                                        _ _)

  span-map-is-equiv : is-Span-equiv span-map
  span-map-is-equiv .fst = is-equivâ†qiso h1-eq
  span-map-is-equiv .snd .fst = is-equivâ†qiso h2-eq
  span-map-is-equiv .snd .snd = is-equivâ†qiso h3-eq

Î›[2,1]â‰ƒSub : Î›[2,1] â‰ƒ Î£Ìƒ Î›[2,1]Sub
Î›[2,1]â‰ƒSub
  = Î›[2,1]                            â‰ƒâŸ¨ totalâ‰ƒtotal-fibre Î›[2,1]-incl eâ»Â¹ âŸ©
    total-fibre Î›[2,1]-incl           â‰ƒâŸ¨âŸ©
    (Î£[ a âˆ¶ Î”Â² ] fibre Î›[2,1]-incl a) â‰ƒâŸ¨ Î£-ap-â‰ƒ Î›[2,1]-as-subtype âŸ©
    (Î£[ a âˆ¶ Î”Â² ] (a âˆˆ Î›[2,1]Sub))     â‰ƒâŸ¨âŸ©
    Î£Ìƒ Î›[2,1]Sub                       â‰ƒâˆ

Î›[2,1]-is-set : is-truncated 2 Î›[2,1]
Î›[2,1]-is-set = Trunc.is-truncatedâ†equiv (Î›[2,1]â‰ƒSub eâ»Â¹)
                  (Trunc.Î£-is-truncated Î”Â²-is-set
                    Î» a â†’ suc-is-truncated 1
                           (is-truncatedâ†is-prop (âˆˆ-is-prop Î›[2,1]Sub a)))

}
%```
}

\subtree[tot-000A]{
\taxon{Lemma}

\p{We include a useful alternative dependent universal property for inner horns.}

%```agda
\agda{
Î›[2,1]-UP : âˆ€ {ğ“¤} (B : Î›[2,1] â†’ Type ğ“¤)
       â†’ Î  Î›[2,1] B
       â‰ƒ Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)]
            HomP (B âˆ˜ Î¹â‚‚) (tr B (glue tt) (f i1)) z
Î›[2,1]-UP B = mkâ‰ƒ (map2 ._â‰ƒ_.fwd âˆ˜ coconeáµˆ-map span pushout {Q = B})
              (is-equiv-âˆ˜ (_â‰ƒ_.has-is-eqv map2) Pushout-is-pushoutÏ‰áµˆ) where
  span : Span lzero ğ“˜ ğ“˜
  span = mk-span _ (const Î”Â¹ ğŸ™ i1) (const Î”Â¹ ğŸ™ i0)

  by-inserting-singleton
    : (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
          Î£[ g âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              (g i0 ï¼ coe (ap B (glue tt)) (f i1)))
    â‰ƒ (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)] Î£[ h âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              Î£[ h0 âˆ¶ h i0 ï¼ coe (ap B (glue tt)) (f i1) ]
               (h i1 ï¼ z) )
  by-inserting-singleton = equivâ†qiso qiso where
    qiso : _
    qiso ._â‰…_.fwd (f , g , h) = (f , g i1 , g , h , refl)
    qiso ._â‰…_.fwd-iso .fst (f , _ , g , h , refl) = (f , g , h)
    qiso ._â‰…_.fwd-iso .snd .fst = ~refl
    qiso ._â‰…_.fwd-iso .snd .snd (f , _ , g , h , refl) = refl

  map2 : CoconeD span pushout B
       â‰ƒ Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)]
            HomP (B âˆ˜ Î¹â‚‚) (tr B (glue tt) (f i1)) z

  map2
    = CoconeD span pushout B â‰ƒâŸ¨ coconeD-reprâ‰ƒ âŸ©

      (Î£[ f âˆ¶ ((l : Î”Â¹) â†’ B (Î¹â‚ l)) ]
        Î£[ g âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
          ((a : ğŸ™) â†’ f i1 ï¼[ ap B (glue a) ] g i0))

                          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» f â†’ Î£-ap-â‰ƒ (Î» g â†’ unit-UPâ‰ƒ âˆ™â‰ƒ symâ‰ƒ)) âŸ©

      (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
          Î£[ g âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              (g i0 ï¼ coe (ap B (glue tt)) (f i1)))

                         â‰ƒâŸ¨ by-inserting-singleton âŸ©

      (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)] Î£[ h âˆ¶ ((r : Î”Â¹) â†’ B (Î¹â‚‚ r)) ]
              Î£[ h0 âˆ¶ h i0 ï¼ coe (ap B (glue tt)) (f i1) ]
               (h i1 ï¼ z) )

                          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-ap-â‰ƒ (Î» b â†’ HomP-reprâ‰ƒ eâ»Â¹)) âŸ©

      (Î£[ f âˆ¶ ((i : Î”Â¹) â†’ B (Î¹â‚ i))]
           Î£[ z âˆ¶ B (Î¹â‚‚ i1)]
            HomP (B âˆ˜ Î¹â‚‚) (tr B (glue tt) (f i1)) z)    â‰ƒâˆ
}
%```
}
