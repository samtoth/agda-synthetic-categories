\title{Lattices}
\date{2025-06-19}
\taxon{module}
\author{markwilliams}
\import{stt-macros}
\meta{module}{\startverb Algebra.Lattice \stopverb}

%```agda
\agda{
module Algebra.Lattice where

open import ufAxioms
open import Foundations.Prelude
open import Algebra.Poset
open import Modalities.Instances.Truncation
open import Core.CoSlice
open import Ergonomics.Auto
open import Ergonomics.Universal
open import Ergonomics.Marker
open import Ergonomics.Representation
open import Ergonomics.Extensionality
}
%```

\subtree[stt-009T]{
\title{Lattices}
\taxon{definition}
\p{A lattice #{L} is an algebraic strucutre with two operations
   #{\wedge,\vee : L \to L \to L}, satisfying absorption laws.
   Equivalently this structure can be described by a poset, with
   operations taking binary meets and joins for each pair of
   elements.}

%```agda
\agda{

record is-lattice {ğ“¤} {L : Type ğ“¤} (0l 1l : L) (_âˆ§_ : L â†’ L â†’ L)
                  (_âˆ¨_ : L â†’ L â†’ L) : Type ğ“¤ where
  no-eta-equality
  field
    car-is-set  : is-truncated 2 L
    âˆ§-assoc : {x y z : L} â†’ x âˆ§ (y âˆ§ z) ï¼ (x âˆ§ y) âˆ§ z
    âˆ¨-assoc : {x y z : L} â†’ x âˆ¨ (y âˆ¨ z) ï¼ (x âˆ¨ y) âˆ¨ z
    âˆ§-comm : {x y : L} â†’ x âˆ§ y ï¼ y âˆ§ x
    âˆ¨-comm : {x y : L} â†’ x âˆ¨ y ï¼ y âˆ¨ x
    âˆ¨-âˆ§-abs : {x y : L} â†’ x âˆ¨ (x âˆ§ y) ï¼ x
    âˆ§-âˆ¨-abs : {x y : L} â†’ x âˆ§ (x âˆ¨ y) ï¼ x
    0-bottom : {x : L} â†’ x âˆ¨ 0l ï¼ x
    1-top    : {x : L} â†’ x âˆ§ 1l ï¼ x

record Lattice {â„“} (L : Type â„“) : Type â„“ where
  field
    0l 1l : L
    _âˆ§_ : L â†’ L â†’ L
    _âˆ¨_ : L â†’ L â†’ L
    str-is-lattice : is-lattice 0l 1l (_âˆ§_) (_âˆ¨_)
  infixr 24 _âˆ§_
  infixr 25 _âˆ¨_

  _â‰¤_ : L â†’ L â†’ Type â„“
  x â‰¤ y = x âˆ§ y ï¼ x

  open is-lattice str-is-lattice public

  0-init : âˆ€ {x} â†’ 0l âˆ§ x ï¼ 0l
  0-init {x}
    =   0l âˆ§ x
      ï¼âŸ¨ ap (0l âˆ§_) (sym (âˆ¨-comm âˆ™ 0-bottom)) âŸ©
        (0l âˆ§ (0l âˆ¨ x))
      ï¼âŸ¨ âˆ§-âˆ¨-abs âŸ©
        0l âˆ

  â‰¤-is-poset : is-poset (_â‰¤_)
  â‰¤-is-poset =
    record { â‰¤-is-prop = â‰¤-is-prop
           ; â‰¤-refl = â‰¤-refl
           ; â‰¤-trans = â‰¤-trans
           ; â‰¤-antisym = â‰¤-antisym }
    where
      â‰¤-is-prop : {x y : L} â†’ is-prop (x â‰¤ y)
      â‰¤-is-prop {x} {y} = is-propâ†is-truncated (car-is-set (x âˆ§ y) x)

      â‰¤-refl : {x : L} â†’ x â‰¤ x
      â‰¤-refl {x} = x âˆ§ x             ï¼âŸ¨ ap (x âˆ§_) (sym âˆ¨-âˆ§-abs) âŸ©
                   x âˆ§ (x âˆ¨ (x âˆ§ x)) ï¼âŸ¨ âˆ§-âˆ¨-abs âŸ©
                   x âˆ

      â‰¤-trans : {x y z : L} â†’ x â‰¤ y â†’ y â‰¤ z â†’ x â‰¤ z
      â‰¤-trans {x} {y} {z} p q =  x âˆ§ z        ï¼âŸ¨  ap (_âˆ§ z) (sym p)  âŸ©
                                  (x âˆ§ y) âˆ§ z ï¼âŸ¨ sym âˆ§-assoc âŸ©
                                  x âˆ§ (y âˆ§ z) ï¼âŸ¨ ap (x âˆ§_) q âŸ©
                                  x âˆ§ y       ï¼âŸ¨ p âŸ©
                                  x âˆ

      â‰¤-antisym : {x y : L} â†’ x â‰¤ y â†’ y â‰¤ x â†’ x ï¼ y
      â‰¤-antisym {x} {y} p q = sym p âˆ™ âˆ§-comm âˆ™ q

record is-lattice-hom
        {ğ“¤} {ğ“¤'} {A : Type ğ“¤} {B : Type ğ“¤'}
        (L : Lattice A) (M : Lattice B) (f : A â†’ B) : Type (ğ“¤ âŠ” ğ“¤') where
  private
    module A = Lattice L
    module B = Lattice M
  field
    pres-âˆ¨ : {x y : A} â†’ f (x A.âˆ¨ y) ï¼ f x B.âˆ¨ f y
    pres-âˆ§ : {x y : A} â†’ f (x A.âˆ§ y) ï¼ f x B.âˆ§ f y
    pres-0 : f A.0l ï¼ B.0l
    pres-1 : f A.1l ï¼ B.1l

is-lattice-algebra : âˆ€ {ğ“¤ ğ“¥ : Level} {A : Type ğ“¤} {B : Type ğ“¥}
                       (L : Lattice A) (M : Lattice B) (f : A â†’ B)
                     â†’ Type (ğ“¤ âŠ” ğ“¥)
is-lattice-algebra = is-lattice-hom

initial-lattice-algebra : âˆ€ {ğ“¤ : Level} {A : Type ğ“¤} (L : Lattice A)
                          â†’ is-lattice-algebra L L id
initial-lattice-algebra L .is-lattice-hom.pres-âˆ¨ = refl
initial-lattice-algebra L .is-lattice-hom.pres-âˆ§ = refl
initial-lattice-algebra L .is-lattice-hom.pres-0 = refl
initial-lattice-algebra L .is-lattice-hom.pres-1 = refl

is-lattice-alg-hom : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                        (L : Lattice A)
                        (M : Lattice B) {f : A â†’ B}
                      â†’ is-lattice-algebra L M f
                      â†’ (N : Lattice C) {g : A â†’ C}
                      â†’ is-lattice-algebra L N g
                      â†’ Coslice-map f g â†’ Type (ğ“¥ âŠ” ğ“¦)
is-lattice-alg-hom L M _ N _ (h , H) = is-lattice-hom M N h
}
%```


\subtree[stt-009S]{
\title{Congruences}
\taxon{definition}
\p{An equivalence relation #{\sim} on a lattice #{L} is a congruence if it
respects all lattice operations}

%```agda
\agda{
module Congruence where

record Equivalence {ğ“¤ ğ“¥} {A : Type ğ“¤} (_~_ : A â†’ A â†’ Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  field
    ~-is-prop : {x y : A} â†’ is-prop (x ~ y)
    reflexive : {x : A} â†’ x ~ x
    symmetric : {x y : A} â†’ x ~ y â†’ y ~ x
    transitive : {x y z : A} â†’ x ~ y â†’ y ~ z â†’ x ~ z

record LatticeCongruence {ğ“¤ ğ“¥} {A : Type ğ“¤} (L : Lattice A)
                         (_~_ : A â†’ A â†’ Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  open Lattice L
  field
    ~-equivalence : Equivalence (_~_)
    ~-âˆ¨ : {a1 a2 b1 b2 : A} â†’ a1 ~ b1 â†’ a2 ~ b2 â†’ a1 âˆ¨ a2 ~ b1 âˆ¨ b2
    ~-âˆ§ : {a1 a2 b1 b2 : A} â†’ a1 ~ b1 â†’ a2 ~ b2 â†’ a1 âˆ§ a2 ~ b1 âˆ§ b2

  open Equivalence (~-equivalence) public


module _ {ğ“¤} {ğ“¥} {A : Type ğ“¤} {L : Lattice A} where
  open Lattice L
  data âŸª_âŸ« (R : A â†’ A â†’ Type ğ“¥) : A â†’ A â†’ Type (ğ“¤ âŠ” ğ“¥) where
    âŸªâŸ«-inc  : {a b : A} â†’ R a b â†’ âŸª R âŸ« a b
    âŸªâŸ«-refl : {a : A} â†’ âŸª R âŸ« a a
    âŸªâŸ«-sym  : {a b : A} â†’ âŸª R âŸ« a b â†’ âŸª R âŸ« b a
    âŸªâŸ«-trans : {a b c : A} â†’ âŸª R âŸ« a b â†’ âŸª R âŸ« b c â†’ âŸª R âŸ« a c
    âŸªâŸ«-âˆ¨ : {a1 a2 b1 b2 : A} â†’ âŸª R âŸ« a1 b1 â†’ âŸª R âŸ« a2 b2 â†’ âŸª R âŸ« (a1 âˆ¨ a2) (b1 âˆ¨ b2)
    âŸªâŸ«-âˆ§ : {a1 a2 b1 b2 : A} â†’ âŸª R âŸ« a1 b1 â†’ âŸª R âŸ« a2 b2 â†’ âŸª R âŸ« (a1 âˆ§ a2) (b1 âˆ§ b2)

  âŸªâŸ«-congruence : {R : A â†’ A â†’ Type ğ“¥}
                â†’ LatticeCongruence L (Î» x y â†’ âˆ¥ âŸª R âŸ« x y âˆ¥)
  âŸªâŸ«-congruence {R} = l-con where
    open LatticeCongruence
    open Trunc {1}

    l-eq : Equivalence (Î» x y â†’ âˆ¥ âŸª R âŸ« x y âˆ¥)
    l-eq .Equivalence.~-is-prop = is-propâ†is-truncated â—‹âˆˆS
    l-eq .Equivalence.reflexive = Î· âŸªâŸ«-refl
    l-eq .Equivalence.symmetric a = do
      rxy â† a
      return (âŸªâŸ«-sym rxy)
    l-eq .Equivalence.transitive a b = do
      rxy â† a
      ryz â† b
      return (âŸªâŸ«-trans rxy ryz)

    l-con : LatticeCongruence L (Î» x y â†’ âˆ¥ âŸª _ âŸ« x y âˆ¥)
    l-con .~-equivalence = l-eq
    l-con .~-âˆ¨ p q = do
      r1 â† p
      r2 â† q
      return (âŸªâŸ«-âˆ¨ r1 r2)
    l-con .~-âˆ§ p q = do
      r1 â† p
      r2 â† q
      return (âŸªâŸ«-âˆ§ r1 r2)
}
%```
}
}


\subtree[stt-007X]{
\title{Distributive lattices}
\taxon{definition}

%```agda
\agda{
module _ {ğ“¤} {L : Type ğ“¤} (Lat : Lattice L) where
  open Lattice Lat

  is-distributive : Type ğ“¤
  is-distributive = âˆ€ {x y z} â†’ x âˆ¨ (y âˆ§ z) ï¼ (x âˆ¨ y) âˆ§ (x âˆ¨ z)

  distrib-âˆ¨-âˆ§' : is-distributive
               â†’ âˆ€ {x y z} â†’ (x âˆ§ y) âˆ¨ z ï¼ (x âˆ¨ z) âˆ§ (y âˆ¨ z)
  distrib-âˆ¨-âˆ§' d = âˆ¨-comm âˆ™ d âˆ™ apâ‚‚ _âˆ§_ âˆ¨-comm âˆ¨-comm

  distrib-âˆ§-âˆ¨ : is-distributive
            â†’ âˆ€ {x y z} â†’ x âˆ§ (y âˆ¨ z) ï¼ (x âˆ§ y) âˆ¨ (x âˆ§ z)
  distrib-âˆ§-âˆ¨ dist {x} {y} {z}
    = âŒœ x âŒ âˆ§ y âˆ¨ z               ï¼âŸ¨ ap! (sym âˆ§-âˆ¨-abs) âŸ©
      ((x âˆ§ x âˆ¨ z) âˆ§ y âˆ¨ z )      ï¼âŸ¨ sym âˆ§-assoc âŸ©
      (x âˆ§ x âˆ¨ z âˆ§ y âˆ¨ z)         ï¼âŸ¨ apâ‚‚ _âˆ§_
                                         (sym âˆ¨-âˆ§-abs âˆ™ âˆ¨-comm)
                                         (sym (distrib-âˆ¨-âˆ§' dist)) âŸ©
      ((x âˆ§ y) âˆ¨ x âˆ§ (x âˆ§ y) âˆ¨ z) ï¼âŸ¨ sym dist âŸ©
      ((x âˆ§ y) âˆ¨ (x âˆ§ z)) âˆ

  distrib-âˆ§-âˆ¨' : is-distributive
            â†’ âˆ€ {x y z} â†’ (x âˆ¨ y) âˆ§ z ï¼ (x âˆ§ z) âˆ¨ (y âˆ§ z)
  distrib-âˆ§-âˆ¨' d = âˆ§-comm âˆ™ distrib-âˆ§-âˆ¨ d âˆ™ apâ‚‚ _âˆ¨_ âˆ§-comm âˆ§-comm

}
%```
}
