\date{2025-02-26}
\title{Function extensionality}
\taxon{Module}

\import{stt-macros}


\subtree[stt-0023]{
\title{Idea}

\p{
Function extensionality says that any homotopy between functions can be made into an equality between functions.

Or equivalently, that #{\textrm{happly} : f = g \to f \sim g} is an equivalence.
}

}

% ```agda
\agda{
module Foundations.FunExt where

open import Foundations.Universes
open import Foundations.Functions
open import Foundations.CoherentIsomorphism
open import Foundations.Identity
open import Foundations.DependentIdentity
open import Foundations.Homotopy
open import Foundations.Sigma
open import Foundations.DependentHomotopy
}
% ```


\subtree[stt-0024]{
\title{Function extensionality}
\taxon{Definition}

\p{Because function extensionality is a property of universes, we build up our definition in stages:
We first define function extensionality relative to a single universe, so that the predicate lives in the successor universe.

In order to account for maps from different universe levels, we also define a predicate on a single universe, which says that paths in maps
with domain type in any universe are characterised by homotopies - this quantifies over universes so must live in #{\UU^\omega}.

Finaly we define global function extensionality,
which says that all (canonical) universes satisfy function extensionality in the above sense, with this final definition of course also
living in #{\UU^\omega}.}

% ```agda
\agda{

FunExt : (ğ“¤ : Level) â†’ Type (lsuc ğ“¤)
FunExt ğ“¤ = âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤} {f g : (a : A) â†’ B a}
           â†’ is-equiv (happly {f = f} {g})

FunExtÏ‰ : Level â†’ TypeÏ‰
FunExtÏ‰ ğ“¥ = âˆ€ {ğ“¤} â†’ âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a}
                   â†’ is-equiv (happly {f = f} {g})

FunExt-global : TypeÏ‰
FunExt-global = âˆ€ {ğ“¥} â†’ FunExtÏ‰ ğ“¥

}
% ```
}

% ```agda
\agda{
module WithFunExt {ğ“¥} (fe : FunExt ğ“¥) where
  funextâ‰ƒ : âˆ€ {A : Type ğ“¥} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a} â†’ (f ï¼ g) â‰ƒ (f ~ g)
  funextâ‰ƒ {ğ“¤} = mkâ‰ƒ happly fe

  funextâ†’ : âˆ€ {A : Type ğ“¥} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a} â†’ f ~ g â†’ f ï¼ g
  funextâ†’ p = is-equiv.bwd fe p 

  funext-J : âˆ€ {ğ“¦} {A : Type ğ“¥} {B : A â†’ Type ğ“¥} {f : (a : A) â†’ B a}
               â†’ (M : (g : (a : A) â†’ B a) â†’ f ~ g â†’ Type ğ“¦) â†’ M f ~refl
               â†’ âˆ€ (g : (a : A) â†’ B a) (h : f ~ g) â†’ M g h
  funext-J M mrfl g h = tr (M g) (is-equiv.Îµ fe h) (J (Î» g p â†’ M g (happly p)) mrfl (funextâ†’ h))

  funext-rec : âˆ€ {ğ“¦} {A : Type ğ“¥} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a}
                 (M : f ~ g â†’ Type ğ“¦)
               â†’ (âˆ€ p â†’ M (happly p))
               â†’ âˆ€ h â†’ M h
  funext-rec M p h = tr M (is-equiv.Îµ fe h) (p (funextâ†’ h))

  funext-refl : âˆ€ {A : Type ğ“¥} {B : A â†’ Type ğ“¥} {f : Î  A B} â†’ funextâ†’ (~refl) ï¼ refl {a = f}
  funext-refl = is-equiv.Î· fe refl

module WithFunExtÏ‰ {ğ“¥} (fe : FunExtÏ‰ ğ“¥) where
  funextâ‰ƒ : âˆ€ {ğ“¤} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a} â†’ (f ï¼ g) â‰ƒ (f ~ g)
  funextâ‰ƒ {ğ“¤} = mkâ‰ƒ happly fe

  module funext {ğ“¤} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
                {f g : Î  A B} = _â‰ƒ_ (funextâ‰ƒ {_}{A}{B}{f}{g})

  funextâ†’ : âˆ€ {ğ“¤} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a} â†’ f ~ g â†’ f ï¼ g
  funextâ†’ p = is-equiv.bwd fe p

  funext-J : âˆ€ {ğ“¤ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f : (a : A) â†’ B a}
               â†’ (M : (g : (a : A) â†’ B a) â†’ f ~ g â†’ Type ğ“¦) â†’ M f ~refl
               â†’ âˆ€ (g : (a : A) â†’ B a) (h : f ~ g) â†’ M g h
  funext-J M mrfl g h = tr (M g) (is-equiv.Îµ fe h) (J (Î» g p â†’ M g (happly p)) mrfl (funextâ†’ h))

  funext-rec : âˆ€ {ğ“¤ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a}
                 (M : f ~ g â†’ Type ğ“¦)
               â†’ (âˆ€ p â†’ M (happly p))
               â†’ âˆ€ h â†’ M h
  funext-rec M p h = tr M (is-equiv.Îµ fe h) (p (funextâ†’ h))

  funext-refl : âˆ€ {ğ“¤} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f : Î  A B} â†’ funextâ†’ (~refl) ï¼ refl {a = f}
  funext-refl = is-equiv.Î· fe refl

  funext-âˆ™ : âˆ€ {ğ“¤} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
               {f g h : Î  A B} (p : f ~ g) (q : g ~ h)
             â†’ funextâ†’ (p ~âˆ™ q) ï¼ funextâ†’ p âˆ™ funextâ†’ q
  funext-âˆ™ p = funext-J (Î» f' H â†’ âˆ€ q â†’ funextâ†’ (H ~âˆ™ q) ï¼ funextâ†’ H âˆ™ funextâ†’ q)
                 (Î» q â†’ sym (ap (_âˆ™ funextâ†’ q) funext-refl)) _ p

module WithFunExt-global (fe : FunExt-global) where
  module FE {ğ“¥} = WithFunExtÏ‰ {ğ“¥} fe
  open FE public


  Î -path : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B C : A â†’ Type ğ“¥}
           â†’ B ï¼ C â†’ ((a : A) â†’ B a) ï¼ ((a : A) â†’ C a)
  Î -path p = ap (Î» f â†’ (a : _) â†’ f a) p

  funextáµˆâ†’ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B C : A â†’ Type ğ“¥}
            {P : B ~ C}
            {f : (a : A) â†’ B a}
            {g : (a : A) â†’ C a}
            â†’ f ~[ P ] g â†’ f ï¼[ ap (Î» f â†’ (a : A) â†’ f a) (funextâ†’ P)  ] g
  funextáµˆâ†’ {A = A} {P = P} {f} = funext-J (Î» C P â†’ âˆ€ {g : (a : A) â†’ C a} â†’ f ~[ P ] g â†’ f ï¼[  Î -path (funextâ†’ P) ] g)
                                 (funext-J (Î» g h â†’ f ï¼[ Î -path (funextâ†’ ~refl) ] g) (IdP-refl (ap Î -path funext-refl)) _) _ P

}
% ```
