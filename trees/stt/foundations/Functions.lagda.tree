\date{2025-02-20}
\title{Function types}

\import{stt-macros}

% ```agda
\agda{
module foundations.Functions where

open import foundations.universe
open import foundations.Sigma
open import foundations.Identity
open import foundations.Singleton
}
% ```



% ```agda
\agda{
id : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ A
id a = a
{-# INLINE id #-}

infixr 40 _âˆ˜_
_âˆ˜_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {C : {a : A} â†’ B a â†’ Type ğ“¦}
      â†’ (f : {a : A} â†’ (b : B a) â†’ C b) â†’ (g : (a : A) â†’ B a) â†’ (a : A) â†’ C (g a)
f âˆ˜ g = Î» a â†’ f (g a)


happly : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a} â†’ f ï¼ g â†’ (a : A) â†’ f a ï¼ g a
happly refl a = refl

}
% ```



\subtree{
\title{Functions are functors}
% ```agda
\agda{
ap : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y : A} â†’ (f : A â†’ B) â†’ x ï¼ y â†’ f x ï¼ f y
ap f refl = refl

ap-refl : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x : A} â†’ (f : A â†’ B) â†’ ap f (refl {a = x}) ï¼ refl
ap-refl f = refl

ap-âˆ™ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y z : A} â†’ (f : A â†’ B) â†’ (p : x ï¼ y) â†’ (q : y ï¼ z) â†’ ap f (p âˆ™ q) ï¼ ap f p âˆ™ ap f q
ap-âˆ™ f refl p = refl

ap-âˆ™âˆ™ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y z w : A} â†’ (f : A â†’ B)
        â†’ (p : x ï¼ y) â†’ (q : y ï¼ z) â†’ (r : z ï¼ w)
        â†’ ap f (p âˆ™ q âˆ™ r) ï¼ ap f p âˆ™ ap f q âˆ™ ap f r
ap-âˆ™âˆ™ f refl q r = ap-âˆ™ f q r

ap-id : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (p : x ï¼ y) â†’ ap id p ï¼ p
ap-id refl = refl

{-# REWRITE ap-id #-}

ap-comp : âˆ€ {ğ“¤ ğ“¥ ğ“¦}  {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {x y : A}
          (f : B â†’ C) (g : A â†’ B) (p : x ï¼ y) â†’ ap (f âˆ˜ g) p ï¼ ap f (ap g p)
ap-comp f g refl = refl

apâ‚‚ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {x y : A} {u v : B} â†’ (f : A â†’ B â†’ C) â†’ x ï¼ y â†’ u ï¼ v â†’ f x u ï¼ f y v
apâ‚‚ f refl refl = refl

}
% ```

}

\subtree[stt-000M]{
\taxon{definition}
\title{Fibres}
\p{Given a function #{f : A \to B}, we define the fibre of #{f} at #{b : B}, notated #{\fibre{f}{a}} to be the type
#{\Sigma_{a : A}{f(a) = b}}. }

\p{Note that this is subtly different to the preimage, as we can show that #{\Sigma_{(b : B)} \fibre{f}{b}} is equivalent to #{A} itself.}

% ```agda
\agda{

fibre : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ B â†’ Type (ğ“¤ âŠ” ğ“¥)
fibre f b = Î£ _ Î» a â†’ f a ï¼ b

total-fibre : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
total-fibre f = Î£ _ (fibre f)
}
% ```
}

\p{The fibre type gives us a useful tool for talking about properties of maps. Generally if we have a property of types for example being #{n}-connected, we reuse the same terminology on maps to mean all fibres of the map have the corresponding property.}


\subtree{
\taxon{definition}
\title{propositional maps}

\p{We call a map propositional if the fibres are all sub-singletons. We will learn later that this is equivalent to the property of a map being an embedding.
This notion is a generalisation of injective set functions, infact if we - for a moment - imagine fibre to mean preimage, then a function of sets is injecte if each preimage is either empty or has a unique inhabitant.}

% ```agda
\agda{
is-prop-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-prop-map f = âˆ€ b â†’ is-subsingleton (fibre f b)
}
% ```
}


\subtree{
\taxon{definition}
\title{contractible maps}

\p{A map is said to be contractible if each of its fibres is a singleton (is contractible). We will see later that this is one of many notions of an equivalence of maps.}

\agda{
is-contr-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-contr-map f = âˆ€ b â†’ is-singleton (fibre f b)
}
% ```
}

