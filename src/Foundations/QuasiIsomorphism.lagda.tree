\date{2025-02-21}
\title{Quasi Isomorphisms}
\taxon{Module}

\import{stt-macros}

\p{Naively, an isomorphism is a function with a two-sided inverse. We can encode this directly in HoTT, but there is an issue;
being an isomorphism in this way is \em{not a [property](stt-0009)} of a type, but instead it is extra structure. This is in contrast to the
(many equivalent) notions of equivalence.}

% ```agda
\agda{
module Foundations.QuasiIsomorphism where

open import Foundations.Universes
open import Foundations.Functions
open import Foundations.FunctionInverses
open import Foundations.Singleton
open import Foundations.Sigma
open import Foundations.Identity
open import Foundations.Homotopy
}
% ```

\subtree[stt-001K]{
  \taxon{Definition}
  \title{Quasi-isomorphism}

  \p{We want to reserve the word isomorphism for the coherent kind in [[Foundations.CoherentIsomorphism]], and so here we define the naive kind of
  isomorphism to be called a quasi-isomorphism.}


% ```agda
\agda{
quasi-iso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
quasi-iso f = Î£ _ Î» g â†’ retract-witness f g Ã— section-witness f g

infix 20 _â‰…_
record _â‰…_ {ğ“¤ ğ“¥} (A : Type ğ“¤) (B : Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  constructor mk-iso
  field
    fwd : A â†’ B
    fwd-iso : quasi-iso fwd

  bwd : B â†’ A
  bwd = fwd-iso .fst

  section-fwd : section fwd
  section-fwd = bwd , fwd-iso .snd .snd

  retract-fwd : retract fwd
  retract-fwd = bwd , fwd-iso .snd .fst

  section-bwd : section bwd
  section-bwd = fwd , retractâ†’section {g = bwd} (retract-fwd .snd)

  retract-bwd : retract bwd
  retract-bwd = fwd , sectionâ†’retract {g = fwd} (section-fwd .snd)
}
% ```
}

\subtree[stt-001L]{
\taxon{Remark}
\title{Isomorphisms form a groupoid on types}

% ```agda
\agda{
idiso : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â‰… A
idiso = mk-iso id (id , ~refl , ~refl)

comp-has-qiso : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                  {f : A â†’ B} {g : B â†’ C}
                  â†’ quasi-iso f â†’ quasi-iso g â†’ quasi-iso (g âˆ˜ f)
comp-has-qiso {f = f} {g} (finv , fret , fsec) (ginv , gret , gsec) = (finv âˆ˜ ginv , ret , sec) where
  sec : section-witness (g âˆ˜ f) (finv âˆ˜ ginv)
  sec = g âˆ˜ f âˆ˜ finv âˆ˜ ginv ~âŸ¨ g â—‚ fsec â–¸ ginv âŸ©
        g âˆ˜ ginv            ~âŸ¨ gsec âŸ©
        id                  ~âˆ

  ret : retract-witness (g âˆ˜ f) (finv âˆ˜ ginv)
  ret = finv âˆ˜ ginv âˆ˜ g âˆ˜ f ~âŸ¨ finv â—‚ gret â–¸ f âŸ©
        finv âˆ˜ f            ~âŸ¨ fret âŸ©
        id ~âˆ

comp-qiso : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
           â†’ A â‰… B â†’ B â‰… C â†’ A â‰… C
comp-qiso (mk-iso f fi) (mk-iso g gi) = mk-iso (g âˆ˜ f) (comp-has-qiso fi gi)


inv-iso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰… B â†’ B â‰… A
inv-iso (mk-iso fwd (bwd , sec , ret)) = mk-iso bwd (fwd , ret , sec)

infix 19 _â‰…â»Â¹
infixr 19 _âˆ™â‰…_

_âˆ™â‰…_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
           â†’ A â‰… B â†’ B â‰… C â†’ A â‰… C
_âˆ™â‰…_ = comp-qiso

_â‰…â»Â¹ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰… B â†’ B â‰… A
_â‰…â»Â¹ = inv-iso

}
% ```
}
