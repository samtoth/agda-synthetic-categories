\title{Commuting cubes}
\taxon{Module}
\author{samueltoth}
\date{2025-12-01}

\import{stt-macros}

%```agda
\agda{
module Core.Cube where

open import Foundations.Prelude
open import Core.Arrow
}
%```


\subtree[stt-00B2]{
\title{Commuting cube}
\taxon{Definition}

\p{Given a pair of arrow maps #{F : f \to g} and #{G : h \to k}, we define the
type of commuting cubes, consisting of a quadruple of maps, fillers for each
of the resulting faces, and a coherence that fills in the solid area of the
cube. Alternatively, this data can be packages up as pair of arrow maps
#{L : f \to h} and #{R : g \to k} together with a homotopy of arrow maps
#{GL \sim RF}.}

\quiver{
\begin{tikzcd}[cramped]
	& X && Z \\
	A && C \\
	& Y && W \\
	B && D
	\arrow[from=1-2, to=1-4]
	\arrow[from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow[from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow[from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow[from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

%```agda
\agda{
record Cube {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
            {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
            {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
            (F : Arrow-map f g)
            {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
            {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
            (G : Arrow-map h k) : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“§ âŠ” ğ“› âŠ” ğ“œ âŠ” ğ“ âŠ” ğ“) where
  module F = Arrow-map F
  module G = Arrow-map G
  field
    left : Arrow-map f h
    right : Arrow-map g k
    comm : Arrow-map-path (paste-squares G left) (paste-squares right F)

  topl : A â†’ X
  topl = left .Arrow-map.top

  topr : C â†’ Z
  topr = right .Arrow-map.top

  botl : B â†’ Y
  botl = left .Arrow-map.bot

  botr : D â†’ W
  botr = right .Arrow-map.bot

  bot : G.bot âˆ˜ botl ~ botr âˆ˜ F.bot
  bot = comm .snd .fst

  top : G.top âˆ˜ topl ~ topr âˆ˜ F.top
  top = comm .fst


  top-amap : Arrow-map F.top G.top
  top-amap .Arrow-map.top = topl
  top-amap .Arrow-map.bot = topr
  top-amap .Arrow-map.comm = top ~â»Â¹

  bot-amap : Arrow-map F.bot G.bot
  bot-amap .Arrow-map.top = botl
  bot-amap .Arrow-map.bot = botr
  bot-amap .Arrow-map.comm = bot ~â»Â¹
}
%```
}


\subtree[stt-00B3]{
\title{Cartesian commuting cubes preserve pullbacks}
\taxon{Theorem}

\p{Consider a commuting cube where the left and right squares are cartesian,}
\quiver{
\begin{tikzcd}[cramped]
	& X && Z \\
	A && C \\
	& Y && W \\
	B && D
	\arrow[from=1-2, to=1-4]
	\arrow[from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow[from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow[from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow[from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

\p{then the front square is cartesian if the back square is.}

\proof{
\p{Follows from the 3 for 2 property for cartesian squares.}
}


%```agda
\agda{
front-cartesianâ†cartesian-cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      (F : Arrow-map f g)
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      (G : Arrow-map h k)
    â†’ (cube : Cube F G) â†’ let open Cube cube
    in is-cartesian left â†’ is-cartesian right
    â†’ is-cartesian G â†’ is-cartesian F
front-cartesianâ†cartesian-cube {f = f} F {k = k} G cube leftCart rightCart GCart
  = 3-for-2-cartesian
      comm
      (compose-cartesian GCart leftCart)
      rightCart where
  open Cube cube
}
%```
}
