\title{Wedge sums}
\taxon{Module}
\date{2026-02-06}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.WedgeSum where

open import Foundations.Prelude
open import ufAxioms

open import Core.CanonicalPushouts
open import Core.FlatteningPushouts
open import Core.Join
open import Core.SpanMap
open import Core.FunctorialPullback
open import Core.FunctorialPushout

open import Modalities.Instances.Truncation

open import Ergonomics.Extensionality
}
%```

\subtree[stt-00E8]{
\title{Wedge sum}
\taxon{Definition}

\p{Given a pair of pointed types, #{A} and #{B}, their wedge sum, written #{A
\vee B} is the pushout of #{A \leftarrow 1 \rightarrow B} given by the points of
#{A} and #{B}. By convention we point the wedge at #{\iota_1(A_{\bullet})}
(although we just as well could have chosen #{\iota_2(B_{\bullet})}).}

%```agda
\agda{
Wedge : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â†’ B â†’ Type (ğ“¤ âŠ” ğ“¥)
Wedge a b = Pushout (const _ ğŸ™ a) (const _ ğŸ™ b)
{-# NOINLINE Wedge #-}

Wedgeâˆ™ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (a : A) (b : B) â†’ Wedge a b
Wedgeâˆ™ a b = Î¹â‚ a

}
%```
}

\subtree[stt-00E9]{
\taxon{Lemma}

\p{There is a canonical (pointed) inclusion of the wedge sum into the product.
The fibre of this map at some #{(x,y) : A \times B} is the join
#{A_\bullet = x * B_\bullet = y}.}

%```agda
\agda{
Wedge-embed
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
    â†’ Wedge a b â†’ A Ã— B
Wedge-embed {a = a} {b = b}
  = cogap (mk-cocone
      (Î» a' â†’ (a' , b))
      (Î» b' â†’ (a , b'))
      ~refl)

opaque
  Wedge-fibre
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
      â†’ âˆ€ x y â†’ fibre (Wedge-embed {a = a}{b}) (x , y) â‰ƒ ((b ï¼ y) * (a ï¼ x))
  Wedge-fibre {ğ“¤} {ğ“¥} {a = a}{b} x y
    = fibre Wedge-embed (x , y) â‰ƒâŸ¨ cogap-fibre _ (x , y) âŸ©
      Pushoutâ‚€ total-fibre-span â‰ƒâŸ¨ coeâ‰ƒ (ap Pushoutâ‚€
                                        (sym (ext! (span-map , span-map-eqv)))) âŸ©
      Pushoutâ‚€ intended-span    â‰ƒâŸ¨âŸ©
      (ULift ğ“¤ (b ï¼ y) * ULift ğ“¥ (a ï¼ x))
                                â‰ƒâŸ¨ mkâ‰ƒ _
                                    (is-equivâ†qiso
                                      (Pushout-qiso span-qisoâ†’ span-qiso)) âŸ©
      ((b ï¼ y) * (a ï¼ x))     â‰ƒâˆ where

    total-fibre-span : Span (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥)
    total-fibre-span = total-span (const _ ğŸ™ a) (const _ ğŸ™ b)
                         (Fibre-family _ (x , y))

    intended-span : Span (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥) (ğ“¤ âŠ” ğ“¥)
    intended-span .Span.Centre = ULift ğ“¤ (b ï¼ y) Ã— ULift ğ“¥ (a ï¼ x)
    intended-span .Span.Left = ULift ğ“¤ (b ï¼ y)
    intended-span .Span.left = fst
    intended-span .Span.Right = ULift ğ“¥ (a ï¼ x)
    intended-span .Span.right = snd

    span-qisoâ†’ : Span-map  intended-span (mk-span ((b ï¼ y) Ã— (a ï¼ x)) fst snd)
    span-qisoâ†’ .Span-map.hâ‚ = unlift
    span-qisoâ†’ .Span-map.hâ‚‚ = unlift âŠ— unlift
    span-qisoâ†’ .Span-map.hâ‚ƒ = unlift
    span-qisoâ†’ .Span-map.H = ~refl
    span-qisoâ†’ .Span-map.K = ~refl

    span-qiso : Span-quasi-iso span-qisoâ†’
    span-qiso .Span-quasi-iso.bwd .Span-map.hâ‚ = mk-lift
    span-qiso .Span-quasi-iso.bwd .Span-map.hâ‚‚ = mk-lift âŠ— mk-lift
    span-qiso .Span-quasi-iso.bwd .Span-map.hâ‚ƒ = mk-lift
    span-qiso .Span-quasi-iso.bwd .Span-map.H = ~refl
    span-qiso .Span-quasi-iso.bwd .Span-map.K = ~refl
    span-qiso .Span-quasi-iso.Îµ = Span-map-homotopy-refl _
    span-qiso .Span-quasi-iso.Î· = Span-map-homotopy-refl _

    span-map : Span-map intended-span total-fibre-span
    span-map .Span-map.hâ‚ p = (x , Ã—-pathâ†’ (refl , unlift p))
    span-map .Span-map.hâ‚‚ p = (tt , Ã—-pathâ†’ (Ã—-swapâ†’ ((unlift âŠ— unlift) p)))
    span-map .Span-map.hâ‚ƒ p = (y , Ã—-pathâ†’ (unlift p , refl))
    span-map .Span-map.H (mk-lift refl , mk-lift refl)
      = Î£-pathâ†’ (refl , sym (Idáµˆ-funcâ†Square (sym (glue tt)) refl refl
          (Square-degen-hor _ _
            ( ap-sym Wedge-embed (glue tt)
            âˆ™ ap sym (pushout-rec-apÎ² _)
            âˆ™ sym (ap-const (sym (glue tt)))))))
    span-map .Span-map.K (mk-lift refl , mk-lift refl) = refl

    span-map-eqv : is-Span-equiv span-map
    span-map-eqv .fst
      = is-equiv-âˆ˜
          (is-total-equivâ†is-fibrewise-equiv (Î» x â†’ Ã—-path ._â‰ƒ_.has-is-eqv))
          ((mkâ‰ƒ _ (is-equivâ»Â¹ lift-is-equiv) âˆ™â‰ƒ Î£-ï¼singl eâ»Â¹) ._â‰ƒ_.has-is-eqv)
    span-map-eqv .snd .fst
      = (Ã—-swap âˆ™â‰ƒ mkâ‰ƒ _ (is-equivâ»Â¹ (âŠ—-is-equiv lift-is-equiv lift-is-equiv))
        âˆ™â‰ƒ Ã—-path âˆ™â‰ƒ Î£-singl ğŸ™-is-singleton tt eâ»Â¹)._â‰ƒ_.has-is-eqv
    span-map-eqv .snd .snd
      = is-equiv-âˆ˜
          (is-total-equivâ†is-fibrewise-equiv (Î» x â†’ Ã—-path ._â‰ƒ_.has-is-eqv))
          ((mkâ‰ƒ _ (is-equivâ»Â¹ lift-is-equiv)
           âˆ™â‰ƒ Î£-ï¼singl eâ»Â¹ âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» aâ‚ â†’ Ã—-swap)) ._â‰ƒ_.has-is-eqv)

}
%```
}

\subtree[stt-00EA]{
\title{The Wedge of sets is a set}
\taxon{Corollary}

\proof{
\p{By \ref{stt-00E9}, the fibre of the inclusion is a join of paths in #{A} and
#{B}. If #{A} and #{B} are both sets, then this fibre is a proposition. Hence,
the wedge is a subset of the product of #{A} and #{B} which is itself a set.}
}

%```agda
\agda{
opaque
  Wedge-is-set
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
      â†’ is-truncated 2 A â†’ is-truncated 2 B â†’ is-truncated 2 (Wedge a b)
  Wedge-is-set {A = A}{B}{a}{b} as bs = Trunc.is-truncatedâ†equiv
    ((Î£[ (x , y) âˆ¶ A Ã— B ] ((b ï¼ y) * (a ï¼ x)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ (_eâ»Â¹ âˆ˜ uncurry Wedge-fibre) âŸ©
     (Î£[ x âˆ¶ A Ã— B ] fibre Wedge-embed x) â‰ƒâŸ¨âŸ©
     total-fibre Wedge-embed â‰ƒâŸ¨ totalâ‰ƒtotal-fibre Wedge-embed âŸ©
     Wedge a b â‰ƒâˆ)
    (Trunc.Î£-is-truncated
      trunc!
      (Î» _ â†’ suc-is-truncated 1
              (is-truncatedâ†is-prop
                (*-is-prop
                  (is-propâ†is-truncated trunc!)
                  (is-propâ†is-truncated trunc!)))))
    where instance
      at : Is-truncated 2 A
      at .Is-truncated.has-is-truncated = as
      bt : Is-truncated 2 B
      bt .Is-truncated.has-is-truncated = bs

instance
  Wedge-Is-set
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A} {b : B}
        â¦ƒ _ : Is-truncated 2 A â¦„ â¦ƒ _ : Is-truncated 2 B â¦„
      â†’ Is-truncated 2 (Wedge a b)
  Wedge-Is-set .Is-truncated.has-is-truncated = Wedge-is-set trunc! trunc!
}
%```
}
