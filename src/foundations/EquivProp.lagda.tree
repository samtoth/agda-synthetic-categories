\date{2025-02-26}
\title{Being an equivalence is a proposition}
\taxon{module}
\meta{module}{\startverb foundations.EquivProp \stopverb}
\author{samueltoth}

\import{stt-macros}

\subtree[stt-001Y]{
\taxon{theorem}

\p{Under the assumption of function extentionality, we have that for any map #{f : A \to B}, the type #{\textrm{isEquiv}(f)} is
a [proposition](stt-0009).}
}


% ```
\agda{

open import foundations.FunExt

module foundations.EquivProp (FE : FunExt-global) where

open import foundations.Universes
open import foundations.CoherentIsomorphism
open import foundations.QuasiIsomorphism
open import foundations.Functions
open import foundations.FunctionInverses
open import foundations.Sigma
open import foundations.Identity
open import foundations.Homotopy
open import foundations.Singleton
open import foundations.EquivSingleton
open import foundations.SingletonClosure
open import foundations.EquivContrFibre
open import foundations.SigmaPath
open import foundations.FibrewiseEquiv
open import foundations.FibrePath
open import foundations.TheoremOfChoice

}
% ```


\subtree[stt-000O]{
\taxon{lemma}
\meta{defines}{\startverb ["precomp-qinv", "precomp-equiv", "precomp-equiv", "family-precomp-qinv",
                           "postcomp-qinv", "postcomp-equiv", "postcomp-≃"] \stopverb}
% HoTT 4.2.8 \citet{4.2.8}{HoTT}

\p{If #{f} has a quasi-inverse, then so do ##{f \circ - : (C \to A) \to (C \to B)} ##{- \circ f : (A \to C) \to (B \to C)}}

\proof{
% ```agda
\agda{
precomp-qinv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} {C : Type 𝓦}
             → quasi-iso f → quasi-iso {B = C → B} (f ∘_)
precomp-qinv {f = f} (g , ret , sec) = (g ∘_) , ret∘ , sec∘ where
  sec∘ : section-witness (_∘_ f) (g ∘_)
  sec∘ h  = WithFunExtω.funext→ FE (sec ▸ h)

  ret∘ : retract-witness (_∘_ f) (g ∘_)
  ret∘ h = WithFunExtω.funext→ FE (ret ▸ h)

precomp-equiv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} {C : Type 𝓦}
                → is-equiv f → is-equiv {B = C → B} (f ∘_)
precomp-equiv eq = is-equiv←qiso (precomp-qinv (qiso←is-equiv eq))                

precomp-≃ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} (e : A ≃ B) {X : Type 𝓦}
                → (X → A) ≃ (X → B)
precomp-≃ (mk≃ f e) = mk≃ (f ∘_) (precomp-equiv e)

family-precomp-qinv : ∀ {𝓤 𝓥 𝓦} {C : Type 𝓦} {A : C → Type 𝓤} {B : C → Type 𝓥} {f : ∀ {c} → A c → B c} 
                → (∀ {q} → quasi-iso (f {q})) → quasi-iso {A = ∀ c → A c} {B = ∀ c → B c} (λ g a → f {a} (g a))
family-precomp-qinv {f = f} eq = (λ g c → eq .fst (g c)) , ret , sec where
   ret : retract-witness (λ g a → f (g a)) (λ g c → eq .fst (g c))
   ret f = WithFunExtω.funext→ FE (λ c → eq .snd .fst (f c))

   sec : section-witness  (λ g a → f (g a)) (λ g c → eq .fst (g c))
   sec g = WithFunExtω.funext→ FE (λ c → eq .snd .snd (g c))

family-precomp-equiv : ∀ {𝓤 𝓥 𝓦} {C : Type 𝓦} {A : C → Type 𝓤} {B : C → Type 𝓥} {f : ∀ {c} → A c → B c} 
                → (∀ {q} → is-equiv (f {q})) → is-equiv {A = ∀ c → A c} {B = ∀ c → B c} (λ g a → f {a} (g a))
family-precomp-equiv eq = is-equiv←qiso (family-precomp-qinv (qiso←is-equiv eq))


postcomp-qinv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} {C : Type 𝓦}
             → quasi-iso f → quasi-iso {B = A → C} (_∘ f)
postcomp-qinv {f = f} (g , η , ε) = (_∘ g) , η∘ , ε∘ where
  η∘ : retract-witness (_∘ f) (_∘ g)
  η∘ h = WithFunExtω.funext→ FE (h ◂ ε)

  ε∘ : section-witness (_∘ f) (_∘ g)
  ε∘ h = WithFunExtω.funext→ FE (h ◂ η)

postcomp-equiv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} {C : Type 𝓦}
                → is-equiv f → is-equiv {B = A → C} (_∘ f)
postcomp-equiv eq = is-equiv←qiso (postcomp-qinv (qiso←is-equiv eq))


postcomp-≃ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} (e : A ≃ B) {C : Type 𝓦}
                → (B → C) ≃ (A → C)
postcomp-≃ (mk≃ f e) = mk≃ (_∘ f) (postcomp-equiv e)

}
% ```
}

}

\subtree[stt-000Q]{
\meta{HoTT}{4.2.9}
\taxon{lemma}


\meta{defines}{\startverb ["retracts-is-single←qinv", "section-is-single←qinv"] \stopverb}

\p{
If #{f : A \to B} is an inverse then the types of sections of #{f} and retracts of #{f} are singletons.
}

\proof{

\citet{4.2.9}{HoTT}

\p{
By function extensionality, the type of sections of #{f} is equivalent to #{\Sigma_{(g : B \to A)} fg = \id}, but this is
just the fibre of #{(-\circ f)} at #{\id}. This type is contractible because [[foundations.EquivContrFibre]].

}

% ```agda
\agda{

retracts-is-single←qinv : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} → quasi-iso f → is-singleton (retract f)
retracts-is-single←qinv {f = f} fqe = is-single←equiv-to-single {A = fibre (_∘ f) id} (Σ-ap-≃ (λ h → WithFunExt.funext≃ FE))
                                        (is-contr-map←is-equiv (is-equiv←qiso (postcomp-qinv fqe)) id)

section-is-single←qinv : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} → quasi-iso f → is-singleton (section f)
section-is-single←qinv {f = f} fqe = is-single←equiv-to-single {A = fibre (f ∘_) id} (Σ-ap-≃ λ h → WithFunExt.funext≃ FE) 
                                        (is-contr-map←is-equiv (is-equiv←qiso (precomp-qinv fqe)) id)
}
% ```
}
}



\subtree[stt-0020]{
\taxon{definition}

\meta{defines}{\startverb ["section-coherence"] \stopverb}

\p{Following the proof given in \citet{4.2}{HoTT}, we split the type #{\textrm{is-equiv}(f)} into a section and the
data witnissing the section map as a retract together with the coherence. We call this latter type a section-coherence for a
section #{s}.}

% ```agda
\agda{
section-coherence : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} (f : A → B) → section f → Type (𝓤 ⊔ 𝓥)
section-coherence f (g , ε) = Σ (g ∘ f ~ id) λ η → f ◂ η ~ ε ▸ f
}
% ```
}

\subtree[stt-0022]{

\taxon{lemma}

\p{We can show that given an equivalence #{f}, and a section #{s} of f, the type of section coherences of s is a singleton.}


\proof{
% ```agda
\agda{
Π-ap-≃ : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : A → Type 𝓥} {B' : A → Type 𝓦} → (∀ a → B a ≃ B' a) → Π A B ≃ Π A B'
Π-ap-≃ {A = A} {B} {B'} beq = equiv←qiso lem where
  module beq a = _≃_ (beq a)

  lem : ((a : A) → B a) ≅ ((a : A) → B' a)
  lem ._≅_.fwd x a = beq.fwd a (x a)
  lem ._≅_.fwd-iso .fst x a = beq.bwd a (x a)
  lem ._≅_.fwd-iso .snd .fst x = WithFunExtω.funext→ FE (λ a → beq.retract-fwd a .snd (x a))
  lem ._≅_.fwd-iso .snd .snd f = WithFunExtω.funext→ FE (λ a → beq.section-fwd a .snd (f a))

  

section-coherence-path : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} (sec@(g , ε) : section f) →
                           (section-coherence f sec) ≃ (∀ (x : A) → Id (fibre f (f x)) (g (f x) , ε (f x)) (x , refl))
section-coherence-path {f = f} (g , ε)
  = Σ (g ∘ f ~ id) (λ η → f ◂ η ~ ε ▸ f)                        ≃⟨ Σ-Π-swap≃ _ _ e⁻¹ ⟩
    (∀ a → Σ ((g ∘ f) a ＝ a) (λ η → ap f η ＝ ε (f a)))         ≃⟨ Π-ap-≃ (λ _ → Σ-ap-≃ lem) ⟩
    (∀ a → Σ ((g ∘ f) a ＝ a) (λ η → ap f η ∙ refl ＝ ε (f a)))  ≃⟨ Π-ap-≃ (λ a → fibre-path≃ e⁻¹ ) ⟩
    (∀ x → Id (fibre f (f x)) (g (f x) , ε (f x)) (x , refl))   ≃∎ where
   lem : ∀ {a} (p : g (f a) ＝ a) → (ap f p ＝ ε (f a)) ≃ (ap f p ∙ refl ＝ ε (f a))
   lem p = equiv←Id (ap (_＝ ε (f _)) (sym (∙-reflr _)))

section-coherence-singleton : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B} → is-equiv f
                              → ∀ (s : section f) → is-singleton (section-coherence f s)
section-coherence-singleton {f = f} feq s = is-single←equiv-to-single (section-coherence-path s e⁻¹)
  (Singleton-Π FE λ x → Singleton-Id (is-contr-map←is-equiv feq (f x)) _ _)
}
% ```
}
}


\subtree[stt-001Z]{

\taxon{proof}
\title{Proof of theorem [\lbrack{}stt-001Y\rbrack{}](stt-001Y)}

% ```agda
\agda{

is-equiv-is-prop : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
                   → {f : A → B} → is-prop (is-equiv f)
is-equiv-is-prop {f = f} = is-prop←is-single-if-inhabited
  (λ eq → is-single←equiv-to-single ((equiv←qiso lem) e⁻¹)
           (Singleton-Σ (section-is-single←qinv (is-equiv.qiso eq ))
                        (section-coherence-singleton eq))) where
  lem : is-equiv f ≅ Σ (section f) (section-coherence f)
  lem ._≅_.fwd (mk-eqv (g , η , ε) coh) = (g , ε) , (η , coh)
  lem ._≅_.fwd-iso .fst ((g , ε) , η , coh) = mk-eqv (g , η , ε) coh
  lem ._≅_.fwd-iso .snd .fst a = refl
  lem ._≅_.fwd-iso .snd .snd a = refl
}
% ```
}

\subtree[stt-0021]{
\title{Characterising the path of equivalences}
\taxon{corollary}

\p{As an easy corollary we can characterise the equality of an equivalence as an equivalence of functions}


% ```agda
\agda{
≃-path : ∀ {𝓤 𝓥} → {A : Type 𝓤} {B : Type 𝓥} → (e1 e2 : A ≃ B) → Type (𝓤 ⊔ 𝓥)
≃-path e1 e2 = fwd e1 ＝ fwd e2 where open _≃_

≃-path→ : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} → {e1 e2 : A ≃ B} → ≃-path e1 e2 → e1 ＝ e2
≃-path→ {e1 = e1@(mk≃ f eq) } {e2@(mk≃ f' eq')} refl = help (is-equiv-is-prop eq eq') where
  help : (q : eq ＝ eq') → e1 ＝ e2
  help refl = refl
}
% ```

}
