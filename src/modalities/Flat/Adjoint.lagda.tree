\date{2025-06-11}
\title{Right adjoint to the Flat Modality}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb modalities.Flat.Adjoint \stopverb}
\import{stt-macros}

%```agda
\agda{
open import foundations.Prelude
open import ufAxioms
open import modalities.HigherModality

module modalities.Flat.Adjoint (@â™­ Sharp : âˆ€ {ğ“¤} â†’ HigherModality ğ“¤) where

module â™¯ {ğ“¤} = HigherModality (Sharp {ğ“¤})
open â™¯ using () renaming (â—‹_ to âŸ¨â™¯|_âŸ©;
                          â—‹-Î· to â™¯-Î·;
                          â—‹-ind to â™¯-ind;
                          â—‹-Î² to â™¯-Î²;
                          is-â—‹-modal to is-codisc)

open import modalities.Flat.Flat
}
%```

\p{Suppose we have a [higher modality](stt-000G) #{\modsharp{-}}. In this module
we define a sufficient condition for this modality to be a right adjoint to
#{\flat}.}


\subtree[stt-0059]{
\taxon{definition}

\p{We say that a modality #{\sharp} satisfies a crisp induction principal if
given a crisp type #{A} and any family of types #{B} over #{A}, then to define
a map #{\Pi_{a : A} \modsharp{B(a)}}, it suffices to define a map
#{\Pi_{a :^\flat A} B(a)}. Furthermore, the action of crisp induction on
a crisp element should be the modal unit of #{\modsharp{-}}}


%```agda
\agda{
record has-crisp-ind : TypeÏ‰ where
  field
    crisp-ind : âˆ€ {@â™­ ğ“¤} {ğ“¥} {@â™­ A : Type ğ“¤} (B : A â†’ Type ğ“¥)
                â†’ ((@â™­ x : A) â†’ B x) â†’ (x : A) â†’ âŸ¨â™¯| B x âŸ©

    crisp-ind-Î² : âˆ€ {@â™­ ğ“¤} {ğ“¥} {@â™­ A : Type ğ“¤} {B : A â†’ Type ğ“¥}
                  â†’ (f : (@â™­ x : A) â†’ B x) â†’ (@â™­ x : A)
                  â†’ crisp-ind B f x ï¼ â™¯-Î· (f x)

    crisp-â™¯ : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} â†’ @â™­ âŸ¨â™¯| A âŸ© â†’ A
    crisp-â™¯-unitÎ² : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} (@â™­ x : A)
                â†’ crisp-â™¯ (â™¯-Î· x) ï¼ x
    crisp-â™¯-unitÎ· : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} (@â™­ x : âŸ¨â™¯|  A âŸ©)
                â†’ â™¯-Î· (crisp-â™¯ x) ï¼ x

    _âŠ¢âŸ¨â™¯|_âŸ© : âˆ€ {@â™­ ğ“¤} {ğ“¥} (@â™­ Î“ : Type ğ“¤)
                (C : @â™­ Î“ â†’ Type ğ“¥)
              â†’ (x : Î“) â†’ Type ğ“¥
    _âŠ¢âŸ¨â™¯|_âŸ©-crisp : âˆ€ {@â™­ ğ“¤} {ğ“¥} (@â™­ Î“ : Type ğ“¤)
                      (C : @â™­ Î“ â†’ Type ğ“¥)
                    â†’ (@â™­ x : Î“) â†’ (Î“ âŠ¢âŸ¨â™¯| C âŸ©) x ï¼ âŸ¨â™¯| C x âŸ©

    crisp-pws-ind : âˆ€ {@â™­ ğ“¤} {ğ“¥} {@â™­ A : Type ğ“¤} (B : @â™­ A â†’ Type ğ“¥)
                â†’ ((@â™­ x : A) â†’ B x) â†’ Î  _ (A âŠ¢âŸ¨â™¯| (Î» x â†’ B x) âŸ©)

-- syntax Î“ âŠ¢âŸ¨â™¯| (Î» x â†’ C) âŸ© = âŸ¨â™¯| x âˆ¶ Î“ â†¦ C âŸ©

âŸ¨â™¯â™­|_âŸ© : âˆ€ {@â™­ ğ“¤} â†’ @â™­ Type ğ“¤ â†’ Type ğ“¤
âŸ¨â™¯â™­| A âŸ© = âŸ¨â™¯| âŸ¨â™­| A âŸ© âŸ©

âŸ¨â™­â™¯|_âŸ© : âˆ€ {@â™­ ğ“¤} â†’ @â™­ Type ğ“¤ â†’ Type ğ“¤
âŸ¨â™­â™¯| A âŸ© = âŸ¨â™­| âŸ¨â™¯| A âŸ© âŸ©

â™¯-eats-â™­ : has-crisp-ind â†’
           âˆ€ {@â™­ ğ“¤} â†’ {@â™­ A : Type ğ“¤} â†’ âŸ¨â™¯â™­| A âŸ© â†’ âŸ¨â™¯| A âŸ©
â™¯-eats-â™­ C = crisp-ind _ Î» x â†’ Îµ (crisp-â™¯ x) where open has-crisp-ind C

â™­-eats-â™¯ : @â™­ has-crisp-ind â†’
           âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} â†’ âŸ¨â™­â™¯| A âŸ© â†’ âŸ¨â™­| A âŸ©
â™­-eats-â™¯ C (modâ™­ a) = modâ™­ (crisp-â™¯ a) where open has-crisp-ind C

â™­-eats-â™¯â‰ƒ : @â™­ has-crisp-ind â†’
           âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} â†’ âŸ¨â™­â™¯| A âŸ© â‰ƒ âŸ¨â™­| A âŸ©
â™­-eats-â™¯â‰ƒ C = mkâ‰ƒ (â™­-eats-â™¯ C) (is-equivâ†qiso qiso) where
  open has-crisp-ind C

  qiso : quasi-iso (â™­-eats-â™¯ C)
  qiso .fst = â™­-map â™¯-Î·
  qiso .snd .fst (modâ™­ x) = modâ™­ï¼ (modâ™­ (crisp-â™¯-unitÎ· x))
  qiso .snd .snd (modâ™­ a) = modâ™­ï¼ (modâ™­ (crisp-â™¯-unitÎ² a))

apâ™­ : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
      â†’ (f : @â™­ A â†’ B) â†’ {@â™­ x y : A} â†’ @â™­ x ï¼ y
      â†’ f x ï¼ f y
apâ™­ f refl = refl
}
%```

\citet{Theorem 5.6}{shulmanRealCohesive2017}

%```agda
\agda{
J-crisp : @â™­ has-crisp-ind â†’ âˆ€ {@â™­ ğ“¤ ğ“¥} â†’ J-crisp-ind ğ“¤ ğ“¥
J-crisp C {A = A}{a} P prfl p = {!!} where
  open has-crisp-ind C
  Mot : (@â™­ b' : A) (p : a ï¼ b') â†’ Type _
  Mot b' = _ âŠ¢âŸ¨â™¯| (Î» p â†’ P b' p ) âŸ©

  lem : âˆ€ (@â™­ b : A) (p : a ï¼ b) â†’ Mot b p
  lem b' = crisp-pws-ind (P b') Î» x â†’ {!Jâ™­ Mot ? x!}

adj : @â™­ has-crisp-ind â†’
      âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
      â†’ (âŸ¨â™­| (âŸ¨â™­| A âŸ© â†’ B) âŸ©) â‰ƒ (âŸ¨â™­| (A â†’ âŸ¨â™¯| B âŸ©) âŸ©)
adj C {A = A} {B = B} = mkâ‰ƒ fwd (is-equivâ†qiso qiso) where
  open has-crisp-ind C

  fwd : âŸ¨â™­| (âŸ¨â™­| A âŸ© â†’ B)âŸ© â†’ âŸ¨â™­| (A â†’ âŸ¨â™¯| B âŸ©)âŸ©
  fwd (modâ™­ f) = modâ™­ (crisp-ind _ Î» x â†’ f (modâ™­ x))

  bwd : âŸ¨â™­| (A â†’ âŸ¨â™¯| B âŸ©)âŸ© â†’ âŸ¨â™­| (âŸ¨â™­| A âŸ© â†’ B) âŸ©
  bwd (modâ™­ f) = modâ™­ (Î» where (modâ™­ x) â†’ crisp-â™¯ (f x))

  qiso : quasi-iso fwd
  qiso .fst = bwd
  qiso .snd .fst (modâ™­ f) = modâ™­ï¼ (modâ™­ (funextâ†’ (Î» where
    (modâ™­ a) â†’   apâ™­ crisp-â™¯ (crisp-ind-Î² _ a)
               âˆ™ crisp-â™¯-unitÎ² (f (modâ™­ a)))))
  qiso .snd .snd (modâ™­ f) = {!!}
}
%```
}
