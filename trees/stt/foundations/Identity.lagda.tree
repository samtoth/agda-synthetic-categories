\date{2025-02-19}
\title{Identity types}
\import{stt-macros}


\subtree[identity-def]{
\taxon{definition}

\title{Id}

\p{
For any type #{A : \cal{U}}, and pair of terms #{a,b : A}, we can define a type #{a = b : \cal{U}} generated by the term #{\textrm{refl}_a : a = a}. If the type of the identity is not obvious from context we write #{a =_A b}.
}

% ```agda
\agda{
module foundations.Identity where

open import foundations.universe

data Id {ğ“¤} (A : Type ğ“¤) (a : A) : A â†’ Type ğ“¤ where
  refl : Id A a a


{-# BUILTIN EQUALITY Id #-}
{-# BUILTIN REWRITE Id #-}

}
% ```
}

\subtree[identity-notation]{
\taxon{notation}

\p{We defined the identity type to be called \code{Id A a b}, but for convenience, we also define an infix notation: \code{a ï¼ b}.
Note that this uses the unicode equals symbol!
}

% ```agda
\agda{
infix 6 _ï¼_
_ï¼_ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ A â†’ Type ğ“¤
a ï¼ b = Id _ a b
{-# DISPLAY Id _ a b = a ï¼ b #-}

}
% ```
}


\subtree[stt-0005]{
\taxon{theorem}
\title{Identity induction}

\p{ Identity induction, or the J-rule, states that for a fixed value #{a}, and given a family of types #{P} over a singleton, it is enough to
give a term at #{P(a,\refl_a)} to get a term #{P(b,p)} for any #{(b,p) : \Sigma_{b : A} a = b}.}


% ```agda
\agda{
J : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a : A} (P : (x : A) â†’ a ï¼ x â†’ Type ğ“¥)
   â†’ P a refl â†’ âˆ€ {b} â†’ (p : a ï¼ b) â†’ P b p
J P prfl refl = prfl

tr : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) â†’ âˆ€ {a b} â†’ a ï¼ b â†’ P a â†’ P b
tr P refl pa = pa

}
% ```

}

\subtree[stt-000B]{
\title{Groupoid structure of the universe}


\p{The J-rule allows us to exhibit the universe as a groupoid with the identity type as the homs}

\subtree[stt-000C]{
  \taxon{theorem}
  \title{The Identity is symmetric, transitive and reflexive}
  \ul{
    \li{Given #{x =_A y}, we can define a term of type #{y =_A x}}
    \li{Given #{x = y}, and #{y = z}, we have a term #{x = z}}
    \li{There is always a term #{x = x}}
  }
  \subtree{
    \taxon{proof}
    \p{Reflexivity comes directly from the definition of Id and proofs of the remaining are trivial applications of the identity elimination rule}
% ```agda
\agda{

sym : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} â†’ x ï¼ y â†’ y ï¼ x
sym refl = refl

sym-sym : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} {p : x ï¼ y} â†’ sym (sym p) ï¼ p
sym-sym {p = refl} = refl

{-#Â REWRITE sym-sym #-}

trans : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A} â†’ x ï¼ y â†’ y ï¼ z â†’ x ï¼ z
trans refl p = p

_âˆ™_ = trans
infixr 20 _âˆ™_

âˆ™-refll : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} â†’ (p : x ï¼ y) â†’ refl âˆ™ p ï¼ p
âˆ™-refll p = refl

âˆ™-reflr : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} â†’ (p : x ï¼ y) â†’ p âˆ™ refl ï¼ p
âˆ™-reflr refl = refl

âˆ™-assoc : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z w : A} (p : x ï¼ y) (q : y ï¼ z) (r : z ï¼ w) â†’ (p âˆ™ q) âˆ™ r ï¼ p âˆ™ q âˆ™ r
âˆ™-assoc refl q r = refl

âˆ™-sym : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (p : x ï¼ y) â†’ p âˆ™ sym p ï¼ refl
âˆ™-sym refl = refl

âˆ™-sym' : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (p : x ï¼ y) â†’ sym p âˆ™ p ï¼ refl
âˆ™-sym' refl = refl

ï¼âŸ¨âŸ©-syntax : âˆ€ {ğ“¤} {A : Type ğ“¤} (x : A) {y z} â†’ y ï¼ z â†’ x ï¼ y â†’ x ï¼ z
ï¼âŸ¨âŸ©-syntax x q p = p âˆ™ q

infixr 2 ï¼âŸ¨âŸ©-syntax
syntax ï¼âŸ¨âŸ©-syntax x q p = x ï¼âŸ¨ p âŸ© q

_ï¼âŸ¨âŸ©_ : âˆ€ {ğ“¤} {A : Type ğ“¤} (x : A) {y : A} â†’ x ï¼ y â†’ x ï¼ y
x ï¼âŸ¨âŸ© p = p

_âˆ : âˆ€ {â„“} {A : Type â„“} (x : A) â†’ x ï¼ x
x âˆ = refl

infixr 2 _ï¼âŸ¨âŸ©_ 
infix  3 _âˆ


trâˆ™tr : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} â†’ âˆ€ {a b c} (p : a ï¼ b) (q : b ï¼ c)
      (b : P a)
      â†’ tr P q (tr P p b) ï¼ tr P (p âˆ™ q) b
trâˆ™tr refl refl b = refl

trâˆ™tr-sym : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} â†’ âˆ€ {a b} (p : a ï¼ b)
            â†’ (b : P a)
            â†’ tr P (sym p) (tr P p b) ï¼ b
trâˆ™tr-sym refl b = refl            

trâˆ™tr-sym' : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} â†’ âˆ€ {a b} (p : a ï¼ b)
            â†’ (b : P b)
            â†’ tr P p (tr P (sym p) b) ï¼ b
trâˆ™tr-sym' refl b = refl            
}
% ```
  }

}
}
