\date{2025-06-21}
\title{(co)diagonal maps}
\taxon{module}
\meta{module}{\startverb core.Codiagonal \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module core.Codiagonal where

open import foundations.Prelude
open import ufAxioms
open import core.CanonicalPushouts
open import core.CoSlice
}
%```


\subtree[stt-005M]{
  \taxon{definition}
  \title{The codiagonal map}
  \p{Given a map #{f : B \to C}, we can define the map #{\nabla_f : B +^A B \to C}
  called the codiagonal map.}

%```agda
\agda{
âˆ‡ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
      (f : A â†’ B)
    â†’ Pushout f f â†’ B
âˆ‡ f = pushout-rec (mk-cocone id id ~refl)
}
%```
}


\subtree[stt-0064]{
\title{Pullback of postcomposition is a cocone}

%```agda
\agda{
Coconeâ†Pullback : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
                    {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                    {X : Type ğ“œ}
                  â†’ Pullback (postcomp X f) (postcomp X g)
                  â†’ Cocone (mk-span A f g) X
Coconeâ†Pullback (p , q , H) =  mk-cocone p q (happly H)

Coconeâ†Pullback-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
      {X : Type ğ“œ}
    â†’ is-equiv (Coconeâ†Pullback {f = f} {g} {X})
Coconeâ†Pullback-is-equiv = is-equivâ†qiso Î» where
  .fst (mk-cocone p q H) â†’ (p , q , funextâ†’ H)
  .snd .fst (p , q , H) â†’ ap (Î» H â†’ (p , q , H)) (funext.Î· _)
  .snd .snd (mk-cocone p q H) â†’ refl
}
%```
}

\subtree[stt-0063]{
\title{Connection between diagonal and codiagonal}
\taxon{theorem}
\citet{2.11}{rijkeMod2020}

\p{We can construct a map in the [coslice category](stt-0062)
from postcomposition by the [codiagonal](stt-005M) of #{f : A \to B}
to the [diagonal](stt-005X) of postcomposition by #{f}. This map
is an equivalence.}

\quiver{
\begin{tikzcd}
	&& {X^A} \\
	\\
	{B +^A B \to X} &&&& {X^B \times_{X^A} X^B}
	\arrow["{-\circ \nabla_f}"', from=1-3, to=3-1]
	\arrow["{\Delta_{-\circ f}}", from=1-3, to=3-5]
	\arrow["\sim"', from=3-1, to=3-5]
\end{tikzcd}
}

% TODO: This proof is horrible. Hopefully there is some kind
%       of abstraction that is useful here. It would be bassically
%       refl if path constructors computed tho....

%```agda
\agda{
Î”â†âˆ‡ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
        (f : A â†’ B) (X : Type ğ“¦)
      â†’ Coslice-map (diagonal (postcomp X f)) (postcomp X (âˆ‡ f))
Î”â†âˆ‡ f X .fst = cogap âˆ˜ Coconeâ†Pullback
Î”â†âˆ‡ f X .snd g = funextâ†’ (pushout-ind _ (mk-coconeD ~refl ~refl
    Î» a â†’ IdP-funcâ†Square (glue a) refl refl
      ( âˆ™-reflr _
      âˆ™ pushout-rec-apÎ² a
      âˆ™ sym ( ap-âˆ˜ g _ _
            âˆ™ ap (ap g) (pushout-rec-apÎ² a)))))

Î”â†âˆ‡-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                 {f : A â†’ B} {X : Type ğ“¦}
               â†’ Coslice-equiv (Î”â†âˆ‡ f X)
Î”â†âˆ‡-is-equiv = is-equiv-âˆ˜ pushout-rec-is-equiv Coconeâ†Pullback-is-equiv
}
%```
}
