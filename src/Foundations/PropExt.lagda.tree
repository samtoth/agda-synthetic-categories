\title{Proposition extensionality}
\date{2025-07-18}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Foundations.PropExt where

open import Foundations.Universes
open import Foundations.Singleton
open import Foundations.Sigma
open import Foundations.SigmaProperties
open import Foundations.Functions
open import Foundations.Identity
open import Foundations.QuasiIsomorphism
open import Foundations.CoherentIsomorphism
open import Foundations.EquivProp
open import Foundations.FunExt
open import Foundations.Univalence
open import Foundations.3for2
open import Foundations.FunextUnivalence
open import Foundations.IdentitySystem
open import Foundations.EquivHomotopy
open import Foundations.EquivSingleton
open import Foundations.FibrewiseEquiv
open import Foundations.SingletonProp
}
%```

\subtree[stt-007P]{
\title{Weak propositional extensionality}
\taxon{Definition}

\p{Weak propositional extensionality says that for propositions
#{P} and #{Q}, the projection from #{P \simeq Q} to #{P \iff Q}
is an equivalence. Functional extensionality implies weak-PropExt}

%```agda
\agda{
logicalâ†equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‰ƒ B â†’ A â‡” B
logicalâ†equiv e = (fwd , bwd) where open _â‰ƒ_ e

is-equivâ†inverse : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                 â†’ is-prop A â†’ is-prop B â†’ {f : A â†’ B}
                 â†’ (g : B â†’ A) â†’ is-equiv f
is-equivâ†inverse aprp bprp g
  = is-equivâ†qiso (g , (Î» a â†’ aprp _ _) , (Î» _ â†’ bprp _ _))

equivâ†logical : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
      â†’ is-prop A â†’ is-prop B
      â†’ A â‡” B â†’ A â‰ƒ B
equivâ†logical aprp bprp (f , g) = mkâ‰ƒ f (is-equivâ†inverse aprp bprp g)

weak-PropExt : (ğ“¤ ğ“¥ : Level) â†’ Type (lsuc (ğ“¤ âŠ” ğ“¥))
weak-PropExt ğ“¤ ğ“¥ = âˆ€ {A : Type ğ“¤} {B : Type ğ“¥}
                       (ap : is-prop A) (bp : is-prop B)
                     â†’ is-equiv (logicalâ†equiv {A = A} {B})

weak-PropExtâ†FunExt : âˆ€ {ğ“¤ ğ“¥} â†’ FunExt-global â†’ weak-PropExt ğ“¤ ğ“¥
weak-PropExtâ†FunExt FE aprp bprp = is-equivâ†qiso lem where
  lem : quasi-iso logicalâ†equiv
  lem .fst = equivâ†logical aprp bprp
  lem .snd .snd (f , g) = refl
  lem .snd .fst e = â‰ƒ-pathâ†’ FE refl
}
%```
}

\subtree[stt-007Q]{
\title{Propositional extensionality}
\taxon{Definition}

\p{By path induction, we can define a function
#{P = Q \to P \iff Q}. Propositional extensionality
says that this map is an equivalence when #{P} and #{Q}
are propositions.}

\p{Since logical equivalences are equivalent to equivalences
(under the assumption of funext), propositional extensionality
can be seen as #{(-1)}-univalence, where the #{-1} refers to
truncation levels. As such full univalence implies prop-ext.}

\todo{Get rid of assumption of global funext here. We have
formalised univalence implies funext for a particular universe,
but certain modules rely needlessly on global funext, which doesn't
follow from univalence. I would like to do a big refactor of how
axioms work which should address this.}

%```agda
\agda{
logicalâ†Id : âˆ€ {ğ“¤} {P Q : Type ğ“¤}
             â†’ P ï¼ Q â†’ P â‡” Q
logicalâ†Id refl = (id , id)

PropExt : (ğ“¤ : Level) â†’ Type (lsuc ğ“¤)
PropExt ğ“¤ = âˆ€ {P Q : Type ğ“¤}
             â†’ is-prop P â†’ is-prop Q
             â†’ is-equiv (logicalâ†Id {ğ“¤} {P} {Q})

PropExtâ†Univalence : âˆ€ {ğ“¤} â†’ FunExt-global â†’ is-univalent ğ“¤ â†’ PropExt ğ“¤
PropExtâ†Univalence {ğ“¤} FE uu pp qq = is-equiv~âˆ˜
                                       (Î» where refl â†’ refl)
                                       (weak-PropExtâ†FunExt FE pp qq)
                                       uu
}
%```
}

\subtree[stt-007R]{
\title{Logical equivalence is an identity system for propositions}
\taxon{Corollary}

%```agda
\agda{
Prop : (ğ“¤ : Level) â†’ Type (lsuc ğ“¤)
Prop ğ“¤ = Î£[ A âˆ¶ Type ğ“¤ ] is-prop A

module PropExt (FE : FunExt-global) (UA : Univalence) where
  Prop-IdS : âˆ€ {ğ“¤} â†’ Identity-system (Prop ğ“¤) ğ“¤
  Prop-IdS .Identity-system.IdS (P , _) (Q , _) = P â‡” Q
  Prop-IdS .Identity-system.IdSâ†Id refl = (id , id)
  Prop-IdS .Identity-system.has-is-ids (A , ap)
    = fundamental-Id _ lem _ where
    lem : is-singleton (Î£ (Î£ (Type _) is-prop) ((A â‡”_) âˆ˜ fst))
    lem = is-singleâ†equiv-to-single
             ((  Î£-assoc
              âˆ™â‰ƒ Î£-ap-â‰ƒ (Î»
                B â†’ Î£-ap-â‰ƒ Î»
                 bp â†’ mkâ‰ƒ _ (PropExtâ†Univalence FE UA ap bp ) eâ»Â¹)
              âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» a â†’ Ã—-swap)
              âˆ™â‰ƒ  Î£-ï¼singl'
             ) eâ»Â¹)
             (mk-singl ap (is-prop-is-prop FE ap))
}
%```
}
