\date{2025-06-26}
\author{samueltoth}
\title{Pi types as sections}
\taxon{Module}
\import{stt-macros}


%```agda
\agda{
module Core.PiSection where

open import Foundations.Prelude
open import ufAxioms
}
%```


\subtree[stt-006J]{
\taxon{Theorem}
\title{Pi types are sections}

\p{We show that the type #{\Pi_{(a : A)} B(a)} is equivalent to
the type of sections of #{\pi : \Sigma_{(a : A)} B(a)}.}


%```agda
\agda{
sectionâ†Î  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
              {B : A â†’ Type ğ“¥}
            â†’ Î  _ B
            â†’ section (fst {B = B})
sectionâ†Î  {B = B} f = ((Î» x â†’ (x , f x)) , ~refl)


sectionâ‰ƒÎ  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
              {B : A â†’ Type ğ“¥}
            â†’ section (fst {B = B})
            â‰ƒ Î  _ B
sectionâ‰ƒÎ  {A = A} {B}
  = section fst                                  â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ _ _ eâ»Â¹ âŸ©
    (âˆ€ (a : A) â†’ Î£[ x âˆ¶ Î£ A B ] (fst x ï¼ a))    â‰ƒâŸ¨ Î -ap-â‰ƒ (Î» a â†’ Î£-assoc) âŸ©
    ((a : A) â†’ Î£[ a' âˆ¶ A ] ((B a') Ã— (a' ï¼ a))) â‰ƒâŸ¨ Î -ap-â‰ƒ (Î» a
                                                    â†’ Î£-ap-â‰ƒ (Î» a' â†’ Ã—-swap)) âŸ©
    (((a : A) â†’ Î£[ a' âˆ¶ A ] ((a' ï¼ a) Ã— B a'))) â‰ƒâŸ¨ Î -ap-â‰ƒ (Î» a â†’ Î£-ï¼singl) âŸ©
    Î  A B â‰ƒâˆ

Î â†section : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
              {B : A â†’ Type ğ“¥}
            â†’ section (fst {B = B})
            â†’ Î  _ B
Î â†section {B = B} (f , s) a = tr B (s a) (snd (f a))
}
%```


\p{More generally, given a diagram as follows:}

\quiver{
\begin{tikzcd}[cramped]
	&& {\Sigma_BA} \\
	\\
	X && A
	\arrow["\pi"', from=1-3, to=3-3]
	\arrow["{\bar{f}}", from=3-1, to=1-3]
	\arrow["f"', from=3-1, to=3-3]
	\arrow[curve={height=12pt}, dashed, from=3-3, to=1-3]
\end{tikzcd}
}

\p{We show that there is an equivalence between maps that extend #{f} along
#{\pi} and dependent functions #{\Pi_{x : X} B(f(x))}.}

%```agda
\agda{
extensionâ†Î  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
                {X : Type ğ“¦} (f : X â†’ A)
              â†’ Î  X (B âˆ˜ f) â†’ fibre (postcomp _ (fst {B = B})) f
extensionâ†Î  f g = ((Î» x â†’ f x , g x) , refl)

extensionâ‰ƒÎ  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
                {X : Type ğ“¦} (f : X â†’ A)
              â†’ fibre (postcomp _ (fst {B = B})) f â‰ƒ Î  X (B âˆ˜ f)
extensionâ‰ƒÎ  f = fibre-postcompâ‰ƒ fst f âˆ™â‰ƒ postcomp-Î -â‰ƒ (fibre-straighten _ âˆ˜ f)

extensionâ†Î -is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
      {X : Type ğ“¦} (f : X â†’ A)
    â†’ is-equiv (extensionâ†Î  {B = B} f)
extensionâ†Î -is-equiv f
  = homotopy-is-equiv
      (Î» a â†’ Î£-pathâ†’ (refl , funext-refl))
      (is-equivâ»Â¹ (extensionâ‰ƒÎ  f ._â‰ƒ_.has-is-eqv))
}
%```
}
