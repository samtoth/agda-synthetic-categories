\date{2025-11-17}
\title{Simplicial types}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\subtree[stt-00AB]{
\taxon{Remark}
\p{This module, as almost all in \code{Synthetic.Categories} assumes a
type #{\Delta^1} with a distributive lattice structure, we
call this type the generic interval.}
}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Simplicial
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Core.Join
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CanonicalPushouts
open import Core.PushoutEquiv
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.FlatteningPushouts

open import Ergonomics.Extensionality
open import Ergonomics.Auto

open import Synthetic.Cubes Î”Â¹ i0 i1
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
}
%```


\subtree[stt-00AC]{
\taxon{Definition}
\title{Simplicial types}

\p{If we don't assume that the interval is totally ordered, we can speak of
particular types which \em{'see'} the interval as totally ordered. This can be
made precise by asking for types which are [null](stt-005G) with respect to the
family of propositions #{(i \le j) \lor (j \le i)}.}

%```agda
\agda{
fam-is-simplicial : Î”Â¹ Ã— Î”Â¹ â†’ Type ğ“˜
fam-is-simplicial (i , j) = (i â‰¤ j) * (j â‰¤ i)

is-simplicial : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
is-simplicial = is-null fam-is-simplicial
}
%```



\p{By virtue of being defined in terms of nullification at a proposition, we know
that simplicial types form a lex [#{\Sigma}-closed](stt-006E)
[reflective subuniverse](stt-0065).}

%```agda
\agda{
Simplicial-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Simplicial-SubU = Null-SubU fam-is-simplicial _

Simplicial-GSU : GSU (_âŠ” ğ“˜)
Simplicial-GSU = Null-GSU fam-is-simplicial

Simplicial-is-globally-reflective
  : is-globally-reflective Simplicial-GSU
Simplicial-is-globally-reflective = Null-globally-reflective

module Simp where
  open GRSUInduction Simplicial-is-globally-reflective
                     Null-globally-Î£-closed public

  open GSU Simplicial-GSU public renaming (S-equiv to is-simplicialâ†equiv)

  open is-globally-reflective Simplicial-is-globally-reflective

  Î£-is-simplicial = Null-globally-Î£-closed

Î”Â²-â‰¤-rec : âˆ€ {ğ“¤} {A : Type ğ“¤} {i j} â†’ is-simplicial A
           â†’ (l : i â‰¤ j â†’ A) â†’ (r : j â‰¤ i â†’ A) 
           â†’ ((p : i ï¼ j) â†’ l (â‰¤â†ï¼ p) ï¼ r (â‰¥â†ï¼ p)) â†’ A
Î”Â²-â‰¤-rec {i = i} {j} asimp l r eq
  = is-equiv.bwd (asimp (i , j)) (cogap (mk-cocone l r
      Î» where (p , q) â†’ ap l (is-prop-separated _ _ _ _)
                      âˆ™ eq (â‰¤-antisym p q)
                      âˆ™ ap r (is-prop-separated _ _ _ _)))

Î”Â²-â‰¤-rec! : âˆ€ {ğ“¤} {A : Type ğ“¤} i j â†’ is-simplicial A
            â†’ (l : â¦ƒ i â‰¤ j â¦„ â†’ A) â†’ (r : â¦ƒ j â‰¤ i â¦„ â†’ A)
            â†’ (âˆ€ (q : i ï¼ j) â†’ l â¦ƒ â‰¤â†ï¼ q â¦„ ï¼ r â¦ƒ â‰¥â†ï¼ q â¦„)
            â†’ A
Î”Â²-â‰¤-rec! i j simp l r eq = Î”Â²-â‰¤-rec simp (Î» p â†’ l â¦ƒ p â¦„) (Î» q â†’ r â¦ƒ q â¦„) eq
}
%```
}

\subtree[stt-00CC]{
\title{Triangulated squares}
\taxon{Lemma}


\p{We first define the triangulated square as the pushout of the following
square, noting also that there is a canonical map into the square.}

\quiver{
\begin{tikzcd}
	{\Delta^1} && {\Delta^2} \\
	\\
	{\Delta^2} && {\square^2}
	\arrow["\delta", from=1-1, to=1-3]
	\arrow["\delta"', from=1-1, to=3-1]
	\arrow["{(x,y)\mapsto(y,x)}", from=1-3, to=3-3]
	\arrow["{(x,y)\mapsto(x,y)}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{We then note that this map is an embedding which identifies the triangulated
square with the subtype of the square consisting of those #{i} and #{j} for
which #{(i \leq j) \lor (j \leq i)}.}


%```agda
\agda{
â§… : Type ğ“˜
â§… = Pushout {B = Î”Â²} {C = Î”Â²} Î”Â²-diagonal Î”Â²-diagonal

â–¡â†Î”Â²-upper : Î”Â² â†’ â–¡^ 2
â–¡â†Î”Â²-upper (x , y) = (x , y)

â–¡â†Î”Â²-lower : Î”Â² â†’ â–¡^ 2
â–¡â†Î”Â²-lower (x , y) = (y , x)

â–¡Â²-diagonal : Î”Â¹ â†’ â–¡^ 2
â–¡Â²-diagonal i = (i , i)

â–¡Â²-diagonal-is-emb : is-embedding â–¡Â²-diagonal
â–¡Â²-diagonal-is-emb = is-equivâ†inverse
                       (is-prop-separated _ _)
                       (is-setâ†is-truncated (â–¡-is-set car-is-set) _ _)
                       (ap fst)

â–¡Â²-Î”Â²-via-diag : â–¡Â²-diagonal ~ â–¡â†Î”Â²-upper âˆ˜ Î”Â²-diagonal
â–¡Â²-Î”Â²-via-diag = ~refl

â–¡â†Î”Â²-upper-is-emb : is-embedding â–¡â†Î”Â²-upper
â–¡â†Î”Â²-upper-is-emb = is-equivâ†inverse
                      (is-setâ†is-truncated Î”Â²-is-set _ _)
                      (is-setâ†is-truncated (â–¡-is-set car-is-set) _ _)
                      Î» p â†’ Î”Â²-ext (ap fst p , ap snd p)

â–¡â†Î”Â²-lower-is-emb : is-embedding â–¡â†Î”Â²-lower
â–¡â†Î”Â²-lower-is-emb = is-equivâ†inverse
                      (is-setâ†is-truncated Î”Â²-is-set _ _)
                      (is-setâ†is-truncated (â–¡-is-set car-is-set) _ _)
                      Î» p â†’ Î”Â²-ext (ap snd p , ap fst p)

â§…-square : Arrow-map (Î¹-const I I-distr) â–¡â†Î”Â²-upper
â§…-square .Arrow-map.top = Î¹-const I I-distr
â§…-square .Arrow-map.bot = â–¡â†Î”Â²-lower
â§…-square .Arrow-map.comm = ~refl

â§…-incl : â§… â†’ â–¡^ 2
â§…-incl = cogap-mapâ†square â§…-square

â§…-Sub : Subtype (â–¡^ 2) ğ“˜
â§…-Sub .Subtype.family (i , j) = (i â‰¤ j) * (j â‰¤ i)
â§…-Sub .Subtype.has-is-subtype (i , j) = *-is-prop â‰¤-is-prop â‰¤-is-prop

opaque
  fibre-â§…-incl : âˆ€ x â†’ fibre â§…-incl x â‰ƒ x âˆˆ â§…-Sub
  fibre-â§…-incl x@(i , j)
    = fibre â§…-incl x   â‰ƒâŸ¨ cogap-fibre _ x âŸ©
      Pushout _ _       â‰ƒâŸ¨ Pushout-equivâ†logical
                             total-fibre-is-prop intended-span-is-prop
                             sle âŸ©
      Pushout fst snd   â‰ƒâŸ¨âŸ©
      (i â‰¤ j) * (j â‰¤ i) â‰ƒâˆ where
    open Span
    total-fibre-span : Span ğ“˜ ğ“˜ ğ“˜
    total-fibre-span = total-span _ _
                         (Fibre-family (Coconeâ†Arrow-map â§…-square .snd) x)

    total-fibre-span' : Span ğ“˜ ğ“˜ ğ“˜
    total-fibre-span' .Centre = fibre â–¡Â²-diagonal (i , j)
    total-fibre-span' .Left = fibre â–¡â†Î”Â²-lower (i , j)
    total-fibre-span' .left = _
    total-fibre-span' .Right = fibre â–¡â†Î”Â²-upper (i , j)
    total-fibre-span' .right = total-map-fst Î”Â²-diagonal

    _ : total-fibre-span ï¼ total-fibre-span'
    _ = refl

    intended-span : Span ğ“˜ ğ“˜ ğ“˜
    intended-span = mk-span ((i â‰¤ j) Ã— (j â‰¤ i)) fst snd

    intended-span-is-prop : is-prop-span intended-span
    intended-span-is-prop .fst = â‰¤-is-prop
    intended-span-is-prop .snd .fst = is-prop-Î£ â‰¤-is-prop (Î» _ â†’ â‰¤-is-prop)
    intended-span-is-prop .snd .snd = â‰¤-is-prop

    total-fibre-is-prop : is-prop-span total-fibre-span
    total-fibre-is-prop .fst = is-prop-mapâ†is-embedding â–¡â†Î”Â²-lower-is-emb (i , j)
    total-fibre-is-prop .snd .fst
      = is-prop-mapâ†is-embedding â–¡Â²-diagonal-is-emb (i , j)
    total-fibre-is-prop .snd .snd
      = is-prop-mapâ†is-embedding â–¡â†Î”Â²-upper-is-emb (i , j)

    sle : Span-logical-equiv total-fibre-span intended-span
    sle .fst .fst (x , refl) = auto!
    sle .fst .snd p = ((j , i) â¦ƒ p â¦„ , refl)
    sle .snd .fst .fst (x , refl) = (auto! , auto! )
    sle .snd .fst .snd (p , q) = (i , Ã—-pathâ†’ (refl , â‰¤-antisym p q))
    sle .snd .snd .fst (a , refl) = auto!
    sle .snd .snd .snd p = ((i , j) â¦ƒ p â¦„ , refl)


open FromFibreSubtype â§…-Sub â§…-incl fibre-â§…-incl public renaming
  (equiv-to-subtype to â§…-as-subtype;
   incl-is-embedding to â§…-incl-is-embedding;
   pres-carr to â§…-pres-carrier;
   pres-carr' to â§…-pres-carrier')
}
%```
}


\subtree[stt-00CS]{
\title{Triangulated types}
\taxon{Lemma}

\p{We call a type triangulated if it is local with respect to the inclusion
of the triangulated square into the square. We show that every simplicial type
is triangulated.}

\proof{
\p{We have that for all #{(i,j) : \square }, #{(i \leq j * j \leq i) \perp A}.
   By closure of left ortgogonality under #{\Sigma}, this gives us
   #{\underset{\square}{\overset{\Sigma_{i,j}(i \leq j * j \leq i)}{\downarrow}}
   \perp A}.  But by the [above lemma](stt-00CC) this sigma type is exactly the
   triangulated square.  }
}

%```agda
\agda{
simp-is-triangulated : âˆ€ {ğ“¤} {A : Type ğ“¤}
                     â†’ is-simplicial A â†’ is-local (Î» (_ : ğŸ™) â†’ â§…-incl) A
simp-is-triangulated {_}{A} simp tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-equiv _ _ amap amap-is-eqv !
        (left-orthogonal-Î£ _ !
          (is-orthogonalâ‡”orthogonal-! .snd
          âˆ˜ (is-localâ†is-null simp)))) where
  amap : Arrow-map (total-map (Î» _ â†’ !)) â§…-incl
  amap .Arrow-map.top = _â‰ƒ_.bwd â§…-as-subtype
  amap .Arrow-map.bot = fst
  amap .Arrow-map.comm = â§…-pres-carrier' ~â»Â¹

  amap-is-eqv : is-Arrow-equiv amap
  amap-is-eqv .fst = is-equivâ»Â¹ (_â‰ƒ_.has-is-eqv â§…-as-subtype)
  amap-is-eqv .snd = singleton-fst-is-equiv (Î» _ â†’ ğŸ™-is-singleton)
}
%```
}
