\date{2025-10-22}
\title{The lattice of propositions}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Algebra.Lattice.Instances.Prop where

open import Foundations.Prelude
open import ufAxioms

open import Ergonomics.Representation

open import Core.Join
open import Modalities.Instances.Truncation
open import Algebra.Lattice
}
%```


\subtree[stt-009R]{
\title{The lattice of propositions}
\taxon{Example}
\p{The subobject/subtype classifier #{\mathrm{Prop}}
has a canonical lattice structure on it, given by logical and and or}

%```agda
\agda{
Prop-ua : âˆ€ {ğ“¤} {P Q : PropU ğ“¤} â†’ (P .fst â‡” Q .fst) â†’ P ï¼ Q
Prop-ua {_} {P} {Q} eq
  = Î£-pathâ†’ (is-equiv.bwd
              (propExt (is-propâ†is-truncated (P .snd))
                       (is-propâ†is-truncated (Q .snd))) eq
            , (Trunc.S .Subtype.has-is-subtype _ _ _))

PropU-ext : âˆ€ {ğ“¤} {P Q : PropU ğ“¤} â†’ (P .fst â‰ƒ Q .fst) â†’ P ï¼ Q
PropU-ext e = Î£-pathâ†’ (ua e , (Trunc.S .Subtype.has-is-subtype _ _ _))

Prop-Lattice : âˆ€ ğ“¤ â†’ Lattice (PropU ğ“¤)
Prop-Lattice ğ“¤ = l where
  l : Lattice (PropU ğ“¤)
  l .Lattice.0l = TULift 1 ğ“¤ (âˆ… , Trunc.âˆ…-is-suc-truncated)
  l .Lattice.1l = TULift 1 ğ“¤ (ğŸ™ , is-truncatedâ†is-prop (is-propâ†is-single ğŸ™-is-singleton))
  l .Lattice._âˆ§_ (A , p) (B , q) = (A Ã— B , Trunc.Î£-is-truncated p Î» _ â†’ q)
  l .Lattice._âˆ¨_ (A , p) (B , q)
    = (A * B , is-truncatedâ†is-prop (*-is-prop
                (is-propâ†is-truncated p)
                (is-propâ†is-truncated q)))
  l .Lattice.str-is-lattice .is-lattice.car-is-set = Trunc-U-is-truncated 1
  l .Lattice.str-is-lattice .is-lattice.âˆ§-assoc
    = Prop-ua ((Î» x â†’ (x .fst , x .snd .fst) , x .snd .snd)
              , Î» x â†’ x .fst .fst , x .fst .snd , x .snd)
  -- todo formalize untruncated *-assoc
  l .Lattice.str-is-lattice .is-lattice.âˆ¨-assoc {x} {y} {z}
    = Prop-ua (*-prop-rec xyzprp
                          (Î¹â‚ âˆ˜ Î¹â‚)
                          (*-prop-rec xyzprp (Î¹â‚ âˆ˜ Î¹â‚‚) Î¹â‚‚)
              , *-prop-rec xyzprp'
                          (*-prop-rec xyzprp' Î¹â‚ (Î¹â‚‚ âˆ˜ Î¹â‚))
                          (Î¹â‚‚ âˆ˜ Î¹â‚‚)) where
      xprp = is-propâ†is-truncated (x .snd)
      yprp = is-propâ†is-truncated (y .snd)
      zprp = is-propâ†is-truncated (z .snd)
      xyzprp = *-is-prop (*-is-prop xprp yprp) zprp
      xyzprp' = *-is-prop xprp (*-is-prop yprp zprp)

  l .Lattice.str-is-lattice .is-lattice.âˆ§-comm
    = PropU-ext Ã—-swap
  l .Lattice.str-is-lattice .is-lattice.âˆ¨-comm
    = PropU-ext *-comm
  l .Lattice.str-is-lattice .is-lattice.âˆ¨-âˆ§-abs {x}
    = Prop-ua ((*-prop-rec (is-propâ†is-truncated (x .snd)) id fst) , Î¹â‚)
  l .Lattice.str-is-lattice .is-lattice.âˆ§-âˆ¨-abs {x}
    = Prop-ua (fst , Î» x â†’ x , (Î¹â‚ x))
  l .Lattice.str-is-lattice .is-lattice.0-bottom {x}
    = Prop-ua (*-prop-rec (is-propâ†is-truncated (x .snd)) id (Â¡_ âˆ˜ unlift)
              , Î¹â‚)
  l .Lattice.str-is-lattice .is-lattice.1-top
    = Prop-ua ((Î» z â†’ z .fst) , (Î» z â†’ z , mk-lift tt))

Prop-Lattice-is-distributive
  : âˆ€ {ğ“¤} â†’ is-distributive (Prop-Lattice ğ“¤)
Prop-Lattice-is-distributive .is-distributive.has-is-distrib {x = x} {y} {z}
  = Prop-ua ((*-prop-rec (is-prop-Î£ (*-is-prop xprp yprp) Î» _ â†’ *-is-prop xprp zprp)
                         (Î» x â†’ (Î¹â‚ x , Î¹â‚ x))
                         (Î» (y , z) â†’ (Î¹â‚‚ y , Î¹â‚‚ z)))
            , Î» (xy , xz) â†’ *-prop-rec xyzprp
                                       Î¹â‚
                            (Î» y â†’ *-prop-rec xyzprp
                                              Î¹â‚
                                              (Î» z â†’ Î¹â‚‚ (y , z)) xz) xy) where
  xprp = is-propâ†is-truncated (x .snd)
  yprp = is-propâ†is-truncated (y .snd)
  zprp = is-propâ†is-truncated (z .snd)
  xyzprp = *-is-prop xprp (is-prop-Î£ yprp (Î» _ â†’ zprp))
}
%```
}
