\title{Hom families}
\taxon{Module}
\author{samueltoth}
\date{2025-12-09}

\import{stt-macros}


\subtree[tot-000R]{
\title{Idea}


}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.HomFamilies
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Data.Bool

open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CoSlice
open import Core.Lifts
open import Core.PullbackPower
open import Core.ExtPullbacks
open import Core.PiSection
open import Core.CanonicalPushouts

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open import Ergonomics.Auto
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.CoComma Î”Â¹ I I-distr
open import Synthetic.Categories.JoinSlice Î”Â¹ I I-distr
}
%```



\subtree[tot-0002]{
\title{Unstraightening hom families}
\taxon{Remark}

\p{The unstraightening of the family #{\Hom(x,-)} is #{X_{x/} \to X}. Thus
representable families are covariant iff #{X_{x/} \to X} are all left fibrations.}


%```agda
\agda{
hom-fam-is-covâ‡”is-left-fibration
  : âˆ€ {ğ“¤} {X : Type ğ“¤} x
  â†’ is-covariant (Î» a â†’ Hom X x a)
  â‡” is-left-fibration {A = Coslice X (Î» (_ : ğŸ™) â†’ x)} fst
hom-fam-is-covâ‡”is-left-fibration x
  = is-covariantâ‡”is-left-fibration (Î» a â†’ Hom _ x a)
  âˆ™â‡” right-orthogonal-iffâ†equiv (Î» _ â†’ i0) amap amap-eq where
  amap : Arrow-map (fst {B = Î» c â†’ (i : ğŸ™) â†’ Hom _ x c})
                   (fst {B = Î» a â†’ Hom _ x a})
  amap .Arrow-map.top = total-map (Î» a â†’ ev tt)
  amap .Arrow-map.bot = id
  amap .Arrow-map.comm = ~refl

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = is-total-equivâ†is-fibrewise-equiv (Î» a â†’ unit-ev-is-equiv)
  amap-eq .snd = id-is-equiv
}
%```
}


\subtree[tot-0005]{
\taxon{Therem}
\title{Representable families are covariant}

\p{We show that a type #{A} is [Segal](stt-00AI) iff the family #{\Hom(-,x)} is
covariant for each #{x}.}

\proof{
We will show that every #{A_{/x} \to A} is a left fibration iff A is right
orthogonal to the map #{\Lambda^2_1 \to \Delta^2}.


}

%```agda
\agda{

precat-orth-lemma
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (i : Î”Â¹)
  â†’ (Î›[2,1]-incl âŠ¥ A)
  â‡” (âˆ€ x â†’ is-equiv (total-map-fst (postcomp A Î›[2,1]-incl)
                                   {Î» f â†’ f (Î¹â‚‚ i) ï¼ x}))
precat-orth-lemma {A = A} i
  =  topâ‡”bot-is-equivâ†Arrow-equiv amap2 eq
  âˆ™â‡” fibrewiseâ‡”total-is-equiv where

  add-singleton : âˆ€ {Q : Type ğ“˜} (j : Î”Â¹ â†’ Q)
                â†’ (Q â†’ A) â†’ Î£[ x âˆ¶ A ] Î£[ f âˆ¶ (Q â†’ A)] (f (j i) ï¼ x)
  add-singleton j f = (f _ , f , refl)

  add-singleton-eq : âˆ€ {Q : Type ğ“˜} (j : Î”Â¹ â†’ Q)
                â†’ quasi-iso (add-singleton j)
  add-singleton-eq j .fst (a , f , refl) = f
  add-singleton-eq j .snd .fst = ~refl
  add-singleton-eq j .snd .snd (a , f , refl) = refl

  amap2 : Arrow-map (postcomp A Î›[2,1]-incl)
                    (total-map (Î» a â†’ total-map-fst (postcomp A Î›[2,1]-incl)))
  amap2 .Arrow-map.top f = add-singleton (i1 ,_) f
  amap2 .Arrow-map.bot f = add-singleton Î¹â‚‚ f
  amap2 .Arrow-map.comm _ = refl

  eq : is-Arrow-equiv amap2
  eq .fst = is-equivâ†qiso (add-singleton-eq (i1 ,_))
  eq .snd = is-equivâ†qiso (add-singleton-eq Î¹â‚‚)

weird-horn-inclusion : Î›[2,1] â†’ ğŸ™ â‹‰ Î”Â¹
weird-horn-inclusion = cogap (mk-cocone (â†‘-hom (tt , i0) .HomP.hom) â†‘-Î¹â‚‚
                             Î» a â†’ glue (Î´Î”Â¹-1 , tt , i0))

weird-horn-inclusionâˆ™ : Coslice-map (Î» (_ : ğŸ™) â†’ Î¹â‚ i0) Î» _ â†’ â†‘-Î¹â‚ tt
weird-horn-inclusionâˆ™ = (weird-horn-inclusion , Î» _ â†’ glue (Î´Î”Â¹-0 , tt , i0))

LEM : âˆ€ {ğ“¤} {A : Type ğ“¤} x
      â†’ Arrow-map (Î» (_ : ğŸ™) â†’ i0) {C = Coslice A (Î» (_ : ğŸ™) â†’ x)} (fst) â†’
      Coslice-map {X = Î›[2,1]} (Î» _ â†’ Î¹â‚ i0) (Î» (_ : ğŸ™) â†’ x)
LEM x (mk-amap top bot comm)
  = cogap (mk-cocone (top tt .snd tt .HomP.hom)
                     bot
                     (Î» c â†’ top tt .snd tt .HomP.hom1 âˆ™ sym (comm c)))
  , Î» _ â†’ HomP.hom0 (top tt .snd tt)

opaque
  LEM-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} x
    â†’ is-equiv (LEM {A = A} x)
  LEM-is-equiv x = is-equivâ†qiso qiso where
    qiso : quasi-iso (LEM x)
    qiso .fst (a , b) = mk-amap (Î» _ â†’ _ , (Î» _ â†’ mk-hom (a âˆ˜ Î¹â‚) (b tt) refl))
                                (a âˆ˜ Î¹â‚‚)
                                (ap a âˆ˜ sym âˆ˜ glue)
    qiso .snd .fst (mk-amap top bot comm)
      = let pth = ( top tt .snd tt .HomP.hom1
                  , Î» i â†’ ~refl , ((Square-degen-vert _ _ refl) , (Square-flatten-hor refl)))
        in Arrow-map-pathâ†’
          ( (Î» a â†’ Coslice-pathâ†’ pth)
          , (~refl , Î» _ â†’ ap (_âˆ™ ap fst (Coslice-pathâ†’ pth)) (ap-sym _ (glue tt) âˆ™ ap sym (pushout-rec-apÎ² tt))
                         âˆ™ ap (sym (HomP.hom1 (top tt .snd tt) âˆ™ sym (comm tt)) âˆ™_)
                              (Coslice-path-ap-fst pth)
                         âˆ™ ap (_âˆ™ top tt .snd tt .HomP.hom1) (âˆ™-symsym _ (sym (comm tt)))
                         âˆ™ âˆ™.cancell _  (âˆ™-sym' (HomP.hom1 (top tt .snd tt)))
                                        {f = sym (sym (comm tt))}
                         âˆ™ sym-sym ))
    qiso .snd .snd (a , p)
      = ext! ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
                      (Î» _ â†’ âˆ™-reflr _ âˆ™ sym (ap sym (ap-sym a _) âˆ™ sym-sym))
             , ~refl)


coslice-is-leftâ‡”weird-inner
  : âˆ€ {ğ“¤} {A : Type ğ“¤} x
  â†’ is-left-fibration {A = Coslice A (Î» (_ : ğŸ™) â†’ x)} fst
  â‡” (is-equiv (Coslice-map-postcompose (Î» (_ : ğŸ™) â†’ x) weird-horn-inclusionâˆ™))
coslice-is-leftâ‡”weird-inner x
  = (orthogonalâ‡”pb-power-is-equiv â‡”â»Â¹)
  âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv amap amap-eq where
  amap : Arrow-map (pullback-power (Î» _ â†’ i0) (Î» r â†’ fst r))
                   (Coslice-map-postcompose (Î» _ â†’ x) weird-horn-inclusionâˆ™)
  amap .Arrow-map.top = joinâ†coslice-map (Î» _ â†’ x)
  amap .Arrow-map.bot = LEM x
  amap .Arrow-map.comm f = ext!
    ( sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
          (Î» a â†’ ap (_âˆ™ refl) ( ap-âˆ˜ _ _ (glue a)
                              âˆ™ ap (ap (pushout-rec _)) (pushout-rec-apÎ² a)
                              âˆ™ pushout-rec-apÎ² _))
    , Î» _ â†’ âˆ™-reflr _ âˆ™ pushout-rec-apÎ² _)

  amap-eq : is-Arrow-equiv amap
  amap-eq .fst = joinâ†coslice-map-is-equiv (Î» _ â†’ x)
  amap-eq .snd = LEM-is-equiv x


coslice-orth-lemma
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
      {p : X â†’ A} {q : X â†’ B} (f : Coslice-map p q)
    â†’ (f .fst âŠ¥ Y)
    â‡” (âˆ€ (x : X â†’ Y) â†’ is-equiv (Coslice-map-postcompose x f))
coslice-orth-lemma {A = A}{B}{X}{Y}{p}{q} (f , H)
  = topâ‡”bot-is-equivâ†Arrow-equiv (amap (funextâ†’ H)) eq âˆ™â‡” fibrewiseâ‡”total-is-equiv where

  add-singleton : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q) (g : Q â†’ Y)
                  â†’ Î£[ x âˆ¶ (X â†’ Y) ] Î£[ f' âˆ¶ (Q â†’ Y) ] (f' âˆ˜ p ~ x)
  add-singleton f g = (g âˆ˜ f , g , ~refl)

  add-singleton-eq : âˆ€ {ğ“ } {Q : Type ğ“ } (p : X â†’ Q)
                     â†’ quasi-iso (add-singleton p)
  add-singleton-eq p .fst (a , f , H) = f
  add-singleton-eq p .snd .fst x = refl
  add-singleton-eq p .snd .snd (a , f , H)
    = funext-rec
        (Î» H â†’ ((f âˆ˜ p) , (f , ~refl)) ï¼ (a , (f , H)))
        (Î» where refl â†’ refl)
        H

  amap : âˆ€ (H : f âˆ˜ p ï¼ q)
         â†’ Arrow-map (postcomp Y f)
                     (total-map (Î» a â†’ Coslice-map-postcompose a (f , happly H)))
  amap H .Arrow-map.top = add-singleton q
  amap H .Arrow-map.bot = add-singleton p
  amap refl .Arrow-map.comm x = refl

  eq : is-Arrow-equiv (amap (funextâ†’ H))
  eq .fst = is-equivâ†qiso (add-singleton-eq q)
  eq .snd = is-equivâ†qiso (add-singleton-eq p)

hom-fam-is-covâ‡”is-weird-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (âˆ€ x â†’ is-covariant (Î» a â†’ Hom A x a))
    â‡” (weird-horn-inclusion âŠ¥ A)
hom-fam-is-covâ‡”is-weird-segal {A = A}
  =  precomp-Î -â‡” (Î»
       x â†’  hom-fam-is-covâ‡”is-left-fibration x
         âˆ™â‡” coslice-is-leftâ‡”weird-inner x)
  âˆ™â‡” logicalâ†equiv (postcomp-Î -â‰ƒ _ unit-UPâ‰ƒ)
  âˆ™â‡” (coslice-orth-lemma (weird-horn-inclusionâˆ™) â‡”â»Â¹)


retract-weird : ğŸ™ â‹‰ Î”Â¹ â†’ Î”Â²
retract-weird
  = cogap (mk-cocone
            (Î» {(i , tt , j) â†’ (i , i âˆ§ j) â¦ƒ âˆ§-â‰¤-eliml auto! â¦„})
            âŠ[ (Î» _ â†’ (i0 , i0)) , (i1 ,_) ]
            Î» { (mk-lift true  , tt , b) â†’ Î”Â²-ext (refl , âˆ§-commÂ âˆ™ 1-top)
              ; (mk-lift false , tt , b) â†’ Î”Â²-ext (refl , 0-init) })

retract-weird-resp-horn
  : retract-weird âˆ˜ weird-horn-inclusion ~ Î›[2,1]-incl
retract-weird-resp-horn = pushout-ind _
  (mk-coconeD
    (Î» l â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ 0-init))
    (Î» r â†’ refl)
    (Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _))

section-weird : Î”Â² â†’ ğŸ™ â‹‰ Î”Â¹
section-weird a = Î¹â‚ (Poly.Î”Â².s a , tt , Poly.Î”Â².t a)

section-weird-resp-horn
  : section-weird âˆ˜ Î›[2,1]-incl ~ weird-horn-inclusion
section-weird-resp-horn = pushout-rec-unique _ _
  ~refl
  (Î» a â†’ glue (Î´Î”Â¹-1 , tt , a))
  Î» a â†’ ap (_âˆ™ glue (Î´Î”Â¹-1 , tt , i0))
         ( ap-âˆ˜ section-weird Î›[2,1]-incl (glue a)
         âˆ™ ap (ap section-weird) (pushout-rec-apÎ² _)
         âˆ™ lem) where
  lem : ap (section-weird) Î”Â²-refl ï¼ refl
  lem = ap-âˆ˜ Î¹â‚ (Î» where (i , j) â†’ (i , tt , j)) Î”Â²-refl
      âˆ™ ap (ap Î¹â‚) (is-propâ†is-truncated
                     (Trunc.Ã—âˆˆS car-is-set (Trunc.Ã—âˆˆS Trunc.ğŸ™âˆˆS car-is-set) _ _)
                     _ _)

sec-weird-is-sec : retract-weird âˆ˜ section-weird ~ id
sec-weird-is-sec (a , b) = Î”Â²-ext (refl , (âˆ§-comm âˆ™ auto!))

strongly-segal-type-is-segal
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (weird-horn-inclusion âŠ¥ A)
    â†’ is-precategory A
strongly-segal-type-is-segal orth tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-retract Î›[2,1]-incl weird-horn-inclusion
        (mk-amap id section-weird section-weird-resp-horn)
        ((mk-amap id retract-weird retract-weird-resp-horn) ,
          (~refl , ((Î» (i , j) â†’ Î”Â²-ext (refl , âˆ§-comm âˆ™ auto!))
          , Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)))
        !
        (is-orthogonalâ‡”orthogonal-! .snd orth))
}
%```
}
