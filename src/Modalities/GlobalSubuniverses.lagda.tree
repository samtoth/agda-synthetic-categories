\date{2025-06-14}
\title{Global subuniverses}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}


\p{The developments in this module follow \citet{foundations.global-subuniverses}{agda-unimath}.}

%```agda
\agda{
module Modalities.GlobalSubuniverses where

open import Foundations.Prelude
open import ufAxioms
open import Modalities.Subuniverses
open import Core.Postwhisker
open import Core.PiSection
open import Ergonomics.Extensionality
open import Ergonomics.Universal
}
%```

\subtree[stt-007A]{
\title{Global subuniverses}

\p{A global subuniverse is a subuniverse for each #{\UU}
which is closed under equivalence. This second property
holds via univalence for a particular univalent universe
but doesn't follow automatically for equivalences between
types in different universes.}

% ```agda
\agda{
record GSU (Î± : Level â†’ Level) : TypeÏ‰ where
  constructor mk-GSU
  no-eta-equality
  field
    S : âˆ€ {ð“¤} â†’ SubU ð“¤ (Î± ð“¤)
    S-equiv : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {B : Type ð“¥}
              â†’ A â‰ƒ B
              â†’ A âˆˆ S â†’ B âˆˆ S

SubUâ†global : âˆ€ {Î±} â†’ GSU Î± â†’  âˆ€ {ð“¤} â†’ SubU ð“¤ (Î± ð“¤)
SubUâ†global = GSU.S

GSU-equiv : âˆ€ {Î± Î²} â†’ GSU Î± â†’ GSU Î² â†’ TypeÏ‰
GSU-equiv S K = âˆ€ {ð“¤} â†’ Subtype-equiv (GSU.S S {ð“¤}) (GSU.S K {ð“¤})
}
%```
}

\subtree[stt-007B]{
\taxon{Definition}
\title{Global reflectors}

\p{For a particular type #{A : \UU}, we say that #{(\circ A, \eta :
A \to \circ A)} is a global reflector for #{A} when postcomposition
by #{\eta} at modal types (of any universe) is an equivalence. This
equivalence gives us a recursion principal for #{\circ A}.}


%```agda
\agda{
record is-global-reflector {Î±} (GS : GSU Î±)
         {ð“¤} (A : Type ð“¤)
         (â—‹A : Type ð“¤) (Î· : A â†’ â—‹A) : TypeÏ‰ where
  constructor mk-grfltor
  no-eta-equality
  open GSU GS
  field
    â—‹âˆˆS : â—‹A âˆˆ S
    reflects : âˆ€ {ð“¥} {Q : Type ð“¥}
               â†’ Q âˆˆ S â†’ is-equiv (postcomp Q Î·)

  â—‹-rec : âˆ€ {ð“¥} {Q : Type ð“¥} â†’ Q âˆˆ S â†’ (A â†’ Q) â†’ (â—‹A â†’ Q)
  â—‹-rec cs = is-equiv.bwd (reflects cs)

  â—‹-rec-Î² : âˆ€ {ð“¥} {Q : Type ð“¥} (p : Q âˆˆ S) (f : A â†’ Q)
             â†’ â—‹-rec p f âˆ˜ Î· ~ f
  â—‹-rec-Î² p f a = happly (is-equiv.Îµ (reflects p) f) a

  module âˆˆSâ–¸Î· {ð“¦} {C : Type ð“¦} {g h} (CâˆˆS : C âˆˆ S)
    = is-equiv (postwhisker-is-equivâ†ap-compose {A = A} {g = g}{h}
                         (is-embeddingâ†is-equiv (reflects CâˆˆS)))

is-reflectorâ†global : âˆ€ {Î±} {GS : GSU Î±} {ð“¤}
                        {A : Type ð“¤} {â—‹A : Type ð“¤} {Î· : A â†’ â—‹A}
                      â†’ is-global-reflector GS A â—‹A Î·
                      â†’ let open GSU GS in is-reflector S A â—‹A Î·
is-reflectorâ†global gr
  = mk-is-rfltor â—‹âˆˆS reflects where open is-global-reflector gr

is-global-reflector-subtype-equiv
  : âˆ€ {Î± Î²} {S : GSU Î±} {K : GSU Î²}
      {ð“¤} {A : Type ð“¤} {â—‹A : Type ð“¤}
      {Î· : A â†’ â—‹A}
    â†’ (GSU-equiv S K)
    â†’ is-global-reflector S A â—‹A Î·
    â†’ is-global-reflector K A â—‹A Î·
is-global-reflector-subtype-equiv {A = A} {â—‹A} {Î·} eq rfl = lem where
  open is-global-reflector rfl

  lem : is-global-reflector _ A â—‹A Î·
  lem .is-global-reflector.â—‹âˆˆS = eq _ .fst â—‹âˆˆS
  lem .is-global-reflector.reflects QK = reflects (eq _ .snd QK)
}
%```

\p{A global subuniverse is said to be reflective if we have all
reflectors.}

%```agda
\agda{
record is-globally-reflective {Î±} (GS : GSU Î±) : TypeÏ‰ where
  constructor mk-gReflectors
  open GSU GS
  field
    â—‹ : âˆ€ {ð“¤} â†’ Type ð“¤ â†’ Type ð“¤
    Î· : âˆ€ {ð“¤} {A : Type ð“¤} â†’ A â†’ â—‹ A
    has-is-reflector : âˆ€ {ð“¤} {A : Type ð“¤}
                       â†’ is-global-reflector GS A (â—‹ A) Î·

  module R {ð“¤} {A} = is-global-reflector (has-is-reflector {ð“¤} {A})
  open R public

  module â–¸Î· {ð“¤ ð“¥} {A : Type ð“¤} {B : Type ð“¥} {g h}
    = is-equiv (postwhisker-is-equivâ†ap-compose {g = g}{h}
                 (is-embeddingâ†is-equiv
                   (reflects {A = B} (â—‹âˆˆS {ð“¤}{A}))))

  reflector : âˆ€ {ð“¤} (A : Type ð“¤) â†’ Reflector S A
  reflector A = mk-rfltor (â—‹ A) Î·
                  (is-reflectorâ†global has-is-reflector)



is-reflectiveâ†global :  âˆ€ {Î±} {GS : GSU Î±} â†’ is-globally-reflective GS
                     â†’ âˆ€ {ð“¤} â†’ is-reflective (SubUâ†global GS {ð“¤})
is-reflectiveâ†global (mk-gReflectors â—‹ Î· has-is-reflector)
  = mk-reflective â—‹ Î· (is-reflectorâ†global has-is-reflector)


is-globally-reflective-subtype-equiv
  : âˆ€ {Î± Î²} {S : GSU Î±} {K : GSU Î²}
    â†’ GSU-equiv S K
    â†’ is-globally-reflective S
    â†’ is-globally-reflective K
is-globally-reflective-subtype-equiv {S = S} eq rfl
  = mk-gReflectors â—‹ Î·
     (is-global-reflector-subtype-equiv eq has-is-reflector)
  where open is-globally-reflective rfl


module GPiClosure {Î±} {GS : GSU Î±} (SR : is-globally-reflective GS) where
  open GSU GS
  open is-globally-reflective SR

  Î âˆˆS : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {B : A â†’ Type ð“¥}
        â†’ (âˆ€ a â†’ B a âˆˆ S)
        â†’ Î  A B âˆˆ S
  Î âˆˆS b = in-SubUâ†Î·-retract (reflector _) ret where
    ret : retract Î·
    ret .fst lab a = â—‹-rec (b a) (ev a) lab
    ret .snd f = funextâ†’ (Î» a â†’ â—‹-rec-Î² (b a) (ev a) f)

  ULiftâˆˆS : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤}
          â†’ A âˆˆ S
          â†’ ULift ð“¥ A âˆˆ S
  ULiftâˆˆS = S-equiv (mkâ‰ƒ _ lift-is-equiv)

  ðŸ™âˆˆS : ðŸ™ âˆˆ S
  ðŸ™âˆˆS = in-SubUâ†Î·-retract (reflector _) (! , ~refl)

  âˆˆSâ†is-singleton : âˆ€ {ð“¤} {A : Type ð“¤} â†’ is-singleton A â†’ A âˆˆ S
  âˆˆSâ†is-singleton sing = in-SubUâ†Î·-retract
                           (reflector _)
                           (retractâ†singleton-dom sing Î·)
}
%```
}


\subtree[stt-007C]{
\taxon{Definition}
\title{Sigma closed global reflective subuniverses}


%```agda
\agda{
is-globally-Î£-closed : âˆ€ {Î±} (GS : GSU Î±) â†’ TypeÏ‰
is-globally-Î£-closed G
  = âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {B : A â†’ Type ð“¥}
    â†’ A âˆˆ S â†’ (âˆ€ a â†’ B a âˆˆ S)
    â†’ Î£ A B âˆˆ S where open GSU G

is-Î£-closedâ†globally : âˆ€ {Î±} (GS : GSU Î±)
                       â†’ is-globally-Î£-closed GS
                       â†’ âˆ€ {ð“¤}
                       â†’ is-Î£-closed (SubUâ†global GS {ð“¤})
is-Î£-closedâ†globally GS sc = sc

}
%```
}
\subtree[stt-007D]{
\taxon{Theorem}
\title{Induction for sigma closed [GRSU](stt-007C)}

\p{When a global reflective subuniverse is closed under sigma types we
can extend the recursion principal in \ref{stt-007B} to an induction
prinicipal.}

\proof{ \p{Because #{S} is closed under #{\Sigma} types, we can use
the universal property of the reflector at #{A} to define a map
#{\bar{f} : \bigcirc A \to \Sigma_{(x : \bigcirc A)} \bigcirc P(x)}
just by it's action on #{\eta(x)} for #{x : A}. This map is given by
#{\eta(x) \mapsto (\eta(x), f(x))}.}

\p{To show that #{\bar{f}} is indeed a section, we first note that the
universal property of the reflector gives us #{\pi \bar{f} \eta \sim
\eta}.  Then because postcomposition by #{\eta} at a modal type is an
equivalence, [so is postwhiskering](stt-006I) by #{\eta} (assuming
funext), thus we can apply the inverse map to get a homotopy #{\pi
\bar{f} \sim \id}.}  }


%```agda
\agda{
module GRSUInduction {Î±} {GS : GSU Î±}
        (Sref : is-globally-reflective GS)
        (SÎ£ : is-globally-Î£-closed GS) where
  open GSU GS
  open is-globally-reflective Sref

  ind : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {P : â—‹ A â†’ Type ð“¥} (PâˆˆS : âˆ€ a â†’ P a âˆˆ S)
        â†’ (Î  A (P âˆ˜ Î·)) â†’ Î  (â—‹ A) P
  ind {A = A} {P} ps f = Î â†section (f' , â–¸Î·.bwd secÎ·) module ind where
    f'' : A â†’ Î£ (â—‹ A) P
    f'' a = (Î· a , f a)

    f' : â—‹ A â†’ Î£ (â—‹ A) P
    f' = â—‹-rec (SÎ£ â—‹âˆˆS ps) f''

    secÎ· : fst âˆ˜ f' âˆ˜ Î· ~ Î·
    secÎ· = fst â—‚ â—‹-rec-Î² _ _

  ind-Î² : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {P : â—‹ A â†’ Type ð“¥}
            (PâˆˆS : âˆ€ a â†’ P a âˆˆ S)
          â†’ (f : Î  A (P âˆ˜ Î·)) â†’ ind PâˆˆS f âˆ˜ Î· ~ f
  ind-Î² {A = A} {P} PS f a
    = tr P (â–¸Î·.bwd secÎ· (Î· a)) (snd (f' (Î· a)))
        ï¼âŸ¨ ap (Î» p â†’ tr P p (snd (f' (Î· a)))) (happly (â–¸Î·.Îµ secÎ·) a) âŸ©
      tr P (ap fst (â—‹-rec-Î² _ f'' a)) (snd (f' (Î· a)))
        ï¼âŸ¨ ap (Î» p â†’ coe p (snd (f' (Î· a)))) (sym (ap-âˆ˜ P fst _)) âŸ©
      tr (P âˆ˜ fst) (â—‹-rec-Î² _ f'' a) (snd (f' (Î· a)))
        ï¼âŸ¨ apáµˆ snd (â—‹-rec-Î² _ f'' a) âŸ©
      snd (f'' a)
        ï¼âŸ¨âŸ©
      f a âˆŽ       where open ind PS f


  ind-qiso : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {P : â—‹ A â†’ Type ð“¥}
               (PS : âˆ€ a â†’ P a âˆˆ S)
             â†’ quasi-iso {A = (a : A) â†’ P (Î· a)} {B = (a : â—‹ A) â†’ P a}
                         (ind PS)
  ind-qiso PS .fst = _âˆ˜ Î·
  ind-qiso PS .snd .fst f = ext! (ind-Î² _ f)
  ind-qiso {A = A} {P} PS .snd .snd f = ext!
    (ind (Î» a â†’ is-modal-ï¼ (is-reflectiveâ†global Sref) (PS a))
         (ind-Î² _ (f âˆ˜ Î·)))

  ind-is-equiv : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {P : â—‹ A â†’ Type ð“¥}
                   (PS : âˆ€ a â†’ P a âˆˆ S)
                 â†’ is-equiv {A = (a : A) â†’ P (Î· a)}
                            {B = (a : â—‹ A) â†’ P a}
                            (ind PS)
  ind-is-equiv = is-equivâ†qiso âˆ˜ ind-qiso


  return = Î·
  _>>=_ : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {B : Type ð“¥}
          â†’ â—‹ A â†’ (A â†’ â—‹ B) â†’ â—‹ B
  ma >>= f = ind (Î» _ â†’ â—‹âˆˆS) f ma
  open Universal
}
%```
}
