\title{Leibniz Adjunction}
\taxon{Module}
\date{2026-02-18}
\author{fredrikbakke}

\import{stt-macros}

%```agda
\agda{
module Core.LeibnizAdjunction where

open import ufAxioms
open import Foundations.NullHomotopy global-funext

open import Foundations.Prelude
open import Foundations.TypeFamily

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Join
open import Core.CanonicalPushouts
open import Core.PullbackPower
open import Core.PullbackPowerFamilies
open import Core.PushoutSum
open import Core.PushoutSumFamilies

open import Ergonomics.Extensionality
}
%```

\subtree[fre-0005]{
\taxon{Definition}
\title{Iterated pullback powers and pushout sums}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  (F@(A , B) : Fam ğ“¤1 ğ“¤2)
  (G@(X , Y) : DepFam ğ“¤3 ğ“¤4 F)
  (H@(U , V) : DepÂ²Fam ğ“¤5 ğ“¤6 F G)
  where

  Î Ì‚Î£Ì‚á¶  : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤5 âŠ” ğ“¤6)
            (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤6)
  Î Ì‚Î£Ì‚á¶  = Î Ì‚á¶  (Î£Ì‚á¶  F G) (Î£Ì‚áµˆá¶  F G H)

  Î Ì‚áµˆá¶  : DepFam (ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤5 âŠ” ğ“¤6) (ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤6) F
  Î Ì‚áµˆá¶ 
    = (Î» a â†’ fst (Î Ì‚á¶  (X a , Y a) (U a , V a)))
    , (Î» a â†’ snd (Î Ì‚á¶  (X a , Y a) (U a , V a)))

  Î Ì‚Î Ì‚á¶  : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤5 âŠ” ğ“¤6)
            (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤6)
  Î Ì‚Î Ì‚á¶  = Î Ì‚á¶  F Î Ì‚áµˆá¶ 

module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  {A : Type ğ“¤1}
  {B : Type ğ“¤2}
  (f : A â†’ B)
  {X : B â†’ Type ğ“¤3}
  {Y : B â†’ Type ğ“¤4}
  (g : (b : B) â†’ X b â†’ Y b)
  {U : (b : B) â†’ Y b â†’ Type ğ“¤5}
  {V : (b : B) â†’ Y b â†’ Type ğ“¤6}
  (h : (b : B) (y : Y b) â†’ U b y â†’ V b y)
  where

  Î Ì‚Î£Ì‚ : (((b , y) : Î£ B Y) â†’ U b y) â†’ Arr-Î  (Î£Ì‚ f g) (Î» (b , y) â†’ h b y)
  Î Ì‚Î£Ì‚ = Î Ì‚ (Î£Ì‚ f g) (Î» (b , y) â†’ h b y)

  Î Ì‚Î Ì‚ : ((b : B) (y : Y b) â†’ U b y) â†’ Arr-Î  f (Î» b â†’ Î Ì‚ (g b) (h b))
  Î Ì‚Î Ì‚ = Î Ì‚ f (Î» b â†’ Î Ì‚ (g b) (h b))
}
%```
}

\subtree[fre-0006]{
\taxon{Theorem}
\title{The dependent Leibniz adjunction for families}

\p{
For all [type families](fre-0032) #{B : A \to \UU}, dependent type families
#{Y : (a : A)\to X(a) \to \UV} and doubly dependent type families
#{V : (a : A)\,(x : X(a)) \to U(a, x) \to \UW}, we have an
[equivalence of families](fre-0034)
##{\pulldpow_{\pushsum_B Y}((a , x) \mapsto V(a, x)) \simeq \pulldpow_B {(a \mapsto \pulldpow_{Y(a)} V(a))}.}
}
%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  (F@(A , B) : Fam ğ“¤1 ğ“¤2)
  (G@(X , Y) : DepFam ğ“¤3 ğ“¤4 F)
  (H@(U , V) : DepÂ²Fam ğ“¤5 ğ“¤6 F G)
  (let Î Î£ = Î Ì‚Î£Ì‚á¶  F G H)
  (let Î Â² = Î Ì‚Î Ì‚á¶  F G H)
  where

  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base : fst Î Î£ â†’ fst Î Â²
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .fst a .fst x = f (a , x)
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .fst a .snd x y = p (a , x) (Î¹â‚‚ y)
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .snd a b x .fst = p (a , x) (Î¹â‚ b)
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .snd a b x .snd y = ap (p (a , x)) (sym (glue (b , y)))

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base : fst Î Â² â†’ fst Î Î£
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (f , p) .fst (a , x) = f a .fst x
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (f , p) .snd (a , x)
    = pushout-rec
        (mk-cocone
          (Î» b â†’ p a b x .fst)
          (Î» y â†’ f a .snd x y)
          (Î» (b , y) â†’ sym (p a b x .snd y)))

  Leibnizáµˆá¶ -base-section-cocone
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ Cocone (mk-span _ fst snd) (V (ax .fst) (ax .snd) (fp .fst ax))
  Leibnizáµˆá¶ -base-section-cocone (f , p) ax
    = mk-cocone
        (Î» b â†’ p ax (Î¹â‚ b))
        (Î» y â†’ p ax (Î¹â‚‚ y))
        (Î» (b , y) â†’ sym (ap (p ax) (sym (glue (b , y)))))

  Leibnizáµˆá¶ -base-section-coherence
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ fp .snd ax â—‚ glue ~âˆ™ ~refl â–¸ snd
    ~ ~refl â–¸ fst ~âˆ™ (Leibnizáµˆá¶ -base-section-cocone fp ax) .Cocone.filler
  Leibnizáµˆá¶ -base-section-coherence (f , p) ax (b , y)
    = âˆ™-reflr _
    âˆ™ sym (ap sym (ap-sym (p ax) (glue (b , y))) âˆ™ sym-sym)
    âˆ™ sym (âˆ™-refll _)

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-retraction
    : (fp : fst Î Î£) â†’ Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base fp) ï¼ fp
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-retraction (f , p)
    = Î£-pathâ†’ (refl , funextâ†’ Î» ax
              â†’ funextâ†’ Î» j
              â†’ (pushout-rec-unique (Leibnizáµˆá¶ -base-section-cocone (f , p) ax) (p ax)
                  ~refl
                  ~refl
                  (Leibnizáµˆá¶ -base-section-coherence (f , p) ax) ~â»Â¹) j)

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section-glue
    : (fq : fst Î Â²)
    â†’ (a : A) (b : B a) (x : X a) (y : Y a x)
    â†’ ap (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base fq .snd (a , x)) (sym (glue (b , y)))
    ï¼ fq .snd a b x .snd y
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section-glue (f , p) a b x y
    = ap-sym (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (f , p) .snd (a , x)) (glue (b , y))
    âˆ™ ap sym (pushout-rec-apÎ² (b , y))
    âˆ™ sym-sym

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section
    : (fq : fst Î Â²) â†’ Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base fq) ï¼ fq
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section (f , p)
    = Î£-pathâ†’
        ( refl
        , funextâ†’ Î» a â†’ funextâ†’ Î» b â†’ funextâ†’ Î» x
        â†’ Î£-pathâ†’ (refl
                  , funextâ†’ (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section-glue (f , p) a b x)))

  Leibnizáµˆá¶ â‰…-base : fst Î Î£ â‰… fst Î Â²
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd = Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd-iso .fst = Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd-iso .snd .fst = Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-retraction
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd-iso .snd .snd = Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section

  Leibnizáµˆá¶ â‰ƒ-base : fst Î Î£ â‰ƒ fst Î Â²
  Leibnizáµˆá¶ â‰ƒ-base = equivâ†qiso Leibnizáµˆá¶ â‰…-base

  Leibnizáµˆá¶ -family-null-homotopy-at-curry
    : (fp : fst Î Î£)
    â†’ (a : A)
    â†’ B a
    â†’ (x : X a)
    â†’ null-homotopy (fp .snd (a , x) âˆ˜ Î¹â‚‚)
  Leibnizáµˆá¶ -family-null-homotopy-at-curry (f , p) a b x .fst
    = p (a , x) (Î¹â‚ b)
  Leibnizáµˆá¶ -family-null-homotopy-at-curry (f , p) a b x .snd y
    = ap (p (a , x)) (sym (glue (b , y)))

  Leibnizáµˆá¶ -family-null-homotopy-at-uncurry
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ B (ax .fst)
    â†’ null-homotopy (fp .snd ax âˆ˜ Î¹â‚‚)
  Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b
    = Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a b x

  module _
    (fp : fst Î Î£) (a : A) (x : X a) (l : V a x (fp .fst (a , x)))
    where

    Leibnizáµˆá¶ -family-cod-uncurry
      : B a * Y a x â†’ V a x (fp .fst (a , x))
    Leibnizáµˆá¶ -family-cod-uncurry = fp .snd (a , x)

    Leibnizáµˆá¶ -family-cod-uncurry-sym
      : (b : B a) (y : Y a x)
      â†’ Leibnizáµˆá¶ -family-cod-uncurry (Î¹â‚‚ y) ï¼ Leibnizáµˆá¶ -family-cod-uncurry (Î¹â‚ b)
    Leibnizáµˆá¶ -family-cod-uncurry-sym b y
      = ap Leibnizáµˆá¶ -family-cod-uncurry (sym (glue (b , y)))

    Leibnizáµˆá¶ -family-cod : B a * Y a x â†’ Type ğ“¤6
    Leibnizáµˆá¶ -family-cod j
      = Leibnizáµˆá¶ -family-cod-uncurry j ï¼ l

    Leibnizáµˆá¶ â‰ƒ-family-cod-inner-over
      : (r : (y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y))
      â†’ (b : B a)
      â†’ (Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
          ((y : Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y)))
      â‰ƒ (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
    Leibnizáµˆá¶ â‰ƒ-family-cod-inner-over r b
      = (Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
          ((y : Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» t â†’ Î -ap-â‰ƒ (Î» y â†’ Idáµˆ-const-â‰ƒ Leibnizáµˆá¶ -family-cod-uncurry (glue (b , y)) t (r y))) âŸ©
        (Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
          ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry-sym b y âˆ™ t ï¼ r y))
        â‰ƒâŸ¨ null-homotopy-pathâ‰ƒ
              {f = Leibnizáµˆá¶ -family-cod-uncurry âˆ˜ Î¹â‚‚}
              (Leibnizáµˆá¶ -family-cod-uncurry-sym b)
              r eâ»Â¹ âŸ©
        (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
        â‰ƒâˆ

    Leibnizáµˆá¶ â‰ƒ-family-cod-inner
      : (r : (y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y))
      â†’ (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          (((b , y) : B a Ã— Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
      â‰ƒ ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
    Leibnizáµˆá¶ â‰ƒ-family-cod-inner r
      = (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          (((b , y) : B a Ã— Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» t â†’ curryâ‰ƒ) âŸ©
        (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          ((b : B a) (y : Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ (Î» b â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b))
                     (Î» b t â†’ (y : Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y))
                     eâ»Â¹ âŸ©
        ((b : B a)
          â†’ Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
            ((y : Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y)))
        â‰ƒâŸ¨ Î -ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-cod-inner-over r) âŸ©
        ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
        â‰ƒâˆ

    Leibnizáµˆá¶ â‰ƒ-family-cod-main
      : (((j : B a * Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry j ï¼ l))
      â‰ƒ (Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry (Î¹â‚‚ y) ï¼ l) ]
          ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r)))
    Leibnizáµˆá¶ â‰ƒ-family-cod-main
      = (((j : B a * Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry j ï¼ l))
        â‰ƒâŸ¨ Pushout-UPáµˆâ‰ƒ eâ»Â¹ âŸ©
        Coconeáµˆ (mk-span _ fst snd) pushout (Leibnizáµˆá¶ -family-cod)
        â‰ƒâŸ¨ coconeD-reprâ‰ƒ âŸ©
        (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y)) ]
            (((b , y) : B a Ã— Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-comm âŸ©
        (Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y)) ]
          Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
            (((b , y) : B a Ã— Y a x) â†’ Idáµˆ (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ Leibnizáµˆá¶ â‰ƒ-family-cod-inner âŸ©
        (Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y)) ]
        ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r)))
        â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-cod-null-homotopy
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ null-homotopy (fp .snd ax) â‰ƒ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax)
  Leibnizáµˆá¶ â‰ƒ-family-cod-null-homotopy fp (a , x)
    = null-homotopy (fp .snd (a , x))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-cod-main fp a x) âŸ©
      (Î£[ l âˆ¶ V a x (fp .fst (a , x)) ]
        Î£[ r âˆ¶ ((y : Y a x) â†’ fp .snd (a , x) (Î¹â‚‚ y) ï¼ l) ]
          ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r)))
      â‰ƒâŸ¨ Î£-assoc eâ»Â¹ âŸ©
      null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x))
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-currying-swap-arguments
    : (fp : fst Î Î£)
    â†’ (a : A)
    â†’ (m : (x : X a) â†’ null-homotopy (fp .snd (a , x) âˆ˜ Î¹â‚‚))
    â†’ (((x : X a) (b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ m x))
    â‰ƒ (((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a b ï¼ m))
  Leibnizáµˆá¶ â‰ƒ-family-currying-swap-arguments fp a m
    = (((x : X a) (b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ m x))
      â‰ƒâŸ¨ flipâ‰ƒ âŸ©
      ((b : B a) (x : X a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ m x)
      â‰ƒâŸ¨ Î -ap-â‰ƒ (Î» b â†’ funextâ‰ƒ eâ»Â¹) âŸ©
      ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a b ï¼ m)
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-currying-at
    : (fp : fst Î Î£)
    â†’ (a : A)
    â†’ ((x : X a) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x)))
    â‰ƒ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a)
  Leibnizáµˆá¶ â‰ƒ-family-currying-at fp a
    = ((x : X a) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x)))
      â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ _ _ âŸ©
      (Î£[ g âˆ¶ ((x : X a) â†’ null-homotopy (fp .snd (a , x) âˆ˜ Î¹â‚‚)) ]
        ((x : X a) (b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ g x))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-currying-swap-arguments fp a) âŸ©
      null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a)
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-currying
    : (fp : fst Î Î£)
    â†’ ((ax : Î£ A X) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax))
    â‰ƒ ((a : A) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a))
  Leibnizáµˆá¶ â‰ƒ-family-currying fp
    = ((ax : Î£ A X) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax))
      â‰ƒâŸ¨ curryâ‰ƒ âŸ©
      ((a : A) (x : X a) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x)))
      â‰ƒâŸ¨ Î -ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-currying-at fp) âŸ©
      ((a : A) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a))
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family
    : (fp : fst Î Î£)
    â†’ snd Î Î£ fp â‰ƒ snd Î Â² (Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base fp)
  Leibnizáµˆá¶ â‰ƒ-family fp
    = snd Î Î£ fp
      â‰ƒâŸ¨ Î -ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-cod-null-homotopy fp) âŸ©
      ((ax : Î£ A X) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax))
      â‰ƒâŸ¨ Leibnizáµˆá¶ â‰ƒ-family-currying fp âŸ©
      snd Î Â² (Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base fp)
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ : Î Î£ â‰ƒá¶  Î Â²
  Leibnizáµˆá¶ â‰ƒ = Leibnizáµˆá¶ â‰ƒ-base , Leibnizáµˆá¶ â‰ƒ-family
}
%```
}

\subtree[fre-0007]{
\taxon{Corollary}
\title{The nondependent Leibniz adjunction for families}

\p{
For all triples of type families #{B : A \to \UU}, #{Y : X(a) \to \UV}, and
#{V : U(a, x) \to \UW}, we have an equivalence of families
##{\pullpow{B \pushprod Y}{V} \simeq \pullpow{B}{\pullpow{Y}{V}}.}
}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  (F : Fam ğ“¤1 ğ“¤2)
  (G : Fam ğ“¤3 ğ“¤4)
  (H : Fam ğ“¤5 ğ“¤6)
  where

  Leibnizá¶ â‰ƒ : âŸ¨(F â–¡á¶  G) ,á¶  H âŸ© â‰ƒá¶  âŸ¨ F ,á¶  âŸ¨ G ,á¶  H âŸ© âŸ©
  Leibnizá¶ â‰ƒ = Leibnizáµˆá¶ â‰ƒ F (Famâ†’DepFam F G) (Famâ†’DepÂ²Fam F G H)
}
%```
}

\subtree[fre-0008]{
\taxon{Corollary}
\title{The dependent Leibniz adjunction for arrows}

\p{
For all [arrows](fre-0001) #{f : A \to B}, dependent arrows
#{g : (b : B) \to X(b) \to Y(b)} and doubly dependent arrows
#{h : (b : B)\,(y : Y(b)) \to U(b, y) \to V(b, y)}, we have an
[equivalence of arrows](stt-004R)
##{\pulldpow_{\pushsum_f g} ((b,y) \mapsto h(b, y)) \simeq \pulldpow_f {(b \mapsto \pulldpow_{g(b)} h(b))}.}
}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  {A : Type ğ“¤1}
  {B : Type ğ“¤2}
  (f : A â†’ B)
  {X : B â†’ Type ğ“¤3}
  {Y : B â†’ Type ğ“¤4}
  (g : (b : B) â†’ X b â†’ Y b)
  {U : (b : B) â†’ Y b â†’ Type ğ“¤5}
  {V : (b : B) â†’ Y b â†’ Type ğ“¤6}
  (h : (b : B) (y : Y b) â†’ U b y â†’ V b y)
  (let h-uncurry = Î» (b , y) â†’ h b y)
  (let F = fibre-fam f)
  (let G = fibre-depfam g)
  (let H = fibre-depÂ²fam h)
  (let Î Ì‚Î£Ì‚á¶ -fibre-fam = Î Ì‚Î£Ì‚á¶  F G H)
  (let Î Ì‚Î Ì‚á¶ -fibre-fam = Î Ì‚Î Ì‚á¶  F G H)
  where

  Î Ì‚Î£Ì‚-bridgeâ‰ƒ
    : Arrow-equiv
        (Î Ì‚Î£Ì‚ f g h)
        (arrâ†Fam Î Ì‚Î£Ì‚á¶ -fibre-fam)
  Î Ì‚Î£Ì‚-bridgeâ‰ƒ
    = Î Ì‚-Arrow-equivâ†â‰ƒá¶ 
        (Î£Ì‚ f g)
        (h-uncurry)
        (Î Ì‚Î£Ì‚á¶ -fibre-fam)
        (Î Ì‚á¶ -ap-base-fam (fibre-depfam h-uncurry) (Î£Ì‚-unstraightenâ‰ƒá¶  f g .snd))

  Î Ì‚Î Ì‚-bridgeâ‰ƒ
    : Arrow-equiv
        (Î Ì‚Î Ì‚ f g h)
        (arrâ†Fam Î Ì‚Î Ì‚á¶ -fibre-fam)
  Î Ì‚Î Ì‚-bridgeâ‰ƒ
    = Î Ì‚-Arrow-equivâ†â‰ƒá¶ 
        (f)
        (Î» b â†’ Î Ì‚ (g b) (h b))
        (Î Ì‚Î Ì‚á¶ -fibre-fam)
        (Î Ì‚á¶ -ap-â‰ƒáµˆá¶ 
          (F)
          (fibre-depfam (Î» b â†’ Î Ì‚ (g b) (h b)))
          (Î Ì‚áµˆá¶  F G H)
          (Î» b â†’ Î Ì‚-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam (g b) (h b)))

  Leibnizáµˆâ‰ƒ : Arrow-equiv (Î Ì‚Î£Ì‚ f g h) (Î Ì‚Î Ì‚ f g h)
  Leibnizáµˆâ‰ƒ
    = concat-Arrow-equiv
        (concat-Arrow-equiv
          (Î Ì‚Î£Ì‚-bridgeâ‰ƒ)
          (Arrow-equivâ†â‰ƒá¶ 
            (Î Ì‚Î£Ì‚á¶ -fibre-fam)
            (Î Ì‚Î Ì‚á¶ -fibre-fam)
            (Leibnizáµˆá¶ â‰ƒ F G H)))
        (inv-Arrow-equiv Î Ì‚Î Ì‚-bridgeâ‰ƒ)
}
%```
}

\subtree[fre-0009]{
\taxon{Corollary}
\title{The nondependent Leibniz adjunction for arrows}

\p{
For all triples of [arrows](fre-0001) #{f : A \to B}, #{g : X \to Y}, and
#{h : U \to V}, we have an [equivalence of arrows](stt-004R)
##{\pullpow{f \pushprod g}{h} \simeq \pullpow{f}{\pullpow{g}{h}}.}
}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  {A : Type ğ“¤1} {B : Type ğ“¤2} (f : A â†’ B)
  {C : Type ğ“¤3} {D : Type ğ“¤4} (g : C â†’ D)
  {E : Type ğ“¤5} {F : Type ğ“¤6} (h : E â†’ F)
  where

  Leibnizâ‰ƒ : Arrow-equiv âŸ¨ (f â–¡ g) , h âŸ© âŸ¨ f , âŸ¨ g , h âŸ© âŸ©
  Leibnizâ‰ƒ = Leibnizáµˆâ‰ƒ f (Î» _ â†’ g) (Î» _ _ â†’ h)
}
%```
}
