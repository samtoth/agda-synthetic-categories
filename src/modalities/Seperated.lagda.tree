\date{2025-06-14}
\title{Seperated types}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb modalities.Seperated \stopverb}
\import{stt-macros}

%```agda
\agda{
module modalities.Seperated  where

open import foundations.Prelude
open import ufAxioms
open import modalities.Subuniverses
open import modalities.GlobalSubuniverses
open import modalities.instances.Localisation
open import core.Suspensions
open import core.Arrow
open import core.ArrowEquiv
open import ergonomics.Universal
open import ergonomics.PushoutUniv
open import axioms.FreeAlgInj
}
%```


\subtree[stt-007E]{
\title{Seperated types for a subuniverse}
\taxon{definition}

\p{A type is seperated if it's identity types are modal. This forms a
[(global)](stt-007A) [subuniverse](stt-003Z).}


%```agda
\agda{
is-seperated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦) â†’ Type ğ“¤ â†’ Type (ğ“¤ âŠ” ğ“¦)
is-seperated S A = âˆ€ (x y : A) â†’ (x ï¼ y) âˆˆ S

seperated-SubU : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦) â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“¦)
seperated-SubU S .Subtype.family = is-seperated S
seperated-SubU S .Subtype.has-is-subtype A
  = is-prop-Î  Î» x â†’ is-prop-Î  Î» y â†’ Subtype.has-is-subtype S (x ï¼ y)

equiv-seperated : âˆ€ {Î±} (S : GSU Î±) {ğ“¤ ğ“¥} {A : Type ğ“¤}
                    {B : Type ğ“¥} (e : A â‰ƒ B)
                  â†’ is-seperated (SubUâ†global S) A
                  â†’ is-seperated (SubUâ†global S) B
equiv-seperated S e sep x y
  = GSU.S-equiv S
       (embeddingâ‰ƒ (is-embeddingâ†is-equiv
                     (is-equivâ»Â¹ has-is-eqv)) x y)
       (sep (bwd x) (bwd y))
  where
    open _â‰ƒ_ e

seperated-GSU : âˆ€ {Î±} (S : GSU Î±) â†’ GSU  (Î» ğ“¤ â†’ ğ“¤ âŠ” Î± ğ“¤)
seperated-GSU S .GSU.S = seperated-SubU (SubUâ†global S)
seperated-GSU S .GSU.S-equiv = equiv-seperated S


is-seperated-SubU-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¥'} (S : SubU ğ“¤ ğ“¥) (K : SubU ğ“¤ ğ“¥')
      {A : Type ğ“¤}
    â†’ Subtype-equiv S K
    â†’ is-seperated S A
    â†’ is-seperated K A
is-seperated-SubU-equiv _ _ eq sep a b = eq _ .fst (sep a b)
}
%```
}


\subtree[stt-007I]{
\title{Local types are seperated}
\taxon{theorem}

\p{Given a reflective subuniverse #{S},
the #{S}-modal types are also #{S}-seperated.}

\todo{
Most of the seperated stuff
requires the modified join construction which we don't have yet.
}

%```agda
\agda{
-- is-seperatedâ†is-modal
--   : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
--       {A : Type ğ“¤}
--     â†’ A âˆˆ S
--     â†’ A âˆˆ seperated-SubU S
-- is-seperatedâ†is-modal S as x y
--   = {!!}
}
%```
}

\subtree[stt-007F]{
\title{Seperated types and localisations}
\taxon{theorem}

\p{Given a family of maps #{f_i : A_i \to B_i}, the seperated
types with respect to localisation at #{f} are the #{\Sigma(f)}
local types. (Where #{\Sigma(-)} is the  functorial action of
the suspension)}


\proof{
\p{We can construct the following commutative diagram:}
\quiver{
\begin{tikzcd}
	{\Sigma_{(x,y : X)} (x = y) ^ {B_i}} && {\Sigma_{(x,y:X)}(x=y)^{A_i}} \\
	\\
	{X^{\Sigma B_i}} && {X^{\Sigma A_i}}
	\arrow["{\textrm{total}((x=y)^f)}", from=1-1, to=1-3]
	\arrow["\sim"', from=1-1, to=3-1]
	\arrow["\sim", from=1-3, to=3-3]
	\arrow["{X^{\Sigma f}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{It then follows that postcomposition by #{f} at #{x = y} is an equivalence
iff postcomposition by #{\Sigma(f)} is at #{X}.}
}

%```agda
\agda{
module _ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
         (f : (i : I) â†’ A i â†’ B i) where

  private
    Î£f : (i : I) â†’ Susp (A i) â†’ Susp (B i)
    Î£f i = Susp-map (f i)

  is-seperatedâ‡”is-Î£-local
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
    â†’ is-local Î£f X
    â‡” is-seperated (Local-SubU f ğ“¤) X
  is-seperatedâ‡”is-Î£-local {X = X}
    = ( (Î» loc x y i â†’ topmapâ‡”botmap-is-equiv i .snd (loc i) (x , y))
       , Î» sep i â†’ topmapâ‡”botmap-is-equiv i .fst Î» (x , y) â†’ sep x y i) where
    module _ i where
      topmap : âˆ€ (ab : X Ã— X)
          â†’ (B i â†’ ab .fst ï¼ ab .snd)
          â†’ (A i â†’ ab .fst ï¼ ab .snd)
      topmap (x , y) = postcomp (x ï¼ y) (f i)

      eqvl : (Î£[ ab âˆ¶ (X Ã— X)] (B i â†’ ab .fst ï¼ ab .snd))
           â‰ƒ (Susp (B i) â†’ X)
      eqvl = Î£-assoc âˆ™â‰ƒ (Susp-UPâ‰ƒ eâ»Â¹)

      eqvr : (Susp (A i) â†’ X)
           â‰ƒ (Î£[ ab âˆ¶ (X Ã— X)] (A i â†’ ab .fst ï¼ ab .snd))
      eqvr = Susp-UPâ‰ƒ âˆ™â‰ƒ Î£-assoc eâ»Â¹

      botmap : (Susp (B i) â†’ X) â†’ (Susp (A i) â†’ X)
      botmap = postcomp X (Î£f i)


      F : Arrow-map (total-map topmap) botmap
      F .Arrow-map.top = eqvl ._â‰ƒ_.fwd
      F .Arrow-map.bot = _â‰ƒ_.bwd eqvr
      F .Arrow-map.comm ((x , y) , H) = funextâ†’ (pushout-ind _
        (mk-coconeD
          ~refl
          ~refl
          Î» a â†’ IdP-funcâ†Square (glue a) refl refl
                  (âˆ™-reflr _ âˆ™ pushout-rec-apÎ² a
                             âˆ™ sym (ap-âˆ˜ (pushout-rec (mk-cocone (Î» _ â†’ x) (Î» _ â†’ y) H))
                                         (pushout-rec (mk-cocone Î¹â‚ Î¹â‚‚ (glue âˆ˜ f i)))
                                         (glue a)
                                    âˆ™ ap (ap _) (pushout-rec-apÎ² a)
                                    âˆ™ pushout-rec-apÎ² (f i a)
                                    ))))

      F-is-equiv : is-Arrow-equiv F
      F-is-equiv = ( eqvl ._â‰ƒ_.has-is-eqv
                   , is-equivâ»Â¹ (eqvr ._â‰ƒ_.has-is-eqv))

      topmapâ‡”botmap-is-equiv
        : is-fibrewise-equiv topmap â‡” is-equiv botmap
      topmapâ‡”botmap-is-equiv
        =    (fibrewiseâ‡”total-is-equiv â‡”â»Â¹)
          âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv F F-is-equiv

  is-seperatedâ†is-Î£-local
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
    â†’ is-local Î£f X
    â†’ is-seperated (Local-SubU f ğ“¤) X
  is-seperatedâ†is-Î£-local = is-seperatedâ‡”is-Î£-local .fst

  is-Î£-localâ†is-seperated
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
    â†’ is-seperated (Local-SubU f ğ“¤) X
    â†’ is-local Î£f X
  is-Î£-localâ†is-seperated = is-seperatedâ‡”is-Î£-local .snd

module _ {ğ“˜ ğ“¤} {I : Type ğ“˜} (A : I â†’ Type ğ“¤) where
  is-seperatedâ†is-Î£-null
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
      â†’ is-null (Susp âˆ˜ A) X
      â†’ is-seperated (Null-SubU A ğ“¤) X
  is-seperatedâ†is-Î£-null null
    = is-seperated-SubU-equiv (Local-SubU !A _) (Null-SubU A _)
                              Nullâ‰ƒ!Local
                              (is-seperatedâ†is-Î£-local !A
                                (is-local-equiv
                                  (Î» i â†’ Susp-!â»Â¹)
                                  (Î» _ â†’ Arrowâ»Â¹-is-equiv Susp-! Susp-!-is-equiv)
                                  (is-localâ†is-null null))) where
      !A : (i : I) â†’ A i â†’ ğŸ™
      !A i _ = tt

  is-Î£-nullâ†is-seperated
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
      â†’ is-seperated (Null-SubU A ğ“¤) X
      â†’ is-null (Susp âˆ˜ A) X
  is-Î£-nullâ†is-seperated sep
    = is-nullâ†is-local
       (is-local-equiv
         (Î» _ â†’ Susp-!)
         (Î» _ â†’ Susp-!-is-equiv)
         (is-Î£-localâ†is-seperated
           (Î» _ _ â†’ tt)
           (is-seperated-SubU-equiv
             (Null-SubU A _)
             (Local-SubU (Î» i _ â†’ tt) _)
             (_â‡”â»Â¹ âˆ˜ Nullâ‰ƒ!Local)
             sep)))
}
%```
}

\subtree[stt-007H]{
\title{Iterated seperation}
\taxon{definition}

\p{Because the seperated types give a (reflective) subuniverse for
each (reflective) subuniverse, we can consider the result of
repeatedly applying seperation.
}

%```agda
\agda{
is-n-seperated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                 â†’ (n : â„•) â†’ Type ğ“¤
                 â†’ Type (ğ“¤ âŠ” ğ“¦)
is-n-seperated {ğ“¤} S zero A = ULift ğ“¤ (A âˆˆ S)
is-n-seperated S (suc n) A
  = âˆ€ (x y : A) â†’ is-n-seperated S n (x ï¼ y)


mk-is-seperated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                 â†’ (n : â„•) (A : Type ğ“¤)
                 â†’ is-n-seperated (seperated-SubU S) n A
                 â†’ is-n-seperated S (suc n) A
mk-is-seperated S zero A (mk-lift sep) x y = mk-lift (sep x y)
mk-is-seperated S (suc n) A sep a b = mk-is-seperated S n (a ï¼ b) (sep a b)


is-n-seperated-is-prop
  : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
      (n : â„•) (A : Type ğ“¤)
    â†’ is-prop (is-n-seperated S n A)
is-n-seperated-is-prop S zero A
  = is-prop-ULift (S .Subtype.has-is-subtype A)
is-n-seperated-is-prop S (suc n) A
  = is-prop-Î  Î»
     a â†’ is-prop-Î  Î»
       b â†’ is-n-seperated-is-prop S n (a ï¼ b)

n-seperated-SubU : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                   â†’ (n : â„•) â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“¦)
n-seperated-SubU S n .Subtype.family = is-n-seperated S n
n-seperated-SubU S n .Subtype.has-is-subtype
  = is-n-seperated-is-prop S n

equiv-n-seperated
  : âˆ€ {ğ“¤ ğ“¥ Î±} (S : GSU Î±)
      (n : â„•)
      {A : Type ğ“¤} {B : Type ğ“¥}
    â†’ A â‰ƒ B
    â†’ is-n-seperated (SubUâ†global S) n A
    â†’ is-n-seperated (SubUâ†global S) n B
equiv-n-seperated S zero eq (mk-lift sep)
  = mk-lift (S .GSU.S-equiv eq sep)
equiv-n-seperated S (suc n) eq sep b b'
  = equiv-n-seperated S n
      (mkâ‰ƒ _ (is-embeddingâ†is-equiv
                 (is-equivâ»Â¹ has-is-eqv)) eâ»Â¹)
      (sep (bwd b) (bwd b')) where open _â‰ƒ_ eq


n-seperated-GSU : âˆ€ {Î±} (S : GSU Î±)
                  â†’ (n : â„•) â†’ GSU (Î» ğ“¤ â†’ ğ“¤ âŠ” Î± ğ“¤)
n-seperated-GSU S n .GSU.S = n-seperated-SubU (SubUâ†global S) n
n-seperated-GSU S n .GSU.S-equiv = equiv-n-seperated S n
}
%```
}

\subtree[stt-007S]{
\title{n-seperated subunverse with respect to localisation are reflective}
\taxon{theorem}

\p{Although the theorem is true in the more general setting of any
reflective subuniverse, we detail the proof in the specific case of
localisation. The general case also requires the modified join construction
which we are yet to formalise.}

%```agda
\agda{

-- localâ‰ƒsep-GSU : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤}
--                   {B : I â†’ Type ğ“¥} (f : (i : I) â†’ A i â†’ B i)
--                 â†’ âˆ€ n â†’ GSU-equiv (Local-GSU {!!}) (n-seperated-GSU (Local-GSU f) n)
-- localâ‰ƒsep-GSU = {!!}

-- local-seperated-is-globally-reflective
--   : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
--       (f : (i : I) â†’ A i â†’ B i)
--     â†’ âˆ€ n â†’ is-globally-reflective (n-seperated-GSU (Local-GSU f) n)
-- local-seperated-is-globally-reflective f n
--   = is-globally-reflective-subtype-equiv (localâ‰ƒsep-GSU f n) {!Local-GSU-is-reflective!}
}
%```
}
