\date{2025-02-24}
\title{Dependent Identity Types}
\author{samueltoth}

\import{stt-macros}

% ```agda
\agda{
module Foundations.DependentIdentity where

open import Foundations.Universes
open import Foundations.Identity
open import Foundations.Functions
open import Foundations.Sigma
}
% ```


\p{Suppose we have types #{A, B : \UU}, and a path between them #{A =_\UU B}.
We want to talk about equalities between terms #{a : A} and #{b : B}, but the
type #{a =_{?} b} is not well formed (what type do we put for \em{?}).  }

\subtree{
\taxon{Example}

\def\Fin[n]{\mathbb{N}^{\n}  }

\p{Consider the type of the standard finite types indexed over natural
numbers. Addition can be defined as a function #{(x : \Fin{<m}) \to (y :
\Fin{<n}) \to \Fin{<(m + n)}}. Then consider the type of #{n + 2} and #{2 +
n}. The types aren't definitionally equal but are equal up to a path (the proof
of commutativity of natural number addition). } }

\subtree{
\taxon{Definition}
\title{Dependent Identity}

\p{
Given:
\ul{
\li{a base type #{A : \UU}}
\li{a family #{B : A \to \UV} over A}
\li{a path #{p : a =_A b}}
\li{a term #{(x : B a)} over a}
\li{a term #{(y : B b)} over b}
}

We define the type of dependent identifications over p, written #{x =_B^p y}.
}


% ```agda
\agda{
module _ {ð“¤} {A : Type ð“¤} {B : Type ð“¤} (P : A ï¼ B) where
  Idáµˆ : A â†’ B â†’ Type ð“¤
  Idáµˆ a b = coe P a ï¼ b


Idáµˆ-syntax : âˆ€ {ð“¤} {A B : Type ð“¤} â†’ A ï¼ B â†’ A â†’ B â†’ Type ð“¤
Idáµˆ-syntax = Idáµˆ

infix 6 Idáµˆ-syntax
syntax Idáµˆ-syntax P a b = a ï¼[ P ] b

module _ {ð“¤} {A B : Type ð“¤} where

  symáµˆ : âˆ€ {P : A ï¼ B} {a} {b} â†’ Idáµˆ P a b â†’ Idáµˆ (sym P) b a
  symáµˆ {P = refl} p = sym p

  symáµˆ' : âˆ€ {P : A ï¼ B} {a} {b} â†’ Idáµˆ (sym P) b a â†’ Idáµˆ P a b
  symáµˆ' {P = refl} p = sym p

  Idáµˆ-inl : âˆ€ {P : A ï¼ B} {a : A} {b : B} â†’ coe P a ï¼ b â†’ Idáµˆ P a b
  Idáµˆ-inl {P = P} p = p

  Idáµˆ-inr :  âˆ€ {P : A ï¼ B} {a : A} {b : B} â†’ a ï¼ coe (sym P) b â†’ Idáµˆ P a b
  Idáµˆ-inr {P = refl} p = p


  Idáµˆ-right : âˆ€ {P : A ï¼ B} {a : A} {b : B}
            â†’ Idáµˆ P a b â†’ a ï¼ coe (sym P) b
  Idáµˆ-right {P = refl} p = p

refláµˆ : âˆ€ {ð“¤} {A : Type ð“¤} {P : A ï¼ A} (_ : P ï¼ refl) {a : A} â†’ Idáµˆ P a a
refláµˆ refl = refl

module _ {ð“¤} {A : Type ð“¤} where
  apáµˆ : âˆ€ {ð“¥} {B : A â†’ Type ð“¥}
           (f : (a  : A) â†’ B a)
           {a b : A}
         â†’ (p : a ï¼ b)
         â†’ Idáµˆ (ap B p) (f a) (f b)
  apáµˆ f refl = refl

  apáµˆ-is-ap : âˆ€ {ð“¥} {B : Type ð“¥}
              â†’ {f : A â†’ B}
              â†’ {a b : A}
              â†’ {p : a ï¼ b}
              â†’ apáµˆ f p ï¼[ (tr-constant _ _) âˆ™- ]  ap f p
  apáµˆ-is-ap {p = refl} = refl

apáµˆ-âˆ˜ : âˆ€ {ð“¤ ð“¥ ð“¦} {A : Type ð“¤} {A' : Type ð“¥} {B : A â†’ Type ð“¦}
          {f : Î  A B}
          {a b : A'}
          {g : A' â†’ A}
          {p : a ï¼ b}
        â†’ apáµˆ (f âˆ˜ g) p ï¼[ (trâˆ˜ B g p âˆ™-) ] apáµˆ f (ap g p)
apáµˆ-âˆ˜ {p = refl} = refl

transp-leftáµˆ : âˆ€ {ð“¤}
                 {A B : Type ð“¤} (P : A ï¼ B)
                 {a : A}  {b : B}
                 â†’ a ï¼[ P ] b â†’ {b' : B} â†’ b ï¼ b' â†’ a ï¼[ P ] b'
transp-leftáµˆ refl p q = p âˆ™ q

transIdáµˆ : âˆ€ {ð“¤} {A B C : Type ð“¤}
             (P : A ï¼ B) (Q : B ï¼ C)
             {a : A} {b : B} {c : C}
           â†’ a ï¼[ P ] b â†’ b ï¼[ Q ] c
           â†’ a ï¼[ P âˆ™ Q ] c
transIdáµˆ P Q {a} p q = sym (coeâˆ™coe P Q a) âˆ™ ap (coe Q) p âˆ™ q
{-# NOINLINE transIdáµˆ #-}

syntax transIdáµˆ P Q p q = p âˆ™[ P âˆ™ Q ] q

Idáµˆ-const-coe
  : âˆ€ {ð“¤ ð“¥} {A : Type ð“¤} {B : Type ð“¥}
      (f : A â†’ B)
      {x y : A} (p : x ï¼ y)
      {l : B}
      (t : f x ï¼ l)
    â†’ coe (ap (Î» z â†’ f z ï¼ l) p) t ï¼ ap f (sym p) âˆ™ t
Idáµˆ-const-coe f refl t = refl

-- syntax transp-rightP B p q r = p âˆ™[ B âˆ£ q ] r
-- syntax transp-leftP  B p q r = q [ B âˆ£ p ]âˆ™ r
}
% ```
}
