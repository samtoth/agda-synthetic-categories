\date{2025-07-02}
\title{Synthetic Tiny objects}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}


%```agda
\agda{
open import Foundations.Prelude

module Synthetic.Tiny {@â™­ ğ“˜} (@â™­ I : Type ğ“˜) where

open import Modalities.Flat.Flat
open import ufAxioms
}
%```


\subtree[stt-00A9]{
\title{Internally Tiny Object}
\date{2025-11-17}
\taxon{Definition}

\p{In a cartesian closed category #{\CC}, for each object #{I}, there is an
adjunction #{- \times I \dashv -^I}. The object is called (internally)-\em{tiny}
or sometimes \em{atomic} if #{-^I} has a further right adjoint, which we will
call #{\sqrt[I]{-}}. This right adjoint is also referred to as \em{the amazing
right adjoint} - terminology which stems from synthetic differential geometry.}
}

\subtree{
\title{Idea}

\p{In type theory, we can represent the situation where a type #{I} has a right
adjoint using with the following judgement (Where #{\mathcal{P}} represents
exponentiating the context by #{I}):}

##{
\frac{\mathcal{P}(\Gamma) \vdash A}{\Gamma \vdash \sqrt[I]{A}}
}

\p{In addition, you need rules expressing the unit and counit of the adjunction.
It is clearly not possible to introduce this type as an axiom inside of type
theory; but there have been structural extensions to type theory that allow this
type to be represented. Firstly, it fits within the general framework of
[multimode type theory](GKNB21) and this aproach is taken in \citek{GWB2024} to
define the category of spaces. Secondly, Mitchel Riley \citek{MR2024} introduced a
bespoke type theory that encorporates a tiny object.}

\p{Seperately, \citek{LOPS2018} make use of the [flat
modality](Modalities.Flat.Flat) to postulate an amazing right adjoint. In this
module we formalise a similar construction, except instead of postulating the
adjunction directly, we postulate a type former with #{\beta} and #{\eta} laws
roughly based off Mitchel Riley's work.  }
}

\subtree[stt-00AG]{
\taxon{Notation}

\p{We first define some notation that allows the posulate rules for the
[root type](stt-00A8) to appear close to how they would be presented in the
description of a type theory.}

\subtree{
\title{Technical remark}

\p{We make the substitution operation (which is just function composition)
opaque, so that we can make use of rewriting to make substitution commute with
new type formers computationally (via rewrite-rules). We prove functoriality of
substitution inside the opaque block, and then \em{re-expose} this computational
behaviour using rewrite rules.}
}

%```agda
\agda{
module LFNotation where
  infixl 20 _âŠ¢_
  _âŠ¢_ : âˆ€ {ğ“¤ ğ“¥} â†’ Type ğ“¤ â†’ Type ğ“¥ â†’ Type (ğ“¤ âŠ” ğ“¥)
  A âŠ¢ B = A â†’ B
  ty-syntax : âˆ€ {@â™­ ğ“¤} (@â™­ Î“ : Type ğ“¤) ğ“¥ â†’ Type (ğ“¤ âŠ” lsuc ğ“¥)
  ty-syntax Î“ ğ“¥ = Î“ â†’ Type ğ“¥

  syntax ty-syntax Î“ ğ“¥ = Î“ âŠ¢ ty ğ“¥
  tm-syntax : âˆ€ {@â™­ ğ“¤ ğ“¥} (@â™­ Î“ : Type ğ“¤) (A : Î“ âŠ¢ ty ğ“¥)
              â†’ Type (ğ“¤ âŠ” ğ“¥)
  tm-syntax Î“ A = Î  _ A

  syntax tm-syntax Î“ A = Î“ âŠ¢ tm A

  infixl 20 _â¨¾_
  _â¨¾_ : âˆ€ {ğ“¤ ğ“¥} â†’ Type ğ“¤ â†’ Type ğ“¥ â†’ Type (ğ“¤ âŠ” ğ“¥)
  Î“ â¨¾ A = Î“ Ã— A


  opaque
   _[_] : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ Î“ : Type ğ“¤} {@â™­ Î” : Type ğ“¥}
        â†’ (Î” âŠ¢ ty ğ“¦)
        â†’ (Î“ â†’ Î”)
        â†’ Î“ âŠ¢ ty ğ“¦
   A [ Ïƒ ] = A âˆ˜ Ïƒ

   _[_]tm : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ Î“ : Type ğ“¤} {@â™­ Î” : Type ğ“¥}
               {A : Î” âŠ¢ ty ğ“¦}
               (a : Î” âŠ¢ tm A)
               (Ïƒ : Î“ â†’ Î”)
             â†’ Î“ âŠ¢ tm (A [ Ïƒ ])
   a [ Ïƒ ]tm = a âˆ˜ Ïƒ

   subst-functorial
     : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦ ğ“œ} {@â™­ Î“ : Type ğ“¤} {@â™­ Î” : Type ğ“¥} {@â™­ Î˜ : Type ğ“¦}
         (A : Î˜ âŠ¢ ty ğ“œ)
         (Ïƒ : Î” â†’ Î˜) (Î´ : Î“ â†’ Î”)
       â†’ (A [ Ïƒ ]) [ Î´ ] ï¼ (A [ Ïƒ âˆ˜ Î´ ])
   subst-functorial _ _ _ = refl

   subst-id
     : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤}
         (A : Î“ âŠ¢ ty ğ“¥)
       â†’ A [ id ] ï¼ A
   subst-id = ~refl

  wk-ty : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤} (A : Type ğ“¥) â†’ Î“ âŠ¢ ty ğ“¥
  wk-ty = const _ _

  {-#Â REWRITE subst-functorial subst-id #-}
}
%```

}

\subtree[stt-00AF]{
\title{The Root type former}
\taxon{Definition}

%```agda
\agda{
open LFNotation
}
%```

\p{We also expose notation for exponentiating a context by #{I}, and show that
this has a functorial action by substution, as well as the unit and counit of
the adjunction #{-;I \dashv \mathcal{P}(-)}.}

%```agda
\agda{
private
  ğ“Ÿ : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“¤ âŠ” ğ“˜)
  ğ“Ÿ A = I â†’ A

  ğ“Ÿâ‚ : âˆ€ {ğ“¤ ğ“¥} {Î“ : Type ğ“¤} {Î” : Type ğ“¥}
     â†’ (Î“ â†’ Î”) â†’ (ğ“Ÿ Î“ â†’ ğ“Ÿ Î”)
  ğ“Ÿâ‚ = precomp _

  unit : âˆ€ {ğ“¤} {Î“ : Type ğ“¤} â†’ Î“ â†’ (ğ“Ÿ (Î“ â¨¾ I))
  unit g i = g , i

  counit : âˆ€ {ğ“¤} {Î“ : Type ğ“¤} â†’ (ğ“Ÿ Î“ â¨¾ I) â†’ Î“
  counit (g , i) = g i
}
%```


\p{With this notation in hand, we can write the formation, introduction and
elimination rules as well as their laws in Agda in a readable way. We also make
as many things as possible commute using rewriting (whilst keeping the confluence
checker happy).}

%```agda
\agda{
postulate
  âˆš : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤}
      â†’ @â™­ (ğ“Ÿ Î“) âŠ¢ ty ğ“¥
      ---------------------
      â†’  Î“ âŠ¢ ty ğ“¥

  âˆš-nat
    : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ Î“ : Type ğ“¤} {@â™­ Î” : Type ğ“¥}
        (@â™­ Ïƒ : Î“ â†’ Î”)
        (@â™­ A : ğ“Ÿ Î” âŠ¢ ty ğ“¦)
      â†’ (âˆš A) [ Ïƒ ] ï¼ âˆš (A [ ğ“Ÿâ‚ Ïƒ ])


{-#Â REWRITE âˆš-nat #-}

postulate
  rintro
    : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤} â†’
          {@â™­ A : ğ“Ÿ Î“ âŠ¢ ty ğ“¥} â†’ (@â™­ a : ğ“Ÿ Î“ âŠ¢ tm A)
      â†’ ----------------------------------------------
                    Î“ âŠ¢ tm (âˆš A)

  relim
    : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤} {@â™­ A : (ğ“Ÿ (Î“ â¨¾ I)) âŠ¢ ty ğ“¥} â†’
         @â™­ ((Î“ â¨¾ I) âŠ¢ tm (âˆš A))
      â†’ ------------------------
          Î“ âŠ¢ tm (A [ unit ])

  relim-Î²
    : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤} {@â™­ A : ğ“Ÿ (Î“ â¨¾ I) âŠ¢ ty ğ“¥} â†’
            (@â™­ a : ğ“Ÿ (Î“ â¨¾ I) âŠ¢ tm A)
     â†’ ------------------------------------------
          relim (rintro a) ~ (a [ unit ]tm)

  relim-Î·
    : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤} {@â™­ A : ğ“Ÿ Î“ âŠ¢ ty ğ“¥} â†’
            (@â™­ a : Î“ âŠ¢ tm âˆš A)
      â†’ --------------------------------------
          a ~ rintro (relim  (a [ counit ]tm))


  R-nat
   : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ Î“ : Type ğ“¤} {@â™­ Î” : Type ğ“¥}
       {@â™­ A : ğ“Ÿ Î” âŠ¢ ty ğ“¦} (@â™­ Ïƒ : Î“ â†’ Î”)
     â†’ (@â™­ f : (ğ“Ÿ Î”) âŠ¢ tm A)
     â†’ rintro f [ Ïƒ ]tm ï¼ rintro (f [ ğ“Ÿâ‚ Ïƒ ]tm)

{-# REWRITE R-nat relim-Î² #-}


opaque
   unfolding _[_]
   tm-subst-functorial
     : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦ ğ“œ} {@â™­ Î“ : Type ğ“¤} {@â™­ Î” : Type ğ“¥} {@â™­ Î˜ : Type ğ“¦}
         {A : Î˜ âŠ¢ ty ğ“œ}
         (a : Î˜ âŠ¢ tm A)
         (Ïƒ : Î” â†’ Î˜) (Î´ : Î“ â†’ Î”)
       â†’ (a [ Ïƒ ]tm) [ Î´ ]tm ï¼ (a [ Ïƒ âˆ˜ Î´ ]tm)
   tm-subst-functorial _ _ _ = refl

   tm-subst-id
     : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ Î“ : Type ğ“¤}
         {A : Î“ âŠ¢ ty ğ“¥}
         (a : Î“ âŠ¢ tm A)
       â†’ a [ id ]tm ï¼ a
   tm-subst-id = ~refl
}
%```
}

\subtree[stt-00AA]{
\title{Root is a right adjoint}
\taxon{Theorem}

\p{We can now derive the adjunction as it is presented in \citek{LOPS2024} -
including a dependent version of the left adjoint.}

%```agda
\agda{
module LOPS where
  L : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
      â†’ @â™­ ( A âŠ¢ tm (âˆš (wk-ty B))) â†’ (ğ“Ÿ A â†’ B)
  L f = relim (f [ counit ]tm)

  R : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
      â†’ @â™­ (ğ“Ÿ A â†’ B) â†’ Î  A (âˆš (wk-ty B))
  R = rintro

  LR : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
           {@â™­ f : ğ“Ÿ A â†’ B}
         â†’ L (R f) ï¼ f
  LR {f = f}
      =    L (R f)
         ï¼âŸ¨âŸ©
           relim ((rintro f) [ counit ]tm)
         ï¼âŸ¨âŸ©
           relim (rintro (f [ ğ“Ÿâ‚ counit ]tm))
         ï¼âŸ¨âŸ© -- âŸ¨ funextâ†’ (relim-Î² (f [ ğ“Ÿâ‚ counit ]tm)) âŸ©
           (f [ ğ“Ÿâ‚ counit ]tm) [ unit ]tm
         ï¼âŸ¨ lem âŸ©
           f âˆ where
    opaque
      unfolding _[_]
      lem : ((f [ ğ“Ÿâ‚ counit ]tm) [ unit ]tm) ï¼ f
      lem = refl


  RL : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
         {@â™­ f : Î  A (âˆš (wk-ty B))}
       â†’ R (L f) ï¼ f
  RL {f = f} = sym (funextâ†’ (relim-Î· f))


  L' : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : ğ“Ÿ A â†’ Type ğ“¥}
      â†’ @â™­ ( A âŠ¢ tm (âˆš B)) â†’ (Î  (ğ“Ÿ A) B)
  L' f = relim (f [ counit ]tm)
}
%```
}

\subtree[stt-00AO]{
\title{Relative notions of fibrancy}
\taxon{Definition}

\p{Fixing a type #{I}, and given #{\mathcal{F}} a family of predicates over
families of types #{A \to \UU}, we say that #{\mathcal{F}} is #{I}-relative for
some type #{I} if #{P} is fibrant iff for any map #{x : I \to A}, #{P \circ x}
is fibrant.
}

%```agda
\agda{
is-relative : âˆ€ {Î± : Level â†’ Level â†’ Level}
              â†’ (âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} â†’ (A â†’ Type ğ“¥) â†’ Type (Î± ğ“¤ ğ“¥))
              â†’ TypeÏ‰
is-relative is-fib
  = âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (P : A â†’ Type ğ“¥)
    â†’ (is-fib P â‡” (âˆ€ (x : I â†’ A) â†’ is-fib (P âˆ˜ x) ))


is-pullback-stable : âˆ€ {Î± : Level â†’ Level â†’ Level}
                     â†’ (âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} â†’ (A â†’ Type ğ“¥) â†’ Type (Î± ğ“¤ ğ“¥))
                     â†’ TypeÏ‰
is-pullback-stable is-fib
  = âˆ€ {ğ“¤ ğ“¤' ğ“¥} {Î“ : Type ğ“¤'} {A : Type ğ“¤} (P : A â†’ Type ğ“¥) (Ïƒ : Î“ â†’ A)
    â†’ is-fib P â†’ is-fib (P âˆ˜ Ïƒ)

is-pullback-stableâ†is-relative
  : âˆ€ {Î± : Level â†’ Level â†’ Level}
    â†’ (P : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} â†’ (A â†’ Type ğ“¥) â†’ Type (Î± ğ“¤ ğ“¥))
    â†’ is-relative P â†’ is-pullback-stable P
is-pullback-stableâ†is-relative is-fib rel P Ïƒ fib
  = rel (P âˆ˜ Ïƒ) .snd (Î» x â†’ rel P .fst fib (Ïƒ âˆ˜ x))
}
%```
}


\subtree[stt-00AH]{
\taxon{Construction}
\title{A universe that weakly classifies relative fibrations}

\p{We first fix a notion of fibrancy, which is predicate on type families, and
ask that it is relative in the sense that a type family #{B} over #{A} is
fibrant if and only if it's precomposition with any #{I \to A} is fibrant.}

\p{From this we can define the notation of \em{amazing fibrancy}, which is a
predicate on a type - not a type family. Informally, amazing fibrancy says that
a type is fibrant over any arbritary context.}

\p{The universe of fibrant types can then be defined to be the types which are
amazingly fibrant. There is a map #{\pi : \UU_{fib} \to \UU}, and \UU_{fib} is
defined by the property that a map #{A \to \UU} factors through #{\pi} iff it is
fibrant.}

%```agda
\agda{
module AFib
       {@â™­ Î± : Level â†’ Level â†’ Level}
       (@â™­ is-fib : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥) â†’ Type (Î± ğ“¤ ğ“¥))
       (@â™­ rel-fib : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
                     â†’ is-fib B â‡” (âˆ€ (x : I â†’ A) â†’ is-fib (B âˆ˜ x)))
       where
  open LOPS

  is-afib : âˆ€ {@â™­ ğ“¤} (A : Type ğ“¤) â†’ Type (Î± ğ“˜ ğ“¤)
  is-afib {ğ“¤} = âˆš is-fib

  UFib : âˆ€ (@â™­ ğ“¤) â†’ Type (Î± ğ“˜ ğ“¤ âŠ” lsuc ğ“¤)
  UFib ğ“¤ = Î£[ A âˆ¶ Type ğ“¤ ] is-afib A

  UFibâˆ™ : âˆ€ (@â™­ ğ“¤) â†’ Type (Î± ğ“˜ ğ“¤ âŠ” lsuc ğ“¤)
  UFibâˆ™ ğ“¤ = Î£ (UFib ğ“¤) fst

  F-Ï€-is-fib : âˆ€ {@â™­ ğ“¤} â†’ is-fib (fst {B = is-afib {ğ“¤}})
  F-Ï€-is-fib {ğ“¤} = rel-fib _ .snd Ï•Ìƒ where
    opaque
      unfolding _[_]
      Ï• : UFib ğ“¤ âŠ¢ tm ((âˆš is-fib) [ fst ])
      Ï• = snd

    Ï•' : UFib ğ“¤ âŠ¢ tm âˆš (is-fib [ ğ“Ÿâ‚ fst ])
    Ï•' = Ï•

    opaque
      unfolding _[_]
      Ï•Ìƒ : (x : ğ“Ÿ (UFib ğ“¤)) â†’ is-fib (fst âˆ˜ x)
      Ï•Ìƒ = L' Ï•'

  UFib-fib : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} â†’ (P : A â†’ UFib ğ“¥)
             â†’ is-fib (fst âˆ˜ P)
  UFib-fib {A = A} P
    = is-pullback-stableâ†is-relative is-fib rel-fib _ P F-Ï€-is-fib

  opaque
    unfolding _[_]
    rel-fibâ™­ : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} (@â™­ B : A â†’ Type ğ“¥)
               â†’ is-fib B â‡” (ğ“Ÿ A âŠ¢ tm (is-fib [ ğ“Ÿâ‚ B ]))
    rel-fibâ™­ B = rel-fib B

  liftFib : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ P : A â†’ Type ğ“¥}
              â†’ âŸ¨â™­| is-fib P âŸ© â‡” âŸ¨â™­| (âˆ€ a â†’ is-afib (P a)) âŸ©
  liftFib {A = A} {P = P} .fst (modâ™­ fib)
    = modâ™­ x' where
      x : (a : A) â†’ (is-afib [ P ]) a
      x = rintro {Î“ = A} {is-fib [ ğ“Ÿâ‚ P ]} (rel-fibâ™­ P .fst fib)

      opaque
       unfolding _[_]
       x' : (a : A) â†’ is-afib (P a)
       x' = x
  liftFib {P = P} .snd (modâ™­ afib) = modâ™­ (UFib-fib (Î» a â†’ _ , afib a))

  U-classifies : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ P : A â†’ Type ğ“¥}
                 â†’ @â™­ is-fib P â†’ A â†’ UFib ğ“¥
  U-classifies {P = P} ifib a = (P a , Îµ (liftFib .fst (modâ™­ ifib)) a)
}
%```
}
