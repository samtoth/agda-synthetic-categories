\date{2025-01-14}
\title{Universal elements}
\taxon{Module}
\author{samueltoth}


%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Universal
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open import Ergonomics.Auto

open import Core.CanonicalPushouts
open import Core.Arrow

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Homotopies Î”Â¹ I I-distr
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.HomFamilies Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.NaturalTransformation Î”Â¹ I I-distr
}
%```


%```agda
\agda{
Homâ†Id
  : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ âˆ€ {a b} â†’ a ï¼ b â†’ Hom A a b
Homâ†Id refl = idH _

Hom-gpd
  : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-groupoid A
  â†’ âˆ€ {a b} â†’ is-equiv (Homâ†Id {_}{A}{a}{b})
Hom-gpd gpd {a} {b}
  = is-equiv~âˆ˜ {f = _â‰ƒ_.bwd HomP-reprâ‰ƒ} {g = g âˆ˜ f}
      (Î» {refl â†’ refl})
      (is-equivâ»Â¹ (_â‰ƒ_.has-is-eqv HomP-reprâ‰ƒ))
      (is-equiv-âˆ˜ {f = g} {g = f}
        (total-is-equivâ†fst-is-equiv (gpd tt))
        (is-equivâ»Â¹ (Î£-ï¼singl ._â‰ƒ_.has-is-eqv))) where
  f : a ï¼ b â†’ Î£[ c âˆ¶ _ ] ((c ï¼ a) Ã— (c ï¼ b))
  f = _â‰ƒ_.bwd Î£-ï¼singl
  g : Î£[ c âˆ¶ _ ] ((c ï¼ a) Ã— (c ï¼ b))
    â†’ Î£[ g âˆ¶ (Î”Â¹ â†’ _) ] Î£ (g i0 ï¼ a) (Î» hom2 â†’ g i1 ï¼ b)
  g (a , p , q) = (const _ _ a , p , q)

yo
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {F : A â†’ Type ğ“¥}
    â†’ is-covariant F
    â†’ âˆ€ b (x : F b) â†’ âˆ€ a â†’ Hom _ b a â†’ F a
yo Fc b x a f = tr-cov-hom (is-covariant-homâ†is-covariant _ Fc) f x

ev-id
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {F : A â†’ Type ğ“¥}
    â†’ âˆ€ b â†’ (âˆ€ a â†’ Hom _ b a â†’ F a) â†’ F b
ev-id b Î± = Î± b (idH b)

tr-hom-is-âˆ˜
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
      (Asimp : is-simplicial A)
      (Apc : is-segal A)
      {a b c} (f : Hom A b c)
    â†’ tr-cov-hom {P = Hom A a}
          (is-covariant-homâ†is-covariant  _
              (hom-fam-is-covâ‡”is-strongly-segal .snd
                (is-strongly-segalâ†is-segal Asimp Apc) a))
          f ~ (f âˆ˜[ Apc ]_)
tr-hom-is-âˆ˜ Asi Ase f g = unique-composite Ase f g
  (tr-cov-hom Ahomcov f g)
  {!tr-cov-over Ahomcov f g!} {- have: Hom_f(g, tr(f,g)). Need Hom2(f,g,tr(f,g)) -} where
  Ahomcov = (is-covariant-homâ†is-covariant  _
              (hom-fam-is-covâ‡”is-strongly-segal .snd
                (is-strongly-segalâ†is-segal Asi Ase) _))

precat-idr : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) {x y}
             â†’ (f : Hom A x y) â†’ (f âˆ˜[ As ] idH _) ï¼ f
precat-idr As f = sym (unique-composite As f (idH _)
  f
  (refl~â–µ f))

precat-idl
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) {x y}
    â†’ (f : Hom A x y) â†’ (idH _ âˆ˜[ As ] f) ï¼ f
precat-idl As f = sym
  (unique-composite As (idH _) f
    f
    ((f .HomP.hom âˆ˜ Poly.Î”Â².s) , funextâ†’
      (pushout-rec-unique _ _
        (pushout-rec-unique _ _
          ~refl (Î» _ â†’ f .HomP.hom1)
          (Î» _ â†’ un-square {ai0 = ap _ (glue tt)} {refl} {f .HomP.hom1} {f .HomP.hom1}
                   (coe (Square-functorial-top
                     (sym (ap-âˆ˜ (f .HomP.hom âˆ˜ Poly.Î”Â².s) Î›[2,1]-incl (glue tt)
                          âˆ™ ap (ap (f .HomP.hom âˆ˜ Poly.Î”Â².s)) (pushout-rec-apÎ² tt)
                          âˆ™ ap-âˆ˜ (HomP.hom f) (Poly.Î”Â².s) Î”Â²-refl
                          âˆ™ ap (ap (f .HomP.hom)) (is-propâ†is-truncated trunc! _ refl))))
                    (Square-drop-j _))))
        ~refl
        {!!})))

tr-naturality
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {F : A â†’ Type ğ“¥} {G : A â†’ Type ğ“¦}
      (Fc : is-covariant-hom F)
      (Gc : is-covariant-hom G)
      (Î± : âˆ€ a â†’ F a â†’ G a)
      {x y} (f : Hom A x y)
    â†’ tr-cov-hom Gc f âˆ˜ Î± x ~ Î± y âˆ˜ tr-cov-hom Fc f
tr-naturality = {!!}

tr-cov-is-equiv
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
      (Asimp : is-simplicial A)
      (Apc : is-segal A)
      {F : A â†’ Type ğ“¥}
    â†’ (Fc : is-covariant F)
    â†’ is-fibrewise-equiv (ev-id {F = F})
tr-cov-is-equiv Asimp Apc {F = F} Fc a = is-equivâ†qiso
  (yo {F = F} Fc a
  , (Î» Î± â†’ funextâ†’ Î» a' â†’ funextâ†’ Î» f â†’
    (yo Fc a (Î± a (idH a)) a' f)
            ï¼âŸ¨âŸ©
    tr-cov-hom Fch f (Î± a (idH a))
            ï¼âŸ¨  tr-naturality {!!} {!Fc!} Î± f (idH _) âŸ©
    Î± a' (tr-cov-hom Ahomcov f (idH a))
                            ï¼âŸ¨ ap (Î± a') (tr-hom-is-âˆ˜ Asimp Apc f (idH a) ) âŸ©
    Î± a' (f âˆ˜[ Apc ] idH a) ï¼âŸ¨ ap (Î± a') (precat-idr Apc f) âŸ©
    Î± a' f âˆ)
  , (Î» x â†’ tr-cov-idH F Fch x)) where
  Fch = is-covariant-homâ†is-covariant _ Fc
  Ahomcov = is-covariant-homâ†is-covariant  _
              (hom-fam-is-covâ‡”is-strongly-segal .snd
                (is-strongly-segalâ†is-segal Asimp Apc) a)

is-universal
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {F : A â†’ Type ğ“¥}
      â†’ is-covariant F
      â†’ Î£ A F â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-universal {F = F} Fcov (a , x)
  = is-fibrewise-equiv (yo Fcov a x)

is-initial : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ Type (ğ“˜ âŠ” ğ“¤)
is-initial a = âˆ€ b â†’ is-singleton (Hom _ a b)

_âŠ£_ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
      â†’ (A â†’ B) â†’ (B â†’ A) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
l âŠ£ r = âˆ€ a b â†’ Hom _ (l a) b â‰ƒ Hom _ a (r b)

is-initialâ†ladj
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {a : A}
    â†’ (l : A â†’ B) â†’ (r : B â†’ A) â†’ l âŠ£ r
    â†’ is-initial a â†’ is-initial (l a)
is-initialâ†ladj f g fg ai b
  = is-singleâ†equiv-to-single (fg _ b eâ»Â¹) (ai (g b))

universal-rec
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {F : A â†’ Type ğ“¥}
    â†’ (Fc : is-covariant F)
    â†’ {x : Î£ A F}
    â†’ is-universal Fc x
    â†’ âˆ€ {b} â†’ F b
    â†’ Hom _ (x .fst) b
universal-rec Fc un = is-equiv.bwd (un _)

Hom-âˆ«
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} (Bc : is-covariant B)
      {x} (x' : B x) {y} (y' : B y)
    â†’ Hom (Î£ A B) (x , x') (y , y')
    â‰ƒ Î£[ f âˆ¶ Hom A x y ]
        (tr-cov-hom (is-covariant-homâ†is-covariant B Bc) f x' ï¼ y')
Hom-âˆ« {B = B} Bc x' y'
  = Hom-Î£â‰ƒ âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» a â†’ mkâ‰ƒ _ (Hom-cov'-is-equiv B Bch a x' y') eâ»Â¹) where
  Bch = is-covariant-homâ†is-covariant B Bc

fundamental-Cov
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {F : A â†’ Type ğ“¥} (Fc : is-covariant F)
      x
    â†’ (f : âˆ€ a â†’ Hom A x a â†’ F a)
    â†’ is-initial {A = Î£ A F} (x , f x (idH x))
    â‡” is-fibrewise-equiv f
fundamental-Cov Fc x f = {!!}

universalâ†initial
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {F : A â†’ Type ğ“¥}
    â†’ (Fc : is-covariant F)
    â†’ {x : Î£ A F}
    â†’ is-initial x
    â†’ is-universal Fc x
universalâ†initial {F = F} Fc {x} init a
  = is-equivâ†is-contr-map Î»
      b â†’ is-singleâ†equiv-to-single
           (Hom-âˆ« Fc (x .snd) b)
           (init (a , b))

-- equiv-pres-initial
--   : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
--     â†’ is-equiv f
--     â†’ âˆ€ x â†’ is-initial x â†’ is-initial (f x)
-- equiv-reflects-initial = {!!}

unit-NTâ†section
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
    â†’ (l : A â†’ B) (r : B â†’ A)
    â†’ (r âˆ˜ l ~ id)
    â†’ id â‡’ r âˆ˜ l
unit-NTâ†section l r H a = adjust-hom refl (sym (H a)) (idH a)

left-adjointâ†NT-sec
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
    â†’ is-segal A â†’ is-segal B
    â†’ (l : A â†’ B) (r : B â†’ A)
    â†’ section-witness r l
    â†’ (Îµ : l âˆ˜ r â‡’ id) â†’ l âŠ£ r
left-adjointâ†NT-sec As Bs l r p Îµ a b ._â‰ƒ_.fwd f
  = ap-hom r f âˆ˜[ As ] unit-NTâ†section l r p a
left-adjointâ†NT-sec As Bs l r p Îµ a b ._â‰ƒ_.has-is-eqv
  = is-equivâ†qiso
      ( (Î» f â†’ Îµ b âˆ˜[ Bs ] ap-hom l f)
      , (Î» f â†’
  Îµ b âˆ˜[ Bs ] ap-hom l (ap-hom r f âˆ˜[ As ] unit-NTâ†section l r p a) ï¼âŸ¨ {!!} âŸ©
  Îµ b âˆ˜[ Bs ] (ap-hom l (ap-hom r f) âˆ˜[ Bs ] ap-hom l (unit-NTâ†section l r p a))
    ï¼âŸ¨ {!!} âŸ©
  Îµ b âˆ˜[ Bs ] {!f âˆ˜[ Bs ] ?!} ï¼âŸ¨ {!!} âŸ©
  f âˆ)
      , Î» aâ‚ â†’ {!!})

record left-adjoint-section'
  {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (r : B â†’ A)
  : Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥) where
  field
    sec : A â†’ B
    Î· : id ~ r âˆ˜ sec
    Î·-univ
      : âˆ€ {a b} â†’ is-equiv ( adjust-hom (sym (Î· a)) (refl {a = r b}) âˆ˜ ap-hom r)

  adjâ†lasec : sec âŠ£ r
  adjâ†lasec a b = mkâ‰ƒ (adjust-hom (sym (Î· a)) refl âˆ˜ ap-hom r) Î·-univ

-- open left-adjoint-section'

record left-adjoint-section
  {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (r : B â†’ A)
  : Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥) where
  field
    sec : A â†’ B
    Î· : id ~ r âˆ˜ sec
    Îµ : sec âˆ˜ r â‡’ id
    Îµ-left : âˆ€ x â†’ Hom-pathP (ap sec (Î· x)) refl  (idH (sec x)) (Îµ (sec x))
    Îµ' : sec âˆ˜ r â‡’ id
    Îµ'-right : âˆ€ x â†’ Hom-pathP (Î· (r x)) refl (idH (r x)) (ap-hom r (Îµ' x))

record bi-diagramatic-adjunction
  {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
  (l : A â†’ B) (r : B â†’ A)
  : Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥) where
  field
    Î· : id â‡’ r âˆ˜ l
    Îµ : l âˆ˜ r â‡’ id
    Îµ-left : âˆ€ x â†’ Hom2 (Îµ (l x)) (ap-hom l (Î· x)) (idH (l x))
    Îµ' : l âˆ˜ r â‡’ id
    Îµ'-right : âˆ€ y â†’ Hom2 (ap-hom r (Îµ y)) (Î· (r y)) (idH (r y))

test
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f g : A â†’ B}
      (Î· : f ~ g) (h : g  â‡’ f)
   â†’ âˆ€ x â†’ Hom-pathP (Î· x) refl (idH (f x)) (h x)
   â†’ Hom2 (h x) (Homâ†Id (Î· x)) (idH _)
test = {!!}

Homâ†Id-ap
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {x y} (p : x ï¼ y) â†’ Homâ†Id (ap f p) ï¼ ap-hom f (Homâ†Id p)
Homâ†Id-ap refl = refl

bi-diagramaticâ†left-adjoint-section
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
      (As : is-segal A)
      (Bs : is-segal B)
      (r : A â†’ B)
    â†’ (s : left-adjoint-section r)
    â†’ bi-diagramatic-adjunction (s .left-adjoint-section.sec) r
bi-diagramaticâ†left-adjoint-section As B s r = adj where
  open bi-diagramatic-adjunction
  module r = left-adjoint-section r

  adj : bi-diagramatic-adjunction (r.sec) s
  adj .Î· x = Homâ†Id (r.Î· x)
  adj .Îµ = r.Îµ
  adj .Îµ-left x = tr (Î» p â†’ Hom2 _ p (idH _))
                     (Homâ†Id ((r.sec â—‚ r.Î·) x) ï¼âŸ¨ Homâ†Id-ap (r.Î· x) âŸ©
                     ap-hom r.sec (Homâ†Id (r.Î· x)) âˆ)
                     (test (r.sec â—‚ r.Î·) (r.Îµ âˆ˜ r.sec) x (r.Îµ-left x))
  adj .Îµ' = r.Îµ'
  adj .Îµ'-right = {!!}

-- adjunctionâ†left-adjoint-section
--   : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
--       (As : is-segal A)
--       (Bs : is-segal B)
--       (r : A â†’ B)
--     â†’ (s : left-adjoint-section r)
--     â†’ s .sec âŠ£ r
-- adjunctionâ†left-adjoint-section As Bs r s a b = equivâ†qiso qiso where
--   qiso : Hom _ (s .sec a) b â‰… Hom _ a (r b)
--   qiso ._â‰…_.fwd f = adjust-hom (s .Î· a) refl (ap-hom r f)
--   qiso ._â‰…_.fwd-iso .fst g = s .Îµ b âˆ˜[ As ] ap-hom (s .sec) g
--   qiso ._â‰…_.fwd-iso .snd .fst f
--     = (s .Îµ b âˆ˜[ As ] ap-hom (s .sec) (adjust-hom (s .Î· a) refl (ap-hom r f)))
--          ï¼âŸ¨ {!!} âŸ©
--       f âˆ
--   qiso ._â‰…_.fwd-iso .snd .snd g
--     = adjust-hom (s .Î· a) refl (ap-hom r (s .Îµ b âˆ˜[ As ] ap-hom (s .sec) g))
--         ï¼âŸ¨ {!!} âŸ©
--       adjust-hom (s .Î· a) refl (ap-hom r (s .Îµ b) âˆ˜[ Bs ] ap-hom (r âˆ˜ s .sec) g)
--         ï¼âŸ¨ {!!} âŸ©
--       (ap-hom r (s .Îµ b) âˆ˜[ Bs ] adjust-hom (s .Î· a) refl (ap-hom (r âˆ˜ s .sec) g))
--         ï¼âŸ¨ {!!} âŸ©
--       g âˆ

ev0-lari'
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
  â†’ is-segal A
  â†’ left-adjoint-section' (ev {B = Î» _ â†’  A} i0)
ev0-lari' As .left-adjoint-section'.sec = const _ _
ev0-lari' As .left-adjoint-section'.Î· = ~refl
ev0-lari' As .left-adjoint-section'.Î·-univ {a} {b} = is-equivâ†qiso
  ( (Î» f â†’ Homâ†NT (Î» i â†’ mk-hom (Î» j â†’ b (i âˆ§ j)) {!!} {!!} âˆ˜[ As ] f))
  , {!!}
  , {!!})

-- ev0-lari
--   : âˆ€ {ğ“¤} {A : Type ğ“¤}
--   â†’ is-segal A
--   â†’ left-adjoint-section (ev {B = Î» _ â†’  A} i0)
-- ev0-lari {A = A} As .sec = const A Î”Â¹
-- ev0-lari {A = A} As .Î· = ~refl
-- ev0-lari {A = A} As .Îµ a = Homâ†NT Î» i â†’ mk-hom (Î» j â†’ a (i âˆ§ j))
--                                                (ap a (âˆ§-comm âˆ™ 0-init))
--                                                (ap a 1-top)
-- ev0-lari {A = A} As .Îµ-left x = ~refl , ({!!} , {!!})
-- ev0-lari {A = A} As .Îµ' a = Homâ†NT Î» i â†’ mk-hom (Î» j â†’ a (i âˆ§ j))
--                                                 (ap a (âˆ§-comm âˆ™ 0-init))
--                                                 (ap a 1-top)
-- ev0-lari {A = A} As .Îµ'-right x = (x â—‚ (Î» _ â†’ 0-init)) , {!!}

lari-pullback
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y} (F : Arrow-map f g)
    â†’ is-cartesian F
    â†’ left-adjoint-section g
    â†’ left-adjoint-section f
lari-pullback = {!!}

lari-! : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ left-adjoint-section (! {A = A}) â‰ƒ Î£ A is-initial
lari-! = {!!}

-- initialâ†lari-!
--   : âˆ€ {ğ“¤} {A : Type ğ“¤}
--     â†’ is-segal A
--     â†’ (s : left-adjoint-section (! {A = A}))
--     â†’ is-initial (s .left-adjoint-section.sec tt)
-- initialâ†lari-! as s b = is-singleâ†equiv-to-single
--   (adjunctionâ†left-adjoint-section as Segal.ğŸ™âˆˆS ! s tt b eâ»Â¹)
--   {!!}

-- R17 lemma 9.8
-- coslice-initial
--   : âˆ€ {ğ“¤} {A : Type ğ“¤} {a : A}
--     â†’ is-segal A
--     â†’ is-initial {A = Coslice A (const _ ğŸ™ a)} (a , Î» _ â†’ idH a)
-- coslice-initial {a = a} as
--   = initialâ†lari-!
--       {!!}
--       (lari-pullback {f = ! {A = Coslice _ (const _ _ a)}} {g = ev i0}
--                      coslice-square {!!} (ev0-lari as)) where
--   coslice-square : Arrow-map ! (ev i0)
--   coslice-square .Arrow-map.top (_ , p) = p tt .HomP.hom
--   coslice-square .Arrow-map.bot _ = a
--   coslice-square .Arrow-map.comm (a , p) = sym {!p tt .HomP.hom0!}

initialâ†universal
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {F : A â†’ Type ğ“¥}
    â†’ (Fc : is-covariant F)
    â†’ {x : Î£ A F}
    â†’ is-universal Fc x
    â†’ is-initial x
initialâ†universal {F = F} Fc {x} univ
  = tr is-initial
       {!!}
       (is-initialâ†ladj
         (total-map (yo {F = F} Fc {!!} {!!}))
         _
         {!!}
         {!!} )
}
%```
