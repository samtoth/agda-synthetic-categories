\date{2025-06-03}
\title{Equivalences of arrows}
\author{samueltoth}
\import{stt-macros}
\taxon{Module}

%```agda
\agda{
module Core.ArrowEquiv where

open import ufAxioms
open import Foundations.Prelude

open import Core.Arrow
}
%```

\subtree[stt-004R]{
\taxon{Definition}
\title{Arrow equivalences}

\p{A pair of arrows #{A \xrightarrow{f} B} and #{X \xrightarrow{g} Y} are said
to be equivalent if there exists an [arrow map](stt-003U) where both horizontal
morphisms are themselves equivalences.}

\quiver{
\begin{tikzcd}
	A && X \\
	\\
	B && Y
	\arrow["\sim", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["\sim"', from=3-1, to=3-3]
\end{tikzcd}
}

%```agda
\agda{
is-Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                     â†’ Arrow-map f g â†’ Type _
is-Arrow-equiv {f = f} {g} (mk-amap top bot comm)
  = is-equiv top Ã— is-equiv bot


Arrowâ»Â¹â†Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                     â†’ (F : Arrow-map f g)
                     â†’ is-Arrow-equiv F
                     â†’ Arrow-map g f
Arrowâ»Â¹â†Arrow-equiv {f = f}{g} (mk-amap top bot comm) (teq , beq)
  = mk-amap top.bwd bot.bwd
    (beq â—‚eqv (   bot.Îµ â–¸ g â–¸ top
               ~âˆ™ (comm ~â»Â¹)
               ~âˆ™ (bot â—‚ f â—‚ top.Î· ~â»Â¹))
               â–¸eqv teq) where
  module top = is-equiv teq
  module bot = is-equiv beq

Arrowâ»Â¹-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                     â†’ (F : Arrow-map f g)
                     â†’ (eq : is-Arrow-equiv F)
                     â†’ is-Arrow-equiv (Arrowâ»Â¹â†Arrow-equiv F eq)
Arrowâ»Â¹-is-equiv F (teq , beq) = (is-equivâ»Â¹ teq  , is-equivâ»Â¹ beq)
}
%```
}

\subtree[stt-004S]{
\taxon{Theorem}
\title{Arrow equivalences preserve equivalences}

\p{If there is an [arrow equivalence](stt-004R) from #{A \xrightarrow{f} B} to
#{X \xrightarrow{g} Y}, then #{f} is an equivalence iff #{g} is.
}

\proof{This is a simple application of the [3-for-2](stt-003E) property of
equivalences.}

%```agda
\agda{
is-equivâ†Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ is-equiv f â†’ is-equiv g
is-equivâ†Arrow-equiv {F = mk-amap top bot comm} (teq , beq) feq
  = 3-for-2~' comm teq (is-equiv-âˆ˜ beq feq)

is-equivâ†Arrow-equivâ»Â¹ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ is-equiv g â†’ is-equiv f
is-equivâ†Arrow-equivâ»Â¹ {F = mk-amap top bot comm} (teq , beq) geq
  = 3-for-2~ (comm ~â»Â¹) beq (is-equiv-âˆ˜ geq teq)

topâ‡”bot-is-equivâ†Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       (F : Arrow-map f g)
                       â†’ is-Arrow-equiv F
                       â†’ is-equiv f â‡” is-equiv g
topâ‡”bot-is-equivâ†Arrow-equiv F eq = ( is-equivâ†Arrow-equiv {F = F} eq
                                    , is-equivâ†Arrow-equivâ»Â¹ {F = F} eq)
}
%```
}

\subtree[stt-0069]{
\title{Arrow equivalences preserve sections}
\taxon{Theorem}

\p{If there is an [arrow equivalence](stt-004R) from #{A \xrightarrow{f} B} to
#{X \xrightarrow{g} Y}, then sections of #{f} are equivalent to sections of #{g}.
}

% TODO(sam): Look into why unification isn't working so well for arrow
%            map

%```agda
\agda{
sectionâ†Arrow-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ section f â†’ section g
sectionâ†Arrow-equiv {f = f} {g} {F = F} eq (secf , p) .fst
  = top âˆ˜ secf âˆ˜ bot.bwd where
  open Arrow-map F
  module top = is-equiv (eq .fst)
  module bot = is-equiv (eq .snd)
sectionâ†Arrow-equiv {f = f} {g} {F} eq (secf , p) .snd
  =  H â–¸ top â–¸ secf â–¸ bot.bwd
  ~âˆ™ bot â—‚ f â—‚ top.Î· â–¸ secf â–¸ bot.bwd
  ~âˆ™ bot â—‚ p â–¸ bot.bwd
  ~âˆ™ bot.Îµ where
  open Arrow-map F
  module top = is-equiv (eq .fst)
  module bot = is-equiv (eq .snd)
  H : g ~ bot âˆ˜ f âˆ˜ top.bwd
  H = comm â–¸ top.bwd ~âˆ™ g â—‚ top.Îµ ~â»Â¹

sectionâ†Arrow-equivâ»Â¹ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {X : Type ğ“¦}
                       {Y : Type ğ“œ} {f : A â†’ B} {g : X â†’ Y}
                       {F : Arrow-map f g}
                       â†’ is-Arrow-equiv F
                       â†’ section g â†’ section f
sectionâ†Arrow-equivâ»Â¹ {f = f}{g}{F} EF sec = sectionâ†Arrow-equiv {f = g}{f}
                                               {Arrowâ»Â¹â†Arrow-equiv F EF}
                                               (Arrowâ»Â¹-is-equiv F EF) sec
}
%```
}

\subtree[stt-007M]{
\taxon{Theorem}
\title{Pre/post-composition of arrow equivalences}
\p{Precomposition preserves arrow equivalences}

%```agda
\agda{
precomp-Arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
    â†’ (Q : Type ğ“ )
    â†’ Arrow-map f g
    â†’ Arrow-map (precomp Q f) (precomp Q g)
precomp-Arrow-map Q F = mk-amap (top âˆ˜_) (bot âˆ˜_) (funextâ†’ âˆ˜ (comm â–¸_)) where
  open Arrow-map F


is-Arrow-equiv-precomp
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
      {Q : Type ğ“ }
    â†’ is-Arrow-equiv F
    â†’ is-Arrow-equiv (precomp-Arrow-map Q F)
is-Arrow-equiv-precomp F eq
  = (precomp-equiv (eq .fst) , precomp-equiv (eq .snd))

postcomp-Arrow-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
    â†’ (Q : Type ğ“ )
    â†’ Arrow-map f g
    â†’ Arrow-map (postcomp Q g) (postcomp Q f)
postcomp-Arrow-map Q F = mk-amap (_âˆ˜ bot) (_âˆ˜ top) (funextâ†’ âˆ˜ (_â—‚ (comm ~â»Â¹))) where
  open Arrow-map F

is-Arrow-equiv-postcomp
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“ } {A : Type ğ“¤} {B : Type ğ“¥}
      {X : Type ğ“¦} {Y : Type ğ“œ}
      {f : A â†’ B} {g : X â†’ Y}
      (F : Arrow-map f g)
      {Q : Type ğ“ }
    â†’ is-Arrow-equiv F
    â†’ is-Arrow-equiv (postcomp-Arrow-map Q F)
is-Arrow-equiv-postcomp F eq
  = (postcomp-equiv (eq .snd) , postcomp-equiv (eq .fst))
}
%```
}
