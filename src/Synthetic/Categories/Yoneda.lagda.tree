\title{Yoneda}
\date{2026-02-10}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Yoneda
        {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I) where

open Lattice I renaming (0l to i0; 1l to i1)
open import ufAxioms

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Categories.Covariant Î”Â¹ I I-distr
open import Synthetic.Categories.Comma Î”Â¹ I I-distr
open import Synthetic.Categories.Homotopies Î”Â¹ I I-distr
open import Synthetic.Categories.HomFamilies Î”Â¹ I I-distr
}
%```


%```agda
\agda{
is-initial : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ Type (ğ“˜ âŠ” ğ“¤)
is-initial a = âˆ€ b â†’ is-singleton (Hom _ a b)

ev-init-is-equiv
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {a : A}
    â†’ is-covariant P
    â†’ is-initial a
    â†’ is-equiv (ev {B = P} a)
ev-init-is-equiv {a = a} Pc ai = is-equivâ†qiso
  ( (Î» x' a' â†’ tr-cov-hom Pc (ai a' .centre) x')
  , (Î» x' â†’ funextâ†’ Î» a' â†’ ap fst (is-covariant-homâ†is-covariant _ Pc
                                    (ai a' .centre) (x' a) .central
                                    (x' a' , ap-hom-over x' (ai a' .centre))))
  , Î» a' â†’ ap fst (is-covariant-homâ†is-covariant _ Pc (ai a .centre) a' .central
             (a' ,  tr (Î» p â†’ Hom-over p a' a') (sym (ai a .central (idH a)))
                       (idH _))))

opaque
  rec-init
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {a : A}
      â†’ is-covariant P
      â†’ is-initial a
      â†’ P a â†’ âˆ€ x â†’ P x
  rec-init Pc ai p0 = is-equiv.bwd (ev-init-is-equiv Pc ai) p0

  rec-init-Î²
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : A â†’ Type ğ“¥} {a : A}
        (Pc : is-covariant P)
        (ai : is-initial a)
      â†’ (p : P a) â†’ rec-init Pc ai p a ï¼ p
  rec-init-Î² {a = a} Pc ai p = is-equiv.Îµ (ev-init-is-equiv Pc ai) p


YonedaJ
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a}
      (P : (x : A) â†’ Hom _ a x â†’ Type ğ“¥)
    â†’ is-covariant (uncurry P)
    â†’ (init : is-initial {A = Î£ A (Hom _ a)} (a , idH a))
    â†’ P a (idH a)
    â†’ âˆ€ x (f : Hom _ a x) â†’ P x f
YonedaJ P cov init p x f = rec-init {P = uncurry P} cov init p (x , f)

YonedaJ-id
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {a}
      (P : (x : A) â†’ Hom _ a x â†’ Type ğ“¥)
      (Pc : is-covariant (uncurry P))
      (init : is-initial {A = Î£ A (Hom _ a)} (a , idH a))
    â†’ (p0 : P a (idH a))
    â†’ YonedaJ P Pc init p0 a (idH a) ï¼ p0
YonedaJ-id P = rec-init-Î²

swap-cov-hom
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
  â†’ (f : Î”Â¹ â†’ A) â†’ (g : Hom _ (f i0) (f i1))
  â†’ HomP (Hom _ (f i0) âˆ˜ f) (idH (f i0)) g
  â†’ Hom-over {B = Hom _ (f i0)} g (idH (f i0)) (Î»hom f)
swap-cov-hom f g H .HomP.hom i .HomP.hom j = H .HomP.hom j .HomP.hom i
swap-cov-hom f g H .HomP.hom i .HomP.hom0 = happly (ap HomP.hom (H .HomP.hom0)) i
swap-cov-hom f g H .HomP.hom i .HomP.hom1 = happly (ap HomP.hom (H .HomP.hom1)) i
swap-cov-hom f g H .HomP.hom0
  = Hom-extâ†’ ((Î» a â†’ {!!}) , {!!})
swap-cov-hom f g H .HomP.hom1 = {!!}

-- .HomP.hom j = H .HomP.hom j .HomP.hom i
-- swap-cov-hom f g H .HomP.hom i .HomP.hom0 =  happly (ap HomP.hom (H .HomP.hom0 âˆ™ {!!})) i
-- swap-cov-hom f g H .HomP.hom i .HomP.hom1
--   =  ap (Î» x â†’ HomP.hom x i) (HomP.hom1 H)
-- swap-cov-hom f (mk-hom g refl p) H .HomP.hom0
--   = Hom-extâ†’ ((Î» j â†’ H .HomP.hom j .HomP.hom0) , (âˆ™-reflr _ âˆ™ {!!}) , {!!})
-- swap-cov-hom f g H .HomP.hom1
--   = {!!}


-- swap-cov-hom-is-equiv
--   : âˆ€ {ğ“¤} {A : Type ğ“¤} a {b}
--   â†’ (f : Hom A a b) â†’ (g : Hom _ a b)
--   â†’ is-equiv (swap-cov-hom a f g)
-- swap-cov-hom-is-equiv a f g = is-equivâ†qiso
--   (swap-cov-hom a g f
--   , (Î» aâ‚ â†’ {!Hom-extPâ†’!})
--   , {!!})

coslice-init
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) (Asimp : is-simplicial A) a
    â†’ is-initial {A = Î£ A (Hom _ a)} (a , idH a)
coslice-init As Asi a (b , f) = is-singleâ†equiv-to-single
  (Î£-ap-â‰ƒ (Î» g â†’ mkâ‰ƒ _ {!!}) âˆ™â‰ƒ Hom-Î£â‰ƒ eâ»Â¹)
  (is-covariant-homâ†is-covariant
    (Hom _ a)
    (hom-fam-is-covâ‡”is-precategory Asi .fst As a)
    f
    (idH a))

precat-idr : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) {x y}
             â†’ (f : Hom A x y) â†’ (f âˆ˜[ As ] idH _) ï¼ f
precat-idr As f = sym (unique-composite As f (idH _)
  f
  (refl~â–µ f))

precat-idl : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A) {x y}
              â†’ (f : Hom A x y) â†’ idH _ âˆ˜[ As ] f ï¼ f
precat-idl As {x} {y} = YonedaJ
  (Î» _ f â†’ idH _ âˆ˜[ As ] f ï¼ f)
  {!!}
  (coslice-init As {!!} x)
  (precat-idr As (idH x)) y

precat-assoc
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (As : is-segal A)
      {x y z w} (f : Hom _ z w) (g : Hom _ y z) (h : Hom _ x y)
    â†’ (f âˆ˜[ As ] g) âˆ˜[ As ] h ï¼ (f âˆ˜[ As ] (g âˆ˜[ As ] h))
precat-assoc As {z = z}{w} f g h = YonedaJ
  (Î» _ f â†’ (f âˆ˜[ As ] g) âˆ˜[ As ] h ï¼ f âˆ˜[ As ] (g âˆ˜[ As ] h))
  {!!}
  (coslice-init As {!!} z)
  (ap (_âˆ˜[ As ] h) (precat-idl As g) âˆ™ sym (precat-idl As (g âˆ˜[ As ] h))) w f
}
%```
