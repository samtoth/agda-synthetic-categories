\date{2025-04-18}
\title{The categrory of maps of types}
\taxon{module}
\meta{module}{\startverb core.Arrow \stopverb}
\import{stt-macros}

% ```agda
\agda{
module core.Arrow where

open import foundations.Prelude
open import ufAxioms
open import ergonomics.Marker
}
% ```


\subtree[stt-0038]{
\taxon{definition}
\title{Walking morphisms in #{\mathcal{S}\omega}}
\meta{defines}{\startverb ["Arrow", "Arrow.dom", "Arrow.cod", "Arrow.f", "mk-arr"] \stopverb}

% ```agda
\agda{
record Arrow : Typeω where
  constructor mk-arr
  field
    {𝓤 𝓥} : Level
    {dom} : Type 𝓤
    {cod} : Type 𝓥
    f : dom → cod
}
% ```
}

% ```agda
\agda{
module _ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} (f : A → B)
         {𝓦 𝓛} {C : Type 𝓦} {D : Type 𝓛} (f' : C → D) where
  record Arrow-map : Type (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛) where
    constructor mk-amap
    field
      top  : A → C
      bot  : B → D
      comm : bot ∘ f ~ f' ∘ top


  arrow-fibre :  (gs : Arrow-map) →
                 ∀ (b : B)
                 → fibre f b → fibre f' (gs .Arrow-map.bot b)
  arrow-fibre (mk-amap g g' hom) b (a , p) = (g a , sym (hom a) ∙ ap g' p)


  arrow-equiv-map : Arrow-map → Type (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛)
  arrow-equiv-map a = ∀ (b : B) → is-equiv (arrow-fibre a b)
                    
id-square : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B}
            → Arrow-map f f
id-square = mk-amap id id ~refl

module _ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B}
         {𝓤' 𝓥'} {A' : Type 𝓤'} {B' : Type 𝓥'} {f' : A' → B'}
        {𝓤'' 𝓥''} {A'' : Type 𝓤''} {B'' : Type 𝓥''} {f'' : A'' → B''} where


  paste-squares : Arrow-map f' f'' → Arrow-map f f'
                  → Arrow-map f f''
  paste-squares (mk-amap g' h' comm') (mk-amap g h comm)
    = mk-amap (g' ∘ g) (h' ∘ h) (  h' ∘ h ∘ f        ~⟨ h' ◂ comm ⟩
                                   h' ∘ f' ∘ g       ~⟨ comm' ▸ g ⟩
                                   f'' ∘ g' ∘ g      ~∎)

  paste-equiv-maps :  ∀ {a : Arrow-map f' f''} {b : Arrow-map f f'}
                     → (ae : arrow-equiv-map _ _ a) → (be : arrow-equiv-map _ _ b)
                     →  arrow-equiv-map _ _ (paste-squares a b)
  paste-equiv-maps {a} {b} ae be x
    = tr is-equiv (funext→ (I x))
       (is-equiv-∘ {f = arrow-fibre _ _ a (b .Arrow-map.bot x)} {g = arrow-fibre f f' b x}
         (ae (b .Arrow-map.bot x))
         (be x)) where
    module b = is-equiv (be x)
    module a = is-equiv (ae (b .Arrow-map.bot x))

    open Arrow-map

    II : (x : B) (fib : fibre f x) →
       sym (paste-squares a b .Arrow-map.comm (fib .fst)) ∙
         ap (paste-squares a b .Arrow-map.bot) (fib .snd)
        ＝
       (arrow-fibre f' f'' a (b .Arrow-map.bot x) ∘ arrow-fibre f f' b x)
         fib .snd
    II x (aa , p)
     = sym (paste-squares a b .comm aa) ∙ ap (paste-squares a b .bot) p
         ＝⟨⟩
       sym (ap (a .bot) (b .comm aa) ∙ ⌜ a .comm (b .top aa) ∙ refl ⌝) ∙ ap (a .bot ∘ b .bot) p
         ＝⟨ ap! (∙-reflr _) ⟩
       ⌜ sym (ap (a .bot) (b .comm aa) ∙ a .comm (b .top aa)) ⌝ ∙ ap (a .bot ∘ b .bot) p
         ＝⟨ ap! (∙-symsym (ap (a .bot) (b .comm aa)) _) ⟩
       (sym (a .comm (b .top aa)) ∙ sym (ap (a .bot) (b .comm aa))) ∙ ap (a .bot ∘ b .bot) p
         ＝⟨ ∙-assoc (sym (a .comm (b .top aa))) _ (ap (a .bot ∘ b .bot) p) ⟩
       sym (a .comm (b .top aa)) ∙ ⌜ sym (ap (a .bot) (b .comm aa)) ⌝ ∙ ap (a .bot ∘ b .bot) p
         ＝⟨ ap! (sym (ap-sym (a .bot) _)) ⟩
       sym (a .comm (b .top aa)) ∙ ap (a .bot) (sym (b .comm aa)) ∙ ⌜ ap (a .bot ∘ b .bot) p ⌝
         ＝⟨ ap! (ap-∘ _ _ _) ⟩
       sym (a .comm (b .top aa)) ∙ ⌜ ap (a .bot) (sym (b .comm aa)) ∙ ap (a .bot) (ap (b .bot) p) ⌝
         ＝⟨ ap! (sym (ap-∙ (a .bot) (sym (b .comm aa)) _)) ⟩ 
       sym (a .comm (b .top aa)) ∙ ap (a .bot) (sym (b .comm aa) ∙ ap (b .bot) p)
         ＝⟨⟩ 
       (arrow-fibre f' f'' a (b .bot x) ∘ arrow-fibre f f' b x) (aa , p) .snd ∎


    I : (x : B) →
      arrow-fibre _ _ a (b .Arrow-map.bot x) ∘ arrow-fibre _ _ b x
        ~
      arrow-fibre _ _ (paste-squares a b) x
    I x fib = fibre-path→ (refl , II x fib)
}
% ```
    

\subtree[stt-002Z]{
\taxon{theorem}
\title{Arrow morphisms are squares}
\meta{defines}{\startverb ["Cocone←Arrow-map", "Cone←Arrow-map"] \stopverb}

% ```agda
\agda{
Cocone←Arrow-map : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B}
                  {𝓦 𝓛} {C : Type 𝓦} {D : Type 𝓛} {f' : C → D}
                → Arrow-map f f' → Σ[ S ∶  Span 𝓤 𝓥 𝓦 ] Cocone S D
Cocone←Arrow-map {f = f} {f' = f'} (mk-amap g g'  comm)
  = (mk-span _ f g) , mk-cocone g' f' comm


Cone←Arrow-map : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} {f : A → B}
                  {𝓦 𝓛} {C : Type 𝓦} {D : Type 𝓛} {f' : C → D}
                 → Arrow-map f f' → Σ[ S ∶ Cospan 𝓛 𝓥 𝓦 ] Cone S A
Cone←Arrow-map {f = f} {f' = f'} (mk-amap top bot comm)
  = (mk-cospan _ bot f') , mk-cone f top comm
}
% ```
}

\subtree[stt-003C]{
\title{Pullback squares from fibre equivalence}
\taxon{theorem}
\p{A square is a pullback iff it is an equivalence on fibres}

\proof{
\p{Suppose we have a square:}

\quiver{
\begin{tikzcd}
	A && B \\
	\\
	C && D
	\arrow["{f'}", from=1-1, to=1-3]
	\arrow["{g'}"', from=1-1, to=3-1]
	\arrow["g", from=1-3, to=3-3]
	\arrow["f"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{such that the map #{\textrm{fib}_{g'}(a) \toeq \textrm{fib}_g(f'(a))} is
an equivalence. Then to verify it is a pullback, then we need
to show that the induced map #{A \to C \times_D B} is also an equivalence.}

\p{We can view both of these maps as living in a slice over #{C}, and a
by [[stt-003D]], a map in the slice is in equivalence iff if is an equivalence
on fibres.}

\quiver{
\begin{tikzcd}
	A && {C \times_D B} \\
	& C
	\arrow["{\textit{gap}}", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=2-2]
	\arrow["{\pi_1}", from=1-3, to=2-2]
\end{tikzcd}
}

\p{So we need to show #{\textrm{fib}_{f}(c) \to \textrm{fib}_{\pi_1}(c)} is
an equivalence. The fibre of the projection is equivalent to the fibre of
#{g} at #{f(c)}, and so by the [3-for-2](foundations.3for2) property of equivalences we
have that the square is a pullback.}

}
}
