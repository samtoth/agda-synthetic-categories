\date{2025-07-30}
\title{Type sequences}
\taxon{module}
\meta{module}{Foundations.TypeSequences}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Foundations.TypeSequence where

open import Foundations.Universes
open import Foundations.Sigma
open import Foundations.Nat
open import Foundations.Functions
open import Foundations.Homotopy
open import Foundations.QuasiIsomorphism
open import Foundations.CoherentIsomorphism
open import Foundations.Identity
open import Foundations.Embedding
open import Foundations.Singleton
open import Foundations.EquivSingleton
open import Foundations.IdentitySystem
}
%```

\subtree[stt-0085]{
\title{Type sequences}
\taxon{definition}

\p{An increasing type sequence is a diagram of the form:}

\quiver{
\begin{tikzcd}
	{A_0} & {A_1} & {A_n} & {A_{n+1}} & {...}
	\arrow["{f_0}"', from=1-1, to=1-2]
	\arrow[dashed, from=1-2, to=1-3]
	\arrow["{f_n}"', from=1-3, to=1-4]
	\arrow[dashed, from=1-4, to=1-5]
\end{tikzcd}
}

\p{Concretely, for each natural number #{n} we have a type #{A_n}
and a map #{f_n : A_n \to A_{n+1}}.
}

%```agda
\agda{
record Incr-seq 𝓤 : Type (lsuc 𝓤) where
  constructor mk-incr-seq
  field
    Point : ℕ → Type 𝓤
    incr  : ∀ {n} → Point n → Point (suc n)

  incrΣ : Σ ℕ Point → Σ ℕ Point
  incrΣ (n , a) = (suc n , incr a)

  incrℕ : ∀ m → Point 0 → Point m
  incrℕ zero = id
  incrℕ (suc m) = incr ∘ incrℕ m

  incr-+ : ∀ {n} m → Point n → Point (n + m)
  incr-+ {n} zero = id
  incr-+ {n} (suc m) = incr ∘ incr-+ m

shift-seq : ∀ {𝓤} → Incr-seq 𝓤 → Incr-seq 𝓤
shift-seq (mk-incr-seq Point incr)
  = mk-incr-seq (Point ∘ suc) (λ {n} → incr {suc n})
}
%```

\p{This trivially dualizes to decreasing sequences}

%```agda
\agda{
record Decr-seq 𝓤 : Type (lsuc 𝓤) where
  constructor mk-decr-seq
  field
    Point : ℕ → Type 𝓤
    decr  : ∀ {n} → Point (suc n) → Point n
}
%```
}


\subtree[stt-0086]{
\title{Maps of sequences}
\taxon{definition}

\p{A map of sequences #{A \to B} is a map of each type
#{A_n \to B_n}, such that all the squares commute.}

%```agda
\agda{
record Incr-seq-map {𝓤 𝓥}
         (A : Incr-seq 𝓤) (B : Incr-seq 𝓥) : Type (𝓤 ⊔ 𝓥) where
  constructor mk-iseq-map
  module A = Incr-seq A
  module B = Incr-seq B
  field
    map  : ∀ {n} → A.Point n → B.Point n
    comm : ∀ {n} → B.incr ∘ map {n} ~ map ∘ A.incr

record Decr-seq-map {𝓤 𝓥}
         (A : Decr-seq 𝓤) (B : Decr-seq 𝓥) : Type (𝓤 ⊔ 𝓥) where
  constructor mk-dseq-map
  module A = Decr-seq A
  module B = Decr-seq B
  field
    map  : ∀ {n} → A.Point n → B.Point n
    comm : ∀ {n} → B.decr ∘ map {suc n} ~ map ∘ A.decr
}
%```
}

\subtree[stt-0090]{
\title{Composing sequence maps}
\taxon{construction}

\p{We compose sequence maps in the obvious way by composing their
components and pasting together squares.}

%```agda
\agda{
compose-iseq-map
  : ∀ {𝓤 𝓥 𝓦} {S : Incr-seq 𝓤} {S' : Incr-seq 𝓥}
      {S'' : Incr-seq 𝓦}
    → Incr-seq-map S' S'' → Incr-seq-map S S'
    → Incr-seq-map S S''
compose-iseq-map F G = map where
  module F = Incr-seq-map F
  module G = Incr-seq-map G

  map : Incr-seq-map _ _
  map .Incr-seq-map.map = F.map ∘ G.map
  map .Incr-seq-map.comm = F.comm ▸ G.map ~∙ F.map ◂ G.comm

id-iseq-map
  : ∀ {𝓤} {S : Incr-seq 𝓤} → Incr-seq-map S S
id-iseq-map .Incr-seq-map.map = id
id-iseq-map .Incr-seq-map.comm = ~refl
}
%```
}

\subtree[stt-0091]{
\title{Homotopies of sequential cocone maps}
\taxon{definition}

\p{Given a pair of sequence maps #{f, g : A \to B}, we define a homotopy
#{f \sim g} to be a homotopy at each component #{f_n \sim g_n} together
with a coherence condition between the squares of each maps.}

%```agda
\agda{
iseq-map~ : ∀ {𝓤 𝓥} {S : Incr-seq 𝓤} {S' : Incr-seq 𝓥}
              (F G : Incr-seq-map S S')
            → Type (𝓤 ⊔ 𝓥)
iseq-map~ F G = Σ[ α ∶ (∀ {n} → map F {n} ~ map G)]
                  (∀ {n} →  comm F ~∙ α ▸ A.incr G
                       ~ (B.incr F ◂ α) ~∙ comm G {n})
  where open Incr-seq-map
}
%```
}


\subtree[stt-008X]{
\title{Equivalences of sequences}
\taxon{definition}
\date{2025-08-14}

\p{A sequence map is an equivalence of sequences when each component
is an equivalence.}

%```agda
\agda{
is-iseq-equiv : ∀ {𝓤 𝓥} {A : Incr-seq 𝓤} {B : Incr-seq 𝓥}
                  (F : Incr-seq-map A B) → Type (𝓤 ⊔ 𝓥)
is-iseq-equiv F = ∀ n → is-equiv (F .Incr-seq-map.map {n})


seq-map-inv←equiv : ∀ {𝓤 𝓥} {A : Incr-seq 𝓤} {B : Incr-seq 𝓥}
                      {F : Incr-seq-map A B} (Feq : is-iseq-equiv F)
                    → Incr-seq-map B A
seq-map-inv←equiv {A = A}{B}{F} Feq = imap where
  open Incr-seq-map
  module F {n} = is-equiv (Feq n)
  imap : Incr-seq-map B A
  imap .map = F.bwd
  imap .comm =   (F.η ~⁻¹) ▸ Incr-seq.incr A ▸ F.bwd
               ~∙ F.bwd ◂ (  (comm F ~⁻¹) ▸ F.bwd
                          ~∙ Incr-seq.incr B ◂ F.ε)
}
%```
}

\subtree[stt-0087]{
\title{Constant sequences}
\taxon{definition}

\p{We can define the constant sequence at a type. We write #{\Delta_A}
for the constant sequence at #{A}.}

%```agda
\agda{
const-incr-seq : ∀ {𝓤} → Type 𝓤 → Incr-seq 𝓤
const-incr-seq A = mk-incr-seq (λ _ → A) id

const-decr-seq : ∀ {𝓤} → Type 𝓤 → Decr-seq 𝓤
const-decr-seq A = mk-decr-seq (λ _ → A) id
}
%```
}

\subtree[stt-0088]{
\title{(Co)cones over a sequence}
\taxon{definition}

%```agda
\agda{
record Cone-seq {𝓤 𝓥} (S : Decr-seq 𝓤) (Apex : Type 𝓥)
         : Type (𝓤 ⊔ 𝓥) where
  constructor mk-cone-seq
  open Decr-seq S
  field
    π : ∀ {n} → Apex → Point n
    comm : ∀ {n} → decr ∘ π ~ π {n}

record Cocone-seq {𝓤 𝓥} (S : Incr-seq 𝓤) (Apex : Type 𝓥)
         : Type (𝓤 ⊔ 𝓥) where
  constructor mk-cocone-seq
  open Incr-seq S

  field
    ι    : ∀ {n} → Point n → Apex
    comm : ∀ {n} → ι ~ ι ∘ incr {n}
}
%```
}

\subtree[stt-0089]{
\title{(co)cones as sequence maps}
\taxon{theorem}

\p{A cone over a decreasing sequence #{B} at apex #{A} is a map
#{\Delta_A \to B}}

%```agda
\agda{
seq-map←cone : ∀ {𝓤 𝓥} {S : Decr-seq 𝓤} {Apex : Type 𝓥}
               → Cone-seq S Apex
               → Decr-seq-map (const-decr-seq Apex) S
seq-map←cone (mk-cone-seq π comm) = mk-dseq-map π comm

seq-map≃cone : ∀ {𝓤 𝓥} {S : Decr-seq 𝓤} {Apex : Type 𝓥}
               → Cone-seq S Apex
               ≃ Decr-seq-map (const-decr-seq Apex) S
seq-map≃cone = mk≃ _ (is-equiv←qiso qiso) where
  qiso : quasi-iso seq-map←cone
  qiso .fst (mk-dseq-map map comm) = mk-cone-seq map comm
  qiso .snd .fst (mk-cone-seq π comm) = refl
  qiso .snd .snd (mk-dseq-map map comm) = refl

seq-map←cocone : ∀ {𝓤 𝓥} {S : Incr-seq 𝓤} {Apex : Type 𝓥}
               → Cocone-seq S Apex
               → Incr-seq-map S (const-incr-seq Apex)
seq-map←cocone (mk-cocone-seq ι comm) = mk-iseq-map ι comm

seq-map≃cocone : ∀ {𝓤 𝓥} {S : Incr-seq 𝓤} {Apex : Type 𝓥}
               → Cocone-seq S Apex
               ≃ Incr-seq-map S (const-incr-seq Apex)
seq-map≃cocone = mk≃ _ (is-equiv←qiso qiso) where
  qiso : quasi-iso seq-map←cocone
  qiso .fst (mk-iseq-map map comm) = mk-cocone-seq map comm
  qiso .snd .fst (mk-cocone-seq π comm) = refl
  qiso .snd .snd (mk-iseq-map map comm) = refl
}
%```
}
