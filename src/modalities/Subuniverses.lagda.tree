\taxon{module}
\title{(Reflective) Subuniverses}
\author{samueltoth}
\date{2025-05-09}
\meta{module}{\startverb modalities.Subuniverses \stopverb}
\import{stt-macros}

% ```agda
\agda{
module modalities.Subuniverses where

open import foundations.Prelude
open import ufAxioms
open import modalities.HigherModality
open import core.Postwhisker
open import core.PiSection
}
% ```


\subtree[stt-003Z]{
\taxon{definition}
\title{Subuniverse}

\p{A subuniverse is a subtype of some universe}

% ```agda
\agda{
SubU : âˆ€ (ğ“¤ ğ“¥ : Level) â†’ Type (lsuc (ğ“¤ âŠ” ğ“¥))
SubU ğ“¤ ğ“¥ = Subtype (Type ğ“¤) ğ“¥
}
% ```
}

\subtree[stt-0040]{
\title{Reflector}
\taxon{definition}
\meta{defines}{\startverb ["Reflector", "Reflector.â—‹", "Reflector.â—‹âˆˆS",
                           "Reflector.Î·-â—‹", "Reflector.reflects", "mk-rfltor"] \stopverb}
\p{Given a subuniverse #{S} of #{\UU}, we say that a type #{A : \UU} has a reflection
if there is a type #{â—‹ A} in #{S} and a map #{\eta_â—‹ : A \to \circ A} such that any map from #{A}
into a type in #{S} factors through #{\eta}. This final condition can be stated by
asking postcomposition by #{\eta} to be an equivalence for all types in #{S}.}

% ```agda
\agda{
record is-reflector
        {ğ“¤ ğ“¥} (S : SubU ğ“¤ ğ“¥)
        (A : Type ğ“¤) (â—‹A : Type ğ“¤)
        (Î· : A â†’ â—‹A) : Type (lsuc ğ“¤ âŠ” ğ“¥) where
  constructor mk-is-rfltor
  field
    â—‹âˆˆS : â—‹A âˆˆ S
    reflects : âˆ€ {C : Type ğ“¤} â†’ C âˆˆ S â†’ is-equiv (postcomp C Î·)

  â—‹-elim : âˆ€ {C : Type ğ“¤} â†’ C âˆˆ S â†’ (A â†’ C) â†’ (â—‹A â†’ C)
  â—‹-elim cs = is-equiv.bwd (reflects cs)

  â—‹-elim-Î² : âˆ€ {C : Type ğ“¤} (p : C âˆˆ S) (f : A â†’ C)
             â†’ â—‹-elim p f âˆ˜ Î· ~ f
  â—‹-elim-Î² p f a = happly (is-equiv.Îµ (reflects p) f) a

  module âˆˆSâ–¸Î· {C : Type ğ“¤} {g h} (CâˆˆS : C âˆˆ S)
    = is-equiv (postwhisker-is-equivâ†ap-compose {A = A} {g = g}{h}
                         (is-embeddingâ†is-equiv (reflects CâˆˆS)))

record Reflector {ğ“¤ ğ“¥} (S : SubU ğ“¤ ğ“¥)
              (A : Type ğ“¤) : Type (lsuc ğ“¤ âŠ” ğ“¥) where
  constructor mk-rfltor
  field
    â—‹ : Type ğ“¤
    Î· : A â†’ â—‹
    has-is-reflector : is-reflector S A â—‹ Î·

  open is-reflector has-is-reflector public
}
% ```
}

\subtree[stt-0042]{
\title{A subuniverse contains #{\bigcirc} modal types}
\taxon{theorem}

\p{In [[modalities.HigherModality]], we start by defining the reflectors, and say that a type
is #{\bigcirc}-modal if the reflection map is an equivalence. In this setting, this definition
is a theorem.}

% ```agda
\agda{
in-subUâ†Î·-is-equiv : âˆ€ {ğ“¤ ğ“¥} {S : SubU ğ“¤ ğ“¥}
                       {A : Type ğ“¤}
                     â†’ (RA : Reflector S A)
                     â†’ is-equiv (RA .Reflector.Î·)
                     â†’ A âˆˆ S
in-subUâ†Î·-is-equiv {S = S} RA eq
  = tr (_âˆˆ S)
       (ua (mkâ‰ƒ Î· eq eâ»Â¹))
       â—‹âˆˆS where open Reflector RA
}
% ```

\p{We can also show that a type is in #{S} iff #{\eta_\circ} has a retract}

% ```agda
\agda{
Î·-has-retractâ†in-subU : âˆ€ {ğ“¤ ğ“¥} {S : SubU ğ“¤ ğ“¥}
                       {A : Type ğ“¤}
                       (RA : Reflector S A)
                       â†’ A âˆˆ S
                       â†’ retract (RA .Reflector.Î·)
Î·-has-retractâ†in-subU RA aâˆˆS = (bwd id , happly (Îµ id)) where
  open Reflector RA
  open is-equiv (reflects aâˆˆS)

Î·-is-equivâ†retract : âˆ€ {ğ“¤ ğ“¥} {S : SubU ğ“¤ ğ“¥}
                         {A : Type ğ“¤}
                         (RA : Reflector S A)
                       â†’ retract (RA .Reflector.Î·)
                       â†’ is-equiv (RA .Reflector.Î·)
Î·-is-equivâ†retract RA (f , ret)
  = is-equivâ†qiso
      ( f
      , ret
      , âˆˆSâ–¸Î·.bwd â—‹âˆˆS (Î· â—‚ ret)) where open Reflector RA

in-subUâ†Î·-retract : âˆ€ {ğ“¤ ğ“¥} {S : SubU ğ“¤ ğ“¥}
                       {A : Type ğ“¤}
                       (RA : Reflector S A)
                       â†’ retract (RA .Reflector.Î·)
                       â†’ A âˆˆ S
in-subUâ†Î·-retract RA Ï = in-subUâ†Î·-is-equiv RA (Î·-is-equivâ†retract RA Ï)
}
% ```
}


\subtree[stt-0041]{
\title{Reflective subuniverse}
\taxon{definition}
\meta{defines}{\startverb ["Reflective", "mk-reflective", "is-reflective.has-reflectors"] \stopverb}
\p{A subuniverse is reflective if it has all reflectors.}

% ```agda
\agda{
record Reflective {ğ“¤ ğ“¥} (S : SubU ğ“¤ ğ“¥) : Type (lsuc ğ“¤ âŠ” ğ“¥) where
  constructor mk-reflective
  field
    â—‹ : Type ğ“¤ â†’ Type ğ“¤
    Î· : âˆ€ {A} â†’ A â†’ â—‹ A
    has-is-reflector : âˆ€ {A} â†’ is-reflector S A (â—‹ A) Î·

  module R {A} = is-reflector (has-is-reflector {A})
  open R public

  module â–¸Î· {A} {B} {g h}
    = is-equiv (postwhisker-is-equivâ†ap-compose {g = g}{h}
                         (is-embeddingâ†is-equiv (reflects {A = B} (â—‹âˆˆS {A}))))

  reflector : âˆ€ (A : Type ğ“¤) â†’ Reflector S A
  reflector A = mk-rfltor (â—‹ A) Î· has-is-reflector

}
% ```
}

\subtree[stt-006L]{
\date{2025-06-25}
\title{Modal types are closed under Identity}
\taxon{lemma}

%```agda
\agda{

Î·ï¼-retract : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
                {x y : A}
                {S : SubU ğ“¤ ğ“¥}
                (RS : Reflective S)
              â†’ A âˆˆ S
              â†’ retract (Reflective.Î· RS {x ï¼ y})
Î·ï¼-retract RS a = (âˆˆSâ–¸Î·.bwd a id , happly (âˆˆSâ–¸Î·.Îµ a id)) where open Reflective RS

is-modal-ï¼ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}
                {x y : A}
                {S : SubU ğ“¤ ğ“¥}
                (RS : Reflective S)
              â†’ A âˆˆ S
              â†’ (x ï¼ y) âˆˆ S
is-modal-ï¼ {A = A}{x}{y} RS a
  = in-subUâ†Î·-retract (reflector (x ï¼ y)) (Î·ï¼-retract RS a) where
  open Reflective RS
}
%```
}

\subtree[stt-004U]{
\date{2025-06-04}
\taxon{definition}
\title{Sigma closed reflective subuniverses}

\p{A reflective subuniverse \SS is said to be sigma closed when given
   #{A : \UU} and #{B : A \to \UU} such that #{A \in \SS} and #{B(a) \in \SS}
   for all #{a : A}, the type #{\Sigma_{(a : A)}B(a)} is in \SS.}

%```agda
\agda{
is-Î£-closed : âˆ€ {ğ“¤ ğ“¥} (S : SubU ğ“¤ ğ“¥) â†’ Type _
is-Î£-closed {ğ“¤} S = âˆ€ {A : Type ğ“¤} {B : A â†’ Type ğ“¤}
                       â†’ A âˆˆ S â†’ (âˆ€ a â†’ B a âˆˆ S)
                       â†’ (Î£[ a âˆ¶ A ] B a) âˆˆ S
}
%```
}



\subtree[stt-006F]{
\taxon{theorem}
\date{2025-06-25}
\title{Sigma closed reflective subuniverses are higher modalities}

\p{Every #{\Sigma}-closed reflective subuniverse
#{(S, \bigcirc, \eta)} gives rise to a higher modality}

\proof{
\p{We have the data of the modal operator and unit, as well as the fact that
modal types are closed under Identity, so we just need to show that this data
satisfies the modal induction principal for [higher modalities](stt-000G).}

\p{Let #{P : \bigcirc A \to \UU} and #{f : \Pi_{(x : A)} \bigcirc P(\eta(x))},
then to define a map #{\Pi_{(x : \bigcirc A)} \bigcirc P(x)}, [it suffices](stt-006J)
to define a section of #{\pi : \Sigma_{(x : \bigcirc A)} \bigcirc P(x) \to \bigcirc
A}.}

\p{Because #{S} is closed under #{\Sigma} types, we can use the universal property
of the reflector at #{A} to define a map
#{\bar{f} : \bigcirc A \to \Sigma_{(x : \bigcirc A)} \bigcirc P(x)} just by it's action
on #{\eta(x)} for #{x : A}. This map, is given by #{\eta(x) \mapsto (\eta(x), f(x))}.}

\p{To show that #{\bar{f}} is indeed a section, we first note that
the universal property of the reflector gives us #{\pi \bar{f} \eta \sim \eta}.
Then because postcomposition by #{\eta} at a modal type is an equivalence,
[so is postwhiskering](stt-006I) by #{\eta} (assuming funext), thus we can apply the
inverse map to get a homotopy #{\pi \bar{f} \sim \id}.}
}

%```agda
\agda{
HigherModalityâ†Î£-ref-SubU
  : âˆ€ {ğ“¤ ğ“¥} {S : SubU ğ“¤ ğ“¥} (Sref : Reflective S)
      (SÎ£ : is-Î£-closed S)
    â†’ HigherModality ğ“¤
HigherModalityâ†Î£-ref-SubU {ğ“¤} {S = S} rfl cls
  = mod where
  open HigherModality
  module S = Reflective rfl

  f'' : âˆ€ {A : Type ğ“¤}
          (P : S.â—‹ A â†’ Type ğ“¤)
        â†’ (Î  A (S.â—‹ âˆ˜ P âˆ˜ S.Î·))
        â†’ A â†’ Î£ (S.â—‹ A) (S.â—‹ âˆ˜ P)
  f'' P f a = (S.Î· a , f a)

  f' : âˆ€ {A : Type ğ“¤}
          (P : S.â—‹ A â†’ Type ğ“¤)
        â†’ (Î  A (S.â—‹ âˆ˜ P âˆ˜ S.Î·))
        â†’ S.â—‹ A â†’ Î£ (S.â—‹ A) (S.â—‹ âˆ˜ P)
  f' P f = S.â—‹-elim (cls S.â—‹âˆˆS Î» _ â†’ S.â—‹âˆˆS)
                 (f'' P f)
  secÎ· : âˆ€ {A : Type ğ“¤}
          {P : S.â—‹ A â†’ Type ğ“¤}
          {f : Î  A (S.â—‹ âˆ˜ P âˆ˜ S.Î·)}
        â†’ fst âˆ˜ f' P f âˆ˜ S.Î· ~ S.Î·
  secÎ· = fst â—‚ S.â—‹-elim-Î² _ _

  sec : âˆ€ {A : Type ğ“¤}
          (P : S.â—‹ A â†’ Type ğ“¤)
        â†’ (Î  A (S.â—‹ âˆ˜ P âˆ˜ S.Î·))
        â†’ section (fst {B = S.â—‹ âˆ˜ P})
  sec {A} P f = (f' P f , S.â–¸Î·.bwd secÎ·)

  mod : HigherModality ğ“¤
  mod .â—‹_ A = S.â—‹ A
  mod .â—‹-Î· = S.Î·
  mod .â—‹-ind P f = Î â†section (sec P f)
  mod .â—‹-Î² P f a
    = tr (S.â—‹ âˆ˜ P) (S.â–¸Î·.bwd secÎ· (S.Î· a)) (snd (f' P f (S.Î· a)))
         ï¼âŸ¨ ap (Î» p â†’ tr (S.â—‹ âˆ˜ P) p (snd (f' P f (S.Î· a)))) (happly (S.â–¸Î·.Îµ secÎ·) a) âŸ©
      tr (S.â—‹ âˆ˜ P) (ap fst (S.â—‹-elim-Î² _ (f'' P f) a)) (snd (f' P f (S.Î· a)))
         ï¼âŸ¨ ap (Î» p â†’ coe p (snd (f' P f (S.Î· a)))) (sym (ap-âˆ˜ (S.â—‹ âˆ˜ P) fst _)) âŸ©
      tr (S.â—‹ âˆ˜ P âˆ˜ fst) (S.â—‹-elim-Î² _ (f'' P f) a) (snd (f' P f (S.Î· a)))
         ï¼âŸ¨ apáµˆ snd (S.â—‹-elim-Î² _ (f'' P f) a) âŸ©
      snd (f'' P f a)
         ï¼âŸ¨âŸ©
      f a âˆ
  mod .ï¼-â—‹-is-â—‹-modal = Î·-is-equivâ†retract
                          (S.reflector _)
                          (Î·ï¼-retract rfl S.â—‹âˆˆS)
}
%```
}
