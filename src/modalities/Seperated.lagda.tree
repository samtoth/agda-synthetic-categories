\date{2025-06-14}
\title{Seperated types}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb modalities.Seperated \stopverb}
\import{stt-macros}

%```agda
\agda{
module modalities.Seperated  where

open import foundations.Prelude
open import ufAxioms
open import modalities.Subuniverses
open import modalities.GlobalSubuniverses
open import modalities.instances.Localisation
open import core.Suspensions
open import core.Arrow
open import core.ArrowEquiv
open import ergonomics.Universal
open import ergonomics.PushoutUniv
open import axioms.FreeAlgInj
}
%```


\subtree[stt-007E]{
\title{Seperated types for a subuniverse}
\taxon{definition}

\p{A type is seperated if it's identity types are modal. This forms a
[(global)](stt-007A) [subuniverse](stt-003Z).}


%```agda
\agda{
is-seperated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦) â†’ Type ğ“¤ â†’ Type (ğ“¤ âŠ” ğ“¦)
is-seperated S A = âˆ€ (x y : A) â†’ (x ï¼ y) âˆˆ S

seperated-SubU : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦) â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“¦)
seperated-SubU S .Subtype.family = is-seperated S
seperated-SubU S .Subtype.has-is-subtype A
  = is-prop-Î  Î» x â†’ is-prop-Î  Î» y â†’ Subtype.has-is-subtype S (x ï¼ y)

equiv-seperated : âˆ€ {Î±} (S : GSU Î±) {ğ“¤ ğ“¥} {A : Type ğ“¤}
                    {B : Type ğ“¥} (e : A â‰ƒ B)
                  â†’ is-seperated (SubUâ†global S) A
                  â†’ is-seperated (SubUâ†global S) B
equiv-seperated S e sep x y
  = GSU.S-equiv S
       (embeddingâ‰ƒ (is-embeddingâ†is-equiv
                     (is-equivâ»Â¹ has-is-eqv)) x y)
       (sep (bwd x) (bwd y))
  where
    open _â‰ƒ_ e

seperated-GSU : âˆ€ {Î±} (S : GSU Î±) â†’ GSU  (Î» ğ“¤ â†’ ğ“¤ âŠ” Î± ğ“¤)
seperated-GSU S .GSU.S = seperated-SubU (SubUâ†global S)
seperated-GSU S .GSU.S-equiv = equiv-seperated S
}
%```
}


\subtree[stt-007I]{
\title{Local types are seperated}
\taxon{theorem}

\p{Given a reflective subuniverse #{S},
the #{S}-modal types are also #{S}-seperated.}

\todo{
Most of the seperated stuff
requires the modified join construction which we don't have yet.
}

%```agda
\agda{
-- is-seperatedâ†is-modal
--   : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
--       {A : Type ğ“¤}
--     â†’ A âˆˆ S
--     â†’ A âˆˆ seperated-SubU S
-- is-seperatedâ†is-modal S as x y
--   = {!!}
}
%```
}

\subtree[stt-007F]{
\title{Seperated types and localisations}
\taxon{theorem}

\p{Given a family of maps #{f_i : A_i \to B_i}, the seperated
types with respect to localisation at #{f} are the #{\Sigma(f)}
local types. (Where #{\Sigma(-)} is the  functorial action of
the suspension)}


\proof{
\p{We can construct the following commutative diagram:}
\quiver{
\begin{tikzcd}
	{\Sigma_{(x,y : X)} (x = y) ^ {B_i}} && {\Sigma_{(x,y:X)}(x=y)^{A_i}} \\
	\\
	{X^{\Sigma B_i}} && {X^{\Sigma A_i}}
	\arrow["{\textrm{total}((x=y)^f)}", from=1-1, to=1-3]
	\arrow["\sim"', from=1-1, to=3-1]
	\arrow["\sim", from=1-3, to=3-3]
	\arrow["{X^{\Sigma f}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{It then follows that postcomposition by #{f} at #{x = y} is an equivalence
iff postcomposition by #{\Sigma(f)} is at #{X}.}
}

%```agda
\agda{
module _ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
         (f : (i : I) â†’ A i â†’ B i) where

  private
    Î£f : (i : I) â†’ Susp (A i) â†’ Susp (B i)
    Î£f i = Susp-map (f i)

  is-seperatedâ†is-Î£-local
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
    â†’ is-local Î£f X
    â†’ is-seperated (Local-SubU f ğ“¤) X
  is-seperatedâ†is-Î£-local {X = X} loc x y i
    = fw-eqv (x , y) where
    map : âˆ€ (ab : X Ã— X)
        â†’ (B i â†’ ab .fst ï¼ ab .snd)
        â†’ (A i â†’ ab .fst ï¼ ab .snd)
    map (x , y) = postcomp (x ï¼ y) (f i)

    eqv : (Î£[ ab âˆ¶ (X Ã— X)] (B i â†’ ab .fst ï¼ ab .snd))
        â‰ƒ (Î£[ ab âˆ¶ (X Ã— X)] (A i â†’ ab .fst ï¼ ab .snd))
    eqv =  Î£-assoc
        âˆ™â‰ƒ (Susp-UPâ‰ƒ eâ»Â¹)
        âˆ™â‰ƒ mkâ‰ƒ _ (loc i)
        âˆ™â‰ƒ Susp-UPâ‰ƒ
        âˆ™â‰ƒ (Î£-assoc eâ»Â¹)

    H : (_â‰ƒ_.fwd eqv) ~ total-map map
    H ((x , y) , K)
      = Î£-pathâ†’
        ( refl
        , funextâ†’ (Î» a
            â†’   ap-âˆ˜ (pushout-rec (mk-cocone (Î» _ â†’ x) (Î» _ â†’ y) K))
                     (pushout-rec (mk-cocone Î¹â‚ Î¹â‚‚ (glue âˆ˜ f i)))
                     (glue a)
              âˆ™ ap (ap _) (pushout-rec-apÎ² a)
              âˆ™ pushout-rec-apÎ² (f i a)))

    fw-eqv : is-fibrewise-equiv map
    fw-eqv = is-fibrewise-equivâ†is-total-equiv
              (homotopy-is-equiv H (eqv ._â‰ƒ_.has-is-eqv))

}
%```
}

\subtree[stt-007H]{
\title{Iterated seperation}
\taxon{definition}

\p{Because the seperated types give a (reflective) subuniverse for
each (reflective) subuniverse, we can consider the result of
repeatedly applying seperation.
}

%```agda
\agda{
is-n-seperated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                 â†’ (n : â„•) â†’ Type ğ“¤
                 â†’ Type (ğ“¤ âŠ” ğ“¦)
is-n-seperated {ğ“¤} S zero A = ULift ğ“¤ (A âˆˆ S)
is-n-seperated S (suc n) A
  = âˆ€ (x y : A) â†’ is-n-seperated S n (x ï¼ y)

is-n-seperated-is-prop
  : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
      (n : â„•) (A : Type ğ“¤)
    â†’ is-prop (is-n-seperated S n A)
is-n-seperated-is-prop S zero A
  = is-prop-ULift (S .Subtype.has-is-subtype A)
is-n-seperated-is-prop S (suc n) A
  = is-prop-Î  Î»
     a â†’ is-prop-Î  Î»
       b â†’ is-n-seperated-is-prop S n (a ï¼ b)

n-seperated-SubU : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                   â†’ (n : â„•) â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“¦)
n-seperated-SubU S n .Subtype.family = is-n-seperated S n
n-seperated-SubU S n .Subtype.has-is-subtype
  = is-n-seperated-is-prop S n

equiv-n-seperated
  : âˆ€ {ğ“¤ ğ“¥ Î±} (S : GSU Î±)
      (n : â„•)
      {A : Type ğ“¤} {B : Type ğ“¥}
    â†’ A â‰ƒ B
    â†’ is-n-seperated (SubUâ†global S) n A
    â†’ is-n-seperated (SubUâ†global S) n B
equiv-n-seperated S zero eq (mk-lift sep)
  = mk-lift (S .GSU.S-equiv eq sep)
equiv-n-seperated S (suc n) eq sep b b'
  = equiv-n-seperated S n
      (mkâ‰ƒ _ (is-embeddingâ†is-equiv
                 (is-equivâ»Â¹ has-is-eqv)) eâ»Â¹)
      (sep (bwd b) (bwd b')) where open _â‰ƒ_ eq


n-seperated-GSU : âˆ€ {Î±} (S : GSU Î±)
                  â†’ (n : â„•) â†’ GSU (Î» ğ“¤ â†’ ğ“¤ âŠ” Î± ğ“¤)
n-seperated-GSU S n .GSU.S = n-seperated-SubU (SubUâ†global S) n
n-seperated-GSU S n .GSU.S-equiv = equiv-n-seperated S n
}
%```
}
