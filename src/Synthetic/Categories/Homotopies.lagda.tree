\date{2025-12-12}
\title{Homotopies of morphisms}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Homotopies
  {@â™­ ğ“˜} (@â™­ Î”Â¹ : Type ğ“˜) (@â™­ I : Lattice Î”Â¹) (@â™­ I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.Flat.Flat renaming (Îµ to Îµâ™­)

open import Core.Orthogonal
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Lifts
open import Core.FlatteningPushouts
open import Core.PiSection
open import Core.CocartesianSquare
open import Core.Postwhisker

open import Ergonomics.Notations.Orthogonality
open import Ergonomics.Extensionality
open Core.Orthogonal.notation

open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Tiny Î”Â¹
open import Synthetic.Categories.Precategories Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
}
%```


\subtree[stt-00CH]{
\title{Homotopies of synthetic morphisms}
\taxon{Definition}

%```agda
\agda{
_~â–µ_ : âˆ€ {ğ“¤} {A : Type ğ“¤} {a b : A} â†’ (f g : Hom A a b) â†’ Type (ğ“˜ âŠ” ğ“¤)
f ~â–µ g = Hom2 f (idH _) g

refl~â–µ : âˆ€ {ğ“¤} {A : Type ğ“¤} {a b : A} (f : Hom A a b) â†’ f ~â–µ f
refl~â–µ f = (f .Homáµˆ.hom âˆ˜ Poly.Î”Â².t , funextâ†’
           (pushout-rec-unique _ _
             (pushout-rec-unique _ _
               (Î» _ â†’ f .Homáµˆ.hom0)
               ~refl
               Î» _ â†’ âˆ™-reflr _
                   âˆ™ ap-âˆ˜ (f .Homáµˆ.hom âˆ˜ Poly.Î”Â².t) (pushout-rec _) (glue tt)
                   âˆ™ ap (ap _) (pushout-rec-apÎ² _)
                   âˆ™ ap-âˆ˜ (f .Homáµˆ.hom) _ Î”Â²-refl
                   âˆ™ ap (ap _) (Î”Â²-ext-ap-t refl refl)
                   âˆ™ sym (âˆ™-sym (f .Homáµˆ.hom0)))
             ~refl
             (~âˆ™-reflr _
             ~âˆ™ Î´Î”Â¹-UPâ†’ ( ap-âˆ˜ (f .Homáµˆ.hom âˆ˜ Poly.Î”Â².t) (pushout-rec _) (glue _)
                        âˆ™ ap (ap _) (pushout-rec-apÎ² _)
                        âˆ™ ap-âˆ˜ (f .Homáµˆ.hom) _ Î”Â²-refl
                        âˆ™ ap (ap _) (Î”Â²-ext-ap-t refl refl)
                        âˆ™ sym (âˆ™-sym (f .Homáµˆ.hom0))
                        , ap-âˆ˜ (f .Homáµˆ.hom âˆ˜ Poly.Î”Â².t) (pushout-rec _) (glue _)
                        âˆ™ ap (ap _) (pushout-rec-apÎ² _)
                        âˆ™ ap-âˆ˜ (f .Homáµˆ.hom) _ Î”Â²-refl
                        âˆ™ ap (ap _) (Î”Â²-ext-ap-t refl refl)
                        âˆ™ sym (âˆ™-sym (f .Homáµˆ.hom1))))))


~â–µâ†ï¼ : âˆ€ {ğ“¤} {A : Type ğ“¤} {a b : A} {f g : Hom A a b} â†’ f ï¼ g â†’ f ~â–µ g
~â–µâ†ï¼ {a = a} {_} {f} refl = refl~â–µ f
}
%```
}

\subtree[stt-00CI]{
\title{Homotopies are an identity system for morphisms}
\taxon{Theorem}

\p{We show that when #{A} is a precategery, #{\sim_{\Delta}} is torsorial,
and thus forms an identity system for morphisms in #{A}}

%```agda
\agda{
opaque
  ~â–µ-is-torsorial
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {a b : A} â†’ is-segal A
      â†’ âˆ€ (f : Hom A a b) â†’ is-singleton (Î£[ g âˆ¶ Hom A a b ] (f ~â–µ g))
  ~â–µ-is-torsorial apc f
    = is-singleâ†equiv-to-single
        (mkâ‰ƒ _ (compositeâ†horn-extension-is-equiv f (idH _)))
        (segal-unique-composite apc f (idH _))

Hom-homotopy-IdS : âˆ€ {ğ“¤} {A : Type ğ“¤} {a b : A} â†’ is-segal A
                   â†’ Identity-system (Hom A a b) (ğ“¤ âŠ” ğ“˜)
Hom-homotopy-IdS apc .Identity-system.IdS = _~â–µ_
Hom-homotopy-IdS apc .Identity-system.IdSâ†Id = ~â–µâ†ï¼
Hom-homotopy-IdS apc .Identity-system.has-is-ids f
  = fundamental-Id _ (~â–µ-is-torsorial apc f) _

_ : âˆ€ {ğ“¤} {A : Type ğ“¤} {a b : A} (apc : is-segal A)
              â†’ is-equiv (Î» (f : Hom A a b) â†’ (f , f , refl~â–µ f))
_ = Î» apc â†’ is-equivâ»Â¹ (singleton-fst-is-equiv
                          (SingS-is-single â¦ƒ Hom-homotopy-IdS apc â¦„))
}
%```
}

\subtree[stt-00DK]{
\title{The walking homotopy}
\taxon{Definition}
\date{2026-01-29}

\p{We define the walking homotopy #{\Delta_\sim} by taking the pushout
#{\Delta^2 +^{\Delta^1} 1}, that contracts the edge #{0 \leq 1}. We show that
a map #{\Delta_\sim \to A} is equivant to the type consisting of a pair of
morphisms and a homotopy between them.}

%```agda
\agda{
Î”~ : Type ğ“˜
Î”~ = Pushout {B = Î”Â²} (_, i0) !

src-Î”~ : Î”Â¹ â†’ Î”~
src-Î”~ = Î¹â‚ âˆ˜ Î”Â²-diagonal

tgt-Î”~ : Î”Â¹ â†’ Î”~
tgt-Î”~ = Î¹â‚ âˆ˜ (i1 ,_)

Î”~-rep1
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (Î”~ â†’ A) â‰ƒ Î£[ x âˆ¶ A ] Ext (Î›[2,1]-incl âˆ˜ Î¹â‚) (const _ _ x)
Î”~-rep1 {A = A}
  = (Î”~ â†’ A) â‰ƒâŸ¨ Pushout-UPâ‰ƒ âˆ™â‰ƒ cocone-reprâ‰ƒ âŸ©
    Î£[ g âˆ¶ (Î”Â² â†’ A)]
     Î£[ x âˆ¶ (ğŸ™ â†’ A)] (g âˆ˜ (_, i0) ~ x âˆ˜ !)
       â‰ƒâŸ¨ Î£-comm âˆ™â‰ƒ (Î£-ap-â‰ƒ-fst unit-UPâ‰ƒ) âŸ©
    Î£[ x âˆ¶ A ] Î£[ g âˆ¶ (Î”Â² â†’ A)]
      (g âˆ˜ Î›[2,1]-incl âˆ˜ Î¹â‚ ~ const A Î”Â¹ x)
       â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» x â†’ Î£-ap-â‰ƒ (Î» g â†’ funextâ‰ƒ eâ»Â¹)) âŸ©
    Î£[ x âˆ¶ A ] Î£[ g âˆ¶ (Î”Â² â†’ A)]
      (g âˆ˜ Î›[2,1]-incl âˆ˜ Î¹â‚ ï¼ const A Î”Â¹ x)    â‰ƒâŸ¨âŸ©
    Î£[ x âˆ¶ A ] (Ext (Î›[2,1]-incl âˆ˜ Î¹â‚) (const A Î”Â¹ x))    â‰ƒâˆ

_ : âˆ€ {ğ“¤} {A : Type ğ“¤} (f : Î”~ â†’ A)
    â†’ f âˆ˜ src-Î”~ ~ Î”~-rep1 ._â‰ƒ_.fwd f .snd .fst âˆ˜ Î”Â²-diagonal
_ = Î» _ â†’ ~refl

Î”~-rep2
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (Î”~ â†’ A)
    â‰ƒ Î£[ x âˆ¶ A ]
       Î£[ f âˆ¶ Ext {B = Î›[2,1]} Î¹â‚ (const _ _ x) ]
         Ext Î›[2,1]-incl (f .fst)
Î”~-rep2 = Î”~-rep1 âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» a â†’ Ext-compose Î›[2,1]-incl Î¹â‚ (const _ _ a))

_ : âˆ€ {ğ“¤} {A : Type ğ“¤} (f : Î”~ â†’ A)
    â†’ f âˆ˜ src-Î”~ ~ Î”~-rep2 ._â‰ƒ_.fwd f .snd .snd .fst âˆ˜ Î”Â²-diagonal
_ = Î» _ â†’ ~refl

Î›[2,1]-ext-l
  : âˆ€ {ğ“¤}{A : Type ğ“¤} (f : Î”Â¹ â†’ A)
  â†’ Ext {B = Î›[2,1]} Î¹â‚ {Î» _ â†’ A} f â‰ƒ Î£[ g âˆ¶ (Î”Â¹ â†’ A)] (g i0 ï¼ f i1)
Î›[2,1]-ext-l f = Î£-ap-â‰ƒ-fst {B = Î» x â†’ x .fst ï¼ f} (Pushout-UPâ‰ƒ âˆ™â‰ƒ cocone-reprâ‰ƒ)
               âˆ™â‰ƒ (remove-singleton-structure Sing'-is-singleton (_ , refl)
               âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» a â†’ unit-UPâ‰ƒ âˆ™â‰ƒ symâ‰ƒ))

Î›[2,1]-ext-lâ†’
  : âˆ€ {ğ“¤}{A : Type ğ“¤} (f : Î”Â¹ â†’ A)
  â†’ Ext {B = Î›[2,1]} Î¹â‚ {Î» _ â†’ A} f â†’ Î£[ g âˆ¶ (Î”Â¹ â†’ A)] (g i0 ï¼ f i1)
Î›[2,1]-ext-lâ†’ f (e , refl) = (e âˆ˜ Î¹â‚‚ , sym (ap e (glue tt)))

fst-Î›[2,1]-ext-lâ†’
  : âˆ€ {ğ“¤}{A : Type ğ“¤} (f : Î”Â¹ â†’ A)
  â†’ fst âˆ˜ (Î›[2,1]-ext-lâ†’ f) ~ (_âˆ˜ Î¹â‚‚) âˆ˜ fst
fst-Î›[2,1]-ext-lâ†’ f (a , refl) = refl

Î›[2,1]-ext-lâ†
  : âˆ€ {ğ“¤}{A : Type ğ“¤} (f : Î”Â¹ â†’ A)
  â†’ Î£[ g âˆ¶ (Î”Â¹ â†’ A)] (g i0 ï¼ f i1) â†’ Ext {B = Î›[2,1]} Î¹â‚ {Î» _ â†’ A} f
Î›[2,1]-ext-lâ† f (g , k) = (cogap (mk-cocone f g (Î» _ â†’ sym k))) , refl

Î›[2,1]-ext-l-is-equiv
  : âˆ€ {ğ“¤}{A : Type ğ“¤} (f : Î”Â¹ â†’ A)
  â†’ is-equiv (Î›[2,1]-ext-lâ†’ f)
Î›[2,1]-ext-l-is-equiv f = is-equivâ†qiso
  ( Î›[2,1]-ext-lâ† f
  , uncurry
      (Î» where
           f refl â†’ fibre-pathâ†’
                     (funextâ†’
                      (sym âˆ˜ pushout-rec-unique _ _ ~refl ~refl
                        (Î» _ â†’ âˆ™-reflr _ âˆ™ sym sym-sym))
                     , âˆ™-reflr _ âˆ™ sym (commutes-prewhisker-funext _)
                       âˆ™ funext-refl))
  , uncurry (Î» x y â†’ Î£-pathâ†’ (refl , (ap sym (pushout-rec-apÎ² tt) âˆ™ sym-sym))))

Î”~-rep3
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (Î”~ â†’ A)
    â‰ƒ Î£[ f âˆ¶ (Î”Â¹ â†’ A) ]
         Ext Î›[2,1]-incl (make-horn (Î»hom f) (idH _))
Î”~-rep3 {A = A}
  = (Î”~ â†’ A) â‰ƒâŸ¨ Î”~-rep2 âŸ©
    Î£[ x âˆ¶ A ]
     (Î£ (Ext Î¹â‚ (const A Î”Â¹ x)) (Ext Î›[2,1]-incl âˆ˜ fst))
             â‰ƒâŸ¨ Î£-assoc eâ»Â¹ âŸ©
    Î£[ xe âˆ¶ (Î£[ x âˆ¶ A ] Ext Î¹â‚ (const _ _ x)) ]
      (Ext Î›[2,1]-incl âˆ˜ fst) (xe .snd)
             â‰ƒâŸ¨ mkâ‰ƒ lem lem-is-eqv âŸ©
    Î£[ f âˆ¶ (Î”Â¹ â†’ A) ]
     (Ext Î›[2,1]-incl (make-horn (Î»hom f) (idH (f _))))
             â‰ƒâˆ where

    H : âˆ€ (a : Î£[ x âˆ¶ A ] Ext Î¹â‚ (const _ _ x))
        â†’ (fst (a .snd)) ~
          make-horn (Î»hom (a .snd .fst âˆ˜ Î¹â‚‚)) (idH _)
    H (x , a , p) = pushout-rec-unique _ _
      (Î» i â†’ happly p i âˆ™ sym (happly p i1) âˆ™ ap a (glue tt)) ~refl
      Î» _ â†’ ap (_âˆ™ refl) (sym (symâˆ™ (happly p i1) (ap a (glue tt))))

    lem : Î£[ xe âˆ¶ (Î£[ x âˆ¶ A ] Ext Î¹â‚ (const _ _ x)) ]
             (Ext Î›[2,1]-incl âˆ˜ fst) (xe .snd)
          â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] Ext Î›[2,1]-incl (make-horn (Î»hom f) (idH _))
    lem (a , b , p) = (a .snd .fst âˆ˜ Î¹â‚‚ , b , p âˆ™ funextâ†’ (H a))

    lem' : Î£[ xe âˆ¶ (Î£[ x âˆ¶ A ] Ext Î¹â‚ (const _ _ x)) ]
             (Ext Î›[2,1]-incl âˆ˜ fst) (xe .snd)
          â†’ Î£[ f âˆ¶ (Î”Â¹ â†’ A)] Ext Î›[2,1]-incl (make-horn (Î»hom f) (idH _))
    lem' = total-map-fst
              {A = Î”Â¹ â†’ A}
              {A' = Î£[ x âˆ¶ A ] Ext {B = Î›[2,1]} Î¹â‚ {X = Î» _ â†’ A} (const A Î”Â¹ x)}
              ((_âˆ˜ Î¹â‚‚) âˆ˜ fst âˆ˜ snd)
              {Î» g â†’ Ext Î›[2,1]-incl (make-horn (Î»hom g) (idH _))}
            âˆ˜ total-map (Î» a â†’ total-map (Î» b â†’ _âˆ™ funextâ†’ (H a)))


    K : fst âˆ˜ Î£-comm ._â‰ƒ_.fwd âˆ˜ total-map (Î›[2,1]-ext-lâ†’ âˆ˜ const _ _)
      ~ (_âˆ˜ Î¹â‚‚) âˆ˜ fst âˆ˜ snd
    K (a , b , c) = fst-Î›[2,1]-ext-lâ†’ (Î» _ â†’ a) (b , c)

    lem-is-eqv : is-equiv lem
    lem-is-eqv
      = is-equiv-âˆ˜
          (total-is-equivâ†fst-is-equiv
            (homotopy-is-equiv K
              (is-equiv-âˆ˜
                 (singleton-fst-is-equiv (Î» _ â†’ Sing-is-singleton))
                 (is-equiv-âˆ˜
                   (Î£-comm ._â‰ƒ_.has-is-eqv)
                   (is-total-equivâ†is-fibrewise-equiv
                     (Î» a â†’ Î›[2,1]-ext-l-is-equiv (const A Î”Â¹ a)))))))
          (is-total-equivâ†is-fibrewise-equiv
            Î» a â†’ is-total-equivâ†is-fibrewise-equiv
              Î» b â†’ âˆ™-is-equiv' (funextâ†’ (H a)))

_ : âˆ€ {ğ“¤} {A : Type ğ“¤} (f : Î”~ â†’ A)
    â†’ f âˆ˜ src-Î”~ ~ Î”~-rep3 ._â‰ƒ_.fwd f .snd .fst âˆ˜ Î”Â²-diagonal
_ = Î» f a â†’ refl

Î”~-rep4
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ (Î”~ â†’ A)
    â‰ƒ Î£[ f âˆ¶ (Î”Â¹ â†’ A) ]
         Î£[ g âˆ¶ Hom A (f i0) (f i1) ]
            Hom2 (Î»hom f) (idH _) g
Î”~-rep4 = Î”~-rep3
        âˆ™â‰ƒ Î£-ap-â‰ƒ
            (Î» f â†’ mkâ‰ƒ _ (compositeâ†horn-extension-is-equiv (Î»hom f) (idH _)))

rep4-Î”~tgt
  : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ fst âˆ˜ Î”~-rep4 ._â‰ƒ_.fwd ~ precomp A (tgt-Î”~)
rep4-Î”~tgt = ~refl

rep4-Î”~src
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ Homáµˆ.hom âˆ˜ fst âˆ˜ snd âˆ˜ Î”~-rep4 ._â‰ƒ_.fwd ~ precomp A (src-Î”~)
rep4-Î”~src f = compositeâ†horn-extension-diagonal _ _ (Î”~-rep3 ._â‰ƒ_.fwd f .snd)
}
%```
}

\subtree[stt-00DL]{
\taxon{Corollary}
\date{2026-01-29}

\p{As a corollary of \ref{stt-00CH}, we have the the map map that picks out the
source (or the target) of the walking homotopy is a Segal equivalence.}


%```agda
\agda{
opaque
  tgt-is-segal-equiv
    : is-segal-equiv tgt-Î”~
  tgt-is-segal-equiv {Q = Q} qpc
    = is-equiv-âˆ˜
        {f = fst}
        {g = Î”~-rep4 ._â‰ƒ_.fwd}
        (singleton-fst-is-equiv
          (Î» f â†’ SingS-is-single â¦ƒ Hom-homotopy-IdS qpc â¦„ _))
        (Î”~-rep4 ._â‰ƒ_.has-is-eqv)

  src-is-segal-equiv
    : is-segal-equiv src-Î”~
  src-is-segal-equiv {Q = Q} qpc
    = is-equiv~âˆ˜
        {f = (Homáµˆ.hom âˆ˜ fst âˆ˜ snd)}
        {g = Î”~-rep4 ._â‰ƒ_.fwd}
        (rep4-Î”~src ~â»Â¹)
        (is-equivâ†qiso lemma)
        (Î”~-rep4 ._â‰ƒ_.has-is-eqv) where
    lemma : quasi-iso {A = Î£[ f âˆ¶ (Î”Â¹ â†’ Q) ]
                             Î£[ g âˆ¶ Hom Q (f i0) (f i1) ]
                               Hom2 (Î»hom f) (idH _) g}
                     {B = Î”Â¹ â†’ Q} (Homáµˆ.hom âˆ˜ fst âˆ˜ snd)
    lemma .fst a = (a , Î»hom a , refl~â–µ (Î»hom a))
    lemma .snd .fst (a , b , p)
      = Î£-pathâ†’ ( sym (ap Homáµˆ.hom (Idâ†IdS â¦ƒ Hom-homotopy-IdS qpc â¦„ p))
                , (composite-is-prop qpc _ _ _ _))
    lemma .snd .snd a = refl
}
%```
}
