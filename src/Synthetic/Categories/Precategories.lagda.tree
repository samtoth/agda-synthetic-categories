\date{2025-11-17}
\title{Precategories}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Precategories
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.ModalMaps

open import Core.Join
open import Core.CanonicalPushouts
open import Core.FlatteningPushouts
open import Core.Postwhisker
open import Core.Orthogonal
open import Core.OrthogonalClosure
open notation
open import Ergonomics.Notations.Orthogonality

open import Data.Bool

open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Hom Î”Â¹ i0 i1

open import Ergonomics.Extensionality
}
%```


\subtree[stt-00AI]{
\title{Segal types}
\taxon{Definition}


\p{We say that a type is \strong{Segal} if it is local with respect to
the inclusion of the [#{(2,1)} horn](stt-00AD) into the 2-simplex. We
can use the fact that [being local with respect to some class of maps
forms a global reflective subuniverse](stt-0066) to bootstrap some
useful notions, such as preservation under identity and pi types as
well as the localisation operation. Note that unlike in the case of
[simplicial types](stt-00AC) this subuniverse is neither
#{\Sigma}-closed nor lex.}

\p{We call maps which are local to the inner horn inclusion \strong{inner maps}.}

%```agda
\agda{
open Subtype

is-segal : âˆ€ {ğ“¤} (C : Type ğ“¤) â†’ Type (ğ“¤ âŠ” ğ“˜)
is-segal = is-local Î» (tt : ğŸ™) â†’ Î›[2,1]-incl

Segal-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Segal-SubU = Local-SubU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl) _

Segal-GSU : GSU (_âŠ” ğ“˜)
Segal-GSU = Local-GSU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

Segal-is-globally-reflective
   : is-globally-reflective Segal-GSU
Segal-is-globally-reflective
  = Local-global-reflectors (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

module Segal where
  open GSU Segal-GSU public renaming (S-equiv to is-segalâ†equiv)

  open is-globally-reflective Segal-is-globally-reflective
  open GPiClosure Segal-is-globally-reflective public
    renaming (Î âˆˆS to Î -is-segal; Ã—âˆˆS to Ã—-is-segal)

  is-fibrewise-inner : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
  is-fibrewise-inner = is-modal-map Segal-SubU

is-inner : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-inner f = Î›[2,1]-incl âŠ¥ f

is-segal-equiv
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
    â†’ (f : A â†’ B) â†’ TypeÏ‰
is-segal-equiv f
  = âˆ€ {ğ“ } {Q : Type ğ“ } â†’ is-segal Q â†’ is-equiv (postcomp Q f)

is-segal-equiv-âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {f : B â†’ C} {g : A â†’ B} â†’ is-segal-equiv f
    â†’ is-segal-equiv g â†’ is-segal-equiv (f âˆ˜ g)
is-segal-equiv-âˆ˜ sf sg qpc = is-equiv-âˆ˜ (sg qpc) (sf qpc)
}
%```
}

\subtree[stt-00C5]{
\title{Inner families}
\taxon{Definition}

\p{ A family #{P : A \to \UU} is an inner family if it's unstraightening is
an inner fibration. The total type of an inner family over a Segal type is
itself Segal.}

%```agda
\agda{
is-inner-family : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)Â â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
is-inner-family B = Î›[2,1]-incl âŠ¥ fst {B = B}

opaque
  is-segal-Î£
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}Â 
    â†’ is-segal A â†’ is-inner-family B â†’ is-segal (Î£ A B)
  is-segal-Î£ apc bin tt
    = is-orthogonalâ‡”orthogonal-! .fst
        (right-orthogonal-âˆ˜
          Î›[2,1]-incl
          (is-orthogonalâ‡”orthogonal-! .snd (apc tt))
          bin)
}
%```
}

\subtree[stt-00AK]{
\title{Composite morphisms}
\taxon{Definition}

\p{Given the data of the boundary of a 2-simplex:}

\quiver{
\begin{tikzcd}
        x && y \\
	\\
	&& z
	\arrow["g", from=1-1, to=1-3]
	\arrow["h"', from=1-1, to=3-3]
	\arrow["f", from=1-3, to=3-3]
\end{tikzcd}
}

\p{We define the type of fillers, written #{\Hom 2(f,g;h)}, which we say witnesses
that #{fg \sim h}.}

%```agda
\agda{
Hom2 : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
         (f : Hom _ y z) (g : Hom _ x y) (h : Hom _ x z)
       â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom2 {A = A} f g h = Ext Î´Î”Â²-incl (make-Î´Î”Â² f g h)
}
%```
}


\subtree[stt-00AL]{
\title{Morphisms in a Segal type have unique composites}
\taxon{Theorem}

\p{Given a pair of composable morphisms, we can naturally define a map
#{\Delta^2_1 \to C}. We show that there is a unique 2-simplex that extends
#{f} and #{g}.}


\proof{
\p{[Segal types](stt-00AI) are defined to be those types which are local
with respect to the inclusion #{i : \Lambda^2_1 \hookrightarrow \Delta^2}. The
fibres of #{i^* : (\Delta^2 \to C) \to (\Lambda^2_1 \to C)} are exactly the maps
#{\Delta^2 \to C} which extend the boundary #{f,g}.}
}

%```agda
\agda{
opaque
  segal-unique-composite
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ is-segal A
      â†’ (f : Hom A y z) (g : Hom A x y)
      â†’ is-singleton (Î£[ H âˆ¶ (Î”Â² â†’ A)] (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g))
  segal-unique-composite Apc f g
    = is-contr-mapâ†is-equiv (Apc tt) (make-horn f g)



private
  ext-Î›[2,1]â‰ƒ
    : âˆ€ {ğ“¤} {A : Type ğ“¤} (fg : Î›[2,1] â†’ A)
    â†’ Ext Î´Î”Â²â†Î›[2,1] {Î» _ â†’ A} fg â‰ƒ Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1))
  ext-Î›[2,1]â‰ƒ {_} {A} fg
    = Ext Î´Î”Â²â†Î›[2,1] fg â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» cc â†’ pushout-rec cc âˆ˜ Î¹â‚ ï¼ fg}
                                      Pushout-UPâ‰ƒ  âŸ©
      Î£[ cc âˆ¶ Cocone _ A ] (cc .Cocone.p ï¼ fg)
                        â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» cr â†’ cr .fst ï¼ fg} cocone-reprâ‰ƒ âŸ©
      _ â‰ƒâŸ¨ remove-singleton-structure Sing'-is-singleton (fg , refl) âŸ©
      Î£[ h âˆ¶ (Î”Â¹ â†’ A) ]
          (fg âˆ˜ Î´Î›[2,1]-incl ~ h âˆ˜ Î´Î”Â¹-incl)
                        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î´Î”Â¹-UP eâ»Â¹ âˆ™â‰ƒ (symâ‰ƒ Ã—â‰ƒ symâ‰ƒ)) âŸ©
      _                 â‰ƒâŸ¨ HomP-reprâ‰ƒ eâ»Â¹ âŸ©
      Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1)) â‰ƒâˆ

ext-Î›[2,1]
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (fg : Î›[2,1] â†’ A)
    â†’ Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1)) â†’ Ext Î´Î”Â²â†Î›[2,1] {Î» _ â†’ A} fg
ext-Î›[2,1] {A = A} fg
  = total-map-fst cogap âˆ˜ map1 module ext-Î›[2,1] where
  map1 : Hom A _ _ â†’ Î£[ cc âˆ¶ Cocone (mk-span Î´Î”Â¹ Î´Î›[2,1]-incl Î´Î”Â¹-incl) _ ]
                        (cc .Cocone.p ï¼ fg)
  map1 h@(mk-hom hh h0 h1) = (mk-cocone fg hh (Î´Î”Â¹-UPâ†’ (sym h0 , sym h1)) , refl)

  map1' : Hom A (fg (Î¹â‚ i0)) (fg (Î¹â‚‚ i1))
        â†’ Î£[ cc âˆ¶ Cocone (mk-span Î´Î”Â¹ Î´Î›[2,1]-incl Î´Î”Â¹-incl) _ ]
                        (cc .Cocone.p ï¼ fg)
  map1' = total-map-fst (_â‰ƒ_.bwd cocone-reprâ‰ƒ )
        âˆ˜ _â‰ƒ_.bwd (remove-singleton-structure Sing'-is-singleton (_ , refl))
        âˆ˜ total-map (Î» x â†’ Î´Î”Â¹-UPâ†’ âˆ˜ (sym âŠ— sym))
        âˆ˜ HomP-reprâ‰ƒ ._â‰ƒ_.fwd

  map1-is-equiv : is-equiv map1
  map1-is-equiv
    = is-equiv-âˆ˜
        (total-is-equivâ†fst-is-equiv
          (is-equivâ»Â¹ (_â‰ƒ_.has-is-eqv cocone-reprâ‰ƒ)))
        (is-equiv-âˆ˜
          (is-equivâ»Â¹ (_â‰ƒ_.has-is-eqv
            (remove-singleton-structure Sing'-is-singleton (_ , refl))))
          (is-equiv-âˆ˜
            (is-total-equivâ†is-fibrewise-equiv
              (Î» a â†’ is-equiv-âˆ˜ (Î´Î”Â¹-UP ._â‰ƒ_.has-is-eqv)
                                (âŠ—-is-equiv sym-is-equiv sym-is-equiv)))
            (HomP-reprâ‰ƒ ._â‰ƒ_.has-is-eqv)))

ext-Î›[2,1]-is-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤} (fg : Î›[2,1] â†’ A)
    â†’ is-equiv (ext-Î›[2,1] fg)
ext-Î›[2,1]-is-equiv fg
  = is-equiv-âˆ˜
      (total-is-equivâ†fst-is-equiv pushout-rec-is-equiv)
      (ext-Î›[2,1].map1-is-equiv fg)

make-Î´Î”Â²-is-extension
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      (h : Hom A x z) â†’ make-Î´Î”Â² f g h âˆ˜ Î´Î”Â²â†Î›[2,1] ï¼ make-horn f g
make-Î´Î”Â²-is-extension f g h = refl

ext-mk-horn : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
             â†’ Hom A x z â†’ Ext Î´Î”Â²â†Î›[2,1] {Î» _ â†’ A} (make-horn f g)
ext-mk-horn {_} {A} f g h = (make-Î´Î”Â² f g h , make-Î´Î”Â²-is-extension f g h)

opaque
  ext-mk-horn-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      â†’ is-equiv (ext-mk-horn f g)
  ext-mk-horn-is-equiv f g
    = homotopy-is-equiv
       (Î» where
          h@(mk-hom hh refl refl) â†’ fibre-pathâ†’ (funextâ†’ (pushout-rec-unique _ _ ~refl ~refl
                               (~âˆ™-reflr _ ~âˆ™ pushout-rec-apÎ²
                               ~âˆ™ Î´Î”Â¹-UPâ†’ ( sym-sym âˆ™ sym (âˆ™-reflr _)
                                          , sym-sym âˆ™ sym (âˆ™-reflr _))))
                       , âˆ™-reflr _ âˆ™  sym (commutes-postwhisker-funext _) âˆ™ funext-refl))
       (is-equiv-âˆ˜ (ext-Î›[2,1]-is-equiv (make-horn f g))
                   (adjust-hom-is-equiv
                     (sym (g .HomP.hom0)) (sym (f .HomP.hom1))))

ext-mk-horn-compute-diagonal
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
    â†’ HomP.hom âˆ˜ is-equiv.bwd (ext-mk-horn-is-equiv f g) ~ postcomp A Î¹â‚‚ âˆ˜ fst
ext-mk-horn-compute-diagonal f g
  = (HomP.hom â—‚  is-equiv.Î· (ext-mk-horn-is-equiv f g))
    â–¸eqv (ext-mk-horn-is-equiv f g)

opaque
  compositeâ†horn-extension
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      â†’ Î£[ H âˆ¶ (Î”Â² â†’ A)] (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g)
      â†’ Î£[ h âˆ¶ Hom A x z ] (Hom2 f g h)
  compositeâ†horn-extension {A = A} {x} {y} {z} f g
    = total-map-fst (is-equiv.bwd (ext-mk-horn-is-equiv f g))
    âˆ˜ total-map (Î» a â†’ tr (Ext Î´Î”Â²-incl)
                          (sym (ap fst (is-equiv.Îµ (ext-mk-horn-is-equiv f g) a))))
    âˆ˜ Ext-compose Î´Î”Â²-incl Î´Î”Â²â†Î›[2,1] (make-horn f g) ._â‰ƒ_.fwd

  compositeâ†horn-extension-is-equiv
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      â†’ is-equiv (compositeâ†horn-extension f g)
  compositeâ†horn-extension-is-equiv f g
    = is-equiv-âˆ˜
       (total-is-equivâ†fst-is-equiv (is-equivâ»Â¹ (ext-mk-horn-is-equiv f g)))
       (is-equiv-âˆ˜
         (is-total-equivâ†is-fibrewise-equiv (Î» a â†’
           tr-is-equiv {B = Ext Î´Î”Â²-incl}
             (sym (ap fst (is-equiv.Îµ (ext-mk-horn-is-equiv f g) a)))))
         (Ext-compose _ _ (make-horn f g) ._â‰ƒ_.has-is-eqv))

  compositeâ†horn-extension-diagonal
    : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
      â†’ HomP.hom âˆ˜ fst âˆ˜ compositeâ†horn-extension f g
      ~ postcomp A Î”Â²-diagonal âˆ˜ fst
  compositeâ†horn-extension-diagonal f g x
    = ext-mk-horn-compute-diagonal f g _

_âˆ˜[_]_ :  âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ Hom A y z â†’ is-segal A
          â†’ Hom A x y â†’ Hom A x z
f âˆ˜[ apc ] g = fst (compositeâ†horn-extension f g
                    (centre (segal-unique-composite apc f g)))

âˆ˜[_]-is-composite
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} {f : Hom A y z} {g : Hom A x y}
    â†’ (apc : is-segal A) â†’ Hom2 f g (f âˆ˜[ apc ] g)
âˆ˜[_]-is-composite {f = f} {g} apc
  = snd (compositeâ†horn-extension _ _
          (centre (segal-unique-composite apc f g)))

opaque
  composite-is-prop
    : âˆ€ {ğ“¤} {A : Type ğ“¤} (apc : is-segal A)
        {x y z} (f : Hom A y z) (g : Hom A x y)
      â†’ is-prop (Î£ (Hom A x z) (Hom2 f g))
  composite-is-prop apc f g
    = is-propâ†equiv-to-prop
        (mkâ‰ƒ _ (compositeâ†horn-extension-is-equiv f g))
        (is-propâ†is-single (segal-unique-composite apc f g))

  unique-composite : âˆ€ {ğ“¤} {A : Type ğ“¤} (apc : is-segal A)
                       {x y z} (f : Hom A y z) (g : Hom A x y)
                    â†’ (h : Hom A x z) â†’ Hom2 f g h â†’ h ï¼ (f âˆ˜[ apc ] g)
  unique-composite apc f g h K
    = sym (ap fst
             ((is-singleâ†equiv-to-single
                (mkâ‰ƒ (compositeâ†horn-extension f g)
                     (compositeâ†horn-extension-is-equiv f g))
                (segal-unique-composite apc f g)) .central (h , K)))
}
%```
}
