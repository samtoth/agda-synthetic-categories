\date{2025-07-30}
\title{Pushouts of equivalent types}
\taxon{module}
\meta{module}{Core.PushoutEquiv}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
module Core.PushoutEquiv where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Postwhisker
open import Core.Arrow
open import Core.CocartesianSquare

open import Ergonomics.Extensionality
}
%```

\subtree[stt-009C]{
\title{Pushouts of homotopic maps are equivalent}
\taxon{lemma}
\date{2025-08}

\p{Given a diagram as follows (with homotopies #{H : f \sim f'} and
#{K : g \sim g'} witnessing the commutativity): }

\quiver{
\begin{tikzcd}
	&& {S'} \\
	A && S && B
	\arrow["{f'}"', from=1-3, to=2-1]
	\arrow[equals, from=1-3, to=2-3]
	\arrow["{g'}", from=1-3, to=2-5]
	\arrow["f", from=2-3, to=2-1]
	\arrow["g"', from=2-3, to=2-5]
\end{tikzcd}
}

\p{
We have that a cocone is a pushout of #{S} iff it is a pushout of
#{S'}.
}


\proof{
\p{We first note that cocones over #{S} are equivalent to cocones over
#{S'}. Then the statement follows by applying the 3-for-2 property
on the following diagram:}

\quiver{
\begin{tikzcd}
	{X^Q} && {\rm{cocone}(S',Q)} \\
	\\
	& {\rm{cocone}(S,Q)}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-2]
	\arrow["\sim"', from=3-2, to=1-3]
\end{tikzcd}
}
}

%```agda
\agda{
module _ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥} {C : Type 𝓦}
         {f f' : A → B} {g g' : A → C} (H : f ~ f') (K : g ~ g')
         where
  private
    S = mk-span _ f g
    S' = mk-span _ f' g'

  open Span

  Cocone≃←homotopy : ∀ {𝓠} {Q : Type 𝓠} → Cocone S Q ≃ Cocone S' Q
  Cocone≃←homotopy {_} {Q}
    = Cocone S _  ≃⟨ cocone-repr≃ ⟩
      (Σ[ p ∶ (B → Q)] Σ[ q ∶ (C → Q)] (p ∘ f ~ q ∘ g))
                  ≃⟨ Σ-ap-≃ (λ p → Σ-ap-≃ (λ q → mk≃ _
                      (is-equiv-∘ (~∙-is-equiv (p ◂ (H ~⁻¹)))
                      (~∙-is-equiv' (q ◂ K))))) ⟩
      ((Σ[ p ∶ (B → Q)] Σ[ q ∶ (C → Q)] (p ∘ f' ~ q ∘ g')))
                  ≃⟨ cocone-repr≃ e⁻¹ ⟩
      Cocone S' _ ≃∎

  Cocone-map←homotopy : ∀ {𝓠} {Q : Type 𝓠} → Cocone S Q → Cocone S' Q
  Cocone-map←homotopy cc = mk-cocone p q ((p ◂ (H ~⁻¹)) ~∙ filler ~∙ q ◂ K)
    where open Cocone cc


  is-pushout←homotopy
    : ∀ {𝓜} {X : Type 𝓜} (cc : Cocone S X)
      → is-pushoutω S cc → is-pushoutω S' (Cocone-map←homotopy cc)
  is-pushout←homotopy cc po {𝓠}{Q}
    = is-equiv~∘ comm
                 (Cocone≃←homotopy ._≃_.has-is-eqv)
                 (po {𝓠}{Q}) where
    comm : cocone-map S' (Cocone-map←homotopy cc) ~
            Cocone-map←homotopy ∘ cocone-map S cc
    comm f = Cocone-path→ _ _ refl refl (
      Cocone.filler (cocone-map S' (Cocone-map←homotopy cc) f) ~∙ ~refl
                  ~⟨ ~∙-reflr _ ⟩
      Cocone.filler (cocone-map S' (Cocone-map←homotopy cc) f)
                  ~⟨⟩
      f ◂ ((p ◂ (H ~⁻¹)) ~∙ filler ~∙ q ◂ K)
                  ~⟨ ◂∙∙ f (p ◂ (H ~⁻¹)) filler (q ◂ K) ⟩
      (f ◂ (p ◂ (H ~⁻¹))) ~∙ f ◂ filler ~∙ f ◂ q ◂ K
                  ~⟨ (◂∘ f p (H ~⁻¹) ~⁻¹) ⟩~∙⟨ ~refl ⟩~∙⟨ (◂∘ f q K ~⁻¹) ⟩
      (f ∘ p ◂ (H ~⁻¹)) ~∙ f ◂ filler ~∙ f ∘ q ◂ K ~∎) where open Cocone cc

  Pushout≃←homotopy : Pushout f' g' ≃ Pushout f g
  Pushout≃←homotopy = mk≃ (cogap (Cocone-map←homotopy pushout))
                          (cogap-is-equiv←is-pushout _
                           (is-pushout←homotopy _ Pushout-is-pushoutω))
}
%```
}


\subtree[stt-0083]{
\date{2025-07-30}
\title{Adjusting Pushouts by equivalences}
\taxon{lemma}

\p{Given #{A \simeq B}, a pushout under #{C \xleftarrow{} B
\xrightarrow{} D}, gives rise to a pushout under the induced span #{C
\xleftarrow{} A \xrightarrow{} D}.}

\p{As a corollary, we also have that the canonical pushout of the span
is equivalent to the pushout of the induced span.}

%```agda
\agda{
precomp-span : ∀ {𝓤 𝓥 𝓦 𝓜} {A : Type 𝓜} → (S : Span 𝓤 𝓥 𝓦)
               → (A → S .Span.Centre) → Span 𝓜 𝓥 𝓦
precomp-span {A = A} S f = mk-span A (S.left ∘ f) (S.right ∘ f) where
  module S = Span S

precomp-cocone : ∀ {𝓤 𝓥 𝓦 𝓜 𝓛} {A : Type 𝓜}  {S : Span 𝓤 𝓥 𝓦}
                   (f : A → Span.Centre S) {D : Type 𝓛}
                 → Cocone S D
                 → Cocone (precomp-span S f) D
precomp-cocone f cc
  = mk-cocone p q (filler ▸ f) where open Cocone cc

precomp-cocone-is-equiv
  : ∀ {𝓤 𝓥 𝓦 𝓜 𝓛} {A : Type 𝓜}  {S : Span 𝓤 𝓥 𝓦}
      (f : A → Span.Centre S) {D : Type 𝓛}
    → is-equiv f
    → is-equiv (precomp-cocone {S = S} f {D})
precomp-cocone-is-equiv {S = S} f feq = is-equiv←qiso qiso where
  module ▸f {𝓠}{C : Type 𝓠}{g}{h} =
    is-equiv (postwhisker-equiv-is-equiv feq {C} {g} {h})

  qiso : quasi-iso (precomp-cocone f)
  qiso .fst (mk-cocone p q filler)
    = mk-cocone p q (▸f.bwd filler)
  qiso .snd .fst (mk-cocone p q filler)
    = ap (mk-cocone p q) (▸f.η filler)
  qiso .snd .snd (mk-cocone p q filler)
    = ap (mk-cocone p q) (▸f.ε filler)


precomp-cocone-is-pushout
  : ∀ {𝓤 𝓥 𝓦 𝓜 𝓛} {A : Type 𝓜}  {S : Span 𝓤 𝓥 𝓦}
      (f : A → Span.Centre S) {D : Type 𝓛}
      (feq : is-equiv f)
      {C : Cocone S D}
     → is-pushoutω _ C
     → is-pushoutω _ (precomp-cocone f C)
precomp-cocone-is-pushout {S = S} f feq {C = C} po
  = is-equiv-∘ (precomp-cocone-is-equiv f feq) po

Pushout-adjust-equiv : ∀ {𝓤 𝓥 𝓦 𝓜} {S : Type 𝓤} {B : Type 𝓥} {C : Type 𝓦}
                  {f : S → B} {g : S → C} {S' : Type 𝓜}
                → (e : S' ≃ S)
                → Pushout (f ∘ e ._≃_.fwd) (g ∘ e ._≃_.fwd)
                ≃ Pushout f g
Pushout-adjust-equiv {f = f} {g} e = mk≃ map map-is-eq where
  module e = _≃_ e

  map : Pushout _ _ → Pushout f g
  map = cogap (precomp-cocone e.fwd (pushout {f = f} {g}))

  map-is-eq : is-equiv map
  map-is-eq = cogap-is-equiv←is-pushout _
                (precomp-cocone-is-pushout
                   e.fwd
                   e.has-is-eqv
                   Pushout-is-pushoutω)

-- precomp-cocone~ : ∀ {𝓤 𝓥 𝓦 𝓜 𝓛} {S : Span 𝓤 𝓥 𝓦}
--                     {S' : Type 𝓜}
--                     {left' : S' → Span.Left S} {right' : S' → Span.Right S}
--                    (f : S' → Span.Centre S) {D : Type 𝓛}
--                  → left' ~ Span.left S ∘ f
--                  → Span.right S ∘ f ~ right'
--                  → Cocone S D
--                  → Cocone (mk-span S' left' right') D
-- precomp-cocone~ f H K cc
--   = mk-cocone p q (p ◂ H ~∙ filler ▸ f ~∙ q ◂ K ) where open Cocone cc

-- precomp-cocone~-is-equiv
--   : ∀ {𝓤 𝓥 𝓦 𝓜 𝓛} {S : Span 𝓤 𝓥 𝓦}
--       {S' : Type 𝓜}
--       {left' : S' → Span.Left S} {right' : S' → Span.Right S}
--       (f : S' → Span.Centre S) {D : Type 𝓛}
--       (H : left' ~ Span.left S ∘ f)
--       (K : Span.right S ∘ f ~ right')
--     → is-equiv f
--     → is-equiv (precomp-cocone~ {S = S} f {D} H K)
-- precomp-cocone~-is-equiv {S = S} f H K feq = is-equiv←qiso qiso where
--   module ▸f {𝓠}{C : Type 𝓠}{g}{h} =
--     is-equiv (postwhisker-equiv-is-equiv feq {C} {g} {h})

--   qiso : quasi-iso (precomp-cocone~ f H K)
--   qiso .fst (mk-cocone p q filler)
--     = mk-cocone p q (▸f.bwd (p ◂ (H ~⁻¹) ~∙ filler ~∙ q ◂ (K ~⁻¹)))
--   qiso .snd .fst (mk-cocone p q filler)
--     = ap (mk-cocone p q) (funext→ (λ a → {!!}))
--   qiso .snd .snd (mk-cocone p q filler)
--     = ap (mk-cocone p q) {!!}

Pushout-adjust-equiv~ : ∀ {𝓤 𝓥 𝓦 𝓜} {S : Type 𝓤} {B : Type 𝓥} {C : Type 𝓦}
                  {f : S → B} {g : S → C} {S' : Type 𝓜}
                  {f' : S' → B} {g' : S' → C}
                → (e : S' ≃ S)
                → f ∘ e ._≃_.fwd ~ f'
                → g ∘ e ._≃_.fwd ~ g'
                → Pushout f' g'
                ≃ Pushout f  g
Pushout-adjust-equiv~ {f = f}{g}{S'}{f'}{g'} e H K
  = Pushout f' g' ≃⟨ Pushout≃←homotopy H K ⟩
    Pushout (f ∘ _≃_.fwd e) (g ∘ _≃_.fwd e)
                  ≃⟨ Pushout-adjust-equiv e ⟩
    Pushout f g ≃∎
}
%```
}

\subtree[stt-009E]{
\title{Extending pullbacks by equivalences}
\taxon{proposition}

\p{Let #{S} be a span #{A \xleftarrow{f} S \xrightarrow{g} B} and #{e}
be an equivalence #{A \to A'}. Then the pushout of #{ef} against #{g}
is equivalent to the pushout of #{f} against #{g}.}
}

\subtree[stt-009F]{
\title{Pushing out equivalences}
\taxon{lemma}

\p{Pushing out an equivalence #{e : A \toeq B} against
any map #{f : A \to C} gives an equivalence #{B \toeq B +^A C}.}

\proof{
This follows immediately from the [analagous theorem for cocartesian
squares](stt-008O)
}

%```agda
\agda{
ι₂-is-equiv←pushout-equiv : ∀ {𝓤 𝓥 𝓦} {S : Type 𝓤} {A : Type 𝓥} {B : Type 𝓦}
                  {f : S → A} (fe : is-equiv f)
                  (g : S → B) → is-equiv (ι₂ {f = f} {g})
ι₂-is-equiv←pushout-equiv {f = f} fe g
 = dom-is-equiv←cocartesian (mk-amap g ι₁ glue) fe
     (is-cocartesian←is-pushout Pushout-is-pushoutω)

Pushout-equiv : ∀ {𝓤 𝓥 𝓦} {S : Type 𝓤} {A : Type 𝓥} {B : Type 𝓦}
                  {f : S → A} (fe : is-equiv f) (g : S → B)
                → B ≃ Pushout f g
Pushout-equiv fe g = mk≃ _ (ι₂-is-equiv←pushout-equiv fe g)
}
%```
}

\subtree[stt-009G]{
\title{Vertical pasting of pushouts}
\taxon{lemma}

\p{Given squares arranged vertically like so:}

\quiver{
\begin{tikzcd}
	A && C \\
	\\
	{B} && \bullet \\
	\\
	{B'} && \bullet
	\arrow[from=1-1, to=1-3]
	\arrow["g", from=1-1, to=3-1]
	\arrow["fg"', curve={height=12pt}, from=1-1, to=5-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow["f", from=3-1, to=5-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[from=3-3, to=5-3]
	\arrow[from=5-1, to=5-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=5-3, to=3-1]
\end{tikzcd}
}

\p{The result of pushing out the top span followed by the bottom span
is equivalent to pushing out the outer span all at once. In symbols,
#{B' +^B (B +^A + C) \simeq B' +^A C}.}

%```
\agda{
module _ {𝓤 𝓥 𝓦 𝓜} {A : Type 𝓤} {B : Type 𝓥} {B' : Type 𝓦}
         {C : Type 𝓜} (f : B → B') (g : A → B) (h : A → C) where

  private
    US : Span 𝓤 𝓥 𝓜
    US = mk-span A g h

    LS : Span 𝓥 𝓦  (𝓤 ⊔ 𝓥 ⊔ 𝓜)
    LS = mk-span B f (ι₁ {f = g} {h})

    TS : Span 𝓤 𝓦 𝓜
    TS = mk-span A (f ∘ g) h


    lemma : ∀ {𝓠}{Q : Type 𝓠}(p : B' → Q)
            → (Σ[ cc ∶ Cocone US Q ] (p ∘ f ~ Cocone.p cc))
            ≃ Σ[ q ∶ (C → Q) ] (p ∘ f ∘ g ~ q ∘ h)
    lemma {𝓠}{Q}p = Σ-ap-≃ (λ cc → funext≃ e⁻¹) ∙≃ equiv←qiso iso where
      open _≅_

      iso : _ ≅ _
      iso .fwd (mk-cocone q r H , K) = r , happly K ▸ g ~∙ H
      iso .fwd-iso .fst (q , H) = (mk-cocone (p ∘ f) q H) , refl
      iso .fwd-iso .snd .fst cc@(mk-cocone p q filler , refl) = refl
      iso .fwd-iso .snd .snd (p , H) = refl

  extend-cocone : ∀ {𝓠}{Q : Type 𝓠} → Cocone LS Q ≃ Cocone TS Q
  extend-cocone {𝓠}{Q}
    = Cocone LS _ ≃⟨ cocone-repr≃ ⟩
      Σ[ p ∶ (B' → Q) ]
       Σ[ q ∶ (Pushout g h → Q)] (p ∘ f ~ q ∘ ι₁)
                  ≃⟨ Σ-ap-≃ (λ p → Σ-ap-≃-fst (Pushout-UP≃)) ⟩
      (Σ[ p ∶ (B' → Q) ] Σ[ q ∶ Cocone US Q ] (p ∘ f ~ q .Cocone.p))
                  ≃⟨ Σ-ap-≃ lemma ⟩
      (Σ[ p ∶ (B' → Q) ]
        Σ[ q ∶ (C → Q)] (p ∘ f ∘ g ~ q ∘ h))
                  ≃⟨ cocone-repr≃ e⁻¹ ⟩
      Cocone TS _ ≃∎

  Pushout-vert-∘ : Pushout (f ∘ g) h ≃ Pushout f (ι₁ {f = g} {h})
  Pushout-vert-∘ = mk≃ map (cogap-is-equiv←is-pushout cc λ
    {𝓠}{Q} → is-equiv~∘ (H Q)
                        (extend-cocone ._≃_.has-is-eqv)
                        (Pushout-is-pushoutω)) where
    cc = (extend-cocone ._≃_.fwd pushout)
    map : Pushout (f ∘ g) h → Pushout f (ι₁ {f = g} {h})
    map = cogap cc

    H : ∀ {𝓠}(Q : Type 𝓠)
        → cocone-map (mk-span A (f ∘ g) h) cc
        ~ _≃_.fwd extend-cocone ∘ cocone-map (mk-span B f ι₁) pushout
    H Q f = Cocone-path→ _ _ refl refl
      ( f ◂ (glue ∘ g ~∙ ι₂ ◂ glue) ~∙ ~refl
                                   ~⟨ ~∙-reflr _ ⟩
       f ◂ (glue ▸ g ~∙ ι₂ ◂ glue) ~⟨ ◂∙ f (glue ▸ g) _ ⟩
       (f ◂ glue ▸ g) ~∙ (f ◂ ι₂ ◂ glue)
                                   ~⟨ ~refl ⟩~∙⟨ (◂∘ f ι₂ glue ~⁻¹) ⟩
       f ◂ (glue ▸ g) ~∙ f ∘ ι₂ ◂ glue ~∎)
}
%```
}


\subtree[stt-009H]{
\title{proof of \ref{stt-009F}}
\taxon{proof}

\p{
Consider the following diagram:
}
\quiver{
\begin{tikzcd}
	A && C \\
	\\
	{A'} && {A' +^A C} \\
	\\
	{A''} && \bullet \\
	{A''} &&& {A'' +^A C}
	\arrow[from=1-1, to=1-3]
	\arrow["g", from=1-1, to=3-1]
	\arrow["fg"', curve={height=12pt}, from=1-1, to=6-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow["f", from=3-1, to=5-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow["\sim"', from=3-3, to=5-3]
	\arrow[from=3-3, to=6-4]
	\arrow[from=5-1, to=5-3]
	\arrow[equals, from=5-1, to=6-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=5-3, to=3-1]
	\arrow["\sim"', from=5-3, to=6-4]
	\arrow[from=6-1, to=6-4]
\end{tikzcd}
}

\p{By \ref{stt-009G}, the cogap map at the bottom right is an
equivalence, and by \ref{stt-009E}, so is the map opposite #{f}.
Then the 3-for-2 property for equivalences completes our proof.}

%```agda
\agda{

module _ {𝓤 𝓥 𝓦 𝓜} {A : Type 𝓤} {B : Type 𝓥} {B' : Type 𝓦}
         {C : Type 𝓜} {f : B → B'} (fe : is-equiv f)
         (g : A → B) (h : A → C) where
  Pushout-vert-extend≃ : Pushout g h ≃ Pushout (f ∘ g) h
  Pushout-vert-extend≃ = Pushout-equiv fe (ι₁ {f = g} {h})
                      ∙≃ Pushout-vert-∘ f g h e⁻¹

}
%```
}
