\date{2025-11-17}
\title{Simplicial types}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\subtree[stt-00AB]{
\taxon{Remark}
\p{This module, as almost all in \code{Synthetic.Categories} assumes a
type #{\Delta^1} with a distributive lattice structure, we
call this type the generic interval.}
}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Simplicial
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Core.Join
open import Core.CanonicalPushouts
open import Ergonomics.Auto
}
%```


\subtree[stt-00AC]{
\taxon{Definition}
\title{Simplicial types}

\p{If we don't assume that the interval is totally ordered, we can speak of
particular types which \em{'see'} the interval as totally ordered. This can be
made precise by asking for types which are [null](stt-005G) with respect to the
family of propositions #{(i \le j) \lor (j \le i)}.}

%```agda
\agda{
is-simplicial : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
is-simplicial = is-null {I = Î”Â¹ Ã— Î”Â¹} Î» (i , j) â†’ (i â‰¤ j) * (j â‰¤ i)
}
%```



\p{By virtue of being defined in terms of nullification at a proposition, we know
that simplicial types form a lex [#{\Sigma}-closed](stt-006E)
[reflective subuniverse](stt-0065).}

%```agda
\agda{
Simplicial-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Simplicial-SubU = Null-SubU (Î» ((i , j) : Î”Â¹ Ã— Î”Â¹) â†’ (i â‰¤ j) * (j â‰¤ i)) _

Simplicial-GSU : GSU (_âŠ” ğ“˜)
Simplicial-GSU = Null-GSU (Î» ((i , j) : Î”Â¹ Ã— Î”Â¹) â†’ (i â‰¤ j) * (j â‰¤ i))

Simplicial-is-globally-reflective
  : is-globally-reflective Simplicial-GSU
Simplicial-is-globally-reflective = Null-globally-reflective

module Simp where
  open GRSUInduction Simplicial-is-globally-reflective
                     Null-globally-Î£-closed public

  open GSU Simplicial-GSU public renaming (S-equiv to is-simplicialâ†equiv)

  open is-globally-reflective Simplicial-is-globally-reflective public

  Î£-is-simplicial = Null-globally-Î£-closed
}
%```
}


\subtree[tot-000T]{
\title{Retracts of the cube}

\p{Under the modest assumption that #{\Delta^2} is a simplicial type,
we have a retract of the inclusion #{\Delta^2 \to I^2}.}


%```agda
\agda{
â–¡Â² : Type ğ“˜
â–¡Â² = Î”Â¹ Ã— Î”Â¹

â–¡â†Î” : Î”Â² â†’ â–¡Â²
â–¡â†Î” (i , j) = (i , j)

-- Follows from simplicial types forming a lex modality
-- polynomial-is-simplicial : is-simplicial Î”Â¹ â†’ is-simplicial Î”Â²
-- polynomial-is-simplicial s = Simp.is-simplicialâ†equiv (Î”Â²-reprâ‰ƒ eâ»Â¹)
--                                (Simp.Î£-is-simplicial s (Î» i â†’ {!!}))

retract-â–¡ : is-simplicial Î”Â² â†’ retract â–¡â†Î”
retract-â–¡ s .fst (i , j) = is-equiv.bwd (s (i , j))
                            (cogap
                              (mk-cocone
                                (Î» x â†’ (j , i) â¦ƒ x â¦„)
                                (Î» x â†’ (i , j) â¦ƒ x â¦„)
                                Î» (p , q) â†’ let eq = sym p âˆ™ âˆ§-comm âˆ™ q
                                             in Î”Â²-ext (sym eq , eq)))
retract-â–¡ s .snd (i , j) = unap-equiv (s (i , j))
                             ( is-equiv.Îµ (s (i , j)) _
                             âˆ™ funextâ†’ (pushout-ind _
                                     (mk-coconeD
                                       (Î» q â†’ let eq = (sym auto! âˆ™ âˆ§-comm âˆ™ q)
                                              in Î”Â²-ext (eq , sym eq))
                                       (Î» _ â†’ Î”Â²-refl)
                                       Î» _ â†’ is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)))
}
%```
}
