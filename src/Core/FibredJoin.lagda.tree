\date{2025-07-30}
\title{Fibred joins and the modified image construction}
\taxon{module}
\meta{module}{Core.FibredJoin}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.FibredJoin where

open import Foundations.Prelude
open import ufAxioms

open import Core.Slice
open import Core.Coequalisers
open import Core.CanonicalSeqColims
open import Core.Image
}
%```

\subtree[stt-0084]{
\title{The Fibred Join}
\taxon{definition}

\p{Given a cospan #{A \xrightarrow{f} B \xleftarrow{g} C}, and a
particular choice of pullback over this span #{A \times'_B C}, we can
form the fibred join #{A *^B C \to B} as the following colimit:}

\quiver{
\begin{tikzcd}
	{A \times'_B C} &&& A \\
	\\
	&& {A *^BC} \\
	C &&& B
	\arrow[from=1-1, to=1-4]
	\arrow[from=1-1, to=4-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=4-4]
	\arrow[from=1-4, to=3-3]
	\arrow["f", from=1-4, to=4-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[dashed, from=3-3, to=4-4]
	\arrow[from=4-1, to=3-3]
	\arrow["g"', from=4-1, to=4-4]
\end{tikzcd}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         (f : A â†’ B) (g : C â†’ B) {PB : Type ğ“œ}
         (pb : Cone (mk-cospan B f g) PB)
         (PB-is-pb : is-pullbackÏ‰ (mk-cospan _ f g) pb) where
  open Cone pb renaming (i to Ï€â‚ ; j to Ï€â‚‚)

  Fibre-join : Type (ğ“¤ âŠ” ğ“¦ âŠ” ğ“œ)
  Fibre-join = Pushout Ï€â‚ Ï€â‚‚

  Fibre-join-Ï€ : Fibre-join â†’ B
  Fibre-join-Ï€ = pushout-rec (Coconeâ†Cone (_ , PB , pb) .snd .snd)
}
%```
}

\subtree[stt-008K]{
\title{Fibred joins preserve universal embedding}
\taxon{lemma}
\citet{3.1}{rijke-2017}

\p{Let #{f} be a map #{A \to B}, then given a map #{f' : A' \to B}
together with a triangle #{f \to f'}, if #{f'} is a
[universal embedding](stt-008H), then so is #{f * f'}.}

\proof{

\p{Let #{i : I' \hookrightarrow B} be an embedding.  To show #{f * f'}
is universal, we need to show the map #{(f * f' \to i) \to (f \to i)}
given by postcomposition is an equivalence, but because #{i} is an
embedding this is a map between propositions, so it suffices to give a
map in the opposite direction. Then let #{k} be a map #{k : f \to i},
and by the assumption that #{f'} is a universal embedding, we
also have a map #{\varphi^i(k) : f' \to i}. These maps are arranged
in the diagram below:}

\quiver{
\begin{tikzcd}
	{A\times_B A'} && {A'} \\
	\\
	A && {A *_B A'} \\
	&&& {I'} \\
	&&&&& B
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow["{\varphi^i(k)}", curve={height=-6pt}, dashed, from=1-3, to=4-4]
	\arrow["{f'}", curve={height=-24pt}, from=1-3, to=5-6]
	\arrow[from=3-1, to=3-3]
	\arrow["k"', from=3-1, to=4-4]
	\arrow["f"', curve={height=18pt}, from=3-1, to=5-6]
	\arrow[dashed, from=3-3, to=4-4]
	\arrow["{f*f'}", curve={height=-12pt}, dashed, from=3-3, to=5-6]
	\arrow["i"{description}, from=4-4, to=5-6]
\end{tikzcd}
}

\p{To construct the map #{j : A *_B A' \to I'}, we need to show that the
square with #{k} and #{\varphi^i(k)} commutes, but because #{i} is an
embedding, it suffices to show the outer square commutes. Now, by
pasting together triangles, we have #{f \sim ij\iota_1} and
#{f' \sim ij\iota_2}, which by the universal property of pullbacks
gives us #{ij \sim f * f'} as required.}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“¦} {B : Type ğ“¥}
         (f : A â†’ B) (f' : A' â†’ B) (tri : Slice-map f f')
         {PB : Type ğ“¤}
         (pb : Cone (mk-cospan B f f') PB)
         (is-pb : is-pullbackÏ‰ _ pb) where
  open Cone pb renaming (i to Ï€â‚ ; j to Ï€â‚‚)

  Fibre-join-slice-map : Slice-map f (Fibre-join-Ï€ f f' pb is-pb)
  Fibre-join-slice-map .fst = Î¹â‚
  Fibre-join-slice-map .snd = ~refl

  Fibre-join-is-universal-embedding
    : is-universal-embedding f f' tri
    â†’ is-universal-embedding
        f
        (Fibre-join-Ï€ f f' pb is-pb)
        Fibre-join-slice-map
  Fibre-join-is-universal-embedding emb i iemb
    = _â‰ƒ_.has-is-eqv (is-equivâ†logical
                       (slice-embedding-is-prop iemb)
                       (slice-embedding-is-prop iemb)
                       (_ , map)) where

    module Ï† = is-equiv (emb i iemb)

    map : Slice-map f i â†’ Slice-map (Fibre-join-Ï€ f f' pb is-pb) i
    map k .fst = pushout-rec (mk-cocone
      (k .fst)
      (Ï†.bwd  k .fst)
      (iemb â—‚emb (k .snd â–¸ Ï€â‚ ~âˆ™ filler ~âˆ™ (Ï†.bwd k .snd â–¸ Ï€â‚‚ ~â»Â¹))))
    map k .snd = pushout-ind _ (mk-coconeD
      (k .snd)
      (Ï†.bwd k .snd)
      Î» a â†’ IdP-funcâ†Square (glue a) _ _
              (ap (_âˆ™ Ï†.bwd k .snd (Ï€â‚‚ a))
                  ( ap-âˆ˜ i _ (glue a)
                  âˆ™ ap (ap i) (pushout-rec-apÎ² a)
                  âˆ™ is-equiv.Îµ iemb _)
              âˆ™ (ap (_âˆ™ Ï†.bwd k .snd (Ï€â‚‚ a)) (sym (âˆ™-assoc (k .snd _) (filler a) _))
              âˆ™ âˆ™-assoc (k .snd _ âˆ™ filler a) (sym _) _
              âˆ™ ap ((k .snd _ âˆ™ filler a) âˆ™_) (âˆ™-sym' (Ï†.bwd k .snd _)))
              âˆ™ âˆ™-reflr _
              âˆ™ ap (k .snd (Ï€â‚ a) âˆ™_) (sym (pushout-rec-apÎ² a))))
}
%```
}


\subtree[stt-008F]{
\title{Iterated fibred join}
\taxon{definition}

\p{Given a map #{f : A \to B}, we can mutually define the iterated
fibred join as a [sequence of types](stt-0085) together with maps down
into #{B}.}

\quiver{
\begin{tikzcd}
	A && {A*^BA} && {(A *^B A) *^B A} && {...} \\
	\\
	&& B
	\arrow["{\iota_2}", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-3]
	\arrow["{\iota_2}", from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=1-7]
	\arrow[from=1-5, to=3-3]
	\arrow[from=1-7, to=3-3]
\end{tikzcd}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
         {PB : Type ğ“¤ â†’ Type ğ“¤}
         (pb : âˆ€ {A' : Type ğ“¤} (g : A' â†’ B) â†’ Cone (mk-cospan B f g) (PB A'))
         (is-pb : âˆ€ {A'} {g} â†’  is-pullbackÏ‰ _ (pb {A'} g)) where

  Im-aprox : â„• â†’ Type ğ“¤
  Im-cocone  : âˆ€ {n} â†’ Im-aprox n â†’ B

  Im-aprox zero = A
  Im-aprox (suc n) = Fibre-join f (Im-cocone {n}) (pb Im-cocone) is-pb

  Im-cocone {zero} = f
  Im-cocone {suc n} = Fibre-join-Ï€ f Im-cocone (pb Im-cocone) is-pb

  Im-slice-map : âˆ€ {n} â†’ Slice-map (Im-cocone {n}) (Im-cocone {suc n})
  Im-slice-map .fst = Î¹â‚‚
  Im-slice-map .snd = ~refl

  iterated-join : Incr-seq ğ“¤
  iterated-join .Incr-seq.Point = Im-aprox
  iterated-join .Incr-seq.incr  = Î¹â‚‚

  iterated-join-cocone : Cocone-seq iterated-join B
  iterated-join-cocone .Cocone-seq.Î¹ = Im-cocone
  iterated-join-cocone .Cocone-seq.comm = ~refl

  Im-cone : âˆ€ {n} â†’ A â†’ Im-aprox n
  Im-cone {zero} = id
  Im-cone {suc n} = Î¹â‚

  Im-coneâˆ˜cocone : âˆ€ {n} â†’ Im-cocone âˆ˜ Im-cone {n} ~ f
  Im-coneâˆ˜cocone {zero} = ~refl
  Im-coneâˆ˜cocone {suc n} = ~refl
}
%```
}

\subtree[stt-008G]{
\title{The modified image of a map}
\taxon{construction}

%```agda
\agda{
module Im' {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
         {PB : Type ğ“¤ â†’ Type ğ“¤}
         (pb : âˆ€ {A' : Type ğ“¤} (g : A' â†’ B) â†’ Cone (mk-cospan B f g) (PB A'))
         (is-pb : âˆ€ {A'} {g} â†’  is-pullbackÏ‰ _ (pb {A'} g)) where

  Im' : Type ğ“¤
  Im' = Seq-colimit (iterated-join f pb is-pb)

  proj : A â†’ Im'
  proj = Î¹-seq _

  incl : Im' â†’ B
  incl = seq-colim-rec (iterated-join-cocone f pb is-pb)

  factors : Slice-map f incl
  factors .fst = proj
  factors .snd = ~refl

  im-slice-map : âˆ€ n â†’ Slice-map f (Im-cocone _ pb is-pb {n})
  im-slice-map n = ( Im-cone _ pb is-pb
                 , Im-coneâˆ˜cocone f pb is-pb {n})

  all-univ : âˆ€ n
             â†’ is-universal-embedding
                f
                (Im-cocone _ pb is-pb)
                (im-slice-map n)
  all-univ zero
    = is-universal-embeddingâ†logical f _ _ Î» _ _ â†’ id
  all-univ (suc n)
    = Fibre-join-is-universal-embedding f _ (im-slice-map n)
                                        _ is-pb (all-univ n)

  universal : is-universal-embedding f incl factors
  universal
    = is-universal-embeddingâ†logical f incl factors map where
      map : âˆ€ {ğ“¦} {I' : Type ğ“¦}
              (i' : I' â†’ B) â†’ is-embedding i'
            â†’ Slice-map f i' â†’ Slice-map incl i'
      map i' iemb fi' .fst = seq-colim-rec (mk-cocone-seq
        (Î» {n} â†’ is-equiv.bwd (all-univ n i' iemb) fi' .fst)
        ~refl)
      map i' iemb fi' .snd = pushout-ind _
        (mk-coconeD
          (uncurry Î» n â†’ is-equiv.bwd (all-univ n i' iemb) fi' .snd)
          (uncurry Î» n â†’ is-equiv.bwd (all-univ n i' iemb) fi' .snd)
          (âŠ-ind
            ( (uncurry Î» n a â†’ IdP-funcâ†Square (glue (inl (n , a))) _ _
                      ( ap (_âˆ™ (is-equiv.bwd (all-univ n i' iemb) fi' .snd a))
                           ( ap-âˆ˜ i' _ (glue (inl (n , a)))
                           âˆ™ ap (ap i') (pushout-rec-apÎ² (inl (n , a))))
                      âˆ™ sym (ap ((is-equiv.bwd (all-univ n i' iemb) fi' .snd a) âˆ™_)
                                (pushout-rec-apÎ² (inl (n , a)))
                      âˆ™ âˆ™-reflr _)))
            , uncurry Î» n a â†’ IdP-funcâ†Square (glue (inr (n , a))) _ _
                 let e = is-equiv.bwd (all-univ n i' iemb) fi' .snd a
                 in ap (_âˆ™ e) ( ap-âˆ˜ i' _ (glue (inr _))
                              âˆ™ ap (ap i') (pushout-rec-apÎ² _))
                    âˆ™ sym ( ap (e âˆ™_) (pushout-rec-apÎ² _)
                          âˆ™ âˆ™-reflr _))))

  -- incl-is-embedding : is-embedding incl
  -- incl-is-embedding
  --   = is-embeddingâ†is-prop-map Î»
  --      b â†’ is-propâ†is-single-if-inhabited Î» f â†’ lem b f where

  --   fib-seq : (b : B) â†’ Incr-seq (ğ“¤ âŠ” ğ“¥)
  --   fib-seq b .Incr-seq.Point n = fibre (Im-cocone f pb is-pb {n}) b
  --   fib-seq b .Incr-seq.incr = total-map-fst Î¹â‚‚

  --   all-constant : âˆ€ b (a : fibre f b) n
  --                  â†’ (fib-seq b .Incr-seq.incr {n}
  --                     ~ Î» _ â†’ total-map-fst Î¹â‚ a)
  --   all-constant b (a , p) zero  = {!!}
  --   all-constant b (a , p) (suc n) = {!!}

  --   lem3 : (b : B) â†’ fibre f b â†’ is-singleton (Seq-colimit (fib-seq b))
  --   lem3 x (y , p) = {!!}

  --   lem2 : (a : B) â†’ fibre f a â†’ is-singleton (fibre incl a)
  --   lem2 b p = {!!}

  --   sm : Slice-map incl (fst {B = is-singleton âˆ˜ fibre incl})
  --   sm = is-equiv.bwd (universal fst (is-embeddingâ†is-prop-map
  --                       (Î£Ìƒ-Ï€-emb (mk-subtype (Î» _ â†’ is-single-is-prop)))))
  --                     (total-map lem2 âˆ˜ refl-fibre f , ~refl)

  --   lem : âˆ€ (b : B) (f : fibre incl b)
  --         â†’ is-singleton (fibre (Î» v â†’ incl v) b)
  --   lem = Slice-family {!sm!}

}
%```
}
