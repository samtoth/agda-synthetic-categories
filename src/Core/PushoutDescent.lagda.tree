\date{2025-08-01}
\title{Descent for pushouts}
\taxon{module}
\meta{module}{Core.PushoutDescent}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.PushoutDescent where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
}
%```

\subtree[stt-008D]{
\title{Flattening lemma for pushouts}
\taxon{theorem}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         (f : A â†’ B) (g : A â†’ C) where
  total-span : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
               â†’ Span _ _ _
  total-span P .Span.Centre = Î£ A (P âˆ˜ Î¹â‚‚ âˆ˜ g)
  total-span P .Span.Left = Î£ B (P âˆ˜ Î¹â‚)
  total-span P .Span.left (a , b) = (f a , tr P (sym (glue a)) b)
  total-span P .Span.Right = Î£ C (P âˆ˜ Î¹â‚‚)
  total-span P .Span.right = total-map-fst g

  total-cocone : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                 â†’ Cocone (total-span P) (Î£ (Pushout f g) P)
  total-cocone P .Cocone.p = total-map-fst Î¹â‚
  total-cocone P .Cocone.q = total-map-fst Î¹â‚‚
  total-cocone P .Cocone.filler (a , b)
    = Î£-pathâ†’ ( glue a , trâˆ™tr-sym' (glue a) b)

  total-is-pushout : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                     â†’ is-pushoutÏ‰ (total-span P) (total-cocone P)
  total-is-pushout P {ğ“ } {Q} = eqv where
    module S' = Span (total-span P)

    Q' : Pushout f g â†’ Type _
    Q' x = P x â†’ Q

    lem2 : âˆ€ {a b} (p : a ï¼ b) {x} {f : P a â†’ Q}
           â†’ (tr Q' p f) x ï¼ f (tr P (sym p) x)
    lem2 refl = refl

    curry-cocone : Cocone (total-span P) Q
           â†’ CoconeD _ pushout Q'
    curry-cocone (mk-cocone p q filler) = mk-coconeD (curry p) (curry q) Î»
      a â†’ funextâ†’ Î» b â†’ lem2 (glue a) âˆ™ curry filler a b

    H : Arrow-map (cocone-map _ (total-cocone P) {Q})
                  (coconeáµˆ-map (mk-span _ f g) pushout {Q'})
    H .Arrow-map.top = curry
    H .Arrow-map.bot = curry-cocone
    H .Arrow-map.comm h
      = ap (mk-coconeD (Î» a b â†’ h (Î¹â‚ a , b)) (Î» a b â†’ h (Î¹â‚‚ a , b)))
           (funextâ†’ Î» a â†’ J {a = Î¹â‚ (f a)} (Î» z G â†’
                 funextâ†’ (Î» b â†’ lem2 G âˆ™ ap h (Î£-pathâ†’ (G , trâˆ™tr-sym' G b)))
               ï¼ apáµˆ (curry h) G)
           funext-refl
           {Î¹â‚‚ (g a)} (glue a))

    curry-cocone-is-equiv : quasi-iso curry-cocone
    curry-cocone-is-equiv .fst (mk-coconeD p q filler)
      = mk-cocone (uncurry p) (uncurry q)
          Î» where (a , b) â†’ sym (lem2 (glue a)) âˆ™ happly (filler a) b
    curry-cocone-is-equiv .snd .fst (mk-cocone p q filler)
      = Cocone-pathâ†’ _  _ (funextâ†’ ~refl) (funextâ†’ ~refl)
          Î» a â†’ âˆ™-reflr _ âˆ™ sym'âˆ™ (lem2 (glue (fst a))) (filler a)
    curry-cocone-is-equiv .snd .snd (mk-coconeD p q filler)
      = ap (mk-coconeD p q) (funextâ†’ Î»
         a â†’   ap funextâ†’ (funextâ†’ (Î» b â†’ symâˆ™ (lem2 (glue a))
                                            (happly (filler a) b)))
             âˆ™ _â‰ƒ_.Î· funextâ‰ƒ (filler a))

    arr-eq : is-Arrow-equiv H
    arr-eq .fst = curry-is-equiv
    arr-eq .snd = is-equivâ†qiso curry-cocone-is-equiv

    eqv : is-equiv (cocone-map _ (total-cocone P))
    eqv = is-equivâ†Arrow-equivâ»Â¹ {F = H} arr-eq Pushout-is-pushoutÏ‰áµˆ
}
%```
}
