\date{2025-06-19}
\title{Pathsplit maps}
\taxon{module}
\meta{module}{\startverb foundations.PathSplit \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module foundations.PathSplit where

open import foundations.Universes
open import foundations.Functions
open import foundations.FunctionInverses
open import foundations.Sigma
open import foundations.Identity
open import foundations.QuasiIsomorphism
open import foundations.CoherentIsomorphism
open import foundations.EquivOfSingleton
open import foundations.EquivProp
open import foundations.SingletonClosure
open import foundations.Singleton
open import foundations.Embedding
open import foundations.EquivSingleton
open import foundations.CanonicalPullbacks
open import foundations.FibrewiseEquiv
open import foundations.TheoremOfChoice
open import foundations.CompositionEquiv
open import foundations.CurryEquiv
open import foundations.SigmaProperties
open import foundations.IdentityEquiv
open import foundations.PullbackPath

open import foundations.FunExt as FE
}
%```

\subtree[stt-005Q]{
\title{Pathsplit maps}
\taxon{definition}

\p{A map #{f : A \to B} is \em{pathsplit} when there
is a section of #{f} and for each #{x, y : A}, there
is a section of #{\rm{ap}_f^{x,y}}.}

%```agda
\agda{
is-pathsplit : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                 (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-pathsplit f = section f Ã— (âˆ€ x y â†’ section (ap f {x} {y}))
}
%```
}

\subtree[stt-005R]{
\title{Pathsplit maps are equivalences}
\taxon{theorem}

\p{To show a [pathsplit](stt-005Q) map #{f : A \to B},
is an equivalence, it surfices to give a retract of #{f}.
We can show that #{fgf = f} where #{g} is the given section,
and since #{\rm{ap}_f} has a section we derive that #{fg = id}.}

%```agda
\agda{
is-equivâ†is-pathsplit : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                           {f : A â†’ B}
                         â†’ is-pathsplit f
                         â†’ is-equiv f
is-equivâ†is-pathsplit {f = f} ((g , sec) , apsec)
  = is-equivâ†qiso Î» where
      .fst â†’ g
      .snd .fst a â†’ apsec _ a .fst (sec (f a))
      .snd .snd â†’ sec
}
%```
}

\subtree[stt-005S]{
\title{Being pathsplit is equivalent to being an equivalence}
\taxon{theorem}

\p{We want to show that the map defined in \ref{stt-005R} is an
equivalence.}

\proof{
\p{To show the map is an equivalence, [it suffices](stt-005T)
to assume the codomain is inhabited. Becuase [being an equivalence
is a property](stt-001Y), we just need to show that the domain is a
singleton. Then if the map is already an equivalence,
[it's type of sections is a singleton](stt-000Q), and it is
an embedding so the type of sections of #{\rm{ap}} is also a singleton.}
}


%```agda
\agda{
module PSWithFunExt (FE : FunExt-global) where
  is-equivâ‰ƒis-pathsplit : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                             {f : A â†’ B}
                           â†’ is-pathsplit f
                           â‰ƒ is-equiv f
  is-equivâ‰ƒis-pathsplit {f = f}
    = mkâ‰ƒ is-equivâ†is-pathsplit (is-equivâ†is-equiv-if-cod (Î»
        e â†’ is-equivâ†single-to-prop
             (Singleton-Î£ (section-is-singleâ†qinv FE (qisoâ†is-equiv e))
                          Î» _ â†’ Singleton-Î  FE
                           Î» a â†’ Singleton-Î  FE
                            Î» b â†’ section-is-singleâ†qinv FE
                                   (qisoâ†is-equiv (is-embeddingâ†is-equiv e)))
             (is-equiv-is-prop FE) _))

  is-pathsplitâ†is-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                            {f : A â†’ B}
                          â†’ is-equiv f
                          â†’ is-pathsplit f
  is-pathsplitâ†is-equiv = _â‰ƒ_.bwd is-equivâ‰ƒis-pathsplit
}
%```
}

\subtree[stt-005V]{
\title{Begin pathsplit is a proposition}
\taxon{corollary}

\p{Any type equivalent to a proposition is a proposition,
so from \ref{stt-005S} it follows being pathsplit is a proposition.}

%```agda
  \agda{
  is-pathsplit-is-prop : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
                           {f : A â†’ B}
                         â†’ is-prop (is-pathsplit f)
  is-pathsplit-is-prop = is-propâ†equiv-to-prop
                             (is-equivâ‰ƒis-pathsplit eâ»Â¹)
                             (is-equiv-is-prop FE)
  }
%```
}

\subtree[stt-005U]{
\title{Pathsplitness via the diagonal}
\taxon{theorem}
\p{The type \code{is-pathsplit f} is equivalent to the type
#{\rm{section}(f) \times \rm{section}(\Delta_f)}, where #{f}
is the [diagonal map](stt-005X) associated to a pullback.}

\proof{
\p{We show #{\rm{section}(\Delta_f) \simeq \Pi_{(x,y : A)}\rm{section}(\rm{ap}_{x,y}(f))}
by calculation:}

##{
\begin{align*}
  \rm{section}(\Delta_f) &\simeq
    \Sigma_{(g : A \times_B A \to A)} \Pi_{(x : A \times_B A)} (g(x), g(x), \refl) = x\\
  &\simeq \Pi_{(x, y : A)} \Pi_{(p : x = y)} \Sigma_{a : A} (a , a , \refl) = (x, y, p) \\
  &\simeq \Pi_{(x, y : A)} \Pi_{(p : x = y)} \Sigma_{a : A}
    \Sigma_{(q : a ï¼ x)} \Sigma_{(r : a = y)} (\rm{ap}_f(q) \cdot p = \rm{ap}_f(r)) \\
  &\simeq \Pi_{(x, y : A)} \Pi_{(p : x = y)}
          \Sigma_{(r : a = y)} (p = \rm{ap}_f(r)) \\
  &\simeq \Pi_{(x, y: A)} \rm{section}(\rm{ap}_f)
\end{align*}
}
}

%```agda
\agda{
  is-pathsplitâ‰ƒsec-diag
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
        {f : A â†’ B}
      â†’ (section f Ã— section (diagonal f)) â‰ƒ is-pathsplit f
  is-pathsplitâ‰ƒsec-diag {A = A}{f = f} = Î£-ap-â‰ƒ Î» a
    â†’ section (diagonal f) â‰ƒâŸ¨âŸ©
      Î£[ g âˆ¶ (Pullback f f â†’ A)] (âˆ€ pb â†’ (g pb , g pb , refl) ï¼ pb)

         â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ _ (Î» pb a â†’ (a , a , refl) ï¼ pb) eâ»Â¹  âŸ©

      ((x : Pullback f f) â†’ Î£[ a âˆ¶ A ] ((a , a , refl) ï¼ x))

          â‰ƒâŸ¨ precomp-Î -â‰ƒ FE(Î» c â†’ Î£-ap-â‰ƒ (Î» _ â†’ pullback-path _ _)) âŸ©

      (âˆ€ (x : Pullback f f) â†’ Î£[ a âˆ¶ A ] pullback-Path (a , a , refl) x)

         â‰ƒâŸ¨ curryâ‰ƒ âŸ©

      (âˆ€ x (y : Î£ _ (Î» vâ‚ â†’ f x ï¼ f vâ‚)) â†’
        Î£[ a âˆ¶ A ] pullback-Path (a , a , refl) (x , y))

         â‰ƒâŸ¨ precomp-Î -â‰ƒ FE (Î» c â†’ curryâ‰ƒ) âŸ©

      (âˆ€ x y (p : f x ï¼ f y) â†’
          Î£[ z âˆ¶ A ] Î£[ P âˆ¶ (z ï¼ x)] Î£[ Q âˆ¶ (z ï¼ y)]
            ((ap f P) âˆ™ p ï¼ ap f Q))

          â‰ƒâŸ¨ precomp-Î -â‰ƒ FE (Î» _ â†’ precomp-Î -â‰ƒ FE Î» _
              â†’ precomp-Î -â‰ƒ FE Î» c â†’ Î£-ï¼singl) âŸ©

      ((x y : A) (p : f x ï¼ f y) â†’ (Î£[ Q âˆ¶ (x ï¼ y)] (p ï¼ ap f Q)))

        â‰ƒâŸ¨ precomp-Î -â‰ƒ FE (Î» _ â†’
             precomp-Î -â‰ƒ FE (Î» _ â†’
               Î£-Î -swapâ‰ƒ _ _ âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» _ â†’ precomp-Î -â‰ƒ FE (Î» _ â†’ symâ‰ƒ)))) âŸ©

      (âˆ€ x y â†’ section (ap f)) â‰ƒâˆ

  is-pathsplitâ†sec-diag
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
        {f : A â†’ B}
      â†’ section f
      â†’ section (diagonal f)
      â†’ is-pathsplit f
  is-pathsplitâ†sec-diag sec secd = sec ,
    _â‰ƒ_.fwd is-pathsplitâ‰ƒsec-diag (sec , secd) .snd

  sec-diagâ†is-pathsplit
    : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
        {f : A â†’ B}
      â†’ is-pathsplit f
      â†’ section (diagonal f)
  sec-diagâ†is-pathsplit = snd âˆ˜ _â‰ƒ_.bwd is-pathsplitâ‰ƒsec-diag
}
%```
}
