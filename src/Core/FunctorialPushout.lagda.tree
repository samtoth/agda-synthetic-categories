\title{Pushouts are functorial over the span diagram}
\author{samueltoth}
\date{2025-11-20}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Core.FunctorialPushout where

open import ufAxioms
open import Foundations.Prelude
open import Core.CanonicalPushouts
open import Core.SpanMap
open import Core.Postwhisker
}
%```


\subtree[stt-00B1]{
\title{Span maps induce functors of pushouts}
\taxon{Theorem}

%```agda
\agda{
Pushout-functorial-cocone
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' ğ“›}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S; module S' = Span S'
      in (F : Span-map S S')
      â†’ {P' : Type ğ“›} (Pc' : Cocone S' P')
      â†’ Cocone S P'
Pushout-functorial-cocone F Pc'
  = mk-cocone (Pc'.p âˆ˜ F.hâ‚) (Pc'.q âˆ˜ F.hâ‚ƒ)
              (  Pc'.p â—‚ F.H
              ~âˆ™ Pc'.filler â–¸ F.hâ‚‚
              ~âˆ™ Pc'.q â—‚ (F.K ~â»Â¹)) where
  module Pc' = Cocone Pc'
  module F = Span-map F

Pushout-mapâ†span-map : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' ğ“œ ğ“›}
                {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
              â†’ let module S = Span S; module S' = Span S'
                in (F : Span-map S S')
                â†’ {P : Type ğ“œ} (Pc : Cocone S P)
                  (Po : is-pushoutÏ‰ S Pc)
                  {P' : Type ğ“›} (Pc' : Cocone S' P')
                â†’ P â†’ P'
Pushout-mapâ†span-map F pcc po pcc'
  = is-equiv.bwd po (Pushout-functorial-cocone F pcc')

Pushout-map-id
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {P : Type ğ“œ} {Pc : Cocone S P}
      (Po : is-pushoutÏ‰ S Pc)
    â†’ Pushout-mapâ†span-map id-span-map Pc Po
                           (Pushout-functorial-cocone id-span-map Pc)
    ï¼ id
Pushout-map-id po
  = ap (is-equiv.bwd po) (ap (mk-cocone _ _)
                         (funextâ†’ (Î» a â†’ âˆ™-reflr _ âˆ™ âˆ™-reflr _ âˆ™ sym (ap-id _))))
  âˆ™ is-equiv.Î· po id

Pushout-functorial-span
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S; module S' = Span S'
      in (F : Span-map S S')
    â†’ Pushout S.left S.right â†’ Pushout S'.left S'.right
Pushout-functorial-span F = cogap (Pushout-functorial-cocone F pushout)

Canonical-pushout-map-id
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
  â†’ id ~ Pushout-functorial-span (id-span-map {S = S})
Canonical-pushout-map-id
  = pushout-rec-unique _ _ ~refl ~refl Î» a â†’ ap (_âˆ™ refl) (ap-id (glue a))

Canonical-Pushout-map-compose
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' ğ“¤'' ğ“¥'' ğ“¦''}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'} {S'' : Span ğ“¤'' ğ“¥'' ğ“¦''}
      (F : Span-map S' S'') (G : Span-map S S')
    â†’ Pushout-functorial-span F âˆ˜ Pushout-functorial-span G
    ~ Pushout-functorial-span (compose-span-map F G)
Canonical-Pushout-map-compose {S = S} F G
  = pushout-rec-unique
          (Pushout-functorial-cocone (compose-span-map F G) pushout)
          (Pushout-functorial-span F âˆ˜ Pushout-functorial-span G)
          ~refl
          ~refl
          (~âˆ™-reflr _
          ~âˆ™ ap-âˆ˜ (Pushout-functorial-span F) (Pushout-functorial-span G) âˆ˜ glue
          ~âˆ™ (Î» x â†’ ap (ap (Pushout-functorial-span F)) (pushout-rec-apÎ² x))
          ~âˆ™ Î» xÂ â†’ ap-âˆ™âˆ™ (Pushout-functorial-span F)
                         (ap Î¹â‚ (G.H x)) (glue (G.hâ‚‚ x)) (ap Î¹â‚‚ (sym (G.K x)))
                  âˆ™   apâ‚ƒ (Î» x y z â†’ x âˆ™ y âˆ™ z)
                         (sym (ap-âˆ˜ (Pushout-functorial-span F) Î¹â‚ (G.H x)))
                         (pushout-rec-apÎ² (G.hâ‚‚ x))
                         (sym (ap-âˆ˜ (Pushout-functorial-span F) Î¹â‚‚ (sym (G.K x))))
                  âˆ™ lem) where
    module F = Span-map F
    module G = Span-map G
    lem : {x : G.S.Centre} â†’
      ap (Î» a â†’ Î¹â‚ (F.hâ‚ a)) (G.H x) âˆ™
      (ap Î¹â‚ (F.H (G.hâ‚‚ x)) âˆ™
       glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™ ap Î¹â‚‚ (sym (F.K (G.hâ‚‚ x))))
      âˆ™ ap (Î» a â†’ Î¹â‚‚ (F.hâ‚ƒ a)) (sym (G.K x))
      ï¼
      ap Î¹â‚ (ap F.hâ‚ (G.H x) âˆ™ F.H (G.hâ‚‚ x)) âˆ™
      glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™ ap Î¹â‚‚ (sym (ap F.hâ‚ƒ (G.K x) âˆ™ F.K (G.hâ‚‚ x)))
    lem {x}
      = ap (Î¹â‚ âˆ˜ F.hâ‚) (G.H x) âˆ™
         (ap Î¹â‚ (F.H (G.hâ‚‚ x)) âˆ™
          glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™ ap Î¹â‚‚ (sym (F.K (G.hâ‚‚ x))))
         âˆ™ ap (Î¹â‚‚ âˆ˜ F.hâ‚ƒ) (sym (G.K x))

          ï¼âŸ¨ apâ‚‚ _âˆ™_ (ap-âˆ˜ Î¹â‚ F.hâ‚ (G.H x))
                     (âˆ™-assoc (ap Î¹â‚ (F.H (G.hâ‚‚ x)))
                              (glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™ ap Î¹â‚‚ (sym (F.K (G.hâ‚‚ x))))
                              (ap (Î¹â‚‚ âˆ˜ F.hâ‚ƒ) (sym (G.K x)))) âŸ©
        ap Î¹â‚ (ap F.hâ‚ (G.H x)) âˆ™
         ap Î¹â‚ (F.H (G.hâ‚‚ x)) âˆ™
         (glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™ ap Î¹â‚‚ (sym (F.K (G.hâ‚‚ x)))) âˆ™
         ap (Î¹â‚‚ âˆ˜ F.hâ‚ƒ) (sym (G.K x))

         ï¼âŸ¨ sym (âˆ™-assoc (ap Î¹â‚ (ap F.hâ‚ (G.H x))) (ap Î¹â‚ (F.H (G.hâ‚‚ x))) _)
             âˆ™ ap (_âˆ™ _) (sym (ap-âˆ™ Î¹â‚ (ap F.hâ‚ (G.H x)) (F.H (G.hâ‚‚ x)))) âŸ©

        ap Î¹â‚ (ap F.hâ‚ (G.H x) âˆ™ F.H (G.hâ‚‚ x)) âˆ™
         (glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™ ap Î¹â‚‚ (sym (F.K (G.hâ‚‚ x)))) âˆ™
         ap (Î¹â‚‚ âˆ˜ F.hâ‚ƒ) (sym (G.K x))

         ï¼âŸ¨ ap (ap Î¹â‚ (ap F.hâ‚ (G.H x) âˆ™ F.H (G.hâ‚‚ x)) âˆ™_)
              (âˆ™-assoc (glue (F.hâ‚‚ (G.hâ‚‚ x))) _ _
              âˆ™ ap (glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™_)
                   (ap (ap Î¹â‚‚ _ âˆ™_) (ap-âˆ˜ Î¹â‚‚ F.hâ‚ƒ (sym (G.K x))
                                    âˆ™ ap (ap Î¹â‚‚) (ap-sym F.hâ‚ƒ (G.K x)))
                   âˆ™ sym (ap-âˆ™ Î¹â‚‚ (sym (F.K (G.hâ‚‚ x))) _)
                   âˆ™ ap (ap Î¹â‚‚) ( sym (âˆ™-symsym (ap F.hâ‚ƒ (G.K x)) (F.K (G.hâ‚‚ x)))))) âŸ©

        ap Î¹â‚ (ap F.hâ‚ (G.H x) âˆ™ F.H (G.hâ‚‚ x)) âˆ™
         glue (F.hâ‚‚ (G.hâ‚‚ x)) âˆ™ ap Î¹â‚‚ (sym (ap F.hâ‚ƒ (G.K _) âˆ™ F.K (G.hâ‚‚ _))) âˆ

Pushout-functorial-qiso
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      (F : Span-map S S')
    â†’ Span-quasi-iso F
    â†’ quasi-iso (Pushout-functorial-span F)
Pushout-functorial-qiso F x .fst = Pushout-functorial-span (x .Span-quasi-iso.bwd)
Pushout-functorial-qiso F x .snd .fst
  = Canonical-Pushout-map-compose (x .Span-quasi-iso.bwd) F
  ~âˆ™ happly (ap Pushout-functorial-span (Span-map-funextâ†’ (x .Span-quasi-iso.Îµ)))
  ~âˆ™ (Canonical-pushout-map-id ~â»Â¹)
Pushout-functorial-qiso F x .snd .snd
  = Canonical-Pushout-map-compose F (x .Span-quasi-iso.bwd)
  ~âˆ™ happly (ap Pushout-functorial-span (Span-map-funextâ†’ (x .Span-quasi-iso.Î·)))
  ~âˆ™ (Canonical-pushout-map-id ~â»Â¹)

Pushout-equivâ†logical
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ is-prop-span S â†’ is-prop-span S'
    â†’ Span-logical-equiv S S'
    â†’ Pushout (Span.left S) (Span.right S)
    â‰ƒ Pushout (Span.left S') (Span.right S')
Pushout-equivâ†logical sp s'p le
  = mkâ‰ƒ (Pushout-functorial-span fwd)
        (is-equivâ†qiso (Pushout-functorial-qiso fwd fwd-qiso)) where
  open Span-logical-equiv sp s'p le
}
%```
}
