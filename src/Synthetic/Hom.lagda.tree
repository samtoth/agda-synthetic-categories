\date{2025-09-11}
\title{Synthetic Hom Types}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
open import Foundations.Prelude

module Synthetic.Hom {ğ“˜} (I : Type ğ“˜) (i0 i1 : I) where

open import Foundations.IdentitySystem

open import Ergonomics.Representation
open import Ergonomics.Extensionality
}
%```

\subtree[stt-00A9]{
\title{Hom types}
\taxon{Definition}

\p{For any bi-pointed type #{I}, we can define the type of synthetic
homomorphisms, which are just (possibly-dependent) functions with specified
end-points.}

\remark{
\p{In this generality, there is not a lot of motivation to call these types
\strong{hom} types. They admit identity homs, but in general not composition.
The idea is that this module will be instantiated with an interval for which
certain types have a notion of fibrancy, and for those fibrant types, the hom
type will deserve it's name.}
}

%```agda
\agda{
record HomP {ğ“¤} (A : I â†’ Type ğ“¤) (a : A i0) (b : A i1) : Type (ğ“¤ âŠ” ğ“˜) where
  constructor mk-hom
  field
    hom  : Î  I A
    hom0 : hom i0 ï¼ a
    hom1 : hom i1 ï¼ b


unquoteDecl HomP-reprâ‰… HomP-reprâ‰ƒ
  = make-record-repr HomP-reprâ‰… HomP-reprâ‰ƒ (quote HomP)

Î»hom : âˆ€ {ğ“¤} {A : I â†’ Type ğ“¤} (f : Î  I A) â†’ HomP A (f i0) (f i1)
Î»hom f = mk-hom f refl refl

Hom : âˆ€ {ğ“¤} (A : Type ğ“¤) (a b : A) â†’ Type (ğ“¤ âŠ” ğ“˜)
Hom A a b = HomP (Î» _ â†’ A) a b

{-# NOINLINE Hom #-}

idH : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ (a : A) â†’ Hom A a a
idH a = Î»hom Î» _ â†’ a
}
%```

\remark{
\p{Unlike in [Cubical Agda](https://agda.readthedocs.io/en/latest/language/cubical.html)
or the [Rzk proof assistant](https://rzk-lang.github.io/rzk/en/latest/),
these hom types do not require their endpoints to be definitionally equal, but only
equal up to a path. It is possible to simulate the \em{definitional} path types
with an indexed-inductive type but this pushes Agda's elaboration beyond what it
is really designed for, and the usability suffers.
}

}
}

\subtree[stt-00AN]{
\title{Extensionality for homs}
\taxon{Theorem}

\p{A homorphism #{\Hom_A(x,y)} constist of the data of a map #{C^{\Delta^2}}
together with a pair of identifications. To define a path in #{\Hom_A(x,y)}
between #{f} and #{g}, we need a homotopy #{H} of the underlying maps, but also
coherence data: #{H_{0} \sim g_0 \sim f_0} for #{i = 0,1}.}

%```agda
\agda{
Hom-path : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (f g : Hom A x y)
           â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom-path (mk-hom f p q) (mk-hom g r s)
  = Î£[ H âˆ¶ f ~ g ] ((H i0 âˆ™ r ï¼ p) Ã— (H i1 âˆ™ s ï¼ q))

opaque
  Hom-path-torsorial : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (f : Hom A x y)
                       â†’ is-singleton (Î£[ g âˆ¶ Hom A x y ] Hom-path f g)
  Hom-path-torsorial f
    = is-singleâ†equiv-to-single (Î£-ap-â‰ƒ-fst (HomP-reprâ‰ƒ eâ»Â¹))
        (is-singleton-structureâ†parts
          (SingS-is-single (f .HomP.hom))
          (f .HomP.hom , ~refl)
          (is-singleton-structureâ†parts
            Sing'-is-singleton
            (_ , refl)
            Sing'-is-singleton))

instance
  IdS-Hom : âˆ€ {ğ“¤}{A : Type ğ“¤} {x y : A} â†’ Identity-system (Hom A x y) (ğ“˜ âŠ” ğ“¤)
  IdS-Hom .Identity-system.IdS = Hom-path
  IdS-Hom .Identity-system.IdSâ†Id refl = (~refl , refl , refl)
  IdS-Hom .Identity-system.has-is-ids f
    = fundamental-Id (Hom-path f) (Hom-path-torsorial f) _


Hom-extâ†’ : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} {f g : Hom A x y}
          â†’ Hom-path f g â†’ f ï¼ g
Hom-extâ†’ = ext!
}
%```
}
