\title{Lattices}
\date{2025-06-19}
\taxon{Module}
\author{markwilliams}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Algebra.Lattice where

open import ufAxioms
open import Foundations.Prelude
open import Algebra.Poset
open import Modalities.Instances.Truncation
open import Core.CoSlice
open import Ergonomics.Auto
open import Ergonomics.Universal
open import Ergonomics.Marker
open import Ergonomics.Representation
open import Ergonomics.Extensionality
}
%```

\subtree[stt-009T]{
\title{Lattices}
\taxon{Definition}
\p{A lattice #{L} is an algebraic strucutre with two operations
   #{\wedge,\vee : L \to L \to L}, satisfying absorption laws.
   Equivalently this structure can be described by a poset, with
   operations taking binary meets and joins for each pair of
   elements.}

%```agda
\agda{

record is-lattice {ğ“¤} {L : Type ğ“¤} (0l 1l : L) (_âˆ§_ : L â†’ L â†’ L)
                  (_âˆ¨_ : L â†’ L â†’ L) : Type ğ“¤ where
  no-eta-equality
  field
    car-is-set  : is-truncated 2 L
    âˆ§-assoc : {x y z : L} â†’ x âˆ§ (y âˆ§ z) ï¼ (x âˆ§ y) âˆ§ z
    âˆ¨-assoc : {x y z : L} â†’ x âˆ¨ (y âˆ¨ z) ï¼ (x âˆ¨ y) âˆ¨ z
    âˆ§-comm : {x y : L} â†’ x âˆ§ y ï¼ y âˆ§ x
    âˆ¨-comm : {x y : L} â†’ x âˆ¨ y ï¼ y âˆ¨ x
    âˆ¨-âˆ§-abs : {x y : L} â†’ x âˆ¨ (x âˆ§ y) ï¼ x
    âˆ§-âˆ¨-abs : {x y : L} â†’ x âˆ§ (x âˆ¨ y) ï¼ x
    0-bottom : {x : L} â†’ x âˆ¨ 0l ï¼ x
    1-top    : {x : L} â†’ x âˆ§ 1l ï¼ x

record Lattice {â„“} (L : Type â„“) : Type â„“ where
  field
    0l 1l : L
    _âˆ§_ : L â†’ L â†’ L
    _âˆ¨_ : L â†’ L â†’ L
    str-is-lattice : is-lattice 0l 1l (_âˆ§_) (_âˆ¨_)
  infixr 25 _âˆ§_
  infixr 24 _âˆ¨_

  _â‰¤_ : L â†’ L â†’ Type â„“
  x â‰¤ y = x âˆ§ y ï¼ x

  open is-lattice str-is-lattice public

  is-set-separated : âˆ€ x y â†’ is-prop (x ï¼ y)
  is-set-separated x y = is-propâ†is-truncated (car-is-set x y)

  1-coinit : âˆ€ {x} â†’ x âˆ¨ 1l ï¼ 1l
  1-coinit {x}
    =   x âˆ¨ 1l
      ï¼âŸ¨ ap (_âˆ¨ 1l) (sym 1-top âˆ™ âˆ§-comm) âŸ©
        (1l âˆ§ x) âˆ¨ 1l
      ï¼âŸ¨ âˆ¨-comm âˆ™ âˆ¨-âˆ§-abs âŸ©
        1l âˆ

  0-init : âˆ€ {x} â†’ 0l âˆ§ x ï¼ 0l
  0-init {x}
    =   0l âˆ§ x
      ï¼âŸ¨ ap (0l âˆ§_) (sym (âˆ¨-comm âˆ™ 0-bottom)) âŸ©
        (0l âˆ§ (0l âˆ¨ x))
      ï¼âŸ¨ âˆ§-âˆ¨-abs âŸ©
        0l âˆ

  âˆ§-idem : âˆ€ {x : L} â†’ x âˆ§ x ï¼ x
  âˆ§-idem {x} = x âˆ§ x             ï¼âŸ¨ ap (x âˆ§_) (sym âˆ¨-âˆ§-abs) âŸ©
               x âˆ§ (x âˆ¨ (x âˆ§ x)) ï¼âŸ¨ âˆ§-âˆ¨-abs âŸ©
               x âˆ

  âˆ¨-idem : âˆ€ {x : L} â†’ x âˆ¨ x ï¼ x
  âˆ¨-idem {x} = (x âˆ¨ x)        ï¼âŸ¨ ap (x âˆ¨_) (sym 1-top) âŸ©
               (x âˆ¨ (x âˆ§ 1l)) ï¼âŸ¨ âˆ¨-âˆ§-abs âŸ©
               x âˆ

  âˆ¨-âˆ§-abs' : âˆ€ {a b} â†’ (a âˆ¨ b) âˆ§ b ï¼ b
  âˆ¨-âˆ§-abs' = ap (_âˆ§ _) âˆ¨-comm âˆ™ âˆ§-comm âˆ™ âˆ§-âˆ¨-abs

  âˆ§-âˆ¨-abs' : âˆ€ {a b} â†’ (a âˆ§ b) âˆ¨ b ï¼ b
  âˆ§-âˆ¨-abs' = ap (_âˆ¨ _) âˆ§-comm âˆ™ âˆ¨-comm âˆ™ âˆ¨-âˆ§-abs

  â‰¤-is-poset : is-poset (_â‰¤_)
  â‰¤-is-poset =
    record { â‰¤-is-prop = â‰¤-is-prop
           ; â‰¤-refl = â‰¤-refl
           ; â‰¤-trans = â‰¤-trans
           ; â‰¤-antisym = â‰¤-antisym }
    where
      â‰¤-is-prop : {x y : L} â†’ is-prop (x â‰¤ y)
      â‰¤-is-prop = is-set-separated _ _

      â‰¤-refl : {x : L} â†’ x â‰¤ x
      â‰¤-refl = âˆ§-idem

      â‰¤-trans : {x y z : L} â†’ x â‰¤ y â†’ y â‰¤ z â†’ x â‰¤ z
      â‰¤-trans {x} {y} {z} p q =  x âˆ§ z        ï¼âŸ¨  ap (_âˆ§ z) (sym p)  âŸ©
                                  (x âˆ§ y) âˆ§ z ï¼âŸ¨ sym âˆ§-assoc âŸ©
                                  x âˆ§ (y âˆ§ z) ï¼âŸ¨ ap (x âˆ§_) q âŸ©
                                  x âˆ§ y       ï¼âŸ¨ p âŸ©
                                  x âˆ

      â‰¤-antisym : {x y : L} â†’ x â‰¤ y â†’ y â‰¤ x â†’ x ï¼ y
      â‰¤-antisym {x} {y} p q = sym p âˆ™ âˆ§-comm âˆ™ q


  open is-poset â‰¤-is-poset public

  â‰¤-max : âˆ€ {a b} â†’ a â‰¤ b â†’ a âˆ¨ b ï¼ b
  â‰¤-max {a} {b} p
    = a âˆ¨ b             ï¼âŸ¨ ap (_âˆ¨ b) (sym p) âŸ©
      (a âˆ§ b) âˆ¨ b       ï¼âŸ¨ âˆ§-âˆ¨-abs' âŸ©
      b âˆ

  â‰¤â†âˆ¨ : âˆ€ {a b} â†’ a âˆ¨ b ï¼ b â†’ a â‰¤ b
  â‰¤â†âˆ¨ {a} {b} p
    = a âˆ§ b           ï¼âŸ¨ ap (a âˆ§_) (sym p) âŸ©
      a âˆ§ (a âˆ¨ b)     ï¼âŸ¨ âˆ§-âˆ¨-abs âŸ©
      a âˆ

  âˆ¨-UP : âˆ€ {a b c} â†’ a â‰¤ c Ã— b â‰¤ c â†’ (a âˆ¨ b â‰¤ c)
  âˆ¨-UP {a} {b} {c} (f , g)
    = â‰¤â†âˆ¨ (sym âˆ¨-assoc âˆ™ â‰¤-max (ap (a âˆ§_) (â‰¤-max g) âˆ™ f) âˆ™ â‰¤-max g)

  âˆ¨-UP-is-equiv : âˆ€ {a b c} â†’ is-equiv (âˆ¨-UP {a}{b}{c})
  âˆ¨-UP-is-equiv {a} {b} {c} = is-equivâ†inverse
                    (is-prop-Î£ (is-set-separated _ _) Î» _ â†’ is-set-separated _ _)
                    (is-set-separated _ _)
                    Î» x â†’ ap (_âˆ§ _) (sym (âˆ§-âˆ¨-abs {a}{b}) )
                          âˆ™ sym âˆ§-assoc âˆ™ ap (a âˆ§_) x
                          âˆ™ âˆ§-âˆ¨-abs
                        , ap (_âˆ§ _) (sym (âˆ§-âˆ¨-abs {b} {a}))
                          âˆ™ sym âˆ§-assoc
                          âˆ™ ap (b âˆ§_) (ap (_âˆ§ c) âˆ¨-comm âˆ™ x âˆ™ âˆ¨-comm)
                          âˆ™ âˆ§-âˆ¨-abs

  âˆ¨-â‰¤-introl : âˆ€ {a b c} â†’ a â‰¤ b â†’ a â‰¤ (b âˆ¨ c)
  âˆ¨-â‰¤-introl p = â‰¤-trans p âˆ§-âˆ¨-abs

  âˆ¨-â‰¤-intror : âˆ€ {a b c} â†’ a â‰¤ c â†’ a â‰¤ (b âˆ¨ c)
  âˆ¨-â‰¤-intror p = â‰¤-trans p (ap (_ âˆ§_) âˆ¨-comm âˆ™ âˆ§-âˆ¨-abs)

  âˆ§-UP : âˆ€ {a b c} â†’ a â‰¤ b Ã— a â‰¤ c â†’ a â‰¤ b âˆ§ c
  âˆ§-UP (p , q) = âˆ§-assoc âˆ™ ap (_âˆ§ _) p âˆ™ q

  âˆ§-â‰¤-eliml : âˆ€ {a b c} â†’ a â‰¤ c â†’ (a âˆ§ b) â‰¤ c
  âˆ§-â‰¤-eliml {a}{b}{c} p = âˆ§-comm âˆ™ âˆ§-assoc âˆ™ ap (_âˆ§ b) (âˆ§-comm âˆ™ p)

  âˆ§-â‰¤-elimr : âˆ€ {a b c} â†’ b â‰¤ c â†’ (a âˆ§ b) â‰¤ c
  âˆ§-â‰¤-elimr {a}{b}{c} q = sym âˆ§-assoc âˆ™ ap (a âˆ§_) q

  instance
    â‰¤-bot : âˆ€ {i} â†’ 0l â‰¤ i
    â‰¤-bot = 0-init

    â‰¤-refl-inst : âˆ€ {i} â†’ i â‰¤ i
    â‰¤-refl-inst = â‰¤-refl

    â‰¤-top = 1-top
    {-#Â INCOHERENT â‰¤-refl-inst â‰¤-top #-}

    â‰¤-âˆ§ : âˆ€ {a b c d} â†’ â¦ƒ _ : a â‰¤ b â¦„ â†’ â¦ƒ _ : c â‰¤ d â¦„
          â†’ (a âˆ§ c) â‰¤ (b âˆ§ d)
    â‰¤-âˆ§ = âˆ§-UP (âˆ§-â‰¤-eliml auto! , âˆ§-â‰¤-elimr auto!)

    â‰¤-âˆ¨ : âˆ€ {a b c d} â†’ â¦ƒ _ : a â‰¤ b â¦„ â†’ â¦ƒ _ : c â‰¤ d â¦„
          â†’ (a âˆ¨ c) â‰¤ (b âˆ¨ d)
    â‰¤-âˆ¨ = âˆ¨-UP (âˆ¨-â‰¤-introl auto! , âˆ¨-â‰¤-intror auto!)
}
%```
}

\subtree[stt-00A4]{
\title{Lattice homomorphisms}
\taxon{Definition}

\p{Given [lattice structures](stt-009T) #{L} and #{M} over sets #{A} and #{B}, we say
that a function #{f : A \to B} is a \strong{lattice homomorphism} when it
preserves the lattice operations. Being a lattice homomorphisms is a
[property](stt-0009) of a function.}

%```agda
\agda{
record is-lattice-hom
        {ğ“¤} {ğ“¤'} {A : Type ğ“¤} {B : Type ğ“¤'}
        (L : Lattice A) (M : Lattice B) (f : A â†’ B) : Type (ğ“¤ âŠ” ğ“¤') where
  private
    module A = Lattice L
    module B = Lattice M
  field
    pres-âˆ¨ : {x y : A} â†’ f (x A.âˆ¨ y) ï¼ f x B.âˆ¨ f y
    pres-âˆ§ : {x y : A} â†’ f (x A.âˆ§ y) ï¼ f x B.âˆ§ f y
    pres-0 : f A.0l ï¼ B.0l
    pres-1 : f A.1l ï¼ B.1l

unquoteDecl lattice-hom-reprâ‰… lattice-hom-reprâ‰ƒ
  = make-record-repr lattice-hom-reprâ‰… lattice-hom-reprâ‰ƒ
                     (quote is-lattice-hom)

is-lattice-hom-is-prop
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
      (L : Lattice A) (M : Lattice B) (f : A â†’ B)
    â†’ is-prop (is-lattice-hom L M f)
is-lattice-hom-is-prop L M f
  = is-propâ†equiv-to-prop
      (lattice-hom-reprâ‰ƒ eâ»Â¹)
      (is-prop-Î£ (is-prop-Î áµ¢ (is-prop-Î áµ¢ (is-set-separated _ _)))
        Î» _ â†’ is-prop-Î£
               ((is-prop-Î áµ¢ (is-prop-Î áµ¢ (is-set-separated _ _))))
               Î» _ â†’ is-prop-Î£
                 (is-set-separated _ _)
                   Î» _ â†’ is-set-separated _ _) where
   open Lattice M
}
%```
}

\subtree[stt-009Z]{
\taxon{Definition}
\title{Lattice algebras and algebra morphisms}

\p{Fixing a lattice #{L}, we say that a lattice #{M} with a map of sets from
#{L} (that is - an object of the [coslice category](stt-0062) under #{L}) is a
lattice algebra if the underlying function is a
[lattice homomorphism](stt-009Y). Given a pair of coslices #{f} and #{g} under
#{L} which are lattice algebras, we say that a [coslice map](stt-0062) #{f \to
g} is a lattice algebra homomorphism if the underlying map is a
[lattice homomorphism](stt-009Y). }

%```agda
\agda{
is-lattice-algebra : âˆ€ {ğ“¤ ğ“¥ : Level} {A : Type ğ“¤} {B : Type ğ“¥}
                       (L : Lattice A) (M : Lattice B) (f : A â†’ B)
                     â†’ Type (ğ“¤ âŠ” ğ“¥)
is-lattice-algebra = is-lattice-hom

is-lattice-alg-hom : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                        (L : Lattice A)
                        (M : Lattice B) {f : A â†’ B}
                      â†’ is-lattice-algebra L M f
                      â†’ (N : Lattice C) {g : A â†’ C}
                      â†’ is-lattice-algebra L N g
                      â†’ Coslice-map f g â†’ Type (ğ“¥ âŠ” ğ“¦)
is-lattice-alg-hom L M _ N _ (h , H) = is-lattice-hom M N h

}
%```
}

\subtree[stt-00A0]{
\taxon{Theorem}
\title{The initial lattice algebra}

\p{The initial coslice (the identity function) is also the initial lattice
algebra.}

%```agda
\agda{
initial-lattice-algebra : âˆ€ {ğ“¤ : Level} {A : Type ğ“¤} (L : Lattice A)
                          â†’ is-lattice-algebra L L id
initial-lattice-algebra L .is-lattice-hom.pres-âˆ¨ = refl
initial-lattice-algebra L .is-lattice-hom.pres-âˆ§ = refl
initial-lattice-algebra L .is-lattice-hom.pres-0 = refl
initial-lattice-algebra L .is-lattice-hom.pres-1 = refl

initial-lattice-algebra-is-initial
  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (L : Lattice A) {X : Type ğ“¥} (M : Lattice X)
      {f : A â†’ X}
    â†’ (falg : is-lattice-algebra L M f)
    â†’ is-singleton
        (Î£ _ (is-lattice-alg-hom L L (initial-lattice-algebra L) M falg))
initial-lattice-algebra-is-initial L M {f} falg
  = mk-singl (initial-coslice f .centre , falg)
             (is-prop-Î£ (is-propâ†is-single (initial-coslice f))
                        (Î» a â†’ is-lattice-hom-is-prop _ _ _) _)
}
%```
}

\subtree[stt-009S]{
\title{Congruences}
\taxon{Definition}
\p{An equivalence relation #{\sim} on a lattice #{L} is a congruence if it
respects all lattice operations}

%```agda
\agda{
module Congruence where


record LatticeCongruence {ğ“¤ ğ“¥} {A : Type ğ“¤} (L : Lattice A)
                         (_~_ : A â†’ A â†’ Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  open Lattice L
  field
    ~-equivalence : is-equivalence-relation (_~_)
    ~-âˆ¨ : {a1 a2 b1 b2 : A} â†’ a1 ~ b1 â†’ a2 ~ b2 â†’ a1 âˆ¨ a2 ~ b1 âˆ¨ b2
    ~-âˆ§ : {a1 a2 b1 b2 : A} â†’ a1 ~ b1 â†’ a2 ~ b2 â†’ a1 âˆ§ a2 ~ b1 âˆ§ b2

  open is-equivalence-relation (~-equivalence) public


module _ {ğ“¤} {ğ“¥} {A : Type ğ“¤} {L : Lattice A} where
  open Lattice L
  data âŸª_âŸ« (R : A â†’ A â†’ Type ğ“¥) : A â†’ A â†’ Type (ğ“¤ âŠ” ğ“¥) where
    âŸªâŸ«-inc  : {a b : A} â†’ R a b â†’ âŸª R âŸ« a b
    âŸªâŸ«-refl : {a : A} â†’ âŸª R âŸ« a a
    âŸªâŸ«-sym  : {a b : A} â†’ âŸª R âŸ« a b â†’ âŸª R âŸ« b a
    âŸªâŸ«-trans : {a b c : A} â†’ âŸª R âŸ« a b â†’ âŸª R âŸ« b c â†’ âŸª R âŸ« a c
    âŸªâŸ«-âˆ¨ : {a1 a2 b1 b2 : A} â†’ âŸª R âŸ« a1 b1 â†’ âŸª R âŸ« a2 b2 â†’ âŸª R âŸ« (a1 âˆ¨ a2) (b1 âˆ¨ b2)
    âŸªâŸ«-âˆ§ : {a1 a2 b1 b2 : A} â†’ âŸª R âŸ« a1 b1 â†’ âŸª R âŸ« a2 b2 â†’ âŸª R âŸ« (a1 âˆ§ a2) (b1 âˆ§ b2)

  âŸªâŸ«-congruence : {R : A â†’ A â†’ Type ğ“¥}
                â†’ LatticeCongruence L (Î» x y â†’ âˆ¥ âŸª R âŸ« x y âˆ¥)
  âŸªâŸ«-congruence {R} = l-con where
    open LatticeCongruence
    open Trunc {1}
    module E = is-equivalence-relation

    l-eq : is-equivalence-relation (Î» x y â†’ âˆ¥ âŸª R âŸ« x y âˆ¥)
    l-eq .E.~-is-prop = is-propâ†is-truncated â—‹âˆˆS
    l-eq .E.reflexive = Î· âŸªâŸ«-refl
    l-eq .E.symmetric a = do
      rxy â† a
      return (âŸªâŸ«-sym rxy)
    l-eq .E.transitive a b = do
      rxy â† a
      ryz â† b
      return (âŸªâŸ«-trans rxy ryz)

    l-con : LatticeCongruence L (Î» x y â†’ âˆ¥ âŸª _ âŸ« x y âˆ¥)
    l-con .~-equivalence = l-eq
    l-con .~-âˆ¨ p q = do
      r1 â† p
      r2 â† q
      return (âŸªâŸ«-âˆ¨ r1 r2)
    l-con .~-âˆ§ p q = do
      r1 â† p
      r2 â† q
      return (âŸªâŸ«-âˆ§ r1 r2)
}
%```
}


\subtree[stt-00A3]{
\title{Distributive lattices}
\taxon{Definition}

%```agda
\agda{
record is-distributive {ğ“¤} {L : Type ğ“¤} (Lat : Lattice L)  : Type ğ“¤ where
  open Lattice Lat

  field
    has-is-distrib : âˆ€ {x y z} â†’ x âˆ¨ (y âˆ§ z) ï¼ (x âˆ¨ y) âˆ§ (x âˆ¨ z)

  distrib-âˆ¨-âˆ§ = has-is-distrib

  distrib-âˆ¨-âˆ§' : âˆ€ {x y z} â†’ (x âˆ§ y) âˆ¨ z ï¼ (x âˆ¨ z) âˆ§ (y âˆ¨ z)
  distrib-âˆ¨-âˆ§' = âˆ¨-comm âˆ™ distrib-âˆ¨-âˆ§ âˆ™ apâ‚‚ _âˆ§_ âˆ¨-comm âˆ¨-comm

  distrib-âˆ§-âˆ¨ : âˆ€ {x y z} â†’ x âˆ§ (y âˆ¨ z) ï¼ (x âˆ§ y) âˆ¨ (x âˆ§ z)
  distrib-âˆ§-âˆ¨ {x} {y} {z}
    = âŒœ x âŒ âˆ§ (y âˆ¨ z)             ï¼âŸ¨ ap! (sym âˆ§-âˆ¨-abs) âŸ©
      ((x âˆ§ (x âˆ¨ z)) âˆ§ (y âˆ¨ z) )  ï¼âŸ¨ sym âˆ§-assoc âŸ©
      (x âˆ§ (x âˆ¨ z) âˆ§ (y âˆ¨ z))     ï¼âŸ¨ apâ‚‚ _âˆ§_
                                         (sym âˆ¨-âˆ§-abs âˆ™ âˆ¨-comm)
                                         (sym (distrib-âˆ¨-âˆ§')) âŸ©
      ((x âˆ§ y âˆ¨ x) âˆ§ (x âˆ§ y âˆ¨ z)) ï¼âŸ¨ sym distrib-âˆ¨-âˆ§ âŸ©
      ((x âˆ§ y) âˆ¨ (x âˆ§ z)) âˆ

  distrib-âˆ§-âˆ¨' : âˆ€ {x y z} â†’ (x âˆ¨ y) âˆ§ z ï¼ (x âˆ§ z) âˆ¨ (y âˆ§ z)
  distrib-âˆ§-âˆ¨' = âˆ§-comm âˆ™ distrib-âˆ§-âˆ¨ âˆ™ apâ‚‚ _âˆ¨_ âˆ§-comm âˆ§-comm

  distribâ‚‚-âˆ§-âˆ¨ : âˆ€ {x y z w}
                 â†’ x âˆ§ (y âˆ¨ z âˆ¨ w) ï¼ x âˆ§ y âˆ¨ x âˆ§ z âˆ¨ x âˆ§ w
  distribâ‚‚-âˆ§-âˆ¨ {x} {y}{z}{w}
    = distrib-âˆ§-âˆ¨ âˆ™ ap (x âˆ§ y âˆ¨_) distrib-âˆ§-âˆ¨

  distribâ‚‚-âˆ§-âˆ¨' : âˆ€ {x y z w}
                 â†’ (y âˆ¨ z âˆ¨ w) âˆ§ x ï¼ y âˆ§ x âˆ¨ z âˆ§ x âˆ¨ w âˆ§ x
  distribâ‚‚-âˆ§-âˆ¨' {x} {y}{z}{w}
    = âˆ§-comm âˆ™ distribâ‚‚-âˆ§-âˆ¨ âˆ™ apâ‚ƒ (Î» x y z â†’ x âˆ¨ (y âˆ¨ z)) âˆ§-comm âˆ§-comm âˆ§-comm

  opaque
    polynomial-mult
      : âˆ€ {aâ‚€ aâ‚ bâ‚€ bâ‚} x â†’
          (aâ‚€ âˆ¨ (aâ‚ âˆ§ x)) âˆ§ (bâ‚€ âˆ¨ (bâ‚ âˆ§ x))
        ï¼ (aâ‚€ âˆ§ bâ‚€) âˆ¨ (((aâ‚ âˆ§ bâ‚€) âˆ¨ (aâ‚€ âˆ§ bâ‚) âˆ¨ (aâ‚ âˆ§ bâ‚)) âˆ§ x)
    polynomial-mult {aâ‚€} {aâ‚} {bâ‚€} {bâ‚} x
      = (aâ‚€ âˆ¨ aâ‚ âˆ§ x) âˆ§ (bâ‚€ âˆ¨ bâ‚ âˆ§ x)
          ï¼âŸ¨ distrib-âˆ§-âˆ¨ âŸ©
        ((aâ‚€ âˆ¨ aâ‚ âˆ§ x) âˆ§ bâ‚€ âˆ¨ âŒœ (aâ‚€ âˆ¨ aâ‚ âˆ§ x) âˆ§ bâ‚ âˆ§ x âŒ)
          ï¼âŸ¨ ap! (âˆ§-assoc âˆ™ ap (_âˆ§ x) distrib-âˆ§-âˆ¨' âˆ™ distrib-âˆ§-âˆ¨' ) âŸ©
        ((aâ‚€ âˆ¨ aâ‚ âˆ§ x) âˆ§ bâ‚€ âˆ¨ (aâ‚€ âˆ§ bâ‚) âˆ§ x âˆ¨ âŒœ ((aâ‚ âˆ§ x) âˆ§ bâ‚) âˆ§ x âŒ)
          ï¼âŸ¨ ap! (ap (_âˆ§ x) (sym âˆ§-assoc âˆ™ ap (aâ‚ âˆ§_) âˆ§-comm) âˆ™ sym âˆ§-assoc
                     âˆ™ ap (aâ‚ âˆ§_) (sym âˆ§-assoc âˆ™ ap (bâ‚ âˆ§_) âˆ§-idem)) âŸ©
        (âŒœ (aâ‚€ âˆ¨ aâ‚ âˆ§ x) âˆ§ bâ‚€ âŒ âˆ¨ (aâ‚€ âˆ§ bâ‚) âˆ§ x âˆ¨ aâ‚ âˆ§ bâ‚ âˆ§ x)
          ï¼âŸ¨ ap! (distrib-âˆ§-âˆ¨'
                 âˆ™ ap (aâ‚€ âˆ§ bâ‚€ âˆ¨_) (sym âˆ§-assoc âˆ™ ap (aâ‚ âˆ§_) âˆ§-comm)) âŸ©
        ((aâ‚€ âˆ§ bâ‚€ âˆ¨ (aâ‚ âˆ§ bâ‚€ âˆ§ x)) âˆ¨ (aâ‚€ âˆ§ bâ‚) âˆ§ x âˆ¨ aâ‚ âˆ§ bâ‚ âˆ§ x)
          ï¼âŸ¨ apâ‚‚ _âˆ¨_ (ap (aâ‚€ âˆ§ bâ‚€ âˆ¨_) âˆ§-assoc)
                      (ap ((aâ‚€ âˆ§ bâ‚) âˆ§ x âˆ¨_) âˆ§-assoc âˆ™ sym distrib-âˆ§-âˆ¨') âŸ©
        ((aâ‚€ âˆ§ bâ‚€) âˆ¨ ((aâ‚ âˆ§ bâ‚€) âˆ§ x)) âˆ¨ (aâ‚€ âˆ§ bâ‚ âˆ¨ aâ‚ âˆ§ bâ‚) âˆ§ x
          ï¼âŸ¨ sym âˆ¨-assoc âˆ™ ap (aâ‚€ âˆ§ bâ‚€ âˆ¨_) (sym distrib-âˆ§-âˆ¨') âŸ©
        (aâ‚€ âˆ§ bâ‚€ âˆ¨ (aâ‚ âˆ§ bâ‚€ âˆ¨ aâ‚€ âˆ§ bâ‚ âˆ¨ aâ‚ âˆ§ bâ‚) âˆ§ x) âˆ

    polynomial-mult'
      : âˆ€ {aâ‚€ aâ‚ bâ‚€ bâ‚} x â†’
           ((aâ‚€ âˆ§ x) âˆ¨ aâ‚) âˆ§ ((bâ‚€ âˆ§ x) âˆ¨ bâ‚)
        ï¼ (((aâ‚€ âˆ§ bâ‚) âˆ¨ (aâ‚ âˆ§ bâ‚€) âˆ¨ (aâ‚€ âˆ§ bâ‚€)) âˆ§ x) âˆ¨ (aâ‚ âˆ§ bâ‚)
    polynomial-mult' {aâ‚€} {aâ‚} {bâ‚€} {bâ‚} x
      = ((aâ‚€ âˆ§ x âˆ¨ aâ‚) âˆ§ (bâ‚€ âˆ§ x âˆ¨ bâ‚))
          ï¼âŸ¨ apâ‚‚ _âˆ§_ âˆ¨-comm âˆ¨-comm âŸ©
        ((aâ‚ âˆ¨ aâ‚€ âˆ§ x) âˆ§ (bâ‚ âˆ¨ bâ‚€ âˆ§ x))
          ï¼âŸ¨ polynomial-mult x âŸ©
        (aâ‚ âˆ§ bâ‚ âˆ¨ (aâ‚€ âˆ§ bâ‚ âˆ¨ aâ‚ âˆ§ bâ‚€ âˆ¨ aâ‚€ âˆ§ bâ‚€) âˆ§ x)
          ï¼âŸ¨ âˆ¨-comm âŸ©
        ((aâ‚€ âˆ§ bâ‚ âˆ¨ aâ‚ âˆ§ bâ‚€ âˆ¨ aâ‚€ âˆ§ bâ‚€) âˆ§ x âˆ¨ aâ‚ âˆ§ bâ‚) âˆ
}
%```
}
