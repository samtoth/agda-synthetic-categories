\title{Maps between span diagrams}
\author{samueltoth}
\date{2025-11-21}
\taxon{Module}

\import{stt-macros}

%```agda
\agda{
module Core.SpanMap where

open import Foundations.Prelude
open import ufAxioms

open import Ergonomics.Marker
open import Ergonomics.Representation
open import Ergonomics.Extensionality

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CanonicalPushouts
}
%```


\subtree[stt-008M]{
\date{2025-08-03}
\title{Maps of spans}
\taxon{Definition}

\p{A map between spans #{S} and #{S'} is a diagram as follows where
all the squares commute:}

\quiver{
\begin{tikzcd}
	A && S && B \\
	\\
	{A'} && {S'} && {B'}
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=1-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=3-5]
	\arrow[from=3-3, to=3-1]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}


%```agda
\agda{
record Span-map {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                {ğ“¤' ğ“¥' ğ“¦'} (S' : Span ğ“¤' ğ“¥' ğ“¦')
                : Type (ğ“¤ âŠ” ğ“¤' âŠ” ğ“¥ âŠ” ğ“¥' âŠ” ğ“¦ âŠ” ğ“¦') where
   constructor mk-span-map
   module S = Span S
   module S' = Span S'
   field
     hâ‚ : S.Left â†’ S'.Left
     hâ‚‚ : S.Centre â†’ S'.Centre
     hâ‚ƒ : S.Right â†’ S'.Right
     H  : hâ‚ âˆ˜ S.left ~ S'.left âˆ˜ hâ‚‚
     K  : hâ‚ƒ âˆ˜ S.right ~ S'.right âˆ˜ hâ‚‚

   amap-lâ†“ : Arrow-map S.left S'.left
   amap-lâ†“ = mk-amap hâ‚‚ hâ‚ H

   amap-l : Arrow-map hâ‚‚ hâ‚
   amap-l = mk-amap S.left S'.left (H ~â»Â¹)

   amap-râ†“ : Arrow-map S.right S'.right
   amap-râ†“ = mk-amap hâ‚‚ hâ‚ƒ K

   amap-r : Arrow-map hâ‚‚ hâ‚ƒ
   amap-r = mk-amap S.right S'.right (K ~â»Â¹)

unquoteDecl Span-map-reprâ‰… Span-map-reprâ‰ƒ
  = make-record-repr Span-map-reprâ‰… Span-map-reprâ‰ƒ (quote Span-map)
}
%```

\p{Equivalently, a span map is a pair of arrow maps between the
left and right maps of each span, together with a homotopy between
the two maps between the centre of the spans.}

%```agda
\agda{
Arrow-mapsâ†Span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S'
    â†’ let module S = Span S ; module S' = Span S'
    in Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top)
Arrow-mapsâ†Span-map S = (amap-lâ†“ , amap-râ†“ , ~refl) where open Span-map S

Span-mapâ†Arrow-maps
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S ; module S' = Span S'
    in Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top)
    â†’ Span-map S S'
Span-mapâ†Arrow-maps (F , G , H)
  = funext-rec (Î» _ â†’ Span-map _ _) (Î» where
      refl â†’ mk-span-map F.bot G.top G.bot F.comm G.comm) H where
  module F = Arrow-map F
  module G = Arrow-map G

Span-mapâ‰ƒArrow-maps
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S ; module S' = Span S'
    in (Î£[ F âˆ¶ Arrow-map S.left S'.left ] Î£[ G âˆ¶ Arrow-map S.right S'.right ]
         (F .Arrow-map.top ~ G .Arrow-map.top))
    â‰ƒ Span-map S S'
Span-mapâ‰ƒArrow-maps = mkâ‰ƒ Span-mapâ†Arrow-maps (is-equivâ†qiso qiso) where
  qiso : quasi-iso Span-mapâ†Arrow-maps
  qiso .fst = Arrow-mapsâ†Span-map
  qiso .snd .fst x@(F , G , HH)
    = funext-rec
        (Î» HH'
          â†’ Arrow-mapsâ†Span-mapÂ (Span-mapâ†Arrow-maps (F , G , HH')) ï¼ (F , G , HH'))
        lem
        HH where
    open Span-map
    lem : (p : (Arrow-map.top F) ï¼ (Arrow-map.top G)) â†’
           Arrow-mapsâ†Span-map (Span-mapâ†Arrow-maps (F , G , happly p)) ï¼
           (F , G , happly p)
    lem refl =
      (Arrow-mapsâ†Span-map âˆ˜ Span-mapâ†Arrow-maps) (F , G , ~refl) ï¼âŸ¨âŸ©
      (mk-amap (Arrow-map.top G) _ _
      , mk-amap (Arrow-map.top G) (Arrow-map.bot G) (Arrow-map.comm G)
      , ~refl) ï¼âŸ¨âŸ©
      (F , G , ~refl) âˆ where open Span-map
  qiso .snd .snd = ~refl

span-map-pathPâ†’
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {S'' : Span ğ“¤' ğ“¥' ğ“¦'}
      {f : Span-map S' S} {g : Span-map S'' S}
    â†’ let module S = Span S
          module S' = Span S'
          module S'' = Span S''
          module f = Span-map f
          module g = Span-map g
    in (p : S'.Centre ï¼ S''.Centre)
    â†’ (q : S'.Left ï¼ S''.Left)
    â†’ (r : S'.Right ï¼ S''.Right)
    â†’ (h : coe r âˆ˜ S'.right ï¼ S''.right âˆ˜ coe p)
    â†’ (k : coe q âˆ˜ S'.left ï¼ S''.left âˆ˜ coe p)
    â†’ (Q : f.hâ‚ ï¼ g.hâ‚ âˆ˜ coe q)
    â†’ (P : f.hâ‚‚ ï¼ g.hâ‚‚ âˆ˜ coe p)
    â†’ (R : f.hâ‚ƒ ï¼ g.hâ‚ƒ âˆ˜ coe r)
    â†’ (H : f.H ï¼   (happly Q â–¸ S'.left) ~âˆ™ (g.hâ‚ â—‚ happly k)
                  ~âˆ™ (g.H â–¸ coe p) ~âˆ™ (S.left â—‚ happly (sym P)))
    â†’ (K : f.K ï¼ (happly R â–¸ S'.right) ~âˆ™ (g.hâ‚ƒ â—‚ happly h)
                 ~âˆ™ (g.K â–¸ coe p) ~âˆ™ S.right â—‚ (happly (sym P)))
    â†’ IdP (ap (Î» P â†’ Span-map P S) (Span-pathâ†’ p q r h k)) f g
span-map-pathPâ†’ refl refl refl refl refl refl refl refl refl refl
  = apâ‚‚ (Î» P Q â†’ mk-span-map _ _ _ P Q)
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))
        (funextâ†’ (Î» a â†’ âˆ™-reflr _))



is-Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S' â†’ Type (ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦' âŠ” ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
is-Span-equiv F = is-equiv hâ‚
                    Ã— is-equiv hâ‚‚
                    Ã— is-equiv hâ‚ƒ where
  open Span-map F

l-is-arrow-equivâ†is-span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ is-Arrow-equiv (Span-map.amap-lâ†“ F)
l-is-arrow-equivâ†is-span-equiv F eq
  = (eq .snd .fst , eq .fst)

r-is-arrow-equivâ†is-span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ is-Arrow-equiv (Span-map.amap-râ†“ F)
r-is-arrow-equivâ†is-span-equiv F eq
  = (eq .snd .fst , eq .snd .snd)

Spanâ»Â¹â†Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F : Span-map S S') â†’ is-Span-equiv F
    â†’ Span-map S' S
Spanâ»Â¹â†Span-equiv F (e1 , e2 , e3)
  = mk-span-map Fâ‚.bwd Fâ‚‚.bwd Fâ‚ƒ.bwd H1 H2 module Span-inv where
  module F = Span-map F
  module S = F.S
  module S' = F.S'
  module Fâ‚ = is-equiv e1
  module Fâ‚‚ = is-equiv e2
  module Fâ‚ƒ = is-equiv e3


  K1 : F.hâ‚ âˆ˜ Fâ‚.bwd âˆ˜ S'.left âˆ˜ F.hâ‚‚ ~ F.hâ‚ âˆ˜ S.left âˆ˜ Fâ‚‚.bwd âˆ˜ F.hâ‚‚
  K1 = (Fâ‚.Îµ â–¸ S'.left â–¸ F.hâ‚‚ ~âˆ™ (F.H ~â»Â¹) ~âˆ™ (F.hâ‚ â—‚ (S.left â—‚ Fâ‚‚.Î·) ~â»Â¹))

  H1 : Fâ‚.bwd âˆ˜ S'.left ~ S.left âˆ˜ Fâ‚‚.bwd
  H1 = e1 â—‚eqv K1 â–¸eqv e2

  K2 : F.hâ‚ƒ âˆ˜ Fâ‚ƒ.bwd âˆ˜ S'.right âˆ˜ F.hâ‚‚ ~ F.hâ‚ƒ âˆ˜ S.right âˆ˜ Fâ‚‚.bwd âˆ˜ F.hâ‚‚
  K2 = (Fâ‚ƒ.Îµ â–¸ S'.right â–¸ F.hâ‚‚) ~âˆ™ (F.K ~â»Â¹) ~âˆ™ (F.hâ‚ƒ â—‚ (S.right â—‚ Fâ‚‚.Î·) ~â»Â¹)

  H2 : Fâ‚ƒ.bwd âˆ˜ S'.right ~ S.right âˆ˜ Fâ‚‚.bwd
  H2 = e3 â—‚eqv K2 â–¸eqv e2
}
%```
}

\subtree[stt-00AJ]{
\title{Span map composition}
\taxon{Construction}
\date{2025-11-21}

%```agda
\agda{
compose-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦' ğ“¤'' ğ“¥'' ğ“¦''}
      {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'} {S'' : Span ğ“¤'' ğ“¥'' ğ“¦''}
    â†’ Span-map S' S'' â†’ Span-map S S'
    â†’ Span-map S S''
compose-span-map F G = map where
  module F = Span-map F
  module G = Span-map G

  map : Span-map _ _
  map .Span-map.hâ‚ = F.hâ‚ âˆ˜ G.hâ‚
  map .Span-map.hâ‚‚ = F.hâ‚‚ âˆ˜ G.hâ‚‚
  map .Span-map.hâ‚ƒ = F.hâ‚ƒ âˆ˜ G.hâ‚ƒ
  map .Span-map.H = (F.hâ‚ â—‚ G.H) ~âˆ™ (F.H â–¸ G.hâ‚‚)
  map .Span-map.K = F.hâ‚ƒ â—‚ G.K ~âˆ™ F.K â–¸ G.hâ‚‚

id-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
  â†’ Span-map S S
id-span-map = mk-span-map id id id ~refl ~refl

id-span-map-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
    â†’ is-Span-equiv (id-span-map {S = S})
id-span-map-is-equiv = (id-is-equiv , id-is-equiv , id-is-equiv)
}
%```
}

\subtree[stt-00AZ]{
\title{Univalence for spans}
\taxon{Theorem}

%```
\agda{
Span-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} (S : Span  ğ“¤ ğ“¥ ğ“¦) (S' : Span ğ“¤' ğ“¥' ğ“¦')
    â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
Span-equiv S S' = Î£[ F âˆ¶ Span-map S S' ] is-Span-equiv F

Span-equiv-lemma
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span  ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ let module S = Span S; module S' = Span S'
    in Span-equiv S S'
    â‰ƒ Î£[ F âˆ¶ (S.Centre â‰ƒ S'.Centre) ]
       Î£[ L âˆ¶ (S.Left â‰ƒ S'.Left)] Î£[ _ âˆ¶ (L ._â‰ƒ_.fwd âˆ˜ S.left ~ S'.left âˆ˜ F ._â‰ƒ_.fwd)]
         Î£[ R âˆ¶ (S.Right â‰ƒ S'.Right)] (R ._â‰ƒ_.fwd âˆ˜ S.right ~ S'.right âˆ˜ F ._â‰ƒ_.fwd)
Span-equiv-lemma = equivâ†qiso qiso where
  open Span-map
  qiso : _
  qiso ._â‰…_.fwd (smap , (leq , ceq , req))
    =
    ( mkâ‰ƒ (smap .hâ‚‚) ceq
    , mkâ‰ƒ (smap .hâ‚) leq
    , smap .H
    , mkâ‰ƒ (smap .hâ‚ƒ) req
    , smap .K)
  qiso ._â‰…_.fwd-iso .fst (mkâ‰ƒ c ceq , mkâ‰ƒ l leq , H , mkâ‰ƒ r req , K)
    = (mk-span-map l c r H K , leq , ceq , req)
  qiso ._â‰…_.fwd-iso .snd .fst = ~refl
  qiso ._â‰…_.fwd-iso .snd .snd = ~refl

Span-equivâ†Id
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S S' : Span ğ“¤ ğ“¥ ğ“¦}
    â†’ S ï¼ S' â†’ Span-equiv S S'
Span-equivâ†Id {S = S} refl = (id-span-map , id-span-map-is-equiv {S = S})

opaque
  Span-equivâ†Id-is-equiv
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S S' : Span ğ“¤ ğ“¥ ğ“¦} â†’ is-equiv (Span-equivâ†Id {S = S}{S'})
  Span-equivâ†Id-is-equiv {S = S} {S'}
    = fundamental-Id
       (Span-equiv S)
       (is-singleâ†equiv-to-single
         ((Î£-ap-â‰ƒ-fst
            {B = Î» (C , _ , f , _ , g) â†’ Span-equiv S (mk-span C f g) }
            Span-reprâ‰ƒ âˆ™â‰ƒ Î£-ap-â‰ƒ (Î» a â†’ Span-equiv-lemma)) eâ»Â¹)
         (is-singleton-structureâ†parts (SingS-is-single (Centre S))
          (S .Centre , idequiv)
          (is-singleton-structureâ†parts
           (SingS-is-single (Left S))
           (Left S , idequiv)
           (is-singleton-structureâ†parts
            (SingS-is-single (left S))
            (left S , ~refl)
            (is-singleton-structureâ†parts
              (SingS-is-single (Right S))
              (Right S , idequiv)
              (SingS-is-single (right S)))))))
       (Î» _ â†’ Span-equivâ†Id)
       S' where open Span

instance
  SpanIdS : âˆ€ {ğ“¤ ğ“¥ ğ“¦} â†’ Identity-system (Span ğ“¤ ğ“¥ ğ“¦) (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
  SpanIdS .Identity-system.IdS = Span-equiv
  SpanIdS .Identity-system.IdSâ†Id = Span-equivâ†Id
  SpanIdS .Identity-system.has-is-ids _ _ = Span-equivâ†Id-is-equiv
}
%```
}


\subtree[stt-00B0]{
\title{Homotopy of span maps}
\taxon{Definition}

%```agda
\agda{
Span-map-homotopy
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ (F G : Span-map S S') â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
Span-map-homotopy F G
  = Î£[ Hâ‚ âˆ¶ F.hâ‚ ~ G.hâ‚ ] Î£[ Hâ‚‚ âˆ¶ F.hâ‚‚ ~ G.hâ‚‚ ] Î£[ Hâ‚ƒ âˆ¶ F.hâ‚ƒ ~ G.hâ‚ƒ ]
       ( F.H ~ Hâ‚ â–¸ F.S.left ~âˆ™ G.H ~âˆ™ F.S'.left â—‚ (Hâ‚‚ ~â»Â¹)
       Ã—  F.K ~ Hâ‚ƒ â–¸ F.S.right ~âˆ™ G.K ~âˆ™ F.S'.right â—‚ (Hâ‚‚ ~â»Â¹)) where
  module F = Span-map F
  module G = Span-map G


Span-map-funextâ†’
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“¤' ğ“¥' ğ“¦'} {S : Span ğ“¤ ğ“¥ ğ“¦} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {F G : Span-map S S'} â†’ Span-map-homotopy F G â†’ F ï¼ G
Span-map-funextâ†’ {S = S} {S'} {F} {G} (p , q , r , s , t)
  = span-map-pathPâ†’ refl refl refl refl refl
     (funextâ†’ p) (funextâ†’ q) (funextâ†’ r)
     (funextâ†’ (Î» a â†’ s a âˆ™ ap ((p (S.left a) âˆ™_) âˆ˜ (G.H a âˆ™_))
                  (ap (ap G.S'.left) (sym (happly (happly-sym (funextâ†’ q) a) a)))))
     (funextâ†’ (Î» a â†’ t a âˆ™ ap ((r (S.right a) âˆ™_) âˆ˜ (G.K a âˆ™_))
                  (ap (ap S'.right) (sym (happly (happly-sym (funextâ†’ q) a) a))))) where
   module S = Span S
   module S' = Span S'
   module G = Span-map G

}
%```
}

\subtree[stt-00AM]{
\title{Isomorphisms of spans}
\taxon{Theorem}

\p{An equivalence of spans gives rise to a quasi-isomorphism in span. I.e. we
get a pair of span maps whose composition is homotopic to the identity span map.}


\remark{This remains to be formalised.}
}
