\date{2025-02-24}
\title{Embeddings}

\import{stt-macros}

\p{Embeddings are the homotopy coherent generalisation of injective functions}

% ```agda
\agda{
module foundations.Embedding where

open import foundations.Universes
open import foundations.Functions
open import foundations.Identity
open import foundations.Homotopy
open import foundations.CoherentIsomorphism
open import foundations.QuasiIsomorphism
open import foundations.Sigma
open import foundations.FunctionInverses
open import foundations.PathReasoning
open import foundations.EquivContrFibre
open import foundations.Singleton
}
% ```

\subtree{
\title{embedding}
\taxon{definition}

\p{A function #{f : A \to B} is an embedding if #{f^* : x = y \to f(x) = f(y)} is an embedding}

% ```agda
\agda{

is-embedding : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-embedding f = âˆ€ {x y} â†’ is-equiv (ap f {x} {y})

unap : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ is-embedding f â†’ âˆ€ {x y} â†’ f x ï¼ f y â†’ x ï¼ y
unap emb = is-equiv.bwd emb
}
% ```
}


\subtree{
\taxon{theorem}
\title{Equivalences are embeddings}

% ```agda
\agda{

is-embeddingâ†is-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B} â†’ is-equiv f â†’ is-embedding f 
is-embeddingâ†is-equiv {B = B} {f = f} eq {x} {y} = is-equivâ†qiso qiso' where
  open is-equiv eq renaming (bwd to finv)
}
% ```

\proof{
\p{Suppose #{f} is an equivalence, we will find a quasi-inserve to #{\textit{ap}_f}.
Given an identity #{p : f x = f y}, we obtain #{f^{-1}(f(x)) = f^{-1}(f(y))} by applying the inverse. }

% ```agda
\agda{
  inverse : f x ï¼ f y â†’ x ï¼ y
  inverse p = {- x          ï¼âŸ¨ -} sym (Î· x) âˆ™ -- âŸ©
              {- finv (f x) ï¼âŸ¨ -} ap finv p âˆ™ -- âŸ©
              {- finv (f y) ï¼âŸ¨ -} Î· y -- âŸ©
              {- y          âˆ -}
}
% ```

% ```agda
\agda{
  ret : retract-witness (ap f) inverse
  ret refl = inverse refl         ï¼âŸ¨âŸ©
             sym (Î· x) âˆ™ refl âˆ™ Î· y  ï¼âŸ¨ refl âŸ©
             sym (Î· x) âˆ™ Î· x         ï¼âŸ¨ âˆ™-sym' (Î· x) âŸ©
             refl âˆ
}
% ```





% ```agda
\agda{
  sec : ap f âˆ˜ inverse ~ id
  sec p = ap f (inverse p)                                 ï¼âŸ¨âŸ©
          ap f (sym (Î· x) âˆ™ ap finv p âˆ™ Î· y)               ï¼âŸ¨  ap-âˆ™âˆ™ f (sym (Î· x)) (ap finv p) (Î· y) âŸ©
          ap f (sym (Î· x)) âˆ™ ap f (ap finv p) âˆ™ ap f (Î· y) ï¼âŸ¨ refl {a = ap f (sym (Î· x))} âŸ©âˆ™âŸ¨ sym (ap-âˆ˜ f finv p) âŸ©âˆ™âŸ¨ coherent y âŸ©
          ap f (sym (Î· x)) âˆ™ ap (f âˆ˜ finv) p âˆ™ Îµ (f y)     ï¼âŸ¨ refl {a = ap f (sym (Î· x))} âŸ©âˆ™âŸ¨ sym (homotopy-natural Îµ p ) âŸ©
          ap f (sym (Î· x)) âˆ™ Îµ (f x) âˆ™ ap id p             ï¼âŸ¨ refl {a = ap f (sym (Î· x))} âŸ©âˆ™âŸ¨ sym (coherent x) âŸ©âˆ™âŸ¨ ap-id _ âŸ©
          ap f (sym (Î· x)) âˆ™ ap f (Î· x) âˆ™ p                ï¼âŸ¨ âˆ™.pullr B {a = ap f (Î· x)} (sym (ap-âˆ™ f (sym (Î· x)) (Î· x))) {f = p} âŸ©
          ap f (sym (Î· x) âˆ™ Î· (x)) âˆ™ p                     ï¼âŸ¨ âˆ™.elimr B (ap (ap f) (âˆ™-sym' (Î· x))) {f = p} âŸ©
          p âˆ
}
% ```

% ```agda
\agda{
  qiso' : quasi-iso (ap f)
  qiso' .fst = inverse
  qiso' .snd .fst = ret
  qiso' .snd .snd = sec
}
% ```

}
}
