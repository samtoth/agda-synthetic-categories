\date{2025-06-06}
\title{The Flat Modalitiy}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Modalities.Flat.Flat where

open import Foundations.Prelude
}

\subtree[stt-004Z]{
\title{The Flat type operator}
\taxon{Definition}

\p{Given a crisp type #{A}, we can form the type #{\modflat{A}}. In agda flat
we can encode this with an inductive datatype generated by a crisp elements
of #{A}. We also note the corresponding induction principal for the inductive
type.}

\agda{
data âŸ¨â™­|_âŸ© {@â™­ ğ“¤} (@â™­ A : Type ğ“¤) : Type ğ“¤ where
  modâ™­ : (@â™­ _ : A) â†’ âŸ¨â™­| A âŸ©

â™­-ind : âˆ€ {@â™­ ğ“¤} {ğ“¥} {@â™­ A : Type ğ“¤} (B : âŸ¨â™­| A âŸ© â†’ Type ğ“¥)
          â†’ ((@â™­ x : A) â†’ B (modâ™­ x))
          â†’ (x : âŸ¨â™­| A âŸ©) â†’ B x
â™­-ind B f (modâ™­ x) = f x
}
%```
}



\subtree[stt-0051]{
\taxon{Theroem}
\title{Flat is a Functor}

\p{Using the rules of [modal type theory](stt-0050) and #{\flat}-induction,
we can define operations making #{\modflat{-}} into a comonad.}

\p{To get a feel for how to reason informally about modal type theory, we
give the definition making #{\modflat{-}} into a functor informally
(in pain-staking detail), and compare it to the agda definition:}

\p{Given crisp types #{A :^\flat \UU} and #{B :^\flat \UV}, and a function
#{f :^\flat A \to B}, we can define a function #{\modflat{A} \to \modflat{B}}.
By crisp induction, it surfices to define a function
#{(a :^\flat A) \to \modflat{B}}. Then by #{\flat}-intro, we can assume a
crisp #{a :^\flat A} and give a crisp term of type #{B}, but now both #{f} and
#{a} were assumed crisp and so #{f(a) :^\flat B}, and we are done.
 }

%```agda
\agda{
â™­-map : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
        â†’ (@â™­ f : A â†’ B) â†’ âŸ¨â™­| A âŸ© â†’ âŸ¨â™­| B âŸ©
â™­-map f (modâ™­ x) = modâ™­ (f x)

â™­-id : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤}
        â†’ â™­-map {A = A} id ~ id
â™­-id (modâ™­ x) = refl

â™­-âˆ˜ : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥} {@â™­ C : Type ğ“¦}
        â†’ (@â™­ f : B â†’ C) (@â™­ g : A â†’ B)
        â†’ â™­-map (f âˆ˜ g) ~ â™­-map f âˆ˜ â™­-map g
â™­-âˆ˜ f g (modâ™­ x) = refl
}
%```
}

\subtree[stt-0052]{
\taxon{Theorem}
\title{Flat is a comonad}

\p{Similarly, we can define the counit and comultiplication functions that
make #{\modflat{-}} into a comonad.}

%```agda
\agda{
Îµ : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} â†’ âŸ¨â™­| A âŸ© â†’ A
Îµ (modâ™­ x) = x

âŸ¨â™­â™­|_âŸ© : âˆ€ {@â™­ ğ“¤} â†’ (@â™­ _ : Type ğ“¤) â†’ Type ğ“¤
âŸ¨â™­â™­| A âŸ© = âŸ¨â™­| âŸ¨â™­| A âŸ© âŸ©

comult : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} â†’ âŸ¨â™­| A âŸ© â†’ âŸ¨â™­â™­| A âŸ©
comult (modâ™­ x) = modâ™­ (modâ™­ x)
}
%```
}

\subtree[stt-0054]{
\title{Flat is an idempotent comonad}
\taxon{Theorem}

\p{We show that \code{comult} is an equivalence.}

%```agda
\agda{
Î¼ : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤}
    â†’ âŸ¨â™­â™­| A âŸ© â†’ âŸ¨â™­| A âŸ©
Î¼ (modâ™­ x) = x

comult-is-equiv : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤}
                  â†’ is-equiv (comult {A = A})
comult-is-equiv = is-equivâ†qiso lem where
  lem : quasi-iso comult
  lem .fst = Î¼
  lem .snd .fst (modâ™­ x) = refl
  lem .snd .snd (modâ™­ (modâ™­ x)) = refl

â™­-idem : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤}
         â†’ âŸ¨â™­â™­| A âŸ© â‰ƒ âŸ¨â™­| A âŸ©
â™­-idem = mkâ‰ƒ Î¼ (is-equivâ»Â¹ comult-is-equiv)
}
%```
}

\subtree[stt-0053]{
\title{Flat commutes with #{\Sigma} and #{1}}
\taxon{Theorem}

\p{First we show that #{\flat} commutes with #{1}, or in other words
#{\modflat{1}} is a [singleton](stt-0006). Similarly we can show that
#{\modflat{-}} preserves all singletons.}

%```agda
\agda{
â™­ğŸ™-is-single : is-singleton âŸ¨â™­| ğŸ™ âŸ©
â™­ğŸ™-is-single = mk-singl (modâ™­ tt) Î» where (modâ™­ tt) â†’ refl

-- â™­-is-single : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤}
--               â†’ @â™­ is-singleton A â†’ is-singleton âŸ¨â™­| A âŸ©
-- â™­-is-single (mk-singl c p) = mk-singl (modâ™­ c) Î» where
--   (modâ™­ x) â†’ modâ™­ï¼ (modâ™­ (p x))
}
%```

\p{Given a crisp type #{A},
and a family of types #{B} crisply over #{A}, we can define the
dependent flat-sum, written #{\Sigma_{a :^\flat A} B(a)}. Defined
as #{\Sigma_{x : \modflat{A}}\flat\textrm{-rec}(\_,B,x)}.}

\agda{
Î£â™­ : âˆ€ {@â™­ ğ“¤ ğ“¥} (@â™­ A : Type ğ“¤) (B : @â™­ A â†’ Type ğ“¥)
     â†’ Type (ğ“¤ âŠ” ğ“¥)
Î£â™­ A B = Î£ âŸ¨â™­| A âŸ© (â™­-ind _ B)

syntax Î£â™­ A (Î» x â†’ B) = Î£[â™­ x âˆ¶ A ] B
}

\p{We now show #{\flat} commutes with #{\Sigma} in the sense that
#{\Sigma_{a :^\flat A} \modflat{B(a)}} is equivalent to
#{\modflat{\Sigma_{a : A}B(a)}}}

%```agda
\agda{
â™­-Î£ : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} (@â™­ B : A â†’ Type ğ“¥)
      â†’ Î£[â™­ x âˆ¶ A ] âŸ¨â™­| B x âŸ©
      â†’ âŸ¨â™­| Î£ A B âŸ©
â™­-Î£ B (modâ™­ a , modâ™­ b) = modâ™­ (a , b)

â™­-Î£' : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} (@â™­ B : A â†’ Type ğ“¥)
      â†’ âŸ¨â™­| Î£ A B âŸ©
      â†’ Î£[â™­ x âˆ¶ A ] âŸ¨â™­| B x âŸ©
â™­-Î£' B (modâ™­ (a , b)) = (modâ™­ a , modâ™­ b)

â™­-commÎ£ : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} (@â™­ B : A â†’ Type ğ“¥)
                 â†’ (Î£[â™­ x âˆ¶ A ] âŸ¨â™­| B x âŸ©) â‰ƒ âŸ¨â™­| Î£ A B âŸ©
â™­-commÎ£ P = equivâ†qiso qiso where
  qiso : (Î£[â™­ x âˆ¶ _ ] âŸ¨â™­| P x âŸ©) â‰… âŸ¨â™­| Î£ _ P âŸ©
  qiso ._â‰…_.fwd = â™­-Î£ P
  qiso ._â‰…_.fwd-iso .fst = â™­-Î£' P
  qiso ._â‰…_.fwd-iso .snd .fst (modâ™­ a , modâ™­ b) = refl
  qiso ._â‰…_.fwd-iso .snd .snd (modâ™­ (a , b))    = refl
}
%```
}

\subtree[stt-0055]{
% \title{Flat is lex}
\taxon{Construction}

\p{There is an obvious map
#{\mod_{\flat}(a) = \mod_{\flat}(b) \to \modflat{a = b}} that sends
#{\refl} to #{\mod_{\flat}(\refl)}.
}

%```agda
\agda{
unmodâ™­ï¼ : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} {@â™­ a b : A}
       â†’ modâ™­ a ï¼ modâ™­ b
       â†’ âŸ¨â™­| a ï¼ b âŸ©
unmodâ™­ï¼ refl = modâ™­ refl
}
%```
}

\subtree[stt-0057]{
\taxon{Definition}
\title{Crisp Identity Induction}
\date{2025-06-10}

\p{We can define an induction principal for crisp identity types. }

%```agda
\agda{
Jâ™­ : âˆ€ {@â™­ ğ“¤ ğ“¥} {@â™­ A : Type ğ“¤} {@â™­ a : A}
       (P : (@â™­ b : A) â†’ (p : a ï¼ b) â†’ Type ğ“¥)
     â†’ P a refl
     â†’ {@â™­ b : A} â†’ (@â™­ p : a ï¼ b)
     â†’ P b p
Jâ™­ P pr refl = pr

_ : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} {@â™­ a b : A}
       â†’ modâ™­ a ï¼ modâ™­ b
       â†’ âŸ¨â™­| a ï¼ b âŸ©
_ = Î» p â†’ J (Î» where (modâ™­ x) p' â†’ âŸ¨â™­| _ ï¼ x âŸ©) (modâ™­ refl) p
}
%```

\p{This can be used to define the functoriality of functions with respect to
crisp-identity types.}

%```agda
\agda{
apâ™­ : âˆ€ {@â™­ ğ“¤} {ğ“¥} {@â™­ A : Type ğ“¤} {B : Type ğ“¥}
      (f : @â™­ A â†’ B) â†’ {@â™­ x y : A} â†’ @â™­ x ï¼ y
      â†’ f x ï¼ f y
apâ™­ f refl = refl
}
%```
\p{We sometimes call the above construction the weak crisp induction principal
in contrast with the following stronger induction principal:
}
%```agda
\agda{
J-crisp-ind : âˆ€ (@â™­ ğ“¤ ğ“¥ : Level) â†’ Type (lsuc (ğ“¤ âŠ” ğ“¥))
J-crisp-ind ğ“¤ ğ“¥ = âˆ€ {@â™­ A : Type ğ“¤} {@â™­ a : A}
                     (@â™­ P : (@â™­ b : A) â†’ (@â™­ p : a ï¼ b) â†’ Type ğ“¥)
                    â†’ @â™­ P a refl
                    â†’ {@â™­ b : A} â†’ (@â™­ p : a ï¼ b)
                    â†’ P b p
}
%```

\p{Unlike the weak induction principal, the full crisp induction principal is
not derivable in base MTT. \citek{DG21}}
}

\subtree[stt-0056]{
\title{Crisp Induction implies Flat is lex}
\taxon{Theorem}
\p{We can define a retraction of the function
#{\mod_{\flat}(a) = \mod_{\flat}(b) \to \modflat{a = b}} defined in
\ref{stt-0055} by using weak crisp identity induction.}

%```agda
\agda{
modâ™­ï¼ : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} {@â™­ a b : A}
       â†’ âŸ¨â™­| a ï¼ b âŸ©
       â†’ modâ™­ a ï¼ modâ™­ b
modâ™­ï¼ (modâ™­ refl) = refl

_ : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} {@â™­ a b : A}
       â†’ âŸ¨â™­| a ï¼ b âŸ©
       â†’ modâ™­ a ï¼ modâ™­ b
_ = Î» { (modâ™­ p) â†’ Jâ™­ (Î» b' pâ‚ â†’ _ ï¼ modâ™­ b') refl p }

unmodâ™­ï¼-retraction : âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} {@â™­ a b : A}
                   â†’ retract-witness (unmodâ™­ï¼ {a = a} {b}) modâ™­ï¼
unmodâ™­ï¼-retraction refl = refl
}
%```

\p{A modality is lex when it preserves identity types, i.e. \code{modâ™­ï¼} is
an equivalence. Whilst we have given a retraction, it is not possible to show
that the map is a section. To see the issue, we carefully construct the
motive over which we perform induction:}

\p{For a crisp type #{A}, and #{a,b} a pair of crisp elements of #{A}, we need
to show that for all #{p :^\flat a = b},
#{\textrm{unmod}_{\flat}(\mod_{\flat}(p)) = p}. To apply induction, we
need to give a motive of type #{M : \Pi_{(y :^\flat A)} \Pi_{(p : a = y)} \UU},
such that #{M(b,p) \equiv (\textrm{unmod}_{\flat}(\mod_{\flat}(p)) = p)}. But
this is already ill-typed for a general #{p} as #{\mod_{\flat}} requires a crisp
identification.}

\p{The above argument gives a syntactic heuristic for why weak crisp induction
does not suffice, but in an [unpublished note](DG21), Gratzer shows that
strong crisp induction is independent of MTT. One sufficient condition for a
modality to have strong crisp induction is that it has a right adjoint. This
will be the case in most modalities of interest at least in this formalisation,
in particular in \em{spatial type theory} as introduced in
\citek{shulmanRealCohesive2017}.}

%```agda
\agda{
unmodâ™­ï¼-section : âˆ€ {@â™­ ğ“œ} {@â™­ A : Type ğ“œ}
    â†’ J-crisp-ind ğ“œ ğ“œ
    â†’ {@â™­ a b : A}
    â†’ section-witness (unmodâ™­ï¼ {a = a} {b}) modâ™­ï¼
unmodâ™­ï¼-section j (modâ™­ p)
  = j (Î» _ p' â†’ unmodâ™­ï¼ (modâ™­ï¼ (modâ™­ p')) ï¼ (modâ™­ p')) refl p

â™­-lex :  âˆ€ {@â™­ ğ“¤} {@â™­ A : Type ğ“¤} {@â™­ a b : A}
       â†’ J-crisp-ind ğ“¤ ğ“¤ â†’ âŸ¨â™­| a ï¼ b âŸ© â‰ƒ (modâ™­ a ï¼ modâ™­ b)
â™­-lex {A = A}{a}{b} j = equivâ†qiso qiso where
  qiso : âŸ¨â™­| _ ï¼ _ âŸ© â‰… (modâ™­ _ ï¼ modâ™­ _)
  qiso ._â‰…_.fwd = modâ™­ï¼
  qiso ._â‰…_.fwd-iso .fst = unmodâ™­ï¼
  qiso ._â‰…_.fwd-iso .snd .fst = unmodâ™­ï¼-section j
  qiso ._â‰…_.fwd-iso .snd .snd = unmodâ™­ï¼-retraction
}
%```
}

\subtree[stt-0058]{
\taxon{Theorem}
\title{Lex modalities preserve pullbacks}

\p{There are numerous ways to define the crisp pullback. Given crisp types
#{A,B} and #{C}, and crisp maps #{f :^\flat A \to C} and #{g :^\flat B \to C},
we define the following notions of crisp pullbacks:}

\ol{
\li{The type #{\modflat{A \times_C B}} (using the [standard pullback](stt-003J)
)}
\li{The type #{A \times_{C}^{\flat} B}, which we define as
  #{\Sigma_{(a :^\flat A)}\Sigma_{(b :^\flat B)} \modflat{f(a) = g(b)}}
using [modal dependent sums](stt-0053)}
\li{The type #{\modflat{A} \times_{\modflat{C}} \modflat{B}} where the maps are given by
the [functorial action of #{\flat}](stt-0051)}
}

\p{We can immediately see that (1) and (2) are equivalent:}


%```agda
\agda{
Pullbackâ™­ : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
               {@â™­ C : Type ğ“¦}
               (@â™­ f : A â†’ C) (@â™­ g : B â†’ C)
             â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Pullbackâ™­ {A = A} {B} {C} f g = Î£[â™­ x âˆ¶ A ] Î£[â™­ y âˆ¶ B ] âŸ¨â™­| f x ï¼ g y âŸ©


â™­-pb : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
              {@â™­ C : Type ğ“¦}
              {@â™­ f : A â†’ C} {@â™­ g : B â†’ C}
            â†’ Pullbackâ™­ f g â†’ âŸ¨â™­| Pullback f g âŸ©
â™­-pb (modâ™­ a , modâ™­ b , modâ™­ p) = modâ™­ (a , b , p)

â™­-pb' : âˆ€  {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
              {@â™­ C : Type ğ“¦}
              {@â™­ f : A â†’ C} {@â™­ g : B â†’ C}
            â†’ âŸ¨â™­| Pullback f g âŸ© â†’ Pullbackâ™­ f g
â™­-pb' (modâ™­ (a , b , p)) = (modâ™­ a , modâ™­ b , modâ™­ p)


â™­-pres-pb : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
              {@â™­ C : Type ğ“¦}
              {@â™­ f : A â†’ C} {@â™­ g : B â†’ C}
            â†’ Pullbackâ™­ f g â‰ƒ âŸ¨â™­| Pullback f g âŸ©
â™­-pres-pb {f = f}{g} = equivâ†qiso qiso where
  qiso : Pullbackâ™­ f g â‰… âŸ¨â™­| Pullback f g âŸ©
  qiso ._â‰…_.fwd = â™­-pb
  qiso ._â‰…_.fwd-iso .fst = â™­-pb'
  qiso ._â‰…_.fwd-iso .snd .fst (modâ™­ a , modâ™­ b , modâ™­ p) = refl
  qiso ._â‰…_.fwd-iso .snd .snd (modâ™­ x) = refl
}
%```

\p{If we have that #{\flat} is a lex modality, then (1),(2) and (3) are
    all equivalent.}

%```agda
\agda{
â™­-pb3 : âˆ€ {@â™­ ğ“¤ ğ“¥ ğ“¦} {@â™­ A : Type ğ“¤} {@â™­ B : Type ğ“¥}
         {@â™­ C : Type ğ“¦}
         (@â™­ f : A â†’ C) (@â™­ g : B â†’ C)
       â†’ J-crisp-ind ğ“¦ ğ“¦
       â†’ Pullback (â™­-map f) (â™­-map g) â‰ƒ Pullbackâ™­ f g
â™­-pb3 f g j = equivâ†qiso lem where
  lem : Pullback (â™­-map f) (â™­-map g) â‰… Pullbackâ™­ f g
  lem ._â‰…_.fwd (modâ™­ a , modâ™­ b , p) = (modâ™­ a , modâ™­ b , unmodâ™­ï¼ p)
  lem ._â‰…_.fwd-iso .fst (modâ™­ a , modâ™­ b , p) = (modâ™­ a , modâ™­ b , modâ™­ï¼ p)
  lem ._â‰…_.fwd-iso .snd .fst (modâ™­ a , modâ™­ b , p)
    = Î£-pathâ†’ (refl , Î£-pathâ†’ (refl , _â‰ƒ_.Îµ (â™­-lex j) p))
  lem ._â‰…_.fwd-iso .snd .snd (modâ™­ a , modâ™­ b , p)
    = Î£-pathâ†’ (refl , (Î£-pathâ†’ (refl , _â‰ƒ_.Î· (â™­-lex j) p)))
}
%```
}
