\title{Commuting cubes}
\taxon{Module}
\author{samueltoth}
\date{2025-12-01}

\import{stt-macros}

%```agda
\agda{
{-#Â OPTIONS --lossy-unification #-}
module Core.Cube where

open import Foundations.Prelude

open import ufAxioms

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Postwhisker
open import Core.FunctorialPullback

open import Ergonomics.Marker
open import Ergonomics.Representation
open import Ergonomics.Extensionality
}
%```


\subtree[stt-00B2]{
\title{Commuting cube}
\taxon{Definition}

\p{Given a pair of arrow maps #{F : f \to g} and #{G : h \to k}, we define the
type of commuting cubes, consisting of a quadruple of maps, fillers for each
of the resulting faces, and a coherence that fills in the solid area of the
cube. Alternatively, this data can be packages up as pair of arrow maps
#{L : f \to h} and #{R : g \to k} together with a homotopy of arrow maps
#{GL \sim RF}.}

\quiver{
\begin{tikzcd}[cramped]
	& X && Z \\
	A && C \\
	& Y && W \\
	B && D
	\arrow[from=1-2, to=1-4]
	\arrow[from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow[from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow[from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow[from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

%```agda
\agda{
record Cube {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
            {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
            {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
            (F : Arrow-map f g)
            {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
            {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
            (G : Arrow-map h k) : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“§ âŠ” ğ“› âŠ” ğ“œ âŠ” ğ“ âŠ” ğ“) where
  constructor mk-cube
  module F = Arrow-map F
  module G = Arrow-map G
  field
    left : Arrow-map f h
    right : Arrow-map g k
    comm : Arrow-map-path (paste-squares G left) (paste-squares right F)

  module left = Arrow-map left
  module right = Arrow-map right

  topl : A â†’ X
  topl = left .Arrow-map.top

  topr : C â†’ Z
  topr = right .Arrow-map.top

  botl : B â†’ Y
  botl = left .Arrow-map.bot

  botr : D â†’ W
  botr = right .Arrow-map.bot

  bot : G.bot âˆ˜ botl ~ botr âˆ˜ F.bot
  bot = comm .snd .fst

  top : G.top âˆ˜ topl ~ topr âˆ˜ F.top
  top = comm .fst


  top-amap : Arrow-map F.top G.top
  top-amap .Arrow-map.top = topl
  top-amap .Arrow-map.bot = topr
  top-amap .Arrow-map.comm = top ~â»Â¹

  bot-amap : Arrow-map F.bot G.bot
  bot-amap .Arrow-map.top = botl
  bot-amap .Arrow-map.bot = botr
  bot-amap .Arrow-map.comm = bot ~â»Â¹

  fill-hex
    : âˆ€ a â†’ Hexagon
              (ap G.bot (left.comm a)) (G.comm (left.top a)) (ap k (top a))
              (bot (f a)) (ap right.bot (F.comm a)) (right.comm (F.top a))
  fill-hex a .Hexagon.un-hex
    = sym (âˆ™-assoc (ap G.bot (left.comm a)) _ (ap k (top a)))
    âˆ™ comm .snd .snd a
}
%```
}


\subtree[stt-00B3]{
\title{Cartesian commuting cubes preserve pullbacks}
\taxon{Theorem}

\p{Consider a commuting cube where the left and right squares are cartesian,}
\quiver{
\begin{tikzcd}[cramped]
	& X && Z \\
	A && C \\
	& Y && W \\
	B && D
	\arrow[from=1-2, to=1-4]
	\arrow[from=1-2, to=3-2]
	\arrow[from=1-4, to=3-4]
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-1, to=2-3]
	\arrow[from=2-1, to=4-1]
	\arrow[from=2-3, to=1-4]
	\arrow[from=2-3, to=4-3]
	\arrow[from=3-2, to=3-4]
	\arrow[from=4-1, to=3-2]
	\arrow[from=4-1, to=4-3]
	\arrow[from=4-3, to=3-4]
\end{tikzcd}
}

\p{then the front square is cartesian if the back square is.}

\proof{
\p{Follows from the 3 for 2 property for cartesian squares.}
}


%```agda
\agda{
front-cartesianâ†cartesian-cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      (F : Arrow-map f g)
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      (G : Arrow-map h k)
    â†’ (cube : Cube F G) â†’ let open Cube cube
    in is-cartesian left â†’ is-cartesian right
    â†’ is-cartesian G â†’ is-cartesian F
front-cartesianâ†cartesian-cube {f = f} F {k = k} G cube leftCart rightCart GCart
  = 3-for-2-cartesian
      comm
      (compose-cartesian GCart leftCart)
      rightCart where
  open Cube cube
}
%```
}

\subtree[tot-000U]{
\taxon{Construction}

\p{A map of squares induces a map between their respective gap maps.}

%```agda
\agda{

module _ where
  open Cube
  cospan-mapâ†cube
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
        {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
        {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
        {F : Arrow-map f g}
        {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
        {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
        {G : Arrow-map h k}
      â†’ (cube : Cube F G)
      â†’ Cospan-map (Coneâ†Arrow-map F .fst) (Coneâ†Arrow-map G .fst)
  cospan-mapâ†cube Î± .Cospan-map.hâ‚ = botl Î±
  cospan-mapâ†cube Î± .Cospan-map.hâ‚‚ = botr Î±
  cospan-mapâ†cube Î± .Cospan-map.hâ‚ƒ = topr Î±
  cospan-mapâ†cube Î± .Cospan-map.H = bot Î± ~â»Â¹
  cospan-mapâ†cube Î± .Cospan-map.K = right.comm Î±


gap-map-squareâ†cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      (F : Arrow-map f g)
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      (G : Arrow-map h k)
    â†’ (cube : Cube F G)
    â†’ Arrow-map (gap-mapâ†square F) (gap-mapâ†square G)
gap-map-squareâ†cube F G Î± .Arrow-map.top = Î± .Cube.left.top
gap-map-squareâ†cube F G Î± .Arrow-map.bot = Pullbackâ‚ (cospan-mapâ†cube Î±)
gap-map-squareâ†cube {f = f} F {k = k} G
   Î±@(mk-cube L R (lc , rc , fill)) .Arrow-map.comm a
  = pullback-pathâ†’ ( Î± .Cube.left.comm a
                   , sym (Cube.top Î± a)
                   , un-square
                       (coe
                         (ap (Î» p â†’ Square _ p _ _) (sym (ap-sym k (lc a))))
                         (Hexagon.Square-compress-left
                          (tr
                           (Î» p â†’
                             Hexagon (ap (Arrow-map.bot G) (Arrow-map.comm L a))
                                     (Arrow-map.comm G (Arrow-map.top L a))
                                     (ap k (lc a))
                                     p
                                     (ap (Arrow-map.bot R) (Arrow-map.comm F a))
                                     (Arrow-map.comm R (Arrow-map.top F a)))
                           (sym sym-sym)
                           (Cube.fill-hex Î± a)))))

postcomp-retract-square
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
      (F : Arrow-map f g)
      ((G , _) : retract-arrow-map F)
      {ğ““} {D : Type ğ““}
     â†’ retract-arrow-map (postcomp-square G D)
postcomp-retract-square F (G , _) .fst = postcomp-square F _
postcomp-retract-square F (G , tr , br , _) .snd .fst a = ap (a âˆ˜_) (funextâ†’ br)
postcomp-retract-square F (G , tr , _) .snd .snd .fst a = ap (a âˆ˜_) (funextâ†’ tr)
postcomp-retract-square {f = f} F (G , lr , rr , coh) .snd .snd .snd j
  = ap (_âˆ˜ _) (funextâ†’ (j â—‚ (Arrow-map.comm G ~â»Â¹)))
  âˆ™ funextâ†’ (Arrow-map.top (postcomp-square G _) j  â—‚ (Arrow-map.comm F ~â»Â¹))
  âˆ™ ap (_âˆ˜ f) (ap (j âˆ˜_) (funextâ†’ rr))
      ï¼âŸ¨ apâ‚ƒ (Î» p q r â†’ p âˆ™ q âˆ™ r) (sym (commutes-postwhisker-funext _)) refl
                      (ap (ap (_âˆ˜ f)) (sym (commutes-prewhisker-funext _))
                        âˆ™ sym (commutes-postwhisker-funext _)) âŸ©
   funextâ†’ (prewhisker j _ _ ((Arrow-map.comm G ~â»Â¹) â–¸ Arrow-map.top F))
 âˆ™ funextâ†’ ((Arrow-map.top (postcomp-square G _) j  â—‚ (Arrow-map.comm F ~â»Â¹)))
 âˆ™ funextâ†’ (postwhisker f (j âˆ˜ Arrow-map.bot G âˆ˜ Arrow-map.bot F) j
             (prewhisker j (Arrow-map.bot G âˆ˜ Arrow-map.bot F) id
               rr))
     ï¼âŸ¨ sym (funext-âˆ™âˆ™ _ _ _) âŸ©
   funextâ†’ (Î» a â†’
              ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
              ap (j âˆ˜ (Arrow-map.bot G)) (sym (Arrow-map.comm F a)) âˆ™
              ap j (rr (f a)))
      ï¼âŸ¨ ap funextâ†’ (funextâ†’ p) âŸ©
   funextâ†’ (prewhisker (j âˆ˜ f) (Arrow-map.top G âˆ˜ Arrow-map.top F)
              id lr) ï¼âŸ¨ commutes-prewhisker-funext lr âŸ©
   ap ((j âˆ˜ f) âˆ˜_) (funextâ†’ lr) âˆ where

  q : âˆ€ a â†’
      sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
      âŒœ sym (ap (Arrow-map.bot G) (Arrow-map.comm F a)) âˆ™
      ap (Arrow-map.bot G) (Arrow-map.comm F a) âˆ™
      Arrow-map.comm G (Arrow-map.top F a) âˆ™ ap f (lr a) âŒ
      ï¼
      sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
      âŒœ sym (ap (Arrow-map.bot G) (Arrow-map.comm F a)) âˆ™
       ap (Arrow-map.bot G) (Arrow-map.comm F a) âˆ™
       Arrow-map.comm G (Arrow-map.top F a) âŒ
      âˆ™ ap f (lr a)
  q a = let
         X = ap f (lr a)
         Y = Arrow-map.comm G (Arrow-map.top F a)
         Z = ap (Arrow-map.bot G) (Arrow-map.comm F a)
         W = sym (ap (Arrow-map.bot G) (Arrow-map.comm F a))
       in ap!
         (sym (âˆ™.assoc-4 _ X Y Z W)
         âˆ™ ap (_âˆ™ ap f (lr a)) (âˆ™-assoc W Z Y ))


  p : âˆ€ a â†’
          ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
          ap (j âˆ˜ Arrow-map.bot G) (sym (Arrow-map.comm F a)) âˆ™
          ap j (rr (f a))
       ï¼
        ap (j âˆ˜ f) (lr a)
  p a
    = ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
       âŒœ ap (j âˆ˜ Arrow-map.bot G) (sym (Arrow-map.comm F a)) âŒ âˆ™
       ap j (rr (f a)) ï¼âŸ¨ ap! (ap-âˆ˜ j (Arrow-map.bot G) _ âˆ™ ap (ap j) (ap-sym _ _)) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a))) âˆ™
      ap j (sym (ap (Arrow-map.bot G) (Arrow-map.comm F a))) âˆ™
      ap j (rr (f a)) ï¼âŸ¨ sym (ap-âˆ™âˆ™ j (sym (Arrow-map.comm G (Arrow-map.top F a)))
                                      _ (rr (f a))) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
            sym (ap (Arrow-map.bot G) (Arrow-map.comm F a))
            âˆ™ âŒœ rr (f a) âŒ) ï¼âŸ¨ ap! (sym (coh a)) âˆ™ ap (ap j) (q a) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
            âŒœ sym (ap (Arrow-map.bot G) (Arrow-map.comm F a)) âˆ™
            ap (Arrow-map.bot G) (Arrow-map.comm F a) âˆ™
            Arrow-map.comm G (Arrow-map.top F a) âŒ âˆ™ ap f (lr a))
          ï¼âŸ¨ ap! (sym'âˆ™ (ap (Arrow-map.bot G) (Arrow-map.comm F a))
                         (Arrow-map.comm G (Arrow-map.top F a))) âŸ©
      ap j (sym (Arrow-map.comm G (Arrow-map.top F a)) âˆ™
            Arrow-map.comm G (Arrow-map.top F a) âˆ™ ap f (lr a))
          ï¼âŸ¨ ap (ap j) (sym'âˆ™ (Arrow-map.comm G (Arrow-map.top F a)) (ap f (lr a))) âŸ©
      ap j (ap f (lr a)) ï¼âŸ¨ sym (ap-âˆ˜ j f (lr a)) âŸ©
      ap (j âˆ˜ f) (lr a) âˆ

is-equivâ†retract-equiv
   : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {X : Type ğ“¦} {Y : Type ğ“œ} {g : X â†’ Y}
    â†’ (F : Arrow-map f g)
    â†’ incoherent-retract-arrow-map F
    â†’ is-equiv g
    â†’ is-equiv f
is-equivâ†retract-equiv {f = f}{g = g} F (G , tr , br) feq
  = is-equivâ†qiso iso where
  open Arrow-map
  open is-equiv feq

  iso : quasi-iso f
  iso .fst = top G âˆ˜ bwd âˆ˜ bot F
  iso .snd .fst = (top G âˆ˜ bwd) â—‚ comm F ~âˆ™Â top G â—‚ Î· â–¸ top F ~âˆ™ tr
  iso .snd .snd = (comm G â–¸ bwd â–¸ bot F ~â»Â¹) ~âˆ™ bot G â—‚ Îµ â–¸ bot F ~âˆ™ br

1-coherent-retract-cube
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
    {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
    {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
    {F : Arrow-map f g}
    {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
    {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
    {G : Arrow-map h k}
  â†’ Cube F G
  â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“§ âŠ” ğ“› âŠ” ğ“œ âŠ” ğ“ âŠ” ğ“)
1-coherent-retract-cube {F = F} {G = G} Î±@(mk-cube L R p)
  = Î£[ Î² âˆ¶ Cube G F ]
     (retract-witness (Cube.topl Î±) (Cube.topl Î²)
      Ã—
     retract-witness-cospan (cospan-mapâ†cube Î±) (cospan-mapâ†cube Î²))

gap-map-square-retâ†cube-partial-ret
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
      {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
      (F : Arrow-map f g)
      {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
      {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
      (G : Arrow-map h k)
    â†’ (cube : Cube F G)
    â†’ (ret : Cube G F)
    â†’ retract-witness (Cube.topl cube) (Cube.topl ret)
    â†’ retract-witness-cospan (cospan-mapâ†cube cube) (cospan-mapâ†cube ret)
    â†’ incoherent-retract-arrow-map (gap-map-squareâ†cube F G cube)
gap-map-square-retâ†cube-partial-ret {g = g} F G Î± Î² tlr cspr
  = (ret  , tlr ,  ret2) where
  open Cube
  ret : Arrow-map (gap-mapâ†square G) (gap-mapâ†square F)
  ret = gap-map-squareâ†cube _ _ Î²


  ret-cspn : Pullbackâ‚
            (cospan-map-compose (cospan-mapâ†cube Î²) (cospan-mapâ†cube Î±)
              )
         ~ Pullbackâ‚ (id-cospan-map)
  ret-cspn
    = happly
        (ap Pullbackâ‚ {cospan-map-compose (cospan-mapâ†cube Î²) _} {id-cospan-map}
          (ext! (cospan-retract-is-cospan-retract (cospan-mapâ†cube Î±)
                                                  (cospan-mapâ†cube Î² , cspr))))

  ret2 : retract-witness
           (gap-map-squareâ†cube _ _ Î± .Arrow-map.bot)
           (ret .Arrow-map.bot)
  ret2 = Pullbackâ‚-âˆ˜ (cospan-mapâ†cube Î²) (cospan-mapâ†cube Î±)
       ~âˆ™ ret-cspn
       ~âˆ™ Pullbackâ‚-id


opaque
  retract-is-cartesian
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“› ğ“œ ğ“ ğ“}
        {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
        {C : Type ğ“¦} {D : Type ğ“§} {g : C â†’ D}
        {F : Arrow-map f g}
        {X : Type ğ“›} {Y : Type ğ“œ} {h  : X â†’ Y}
        {Z : Type ğ“} {W : Type ğ“} {k : Z â†’ W}
        {G : Arrow-map h k}
      â†’ (cube : Cube F G)
      â†’ 1-coherent-retract-cube cube
      â†’ is-cartesian G
      â†’ is-cartesian F
  retract-is-cartesian Î± (Î² , tlr , cspr) gcart
    = is-cartesianâ†is-pullback _
        (is-pullbackâ†gap _
          (is-equivâ†retract-equiv
            (gap-map-squareâ†cube _ _ Î±)
            (gap-map-square-retâ†cube-partial-ret _ _ Î± Î² tlr cspr)
            (gap-is-equivâ†is-pullback _
              (is-pullbackâ†is-cartesian _ gcart))))

}
%```
}
