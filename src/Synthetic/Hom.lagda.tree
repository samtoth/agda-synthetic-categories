\date{2025-09-11}
\title{Synthetic Hom Types}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}


%```agda
\agda{
open import Foundations.Prelude

module Synthetic.Hom {ğ“˜} (I : Type ğ“˜) (i0 i1 : I) where
}
%```

\subtree[stt-00A9]{
\title{Hom types}
\taxon{Definition}

\p{For any bi-pointed type #{I}, we can define the type of synthetic
homomorphisms, which are just (possibly-dependent) functions with specified
end-points.}

\remark{
\p{In this generality, there is not a lot of motivation to call these types
\strong{hom} types. They admit identity homs, but in general not composition.
The idea is that this module will be instantiated with an interval for which
certain types have a notion of fibrancy, and for those fibrant types, the hom
type will deserve it's name.}
}

%```agda
\agda{
record HomP {ğ“¤} (A : I â†’ Type ğ“¤) (a : A i0) (b : A i1) : Type (ğ“¤ âŠ” ğ“˜) where
  constructor mk-hom
  field
    hom  : Î  I A
    hom0 : hom i0 ï¼ a
    hom1 : hom i1 ï¼ b

Î»hom : âˆ€ {ğ“¤} {A : I â†’ Type ğ“¤} (f : Î  I A) â†’ HomP A (f i0) (f i1)
Î»hom f = mk-hom f refl refl

Hom : âˆ€ {ğ“¤} (A : Type ğ“¤) (a b : A) â†’ Type (ğ“¤ âŠ” ğ“˜)
Hom A a b = HomP (Î» _ â†’ A) a b

{-# NOINLINE Hom #-}

idH : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ (a : A) â†’ Hom A a a
idH a = Î»hom Î» _ â†’ a
}
%```

\remark{
\p{Unlike in [Cubical Agda](https://agda.readthedocs.io/en/latest/language/cubical.html)
or the [Rzk proof assistant](https://rzk-lang.github.io/rzk/en/latest/),
these hom types do not require their endpoints to be definitionally equal, but only
equal up to a path. It is possible to simulate the \em{definitional} path types
with an indexed-inductive type but this pushes Agda's elaboration beyond what it
is really designed for, and the usability suffers.
}

}
}


%```agda
\agda{
-- module _ (_âˆ§_ : I â†’ I â†’ I) (_âˆ¨_ : I â†’ I â†’ I)
--          (L : is-lattice i0 i1 _âˆ§_ _âˆ¨_) where
--
-- open import ufAxioms
-- open import Modalities.Instances.Truncation
-- open import Modalities.Instances.Localisation
-- open import Algebra.Lattice
-- open import Algebra.Poset
-- open import Core.Orthogonal
-- open import Core.CanonicalPushouts
-- open import Core.Coequalisers
-- open import Core.Join
-- open import Foundations.IdentitySystem
--
--   open Lattice (record
--                 { 0l = i0
--                 ; 1l = i1
--                 ; _âˆ§_ = _âˆ§_
--                 ; _âˆ¨_ = _âˆ¨_
--                 ; str-is-lattice = L })

--   open is-poset â‰¤-is-poset

--   Î”â‚ : Type ğ“˜
--   Î”â‚ = I

--   is-simplicial : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
--   is-simplicial = is-null {I = I Ã— I} Î» (i , j) â†’ (i â‰¤ j) * (j â‰¤ i)

--   -- Hom2 f g h ~> f âˆ˜ g ~ h
--   Hom2 : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
--            (f : Hom _ y z) (g : Hom _ x y) (h : Hom _ x z)
--          â†’ Type (ğ“˜ âŠ” ğ“¤)
--   Hom2 {A = A} f g h
--     = Î£[ H âˆ¶ (Î”â‚‚ â†’ A) ] (
--         (âˆ€ i â†’ H (mk-Î”â‚‚ i0 i) ï¼ g .HomP.hom i)
--       Ã— (âˆ€ i â†’ H (mk-Î”â‚‚ i i1) ï¼ f .HomP.hom i)
--       Ã— (âˆ€ i â†’ H (mk-Î”â‚‚ i i)  ï¼ h .HomP.hom i))

--   composite-simplex : Î”â‚ â†’ Î”â‚‚
--   composite-simplex i = mk-Î”â‚‚ i i

--   is-covariant : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (B : A â†’ Type ğ“¥)
--                â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
--   is-covariant {A = A} B
--     = âˆ€ (x : I â†’ A) (xâ‚€ : B (x i0))
--       â†’ is-singleton (Î£[ xâ‚ âˆ¶ B (x i1)] HomP (B âˆ˜ x) xâ‚€ xâ‚)

--   Î›[2,1] : Type ğ“˜
--   Î›[2,1] = Pushout (const _ ğŸ™ i1) (const _ ğŸ™ i0)

--   homotopy : âˆ€ {ğ“¤} {ğ“’ : Type ğ“¤} {X Y : ğ“’}
--                (f g : Hom ğ“’ X Y)
--              â†’ Type (ğ“˜ âŠ” ğ“¤)
--   homotopy {ğ“’ = ğ“’} f g = Hom _ f g

--   incl-horn : Î›[2,1] â†’ Î”â‚‚
--   incl-horn = pushout-rec (mk-cocone
--     (Î» i â†’ mk-Î”â‚‚ i0 i)
--     (Î» i â†’ mk-Î”â‚‚ i i1)
--     Î» a â†’ refl)


--   is-precategory : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
--   is-precategory = is-local {I = ğŸ™} Î» _ â†’ incl-horn



--   record is-precategory-I {ğ“¤} (A : Type ğ“¤) : Type (ğ“˜ âŠ” ğ“¤) where
--     field has-is-precat : is-precategory A

--     open is-equiv (has-is-precat tt) public

--   instance
--     hom-IdS : âˆ€ {ğ“¤} {A : Type ğ“¤} â¦ƒ _ : is-precategory-I A â¦„
--               â†’ {x y : A}
--               â†’ Identity-system (Hom A x y) (ğ“˜ âŠ” ğ“¤)
--     hom-IdS .Identity-system.IdS f g = Hom2 (idH _) f g
--     hom-IdS .Identity-system.IdSâ‚€ {a = f} .fst (mk-Î”â‚‚ _ j) = f .HomP.hom j
--     hom-IdS .Identity-system.IdSâ‚€ {a = f} .snd = (~refl , (Î» _ â†’ f .HomP.hom1) , ~refl)
--     hom-IdS .Identity-system.has-is-ids f = is-identity-systemâ†Sing-sing _ _
--       {!is-precategory!}

--   _âŠ™_ : âˆ€ {ğ“¤} {A : Type ğ“¤} â¦ƒ pc : is-precategory-I A â¦„
--         â†’ {x y z : A}
--         â†’ Hom A y z â†’ Hom A x y â†’ Hom A x z
--   _âŠ™_ {A = A} â¦ƒ pc â¦„ f g = mk-hom (Î» i â†’ simplex (mk-Î”â‚‚ i i))
--                                 (happly (Îµ comp) (Î¹â‚ i0) âˆ™ g .hom0)
--                                 (happly (Îµ comp) (Î¹â‚‚ i1) âˆ™ f .hom1) where
--     open is-precategory-I pc
--     open HomP

--     comp : Î›[2,1] â†’ A
--     comp = pushout-rec
--       (mk-cocone
--         (g .hom)
--         (f .hom)
--         Î» _ â†’ g .hom1 âˆ™ sym (f .hom0))

--     simplex : Î”â‚‚ â†’ A
--     simplex = bwd comp

--   record _^Î”â‚‚ {ğ“¤} (A : Type ğ“¤) : Type (ğ“˜ âŠ” ğ“¤) where
--     field
--       {x y z} : A
--       f : Hom A y z
--       g : Hom A x y
--       h : Hom A x z
--       H : Hom2 f g h

--   Î”â‚‚-reprâ‰ƒ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ (Î”â‚‚ â†’ A) â‰ƒ A ^Î”â‚‚
--   Î”â‚‚-reprâ‰ƒ = {!!}

--   precategory-unique-composite
--     : âˆ€ {ğ“¤} {A : Type ğ“¤} â¦ƒ pc : is-precategory-I A â¦„
--       â†’ {X Y Z : A} (f : Hom A Y Z) (g : Hom A X Y)
--       â†’ is-singleton (Î£[ h âˆ¶ Hom A X Z ] Hom2 f g h)
--   precategory-unique-composite {_} {A} â¦ƒ pc â¦„ f g
--     = is-singleâ†equiv-to-single
--         fibre-pcomp
--         (is-contr-mapâ†is-equiv (has-is-precat tt) comp) where
--     open is-precategory-I pc
--     open HomP

--     comp : Î›[2,1] â†’ A
--     comp = pushout-rec
--       (mk-cocone
--         (g .hom)
--         (f .hom)
--         Î» a â†’ g .hom1 âˆ™ sym (f .hom0))

--     splex : Î”â‚‚ â†’ A
--     splex = bwd comp

--     ctr1 : Hom A _ _
--     ctr1 .hom i = splex (mk-Î”â‚‚ i i)
--     ctr1 .hom0 = happly (Îµ comp) (Î¹â‚ i0) âˆ™ g .hom0
--     ctr1 .hom1 = happly (Îµ comp) (Î¹â‚‚ i1) âˆ™ f .hom1

--     ctr2 : Hom2 f g ctr1
--     ctr2 .fst = splex
--     ctr2 .snd .fst i = happly (Îµ comp) (Î¹â‚ i)
--     ctr2 .snd .snd .fst i = happly (Îµ comp) (Î¹â‚‚ i)
--     ctr2 .snd .snd .snd = ~refl

--     fibre-pcomp : fibre (postcomp _ incl-horn) comp
--                   â‰ƒ Î£[ h âˆ¶ Hom A _ _ ] Hom2 f g h
--     fibre-pcomp =
--         fibre (postcomp A incl-horn) comp
--       â‰ƒâŸ¨âŸ©
--        (Î£[ s âˆ¶ (Î”â‚‚ â†’ A)] (postcomp A incl-horn s ï¼ comp))
--       â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ funextâ‰ƒ) âŸ©
--        (Î£[ s âˆ¶ (Î”â‚‚ â†’ A)] (postcomp A incl-horn s ~ comp))
--       â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ (mkâ‰ƒ _ Pushout-is-pushoutÏ‰áµˆ âˆ™â‰ƒ coconeD-reprâ‰ƒ)) âŸ©
--        (Î£[ s âˆ¶ (Î”â‚‚ â†’ A)] {!!})
--       â‰ƒâŸ¨  Î£-ap-â‰ƒ-fst {B = {!!}} Î”â‚‚-reprâ‰ƒ   âŸ©
--        Î£[ s âˆ¶ A ^Î”â‚‚ ] _
--       â‰ƒâŸ¨ {!!} âŸ©
--        Î£ (Hom A _ _) (Î» h â†’ Hom2 f g h) â‰ƒâˆ

--   homâ†Id : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} â†’ x ï¼ y â†’ Hom A x y
--   homâ†Id refl = Î»hom _

--   is-groupoid : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Type (ğ“˜ âŠ” ğ“¤)
--   is-groupoid A = âˆ€ (x y : A) â†’ is-equiv {A = x ï¼ y} homâ†Id

--   Hom-is-cov : âˆ€ {ğ“¤} {A : Type ğ“¤} {a : A}
--              â†’ is-precategory A
--              â†’ is-covariant (Hom A a)
--   Hom-is-cov {_} {A} {x} pc p dh
--     = is-singleâ†equiv-to-single fibreChar
--         (is-contr-mapâ†is-equiv (pc tt) horn) where
--     open HomP
--     a : A
--     a = p i0
--     b = p i1

--     f : Hom A a b
--     f .HomP.hom = p
--     f .HomP.hom0 = refl
--     f .HomP.hom1 = refl

--     horn : Î›[2,1] â†’ A
--     horn = pushout-rec
--       (mk-cocone
--         (dh .hom)
--         p
--         Î» _ â†’ dh .hom1)

--     {-
--     aâ‚€  -- f ---> bâ‚€
--     ^
--     | diag
--     |
--     x


--     Out goal is a unique inhabitant of
--     Hom A bâ‚€ bâ‚, HomP
--     -}


--     fibreChar : fibre (postcomp _ incl-horn) horn
--               â‰ƒ (Î£[ h âˆ¶ Hom A x b ] HomP (Î» i â†’ Hom A x (f .hom i)) dh h)
--     fibreChar
--       =    fibre (postcomp A incl-horn) horn
--         â‰ƒâŸ¨âŸ©
--            (Î£[ k âˆ¶ (Î”â‚‚ â†’ A)] (postcomp A incl-horn k ï¼ horn))
--         â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» k â†’ funextâ‰ƒ) âŸ©
--            (Î£[ k âˆ¶ (Î”â‚‚ â†’ A)] âˆ€ i â†’ k (incl-horn i) ï¼ horn i)
--         â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» k â†’ mkâ‰ƒ _ Pushout-is-pushoutÏ‰áµˆ âˆ™â‰ƒ coconeD-reprâ‰ƒ)âŸ©
--            (Î£[ k âˆ¶ (Î”â‚‚ â†’ A)]
--                Î£[ P âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i0 i) ï¼ dh .hom i) ]
--                 Î£[ Q âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i i1) ï¼ p i) ]
--                  ((x : ğŸ™) â†’ IdP
--                       (ap (Î» z â†’ k (incl-horn z) ï¼ horn z) (glue x))
--                       (P i1)
--                       (Q i0)))
--         â‰ƒâŸ¨ {!!} âŸ©
--            (Î£[ k âˆ¶ (Î”â‚‚ â†’ A)]
--                Î£[ P âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i0 i) ï¼ dh .hom i) ]
--                 Î£[ Q âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i i1) ï¼ p i) ]
--                     ((ap (k âˆ˜ incl-horn) (glue tt)) âˆ™ (Q i0)
--                      ï¼ (P i1) âˆ™ ap (horn) (glue tt)))
--         â‰ƒâŸ¨ {!!} âŸ©
--            (Î£[ k âˆ¶ (Î”â‚‚ â†’ A)]
--                Î£[ P âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i0 i) ï¼ dh .hom i) ]
--                 Î£[ Q âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i i1) ï¼ p i) ]
--                     (Q i0
--                      ï¼ (P i1) âˆ™ dh .hom1))
--         â‰ƒâŸ¨ {!!} âŸ©
--            (Î£[ k âˆ¶ (Î”â‚‚ â†’ A)]
--                Î£[ Q âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i0 i) ï¼ dh .hom i) ]
--                 Î£[ P âˆ¶ ((i : I) â†’ k (mk-Î”â‚‚ i i1) ï¼ p i) ]
--                     (P i0
--                      ï¼ (Q i1) âˆ™ dh .hom1))
--         â‰ƒâŸ¨ {!!} âŸ©
--            (Î£[ h âˆ¶ (Hom A x b)]
--              Î£[ K âˆ¶ Î£[ K âˆ¶ ((i j : I) â†’ A) ] ((âˆ€ i â†’ K i i0 ï¼ x) Ã—
--                                               (âˆ€ i â†’ K i i1 ï¼ f .hom i)) ]
--                ((K .fst i0 ï¼ dh .hom) Ã— (K .fst i1 ï¼ h .hom)))
--         â‰ƒâŸ¨ {!!} âŸ©
--            (Î£[ h âˆ¶ (Hom A x b)]
--              Î£[ K âˆ¶ ((i : I) â†’ Hom A x (f .hom i))]
--                ((K i0 ï¼ dh) Ã— (K i1 ï¼ h)))
--         â‰ƒâŸ¨ {!!} âŸ©
--           Î£ (Hom A x b) (Î» h â†’ HomP (Î» i â†’ Hom A x (f .hom i)) dh h) â‰ƒâˆ

}
%```
