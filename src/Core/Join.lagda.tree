\date{2025-04-18}
\title{Joins}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb Core.Join \stopverb}

\import{stt-macros}


% ```agda
\agda{
module Core.Join where

open import Foundations.Prelude
open import ufAxioms
open import Core.Suspensions
open import Core.Arrow
open import Core.CocartesianSquare
open import Core.CanonicalPushouts
open import Core.PushoutEquiv
open import Ergonomics.Universal
open import Ergonomics.PushoutUniv
open import Ergonomics.Auto
open import Ergonomics.Extensionality

}
% ```


\subtree[stt-002S]{
\taxon{definition}
\title{Joins of types}
\meta{defines}{\startverb ["_*_"] \stopverb}

\p{The join of types #{A} and #{B}, written #{A * B} is
the pushout of the span
#{A \xleftarrow{\pi_1} A \times B \xrightarrow{pi_2} B}}

\quiver{
\begin{tikzcd}
	{A \times B} && A \\
	\\
	B && {A * B}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
\end{tikzcd}
}

% ```agda
\agda{
infixl 25 _*_

_*_ : ∀ {𝓤 𝓥} → Type 𝓤 → Type 𝓥 → Type (𝓤 ⊔ 𝓥)
A * B = Pushout {A = A × B} fst snd
}
% ```

}


\subtree[stt-002V]{
\title{Singleton joins}

\p{The join of a singleton with any type is also a singleton}

\proof{
\p{This follows from the fact that [pushing an equivalence out gives
an equivalence](stt-0080).}
}

% ```agda
\agda{
*-comm : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥} → A * B ≃ B * A
*-comm {A = A} {B} = pushout-comm ∙≃ (Pushout-adjust-equiv ×-swap)


*-single' : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
            → is-singleton B → is-singleton (A * B)
*-single' {A = A} {B} sb
  = is-single←equiv-to-single (mk≃ _ ι₂-is-equiv) sb where
  ι₂-is-equiv : is-equiv {B = A * B} ι₂
  ι₂-is-equiv = dom-is-equiv←cocartesian
                  (mk-amap snd ι₁ glue)
                  (singleton-fst-is-equiv (λ _ → sb))
                  (is-cocartesian←is-pushout Pushout-is-pushoutω)

*-single : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
           → is-singleton A → is-singleton (A * B)
*-single sa
  = is-single←equiv-to-single *-comm (*-single' sa)
}
% ```
}

\subtree[stt-002W]{
\taxon{theorem}
\title{Joins of propositions}

\p{The universal property for joins of propositions says that
for propositions #{P} and #{Q}, to eliminate into a proposition #{R},
it suffices to supply #{P \to R}, and #{Q \to R}}

\p{As an easy corollary, we have that the join of two propositions
is again a proposition.}

% ```agda
\agda{
*-prop-disj : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
              {Q : Type 𝓦}
           → is-prop A → is-prop B
           → is-prop Q
           → (A * B → Q) → (A → Q) × (B → Q)
*-prop-disj a b q f = (f ∘ ι₁ , f ∘ ι₂)


*-prop-disj≃ : ∀ {𝓤 𝓥 𝓦}
              {A : Type 𝓤} {B : Type 𝓥} {Q : Type 𝓦}
           → (pa : is-prop A) → (pb : is-prop B)
           → (pq : is-prop Q)
           → (A * B → Q) ≃ ((A → Q) × (B → Q))
*-prop-disj≃ {A = A} {B} {Q} pa pb pq
 = (A * B → Q)
      ≃⟨ Pushout-UP≃ ⟩
   Cocone (mk-span _ fst snd) Q
      ≃⟨ cocone-repr≃ ⟩
   Σ[ f ∶ (A → Q) ] Σ[ g ∶ (B → Q) ] (f ∘ fst ~ g ∘ snd)
      ≃⟨ Σ-ap-≃ (λ f → Σ-ap-≃ (λ g → curry≃)) ⟩
   Σ[ f ∶ (A → Q) ] Σ[ g ∶ (B → Q) ] ((a : A) → (b : B) → f a ＝ g b)
      ≃⟨ Σ-ap-≃ (λ a → Σ-singleton (λ x → is-singleton-Π λ
                     b → is-singleton-Π (λ
                       c → ＝-singleton←is-prop pq _ _))) ⟩
   ((A → Q) × (B → Q)) ≃∎

*-prop-UP : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
              {Q : Type 𝓦}
              (ap : is-prop A) (bp : is-prop B)
              (qp : is-prop Q)
            → is-equiv (*-prop-disj ap bp qp)
*-prop-UP ap bp qp = *-prop-disj≃ ap bp qp ._≃_.has-is-eqv

*-prop-rec : ∀ {𝓤 𝓥 𝓦}
              {A : Type 𝓤} {B : Type 𝓥} {Q : Type 𝓦}
           → (pa : is-prop A) → (pb : is-prop B)
           → (pq : is-prop Q)
           →  (A → Q) → (B → Q) → (A * B → Q)
*-prop-rec pa pb pq f g = _≃_.bwd (*-prop-disj≃ pa pb pq) (f , g)
{-# NOINLINE *-prop-rec #-}

*-is-prop : ∀ {𝓤 𝓥} {A : Type 𝓤} {B : Type 𝓥}
            → is-prop A → is-prop B
            → is-prop (A * B)
*-is-prop aprop bprop = is-prop←is-single-if-inhabited
  (*-prop-rec aprop bprop is-single-is-prop
    (λ a → *-single (mk-singl a (aprop a)))
    (λ b → *-single' (mk-singl b (bprop b))))
}
% ```

}
