\date{2025-06-17}
\title{Localisations}
\taxon{module}
\meta{module}{\startverb modalities.instances.Localisation \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module modalities.instances.Localisation where

open import ufAxioms
open import axioms.FreeAlgInj
open import foundations.Prelude
open import core.Orthogonal
open import core.CanonicalPushouts
open import core.Codiagonal
open import core.CoSlice
open import ergonomics.notations.Orthogonality
open import modalities.HigherModality
open import modalities.Subuniverses
open core.Orthogonal.notation
}
%```

\subtree[stt-005F]{
\taxon{definition}
\title{Local types}

\p{Given a family of maps #{f_i : A_i \to B_i}, we say that a type
is #{f}-local if it is [orthogonal](stt-004O) to each map.}

%```agda
\agda{
is-local : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘} {A : I → Type 𝓤} {B : I → Type 𝓥}
               → (f : (i : I) → A i → B i)
               → Type 𝓦
               → Type (𝓘 ⊔ 𝓤 ⊔ 𝓥 ⊔ 𝓦)
is-local f A = ∀ i → orthogonal-type (f i) A

is-local-is-prop
  : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘} {A : I → Type 𝓤} {B : I → Type 𝓥}
      {f : (i : I) → A i → B i}
    → ∀ (A : Type 𝓦) → is-prop (is-local f A)
is-local-is-prop A = is-prop-Π λ i → is-equiv-is-prop
}
%```
}


\subtree[stt-005G]{
\taxon{definition}
\title{Null types}

\p{Given a family of types #{A_i}, we say a type #{X} is #{A} null if
it is right orthogonal to each #{A_i}. Or equivalently, if the
obvious maps #{X \to (A_i \to X)} are equivalences for each #{i}.}

%```agda
\agda{
is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} (A : I → Type 𝓤)
            → Type 𝓥 → Type (𝓘 ⊔ 𝓤 ⊔ 𝓥)
is-null A X = ∀ i → is-equiv (const X (A i))
}
%```
}

\subtree[stt-005H]{
\taxon{theorem}
\title{Null types are #{!\rm{-local}}}

\p{A type is #{A_i}-null iff it is #{(! : A_i \to 1)\rm{-local}}.}

\proof{
\p{A type #{X} is #{!\rm{-local}} when the map #{- \circ\ ! : (1 \to X) \to (A_i \to X)}
is an equivalence.}
}

%```agda
\agda{
is-local←is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} {A : I → Type 𝓤}
                   → {X : Type 𝓥}
                   → is-null A X
                   → is-local (λ i → ! {A = A i}) X
is-local←is-null eq i = 3-for-2' (is-equiv⁻¹ unit-ev-is-equiv) (eq i)

is-null←is-local : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} {A : I → Type 𝓤}
                   → {X : Type 𝓥}
                   → is-local (λ i → ! {A = A i}) X
                   → is-null A X
is-null←is-local eq i = is-equiv-∘ (eq i) unit-const-is-equiv
}
%```
}

\subtree[stt-005K]{
\title{Nullfication at an pointed family}
\taxon{definition}

\p{The nullification of a pointed type can be constructed
using the [free algabraic injection](stt-005I)
higher inductive type. By definition, the free
algabraic injection already gives a section to
the precomposition map. Because any map #{A \to 1}
has a section, then the precomposition by this
map already has a retract, and so the type is not just
algabraicly #{A}-injective, but #{A}-null.}

%```agda
\agda{
Null∙ : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} (A : I → Type 𝓤)
         (A∙ : Π _ A) (X : Type 𝓥)
       → Type 𝓥
Null∙ A _ X = Free-inj
               (λ i → ! {A = A i})
                X

Null∙-is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘}
                 {A : I → Type 𝓤} {A∙ : Π _ A}
                 {X : Type 𝓥}
               → is-null A (Null∙ A A∙ X)
Null∙-is-null {A∙ = a} = is-null←is-local I where
  I : is-local (λ _ → !) _
  I i = is-equiv←qiso λ where
    .fst → injector-Free-inj i .fst
    .snd .fst α → funext→ (λ _ → Free-inj.is-ext (α ∘ !) (a i))
    .snd .snd → injector-Free-inj i .snd
}
%```
}


\subtree[stt-005Z]{
\taxon{lemma}
\title{Locality via sections of the codiagonal}
\citet{rijkeMod2020}{2.13}

\p{Given maps #{f_i : A_i \to B_i}, a type #{X} is #{f\rm{-local}}
iff #{-\circ f_i} and #{-\circ \nabla_{f_i}} all have sections.}

%```agda
\agda{
is-local←sec←sec-∇
  : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘}
      {A : I → Type 𝓤} {B : I → Type 𝓥}
      {f : (i : I) → A i → B i}
      {X : Type 𝓦}
    → (∀ i → section (postcomp X (f i)))
    → (∀ i → section (postcomp X (∇ (f i))))
    → is-local f X
is-local←sec←sec-∇ sec sec∇ i
  = is-equiv←is-pathsplit
      (is-pathsplit←sec-diag
        (sec i)
        (sec←sec-Coslice-equiv'
          (Δ←∇ _ _)
          Δ←∇-is-equiv
          (sec∇ i)))


sec∇←is-local
  : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘}
      {A : I → Type 𝓤} {B : I → Type 𝓥}
      {f : (i : I) → A i → B i}
      {X : Type 𝓦}
    → is-local f X
    → ∀ i → section (postcomp X (∇ (f i)))
sec∇←is-local loc i = sec←sec-Coslice-equiv
                        (Δ←∇ _ _)
                        Δ←∇-is-equiv
                        (sec-diag←is-pathsplit
                          (is-pathsplit←is-equiv (loc i)))
}
%```
}

\subtree[stt-005Y]{
\title{Localisation}
\taxon{definition}

\p{Unlike in the case of [nullification](stt-005K), we cannot
in general expect the family of functions against which we are
localising to all have sections. As such the [Free algabraicly injective](stt-005I)
type will not get us all the way to a localisation.}


\p{As explained in \citet{2.14}{rijkeMod2020}, even though the free algabraicly
#{f}-injective type is not a localisation, we can add some morphisms to the class
with which we localise against to make it so. By the observation in \ref{stt-005Z},
we need to add all maps of the form #{\nabla_{f_i}} to #{f}.}

%```agda
\agda{

module _ {𝓘 𝓤 𝓦 : Level} {I : Type 𝓘}
         {A : I → Type 𝓤} {B : I → Type 𝓤}
         where
  private
    A' : (f : ∀ i → A i → B i) → I ⊎ I → Type 𝓤
    A' f (left i) = A i
    A' f (right i) = Pushout (f i) (f i)

    B' : (f : ∀ i → A i → B i) → I ⊎ I → Type 𝓤
    B' f (left i)  = B i
    B' f (right i) = B i

    f' : (f : ∀ i → A i → B i) → (i : I ⊎ I) → A' f i → B' f i
    f' f (left i) = f i
    f' f (right i) = ∇ (f i)

  Loc : (f : ∀ i → A i → B i) → Type 𝓦 → Type 𝓦
  Loc f = Free-inj (f' f)

  Loc-is-local : ∀ {X : Type 𝓦}
                   {f : ∀ i → A i → B i}
                 → is-local f (Loc f X)
  Loc-is-local = is-local←sec←sec-∇
                   (λ i → injector-Free-inj (left i))
                   (λ i → injector-Free-inj (right i))
}
%```
}

\subtree[stt-0065]{
\date{2025-06-21}
\title{Nullification is a [higher modality](stt-000G)}
\taxon{theorem}


%```agda
\agda{
Null∙-HigherModality
  : ∀ {𝓘 𝓤} {I : Type 𝓘}
      {A : I → Type 𝓤}
      (a∙ : ∀ i → A i)
      𝓥
    → HigherModality 𝓥
Null∙-HigherModality a 𝓥 = hm where
  open HigherModality

  hm : HigherModality 𝓥
  ○ hm = Null∙ _ a
  hm .○-η = Free-inj.inc
  hm .○-ind P f = {!!}
  hm .○-β = {!!}
  hm .＝-○-is-○-modal = {!!}
}
%```
}


\subtree[stt-0066]{
\title{Localisation is a [reflective subuniverse](stt-0041)}

\p{Localisation at any family of maps forms a reflective subuniverse
which is not in general #{\Sigma}-closed.}

%```agda
\agda{
module _ {𝓘 𝓤 𝓦 : Level} {I : Type 𝓘}
         {A : I → Type 𝓤} {B : I → Type 𝓤}
         where
  open is-reflective
  open Reflector

  Local-SubU
    : (f : (i : I) → A i → B i)
      → SubU 𝓦 (𝓘 ⊔ 𝓤 ⊔ 𝓦)
  Local-SubU f = mk-subtype
                         {family = is-local f}
                         is-local-is-prop

  postcomp-inj : ∀ {𝓜}
                   {f : (i : I) → A i → B i}
                   (X : Type 𝓦) {Y : Type 𝓜}
                 → (Free-inj f X → Y)
                 → (X → Y)
  postcomp-inj X {Y} = postcomp Y Free-inj.inc


  -- This is RSS lemma 2.7: Should extract to it's own tree probably
  Local-reflects : ∀ {𝓜}
                   {f : (i : I) → A i → B i}
                   (X : Type 𝓦) {Y : Type 𝓜}
                 → is-local f Y
                 → is-equiv (postcomp-inj {f = f} X {Y})
  Local-reflects {_}{f} X {Y} Y-loc = is-equiv←is-pathsplit ps where
    module Y {i} = is-equiv (Y-loc i)
    module ∘Y {i g h} where
      abstract
        e : is-equiv (ap (postcomp Y (f i)) {g} {h})
        e = (is-embedding←is-equiv (Y-loc i))
      open is-equiv e public

    -- RHS (2.8) from RSS modalities
    lem : (g h : Free-inj f X → Y)
       (p : postcomp-inj X g ＝ postcomp-inj X h) (i : I)
       (g' : A i → Free-inj _ X)
       (x : g ∘ g' ~ h ∘ g') →
       postcomp Y (f i) (g ∘ Free-inj.ext g') ＝
       postcomp Y (f i) (h ∘ Free-inj.ext g')
    lem g h p i g' q = funext→ λ a → ap g (Free-inj.is-ext g' a)
                                   ∙ q a
                                   ∙ ap h (sym (Free-inj.is-ext g' a))

    ps : is-pathsplit (postcomp-inj X)
    -- The section for postcomp is easy
    ps .fst .fst g = Free-inj.ind
                       (λ _ → Y)
                       g
                       (λ _ → Y.bwd)
                       λ g' h a → tr-const (Free-inj.is-ext g' a)
                                  ∙ happly (Y.ε h) a
    ps .fst .snd h = refl
    -- Proof for second part (section of ap) at page 2:34
    ps .snd g h .fst p
      = funext→ (Free-inj.ind
                  (λ z → g z ＝ h z)
                  (happly p)
                  (λ g' x → happly
                    (∘Y.bwd (lem g h p _ g' x)))
                  λ g' H a → IdP-func←Square {f = g} {h}
                                              (Free-inj.is-ext g' a)
                                              _
                                              (H a)
                                              {!!})
    ps .snd g h .snd p = {!!}

  Local-reflective
    : (f : (i : I) → A i → B i)
    → is-reflective (Local-SubU f)
  Local-reflective f .has-reflectors A .Reflector.○ = Loc f A
  Local-reflective f .has-reflectors A .○∈S = Loc-is-local
  Local-reflective f .has-reflectors A .○-η = Free-inj.inc
  Local-reflective f .has-reflectors A .reflects = {!!}
}
%```
}
