\date{2025-11-17}
\title{Precategories}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\transclude{stt-00AB}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Precategories
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I I-distr

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation
open import Modalities.ModalMaps

open import Core.Join
open import Core.CanonicalPushouts

open import Data.Bool

open import Synthetic.Categories.Simplicial Î”Â¹ I I-distr
open import Synthetic.Categories.Horns Î”Â¹ I I-distr
open import Synthetic.Categories.Boundaries Î”Â¹ I I-distr
open import Synthetic.Hom Î”Â¹ i0 i1
}
%```


\subtree[stt-00AI]{
\title{Precategories}
\taxon{Definition}


\p{We say that a type is a \strong{precategory} or that it is a \strong{Segal}
type if it is local with respect to the inclusion of the [#{(2,1)} horn](stt-00AD)
into the 2-simplex. We can use the fact that [being local with respect to some
class of maps forms a global reflective subuniverse](stt-0066) to bootstrap some
useful notions, such as preservation under identity and pi types as well as the
localisation operation. Note that unlike in the case of [simplicial types](stt-00AC)
this subuniverse is neither #{\Sigma}-closed nor lex.}

\p{We call maps which are local to the inner horn inclusion \strong{inner maps}.}

%```agda
\agda{
open Subtype

is-precategory : âˆ€ {ğ“¤} (C : Type ğ“¤) â†’ Type (ğ“¤ âŠ” ğ“˜)
is-precategory = is-local Î» (tt : ğŸ™) â†’ Î›[2,1]-incl

Precats-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Precats-SubU = Local-SubU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl) _

Precats-GSU : GSU (_âŠ” ğ“˜)
Precats-GSU = Local-GSU (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

Precats-is-globally-reflective
   : is-globally-reflective Precats-GSU
Precats-is-globally-reflective
  = Local-global-reflectors (Î» (tt : ğŸ™) â†’ Î›[2,1]-incl)

module Precat where
  open GSU Precats-GSU public renaming (S-equiv to is-precategoryâ†equiv)

  open is-globally-reflective Precats-is-globally-reflective
  open GPiClosure Precats-is-globally-reflective public
    renaming (Î âˆˆS to Î -is-precategory; Ã—âˆˆS to Ã—-is-precategory)

  is-inner : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ (A â†’ B) â†’ Type (ğ“˜ âŠ” ğ“¤ âŠ” ğ“¥)
  is-inner = is-modal-map Precats-SubU
}
%```
}

\subtree[stt-00AK]{
\title{Composite morphisms}
\taxon{Definition}

\p{Given the data of the boundary of a 2-simplex:}

\quiver{
\begin{tikzcd}
        x && y \\
	\\
	&& z
	\arrow["g", from=1-1, to=1-3]
	\arrow["h"', from=1-1, to=3-3]
	\arrow["f", from=1-3, to=3-3]
\end{tikzcd}
}

\p{We define the type of fillers, written #{\Hom 2(f,g;h)}, which we say witnesses
that #{fg \sim h}.}

%```agda
\agda{
Hom2 : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z : A}
         (f : Hom _ y z) (g : Hom _ x y) (h : Hom _ x z)
       â†’ Type (ğ“˜ âŠ” ğ“¤)
Hom2 {A = A} f g h
  = Î£[ H âˆ¶ (Î”Â² â†’ A) ] (H âˆ˜ Î´Î”Â²-incl ï¼ make-Î´Î”Â² f g h)
}
%```
}


\subtree[stt-00AL]{
\title{Morphisms have unique composites in a precategory}
\taxon{Theorem}

\p{Given a pair of composable morphisms, we can naturally define a map
#{\Delta^2_1 \to C}. We show that there is a unique 2-simplex that extends
#{f} and #{g}.}


\proof{
\p{[Precategories](stt-00AI) are defined to be those types which are local
with respect to the inclusion #{i : \Lambda^2_1 \hookrightarrow \Delta^2}. The
fibres of #{i^* : (\Delta^2 \to C) \to (\Lambda^2_1 \to C)} are exactly the maps
#{\Delta^2 \to C} which extend the boundary #{f,g}.}
}

%```agda
\agda{
opaque
  precategory-unique-composite : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ is-precategory A
                               â†’ (f : Hom A y z) (g : Hom A x y)
                               â†’ is-singleton (Î£[ H âˆ¶ (Î”Â² â†’ A)]
                                                 (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g))
  precategory-unique-composite Apc f g
    = is-contr-mapâ†is-equiv (Apc tt) (make-horn f g)

ext-Î›[2,1] : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
             â†’ Ext Î´Î”Â²â†Î›[2,1] {Î» _ â†’ A} (make-horn f g) â†’ Hom A x z
ext-Î›[2,1] f g (h , k)
    = mk-hom (h âˆ˜ Î¹â‚‚)
             (ap h (sym (glue Î´Î”Â¹-0)) âˆ™ happly k (Î¹â‚ i0) âˆ™ g .HomP.hom0)
             (ap h (sym (glue Î´Î”Â¹-1)) âˆ™ happly k (Î¹â‚‚ i1) âˆ™ f .HomP.hom1)

ext-Î›[2,1]-is-equiv : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
                    â†’ is-equiv (ext-Î›[2,1] f g)
ext-Î›[2,1]-is-equiv f g = is-equivâ†qiso qiso where
  qiso : quasi-iso (ext-Î›[2,1] f g)
  qiso .fst h@(mk-hom hh h0 h1) =  make-Î´Î”Â² f g h , refl
  qiso .snd .fst h
    = fibre-pathâ†’ (sym (pushout-rec-unique _ _
                         (happly (pushout-rec-unique _ _
                                   (happly (h .snd) âˆ˜ Î¹â‚)
                                   (happly (h .snd) âˆ˜ Î¹â‚‚)
                                   {!!}))
                       ~refl
                       Î» { (mk-lift true) â†’ {!!} ; (mk-lift false) â†’ {!!}})
                  , {!!})
  qiso .snd .snd b
    = Hom-extâ†’
        ( ~refl
        , sym (ap (_âˆ™ g .HomP.hom0) ( ap-sym (pushout-rec _) (glue Î´Î”Â¹-0)
                                     âˆ™ ap sym (pushout-rec-apÎ² (mk-lift false)))
              âˆ™ {!!} )
        , sym (ap (_âˆ™ f .HomP.hom1) ( ap-sym (pushout-rec _) (glue Î´Î”Â¹-1)
                                     âˆ™ ap sym (pushout-rec-apÎ² (mk-lift true)))
              âˆ™ {!!}))

compositeâ†horn-extension
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
    â†’ Î£[ H âˆ¶ (Î”Â² â†’ A)] (H âˆ˜ Î›[2,1]-incl ï¼ make-horn f g)
    â†’ Î£[ h âˆ¶ Hom A x z ] (Hom2 f g h)
compositeâ†horn-extension {A = A} {x} {y} {z} f g
  = total-map-fst (ext-Î›[2,1] f g)
  âˆ˜ total-map (Î» e â†’ tr (Ext Î´Î”Â²-incl)
                        (ap fst ((is-equiv.Î·â»Â¹ (ext-Î›[2,1]-is-equiv f g)) e)))
  âˆ˜ Ext-compose Î´Î”Â²-incl Î´Î”Â²â†Î›[2,1] (make-horn f g) ._â‰ƒ_.fwd


compositeâ†horn-extension-is-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} (f : Hom A y z) (g : Hom A x y)
    â†’ is-equiv (compositeâ†horn-extension f g)
compositeâ†horn-extension-is-equiv f g
  = is-equiv-âˆ˜ (total-is-equivâ†fst-is-equiv (ext-Î›[2,1]-is-equiv f g))
               (is-equiv-âˆ˜ (is-total-equivâ†is-fibrewise-equiv
                 (Î» e â†’ tr-is-equiv {B = Ext Î´Î”Â²-incl}
                         ((ap fst ((is-equiv.Î·â»Â¹ (ext-Î›[2,1]-is-equiv f g)) e)))))
               (Ext-compose Î´Î”Â²-incl Î´Î”Â²â†Î›[2,1] (make-horn f g) ._â‰ƒ_.has-is-eqv))

Î”Â²-UPâ†’ : âˆ€ {ğ“¤} {A : Type ğ“¤}
        â†’ (Î”Â² â†’ A)
        â†’ Î£[ g âˆ¶ (Î”Â¹ â†’ A) ]
           Î£[ z âˆ¶ A ] Î£[ f âˆ¶ Hom A (g i1) z ]
             Î£[ h âˆ¶ Hom A (g i0) z ] Hom2 f (Î»hom g) h
Î”Â²-UPâ†’ H = (H âˆ˜ (_, i0)
           , (H (i1 , i1))
           , mk-hom (H âˆ˜ (i1 ,_)) (ap H Î”Â²-refl) (ap H Î”Â²-refl)
           , mk-hom (H âˆ˜ Î”Â²-diagonal) (ap H Î”Â²-refl) refl
           , (H , pushout-rec-unique _ _
                   (pushout-ind _
                     (mk-coconeD ~refl ~refl Î» _
                      â†’ IdP-funcâ†Square (glue tt) refl refl
                          (âˆ™-reflr _
                          âˆ™ ap-âˆ˜ H _ (glue tt)
                          âˆ™ ap (ap H) (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _) âˆ™ ap-sym _ _ âˆ™ sym (pushout-rec-apÎ² tt))))
                   ~refl
               Î» { (mk-lift true) â†’ âˆ™-reflr _ âˆ™ ap-âˆ˜ H _ (glue Î´Î”Â¹-1)
                                    âˆ™ ap (ap H) (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
                                    âˆ™ sym (âˆ™-reflr _)
               ; (mk-lift false) â†’ âˆ™-reflr _
                                   âˆ™ ap-âˆ˜ H _ (glue Î´Î”Â¹-0)
                                   âˆ™ ap (ap H) (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
                                   âˆ™ ap-sym _ _ }))

Î”Â²-UP-is-equiv : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-equiv (Î”Â²-UPâ†’ {A = A})
Î”Â²-UP-is-equiv = {!!}


_âˆ˜[_]_ :  âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} â†’ Hom A y z â†’ is-precategory A
          â†’ Hom A x y â†’ Hom A x z
f âˆ˜[ apc ] g = fst (compositeâ†horn-extension f g
                    (centre (precategory-unique-composite apc f g)))

âˆ˜[_]-is-composite
  : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z} {f : Hom A y z} {g : Hom A x y}
    â†’ (apc : is-precategory A) â†’ Hom2 f g (f âˆ˜[ apc ] g)
âˆ˜[_]-is-composite {f = f} {g} apc
  = snd (compositeâ†horn-extension _ _
          (centre (precategory-unique-composite apc f g)))

opaque
  unique-composite : âˆ€ {ğ“¤} {A : Type ğ“¤} (apc : is-precategory A)
                       {x y z} (f : Hom A y z) (g : Hom A x y)
                    â†’ (h : Hom A x z) â†’ Hom2 f g h â†’ h ï¼ (f âˆ˜[ apc ] g)
  unique-composite apc f g h K
    = sym (ap fst
             ((is-singleâ†equiv-to-single
                (mkâ‰ƒ (compositeâ†horn-extension f g)
                     (compositeâ†horn-extension-is-equiv f g))
                (precategory-unique-composite apc f g))
               .central (h , K)))
}
%```
}
