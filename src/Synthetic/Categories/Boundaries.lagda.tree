\date{2025-12-18}
\title{The booundary of simpleces}
\author{samtoth}
\taxon{module}
\import{stt-macros}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Boundaries
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I


open import Synthetic.Hom Î”Â¹ i0 i1
open import Synthetic.Categories.Horns Î”Â¹ I I-distr

open import Ergonomics.Extensionality

open import Modalities.Instances.Truncation

open import Data.Bool

open import Core.Join
open import Core.FlatteningPushouts
open import Core.SpanMap
}
%```

\subtree[tot-000O]{
\taxon{Definition}
\title{The boundary of the interval}

\p{The boundary of the interval, written #{\delta \Delta^1}, is just the two
pointed type #{\{0,1\}}. Specifically, we use a copy of the booleans living in
the same universe as the interval.}

\p{We record the universal property (that of the booleans), as well as it's
inclusion into the interval, as well as into the [inner horn](stt-00AD).
Finally we note that this inclusion is an embedding, as long as #{I} is not
the trivial lattice.}

%```agda
\agda{
Î´Î”Â¹ : Type ğ“˜
Î´Î”Â¹ = ULift _ Bool

Î´Î”Â¹-0 Î´Î”Â¹-1 : Î´Î”Â¹
Î´Î”Â¹-0 = mk-lift false
Î´Î”Â¹-1 = mk-lift true

make-Î´Î”Â¹ : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ A â†’ Î´Î”Â¹ â†’ A
make-Î´Î”Â¹ a b (mk-lift true) = a
make-Î´Î”Â¹ a b (mk-lift false) = b

Î´Î”Â¹-UPâ†’ : âˆ€ {ğ“¤} {A : Î´Î”Â¹ â†’ Type ğ“¤} â†’ (A Î´Î”Â¹-0 Ã— A Î´Î”Â¹-1) â†’ Î  _ A
Î´Î”Â¹-UPâ†’ x (mk-lift false) = x .fst
Î´Î”Â¹-UPâ†’ x (mk-lift true)  = x .snd

Î´Î”Â¹-UP : âˆ€ {ğ“¤} {A : Î´Î”Â¹ â†’ Type ğ“¤} â†’ (A Î´Î”Â¹-0 Ã— A Î´Î”Â¹-1) â‰ƒ Î  _ A
Î´Î”Â¹-UP = mkâ‰ƒ Î´Î”Â¹-UPâ†’ (is-equivâ†qiso ((Î» x â†’ (x Î´Î”Â¹-0 , x Î´Î”Â¹-1))
                                    , ~refl
                                    , (Î» f â†’ funextâ†’ (Î´Î”Â¹-UPâ†’ (refl , refl)))))

Î´Î”Â¹-incl : Î´Î”Â¹ â†’ Î”Â¹
Î´Î”Â¹-incl (mk-lift false) = i0
Î´Î”Â¹-incl (mk-lift true) = i1

Î´Î”Â¹-embeds : ((i0 ï¼ i1) â†’ âˆ…) â†’ is-embedding (Î´Î”Â¹-incl)
Î´Î”Â¹-embeds nt = is-equivâ†inverse
                  (is-propâ†is-truncated
                    (Trunc.ULift-is-truncated
                      (is-truncatedâ†is-set Bool-is-set) _ _))
                  (is-propâ†is-truncated (car-is-set _ _))
                  map where
  map : âˆ€ {x y} â†’ Î´Î”Â¹-incl x ï¼ Î´Î”Â¹-incl y â†’ x ï¼ y
  map {mk-lift true} {mk-lift true} _ = refl
  map {mk-lift true} {mk-lift false} p = Â¡ nt (sym p)
  map {mk-lift false} {mk-lift true} p = Â¡ nt p
  map {mk-lift false} {mk-lift false} _ = refl

Î´Î›[2,1]-incl : Î´Î”Â¹ â†’ Î›[2,1]
Î´Î›[2,1]-incl (mk-lift false) = Î¹â‚ i0
Î´Î›[2,1]-incl (mk-lift true ) = Î¹â‚‚ i1
}
%```
}

\subtree[tot-000S]{
\title{The boundary of the 2-simplex}
\taxon{Definition}

\p{
We construct the boundary of the [2 simplex](stt-009X) on the interval as the
result of gluing a copy of the interval along the boundary of the
[inner horn](stt-00AD). There are many choices of this construction, but we use
one which is particularly useful when dealing with the segal condition for
precategories.
}

\p{Just as above, and in [[stt-00B8]], we record that there is an inclusion
#{\delta \Delta^2 \to \Delta^2}, and that this is an embedding as long as #{I}
is not the trivial lattice. Even better, we show that the image of this inclusion
determines #{\delta \Delta^2} as the subset of the 2-simplex #{(i,j)} where
#{(i,j) \in \Lambda^2_1 \lor i = j}.
}

%```agda
\agda{
Î´Î”Â² : Type ğ“˜
Î´Î”Â² = Pushout {A = Î´Î”Â¹} {B = Î›[2,1]} {C = Î”Â¹} Î´Î›[2,1]-incl Î´Î”Â¹-incl

Î´Î”Â²-Î”Â²-cocone : Cocone (mk-span _ Î´Î›[2,1]-incl Î´Î”Â¹-incl) Î”Â²
Î´Î”Â²-Î”Â²-cocone = (mk-cocone Î›[2,1]-incl Î”Â²-diagonal Î» where
                         (mk-lift true) â†’ Î”Â²-refl
                         (mk-lift false) â†’ Î”Â²-refl)

Î´Î”Â²-incl : Î´Î”Â² â†’ Î”Â²
Î´Î”Â²-incl = pushout-rec Î´Î”Â²-Î”Â²-cocone

Î´Î”Â²â†Î›[2,1] : Î›[2,1] â†’ Î´Î”Â²
Î´Î”Â²â†Î›[2,1] = Î¹â‚

module _ (non-triv : (I .Lattice.0l ï¼ I .Lattice.1l) â†’ âˆ…) where
  Î´Î”Â²-sub : Subtype Î”Â² ğ“˜
  Î´Î”Â²-sub .Subtype.family t@(i , j) = (t âˆˆ Î›[2,1]Sub) * (j ï¼ i)
  Î´Î”Â²-sub .Subtype.has-is-subtype a@(i , j)
    = *-is-prop (âˆˆ-is-prop Î›[2,1]Sub a) (is-prop-separated _ _)

  Î´Î”Â²-as-subtype : âˆ€ a â†’ fibre Î´Î”Â²-incl a â‰ƒ a âˆˆ Î´Î”Â²-sub
  Î´Î”Â²-as-subtype a@(i , j)
    = fibre Î´Î”Â²-incl a â‰ƒâŸ¨ cogap-fibre _ a âŸ©
      Pushout (total-fibre-span .left) (total-fibre-span .right)
          â‰ƒâŸ¨  coeâ‰ƒ (ap (Î» x â†’ Pushout (left x) (right x))
                             (ext! (span-map' , span-map-is-equiv))) âŸ©
      Pushout (intended-span .left) (intended-span .right)
                                â‰ƒâŸ¨âŸ©
      (a âˆˆ Î´Î”Â²-sub)             â‰ƒâˆ where
    open Span

    total-fibre-span : Span ğ“˜ ğ“˜ ğ“˜
    total-fibre-span = total-span Î´Î›[2,1]-incl Î´Î”Â¹-incl
                                  (Fibre-family Î´Î”Â²-Î”Â²-cocone a)

    intended-span : Span ğ“˜ ğ“˜ ğ“˜
    intended-span = mk-span ((a âˆˆ Î›[2,1]Sub) Ã— (j ï¼ i)) fst snd

    span-map' : Span-map total-fibre-span intended-span
    span-map' .Span-map.hâ‚ = _â‰ƒ_.fwd (Î›[2,1]-as-subtype a)
    span-map' .Span-map.hâ‚‚ (mk-lift true , p)
       = (Î¹â‚‚ (ap Poly.Î”Â².s p) , sym (ap Poly.Î”Â².t p) âˆ™ ap Poly.Î”Â².s p)
    span-map' .Span-map.hâ‚‚ (mk-lift false , p)
       = (Î¹â‚ (ap Poly.Î”Â².t p) , sym (ap Poly.Î”Â².t p) âˆ™ ap Poly.Î”Â².s p)
    span-map' .Span-map.hâ‚ƒ (b , refl) = refl
    span-map' .Span-map.H (mk-lift true , _)
      = âˆˆ-is-prop Î›[2,1]Sub a _ _
    span-map' .Span-map.H (mk-lift false , _)
      = âˆˆ-is-prop Î›[2,1]Sub a _ _
    span-map' .Span-map.K (mk-lift true , refl) = refl
    span-map' .Span-map.K (mk-lift false , refl) = refl

    test : ((i1 ï¼ i) Ã— (i1 ï¼ j)) âŠ ((i0 ï¼ i) Ã— (i0 ï¼ j))
         â†’ Î£[ t âˆ¶ Î´Î”Â¹ ] ((Î´Î”Â¹-incl t , Î´Î”Â¹-incl t) ï¼ (i , j))
    test (inl x) = (mk-lift true , Î”Â²-ext x)
    test (inr x) = (mk-lift false , Î”Â²-ext x)

    inv : Centre intended-span â†’ Î£[ t âˆ¶ Î´Î”Â¹ ] ((Î´Î”Â¹-incl t , Î´Î”Â¹-incl t) ï¼ (i , j))
    inv (horn , refl) = test (pushout-rec
                               (mk-cocone
                                 (Î» where refl â†’ inr (refl , refl))
                                 (Î» where refl â†’ inl (refl , refl))
                                 Î» where (p , refl) â†’ Â¡ non-triv p)
                               horn)

    linv : retract-witness (Span-map.hâ‚‚ span-map') inv
    linv (mk-lift false , refl)
      = Î£-pathâ†’ (refl , is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)
    linv (mk-lift true , refl)
      = Î£-pathâ†’ (refl , is-propâ†is-truncated (Î”Â²-is-set _ _) _ _)

    rinv : section-witness (Span-map.hâ‚‚ span-map') inv
    rinv (horn , refl) = p horn where
      p : âˆ€ (P : (i , i) âˆˆ Î›[2,1]Sub)
        â†’ (Span-map.hâ‚‚ span-map' âˆ˜ inv) (P , refl) ï¼ (P , refl)
      p = pushout-ind _ (mk-coconeD
           (Î» where refl â†’ Î£-pathâ†’ ( ap Î¹â‚ (Î”Â²-ext-ap-t refl refl)
                                   , is-prop-separated _ _ _ _))
           (Î» where refl â†’ Î£-pathâ†’ ( ap Î¹â‚‚ (Î”Â²-ext-ap-s refl refl)
                                   , is-prop-separated _ _ _ _))
           Î» where (p , refl) â†’ Â¡ non-triv p)

    span-map-is-equiv : is-Span-equiv span-map'
    span-map-is-equiv .fst = _â‰ƒ_.has-is-eqv (Î›[2,1]-as-subtype a)
    span-map-is-equiv .snd .fst
      = is-equivâ†qiso (inv , linv , rinv)
    span-map-is-equiv .snd .snd
      = is-equivâ†qiso ((Î» p â†’ (j , Î”Â²-ext (p , refl)))
                      , (Î» {(k , refl) â†’ Î£-pathâ†’ (refl ,
                                     (is-propâ†is-truncated (Î”Â²-is-set _ _) _ _))})
                      , Î» p â†’ is-propâ†is-truncated (car-is-set _ _) _ _ )

  Î´Î”Â²â‰ƒSub : Î´Î”Â² â‰ƒ Subtype.Î£Ìƒ Î´Î”Â²-sub
  Î´Î”Â²â‰ƒSub
    = Î´Î”Â²                               â‰ƒâŸ¨ totalâ‰ƒtotal-fibre Î´Î”Â²-incl eâ»Â¹ âŸ©
      total-fibre Î´Î”Â²-incl              â‰ƒâŸ¨âŸ©
      (Î£[ a âˆ¶ Î”Â² ] fibre Î´Î”Â²-incl a)    â‰ƒâŸ¨ Î£-ap-â‰ƒ Î´Î”Â²-as-subtype âŸ©
      (Î£[ a âˆ¶ Î”Â² ] (a âˆˆ Î´Î”Â²-sub))       â‰ƒâŸ¨âŸ©
      Subtype.Î£Ìƒ Î´Î”Â²-sub                 â‰ƒâˆ

make-Î´Î”Â² : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y z}
          â†’ Hom A y z â†’ Hom A x y â†’ Hom A x z
          â†’ Î´Î”Â² â†’ A
make-Î´Î”Â² f@(mk-hom fh f0 f1) g@(mk-hom gh g0 g1) h@(mk-hom hh h0 h1)
  = pushout-rec (mk-cocone (make-horn f g) (h .HomP.hom) Î» where
                               (mk-lift false) â†’ g0 âˆ™ sym h0
                               (mk-lift true ) â†’ f1 âˆ™ sym h1)
}
%```
}
