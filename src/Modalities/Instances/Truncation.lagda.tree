\date{2025-06-27}
\title{Truncation modalities}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Modalities.Instances.Truncation where

open import Foundations.Prelude
open import Foundations.IdentitySystem
open import ufAxioms
open import Core.Suspensions
open import Core.Spheres
open import Modalities.Instances.Localisation
open import Modalities.Subuniverses
open import Modalities.HigherModality
open import Modalities.GlobalSubuniverses
open import Modalities.Separated
open import Ergonomics.Universal
open import Ergonomics.PushoutUniv
open import Ergonomics.Extensionality
import Modalities.ModalMaps
}
%```

\subtree[stt-006P]{
\taxon{Definition}
\title{#{n}-truncated types}

\p{A type #{X} is #{n}-truncated for #{n : \mathbb{N}} when it is
#{n}-[separated](stt-007H) with respect to being a
[singleton](stt-0006).  Equivalently, a type is #{n}-truncated if it
is [null](stt-005G) with respect to #{S^{n-1}}.  }

%```agda
\agda{
is-S-null : âˆ€ {ğ“¤}
             â†’ â„•
             â†’ Type ğ“¤ â†’ Type ğ“¤
is-S-null n = is-null {I = ğŸ™} (const _ _ (S n))

singleton-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ ğ“¤
singleton-SubU .Subtype.family = is-singleton
singleton-SubU .Subtype.has-is-subtype _ = is-single-is-prop

is-truncated : âˆ€ {ğ“¤} (n : â„•) (A : Type ğ“¤) â†’ Type ğ“¤
is-truncated = is-n-separated singleton-SubU
}
%```
}

\remark{Note that we use numbering starting from #{0}
as opposed to from #{-2} as is often used.}

\subtree[stt-006T]{
\title{Truncation-modal types are #{n}-types}
\taxon{Theorem}

\p{We show #{0}-truncated types are singletons, and #{1}-truncated
types are propositions. Furthermore, by the [general theory](stt-007F)
of separated types, we show that #{n + 1} truncated types are null
with respect to the #{n}-sphere.
}

%```agda
\agda{
is-singletonâ†is-truncated
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ is-truncated 0 A
    â†’ is-singleton A
is-singletonâ†is-truncated {A = A} trunc = unlift trunc

is-truncatedâ†is-singleton
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ is-singleton A
    â†’ is-truncated 0 A
is-truncatedâ†is-singleton {A = A} tr
  = mk-lift tr

is-propâ†is-truncated
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ is-truncated 1 A
    â†’ is-prop A
is-propâ†is-truncated {A = A} tr x = is-singleton.centre âˆ˜ unlift âˆ˜ tr x

is-truncatedâ†is-prop
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
    â†’ is-prop A
    â†’ is-truncated 1 A
is-truncatedâ†is-prop {A = A} pr x y
  = mk-lift (ï¼-singletonâ†is-prop pr x y)

is-propâ†is-S0-null : âˆ€ {ğ“¤} {A : Type ğ“¤}
                     â†’ is-null (const _ ğŸ™ (S 0)) A
                     â†’ is-prop A
is-propâ†is-S0-null {A = A} null x y
  =   sym (happly (Îµ f) (Î¹â‚ tt)) âˆ™ happly (Îµ f) (Î¹â‚‚ tt) where
  open is-equiv (null tt)

  f : S 0 â†’ A
  f = rec! (mk-coconeU x y (Î» ()))

is-S0-nullâ†is-prop : âˆ€ {ğ“¤} {A : Type ğ“¤}
                     â†’ is-prop A
                     â†’ is-null (const _ ğŸ™ (S 0)) A
is-S0-nullâ†is-prop {_}{A} pr _ = is-equivâ†qiso qiso where
  qiso : quasi-iso Î» (a : A) (b : Susp âˆ…) â†’ a
  qiso .fst f = f (Î¹â‚ tt)
  qiso .snd .fst = ~refl
  qiso .snd .snd f = funextâ†’ (Î» a â†’ pr _ _)

is-truncatedâ†null : âˆ€ {ğ“¤} n {A : Type ğ“¤}
                    â†’ is-S-null n A
                    â†’ is-truncated (suc n) A
is-truncatedâ†null zero = is-truncatedâ†is-prop âˆ˜ is-propâ†is-S0-null
is-truncatedâ†null (suc n) {A} null x y
  = is-truncatedâ†null n (lem x y) where
  lem : is-separated (Null-SubU (Î» (_ : ğŸ™) â†’ S n) _) A
  lem = is-separatedâ†is-Î£-null (Î» _ â†’ S n) null

is-nullâ†truncated : âˆ€ {ğ“¤} n {A : Type ğ“¤}
                    â†’ is-truncated (suc n) A
                    â†’ is-S-null n A
is-nullâ†truncated zero = is-S0-nullâ†is-prop âˆ˜ is-propâ†is-truncated
is-nullâ†truncated (suc n) tr  = is-Î£-nullâ†is-separated _ lem where
  lem : âˆ€ x y â†’ is-S-null n (x ï¼ y)
  lem x y = is-nullâ†truncated n (tr x y)

is-set : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
is-set A = âˆ€ (x y : A) â†’ is-prop (x ï¼ y)

is-truncatedâ†is-set : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-set A â†’ is-truncated 2 A
is-truncatedâ†is-set A-set = Î» x y â†’ is-truncatedâ†is-prop (A-set x y)
}
%```
}

\subtree[stt-006Q]{
\title{Truncation is a [global reflective subuniverse](stt-007A)}
\taxon{Corollary}

%```agda
\agda{
Truncation-SubU
  : âˆ€ {ğ“¤} (n : â„•)
    â†’ SubU ğ“¤ ğ“¤
Truncation-SubU = n-separated-SubU singleton-SubU

singleton-GSU : GSU id
singleton-GSU .GSU.S = singleton-SubU
singleton-GSU .GSU.S-equiv = is-singleâ†equiv-to-single

Truncation-GSU : â„• â†’ GSU id
Truncation-GSU = n-separated-GSU singleton-GSU

Truncâ‰ƒSNull-GSU : âˆ€ {n} â†’ GSU-equiv (Null-GSU (Î» (_ : ğŸ™) â†’ S n))
                                    (Truncation-GSU (suc n))
Truncâ‰ƒSNull-GSU A = (is-truncatedâ†null _ , is-nullâ†truncated _)

singleton-GSU-is-reflective : is-globally-reflective singleton-GSU
singleton-GSU-is-reflective .is-globally-reflective.â—‹ A = âˆ… â†’ A
singleton-GSU-is-reflective .is-globally-reflective.Î· a _ = a
singleton-GSU-is-reflective .is-globally-reflective.has-is-reflector
  {ğ“¤} {A} = gr where
  open is-global-reflector
  gr : is-global-reflector singleton-GSU A (âˆ… â†’ A) (const A âˆ…)
  gr .â—‹âˆˆS = âˆ…-UP-sing
  gr .reflects Qs = is-equivâ†single-to-prop
                     (is-singleton-Î  (Î» _ â†’ Qs))
                     (is-propâ†is-single (is-singleton-Î  (Î» _ â†’ Qs)))
                     (postcomp _ (const A âˆ…))



Truncation-grefl : âˆ€ {n} â†’ is-globally-reflective (Truncation-GSU n)
Truncation-grefl {zero}
  = mk-gReflectors â—‹ Î· (mk-grfltor (mk-lift â—‹âˆˆS) (reflects âˆ˜ unlift))
  where open is-globally-reflective singleton-GSU-is-reflective
Truncation-grefl {suc n} = is-globally-reflective-subtype-equiv
                            Truncâ‰ƒSNull-GSU
                            (Nullâˆ™-global-reflectors (Î» _ â†’ S-âˆ™))

Truncation-refl : âˆ€ {ğ“¤} n â†’ is-reflective (Truncation-SubU {ğ“¤} n)
Truncation-refl n = is-reflectiveâ†global (Truncation-grefl)

Truncation-Î£-closed : âˆ€ {n} â†’ is-globally-Î£-closed (Truncation-GSU n)
Truncation-Î£-closed {zero} As Bs
  = mk-lift (Singleton-Î£ (unlift As) (unlift âˆ˜ Bs))
Truncation-Î£-closed {suc n} {A = A} {B} As Bs
  = Truncâ‰ƒSNull-GSU (Î£ A B) .fst (Null-globally-Î£-closed
                                   (is-nullâ†truncated _ As)
                                   (is-nullâ†truncated _ âˆ˜ Bs))
module Trunc {n} where
  open GRSUInduction (Truncation-grefl {n}) Truncation-Î£-closed public

  open GSU (Truncation-GSU n) public renaming (S-equiv to is-truncatedâ†equiv)
  open GPiClosure (Truncation-grefl {n}) public
    renaming (Î âˆˆS to Î -is-truncated; ULiftâˆˆS to ULift-is-truncated)
  open is-globally-reflective (Truncation-grefl {n}) public

  Î£-is-truncated = Truncation-Î£-closed {n}

Trunc : âˆ€ {ğ“¤} n â†’ Type ğ“¤ â†’ Type ğ“¤
Trunc n = Trunc.â—‹ {n}

âˆ¥_âˆ¥ : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
âˆ¥_âˆ¥ = Trunc 1
{-# NOINLINE âˆ¥_âˆ¥ #-}

âˆ¥-âˆ¥-is-prop : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-prop âˆ¥ A âˆ¥
âˆ¥-âˆ¥-is-prop = is-propâ†is-truncated Trunc.â—‹âˆˆS

{-# DISPLAY Trunc.â—‹ {n} A = Trunc n A #-}
}
%```
}


\subtree[stt-0075]{
\title{Lifting truncation levels}
\taxon{Theorem}

\p{An #{n}-truncated type is #{n+k} truncated for any #{k : â„•}.}



\quiver{
\begin{tikzcd}
	A &&&& {A^{\Sigma S^n}} \\
	\\
	&&&& {\Sigma_{a,b}(a=b)^{S^n}}
	\arrow["{\Delta_{A}}", from=1-1, to=1-5]
	\arrow["{(a,a,\Delta_{\rm{refl}})}"', from=1-1, to=3-5]
	\arrow[from=3-5, to=1-5]
\end{tikzcd}
}

%```agda
\agda{
suc-is-null : âˆ€ {ğ“˜ ğ“¤ ğ“¥}
                {I : Type ğ“˜}
                {X : I â†’ Type ğ“¥}
                {A : Type ğ“¤}
              â†’ is-null X A
              â†’ is-null (Susp âˆ˜ X) A
suc-is-null {X = X}{A} AXnull i = eqv where opaque
  module eqv = is-equiv (AXnull i)
  Ideq : {x y : A} â†’ (x ï¼ y) â‰ƒ (X i â†’ x ï¼ y)
  Ideq {x} {y} = (mkâ‰ƒ _ (ï¼-is-null AXnull {x} {y} i))

  module Ideq x y = _â‰ƒ_ (Ideq {x} {y})

  map1 : A â†’ Î£[ a âˆ¶ A ] Î£[ b âˆ¶ A ] (X i â†’ a ï¼ b)
  map1 a = (a , a , ~refl)

  map1-eqv : A â‰ƒ (Î£[ a âˆ¶ A ] Î£[ b âˆ¶ A ] (X i â†’ a ï¼ b))
  map1-eqv
    = A                                     â‰ƒâŸ¨ Î£-singleton (Î» _ â†’ Sing-is-singleton) eâ»Â¹ âŸ©
      ((Î£[ a âˆ¶ A ] Sing A a))               â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-ap-â‰ƒ (Î» b â†’ Ideq)) âŸ©
      (Î£[ a âˆ¶ A ] Î£[ b âˆ¶ A ] (X i â†’ a ï¼ b)) â‰ƒâˆ

  map1-is-equiv : is-equiv map1
  map1-is-equiv = map1-eqv ._â‰ƒ_.has-is-eqv

  homtpy : const A (Susp (X i)) ~ Susp-UPâ†’ âˆ˜ map1
  homtpy a = funextâ†’ (pushout-ind _
                       (mk-coconeD
                         ~refl ~refl Î» x
                         â†’ IdP-funcâ†Square
                             (glue x)
                             _
                             _
                             (âˆ™-reflr _ âˆ™ sym (pushout-rec-apÎ² x
                                              âˆ™ sym (ap-const _)))))

  eqv : is-equiv (const A (Susp (X i)))
  eqv = is-equiv~âˆ˜ homtpy
                   (_â‰ƒ_.has-is-eqv (Susp-UPâ‰ƒ eâ»Â¹))
                   map1-is-equiv

suc-is-truncated : âˆ€ {ğ“¤} {A : Type ğ“¤} n
                   â†’ is-truncated n A
                   â†’ is-truncated (suc n) A
suc-is-truncated zero
  = is-truncatedâ†is-prop
  âˆ˜ is-propâ†is-single
  âˆ˜ is-singletonâ†is-truncated
suc-is-truncated {A = A} (suc n)
  = is-truncatedâ†null (suc n)
  âˆ˜ suc-is-null
  âˆ˜ is-nullâ†truncated n

+-is-truncated : âˆ€ {ğ“¤} {A : Type ğ“¤}
                   n k
                 â†’ is-truncated n A
                 â†’ is-truncated (n + k) A
+-is-truncated n zero = id
+-is-truncated n (suc k) tr = suc-is-truncated (n + k)
                                (+-is-truncated n k tr)

is-n-truncatedâ†is-single : âˆ€ {ğ“¤} {A : Type ğ“¤}
                        â†’ is-singleton A â†’ âˆ€ n â†’ is-truncated n A
is-n-truncatedâ†is-single s zero = mk-lift s
is-n-truncatedâ†is-single s (suc n) x y
  = is-n-truncatedâ†is-single
      (ï¼-singletonâ†is-prop (is-propâ†is-single s) x y) n

is-suc-truncatedâ†is-prop
  : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ is-prop A â†’ âˆ€ n â†’ is-truncated (suc n) A
is-suc-truncatedâ†is-prop ap n x y
  = is-n-truncatedâ†is-single (ï¼-singletonâ†is-prop ap _ _) n
}
%```
}

\subtree[stt-0082]{
\title{The universe of #{n}-truncated types is #{n + 1} truncated}

%```agda
\agda{
â‰ƒ-is-truncated : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} n
                 â†’ is-truncated n A â†’ is-truncated n B
                 â†’ is-truncated n (A â‰ƒ B)
â‰ƒ-is-truncated zero Atr Btr
  = is-truncatedâ†is-singleton
     (is-singleâ†equiv-to-single (â‰ƒ-rep eâ»Â¹)
       (Singleton-Î£ (is-singleton-Î  (Î» _ â†’ unlift Btr ))
       Î» a â†’ mk-singl (is-equivâ†single-to-prop (unlift Atr)
                         (is-propâ†is-single (unlift Btr)) a)
                      (is-equiv-is-prop _)))
â‰ƒ-is-truncated (suc n) Atr Btr = Trunc.is-truncatedâ†equiv (â‰ƒ-rep eâ»Â¹)
                            (Trunc.Î£-is-truncated
                              (Trunc.Î -is-truncated (Î» a â†’ Btr))
                              Î» a â†’ is-suc-truncatedâ†is-prop
                                       is-equiv-is-prop n)

Trunc-U : âˆ€ n ğ“¤ â†’ Type (lsuc ğ“¤)
Trunc-U n ğ“¤ = Î£ (Type ğ“¤) (is-truncated n)

PropU = Trunc-U 1
SetU = Trunc-U 2

TULift : âˆ€ {ğ“¤} n ğ“¥ â†’ Trunc-U n ğ“¤ â†’ Trunc-U n (ğ“¤ âŠ” ğ“¥)
TULift n ğ“¥ (t , p) = (ULift ğ“¥ t , Trunc.ULift-is-truncated p)

Trunc-U-is-truncated : âˆ€ n {ğ“¤} â†’ is-truncated (suc n) (Trunc-U n ğ“¤)
Trunc-U-is-truncated n (X , Xtr) (Y , Ytr)
  = Trunc.is-truncatedâ†equiv Î£-path
      (Trunc.Î£-is-truncated (Trunc.is-truncatedâ†equiv
                              (mkâ‰ƒ _ (is-equivâ»Â¹ UA))
                              (â‰ƒ-is-truncated n Xtr Ytr))
      (Î» where refl â†’ let is-sing = ï¼-singletonâ†is-prop
                                     (is-n-separated-is-prop _ n X) Xtr Ytr
                      in is-n-truncatedâ†is-single is-sing n))
}
%```
}

\subtree[stt-0073]{
\date{2025-06-29}
\title{Instance resolution for truncated types}

\p{Truncation is not a single modality but a tower of connected
modalities.  Whilst we [have](stt-006Z) instances in place for
automatically resolving goals of type #{\rm{is-modal}}, but if we just
naively implement rules #{\rm{is-modal}_n \implies
\rm{is-modal}_{n+1}} and #{\rm{is-modal}_{n+1}(A) \implies
\rm{is-modal}_{n}(x =_A y)}, we run into trouble with Agda's instance
search.
   }

\p{To remedy this, we follow the approach taken in the
\citek{1lab}{1Lab.HLevel.Closure}, and define instances uniformly for
all truncation levels.}

\todo{Get this working - or take a different approach all together}

%```agda
\agda{
-- truncation-instance : âˆ€ {ğ“¤} {A : Type ğ“¤} n
--                       â†’ Trunc.is-truncated n A
--                       â†’ âˆ€ {k}
--                       â†’ Trunc.Is-truncated (n + k) A
-- truncation-instance n tr {k} = Trunc.mk-trunc (n + k)
--                                 (+-is-truncated n k tr)

-- instance opaque
--   unfolding Trunc.Is-truncated

--   Truncated-Id : âˆ€ {ğ“¤} {A : Type ğ“¤} {n}
--                    â¦ƒ _ : Trunc.Is-truncated (suc n) A â¦„
--                  â†’ âˆ€ {x y : A} â†’ Trunc.Is-truncated n (x ï¼ y)
--   Truncated-Id â¦ƒ (mk-modal t) â¦„ = mk-modal (ï¼-is-pred-truncated t)


-- instance opaque
--   unfolding Trunc.Is-truncated
--   Î -trunc : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
--               {n}
--                â†’ â¦ƒ _ : âˆ€ {a} â†’ Trunc.Is-truncated n (B a) â¦„
--                â†’ Trunc.Is-truncated n (Î  A B)
--   Î -trunc {n = zero} â¦ƒ m â¦„
--     = mk-modal (Trunc.trâ†null 0
--                  (Î -is-null (Î» a
--                    â†’ Trunc.nullâ†tr 0 (m .has-is-modal)))) where
--     open Is-modal
--   Î -trunc {n = suc n} â¦ƒ m â¦„
--     = mk-modal (Trunc.trâ†null (suc n)
--                  (Î -is-null (Î» a
--                    â†’ Trunc.nullâ†tr (suc n) (m .has-is-modal)))) where
--     open Is-modal

-- instance opaque
--   unfolding Trunc.Is-truncated
--   Trunc-trunc : âˆ€ {ğ“¤} {A : Type ğ“¤}
--                   {n k}
--                 â†’ Trunc.Is-truncated (n + k) (Trunc n A)
--   Trunc-trunc {n = n}{k} = truncation-instance n
--                             (Trunc.â—‹-is-modal n) {k}
--   {-# INCOHERENT Trunc-trunc #-}

-- module TruncDo where
--   open Trunc

--   open Universal

--   instance
--     Universal-â—‹ : âˆ€ {ğ“¤ ğ“¦} {A : Type ğ“¤} {n} {P : Trunc n A â†’ Type ğ“¤}
--                  â†’ â¦ƒ _ : âˆ€ {a} â†’ Is-truncated n (P a) â¦„
--                  â†’ â¦ƒ _ : Universal ((a : A) â†’ P (Trunc.Î· n a)) ğ“¦ â¦„
--                  â†’ Universal ((a : Trunc n A) â†’ P a) ğ“¦
--     Universal-â—‹ â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.methods = u .methods
--     Universal-â—‹ {n = n} â¦ƒ mod â¦„ â¦ƒ u â¦„ .Universal.from
--        = ind' n (is-trunc! n) âˆ˜ u .from
--     Universal-â—‹ {n = n} â¦ƒ _ â¦„ â¦ƒ u â¦„ .Universal.from-is-equiv
--       = is-equiv-âˆ˜ (ind'-is-equiv n) (u .from-is-equiv)

--   -- It can't figure this out
--   _>>=_ : âˆ€ {ğ“¤} {A : Type ğ“¤} {B : Type ğ“¤}
--             {n}
--             â¦ƒ _ : âˆ€ {k} â†’ Trunc.Is-truncated (n + k) B â¦„
--           â†’ Trunc n A
--           â†’ (A â†’ B)
--           â†’ B
--   _>>=_ {B = B}{n = n} â¦ƒ t â¦„ x f
--     = rec! {B = B}
--            â¦ƒ Universal-â—‹ {n = n} â¦ƒ t â¦„ â¦ƒ Universal-default â¦„ â¦„
--            f x

--   return : âˆ€ {ğ“¤} {A : Type ğ“¤} {n} â†’ A â†’ Trunc n A
--   return {n = n} = Trunc.Î· n


-- module _ {ğ“¤} {A : Type ğ“¤} â¦ƒ _ : âˆ€ {k} â†’ Trunc.Is-truncated (suc (suc k)) A â¦„ where
  -- tst : Trunc.is-truncated 3 A
  -- tst =  Trunc.is-trunc! 3

  -- tst2 : âˆ€ {x y : A} â†’ Trunc.is-truncated 1 (x ï¼ y)
  -- tst2 = Trunc.is-trunc! 1

  -- tst3 : Trunc.is-truncated 2 (A â†’ A)
  -- tst3 = Trunc.is-trunc! 2

  -- tst4 : âˆ€ {f g : S 5 â†’ A} â†’ Trunc.is-truncated 1 (f ~ g)
  -- tst4 = Trunc.is-trunc! 1

  -- tst5 : (x : Trunc 1 A) (f : Trunc 1 A â†’ A) â†’ Trunc.Î· 1 (f x) ï¼ x
  -- tst5 x f = do
  --   x' â† x
  --   {!!}
  --   where open TruncDo

}
%```
}
