\title{Lattices}
\date{2025-06-19}
\taxon{module}
\author{markwilliams}
\import{stt-macros}
\meta{module}{\startverb algebra.Lattice \stopverb}

%```agda
\agda{
module algebra.Lattice where

open import ufAxioms
open import foundations.Prelude
open import algebra.Poset
open import Data.Bool

}
%```

\subtree[stt-004T]{
\title{Lattices}
\taxon{definition}
\p{A lattice #{L} is an algebraic strucutre with two operations #{\wedge,\vee : L \to L \to L}, satisfying absorption laws.
   Equivalently this structure can be described by a poset, with operations taking binary meets and joins for each pair of elements.}

%```agda
\agda{

record is-lattice {ğ“¤} {L : Type ğ“¤} (0l 1l : L) (_âˆ§_ : L â†’ L â†’ L) (_âˆ¨_ : L â†’ L â†’ L) : Type ğ“¤ where
  no-eta-equality
  field
    car-is-set  : is-set L
    âˆ§-assoc : {x y z : L} â†’ x âˆ§ (y âˆ§ z) ï¼ (x âˆ§ y) âˆ§ z
    âˆ¨-assoc : {x y z : L} â†’ x âˆ¨ (y âˆ¨ z) ï¼ (x âˆ¨ y) âˆ¨ z
    âˆ§-comm : {x y : L} â†’ x âˆ§ y ï¼ y âˆ§ x
    âˆ¨-comm : {x y : L} â†’ x âˆ¨ y ï¼ y âˆ¨ x
    âˆ¨-âˆ§-abs : {x y : L} â†’ x âˆ¨ (x âˆ§ y) ï¼ x
    âˆ§-âˆ¨-abs : {x y : L} â†’ x âˆ§ (x âˆ¨ y) ï¼ x
    0-bottom : {x : L} â†’ x âˆ¨ 0l ï¼ x
    1-top    : {x : L} â†’ x âˆ§ 1l ï¼ x

record Lattice {â„“} (L : Type â„“) : Type â„“ where
  field
    0l 1l : L
    _âˆ§_ : L â†’ L â†’ L
    _âˆ¨_ : L â†’ L â†’ L
    str-is-lattice : is-lattice 0l 1l (_âˆ§_) (_âˆ¨_)
  infixr 24 _âˆ§_
  infixr 25 _âˆ¨_

  _â‰¤_ : L â†’ L â†’ Type â„“
  x â‰¤ y = x âˆ§ y ï¼ x

  open is-lattice str-is-lattice public

  â‰¤-is-poset : is-poset (_â‰¤_)
  â‰¤-is-poset =
    record { â‰¤-is-prop = â‰¤-is-prop
           ; â‰¤-refl = â‰¤-refl
           ; â‰¤-trans = â‰¤-trans
           ; â‰¤-antisym = â‰¤-antisym }
    where
      â‰¤-is-prop : {x y : L} â†’ is-prop (x â‰¤ y)
      â‰¤-is-prop {x} {y} = car-is-set (x âˆ§ y) x

      â‰¤-refl : {x : L} â†’ x â‰¤ x
      â‰¤-refl {x} = x âˆ§ x             ï¼âŸ¨ ap (x âˆ§_) (sym âˆ¨-âˆ§-abs) âŸ©
                   x âˆ§ (x âˆ¨ (x âˆ§ x)) ï¼âŸ¨ âˆ§-âˆ¨-abs âŸ©
                   x âˆ

      â‰¤-trans : {x y z : L} â†’ x â‰¤ y â†’ y â‰¤ z â†’ x â‰¤ z
      â‰¤-trans {x} {y} {z} p q =  x âˆ§ z        ï¼âŸ¨  ap (_âˆ§ z) (sym p)  âŸ©
                                  (x âˆ§ y) âˆ§ z ï¼âŸ¨ sym âˆ§-assoc âŸ©
                                  x âˆ§ (y âˆ§ z) ï¼âŸ¨ ap (x âˆ§_) q âŸ©
                                  x âˆ§ y       ï¼âŸ¨ p âŸ©
                                  x âˆ

      â‰¤-antisym : {x y : L} â†’ x â‰¤ y â†’ y â‰¤ x â†’ x ï¼ y
      â‰¤-antisym {x} {y} p q = sym p âˆ™ âˆ§-comm âˆ™ q

record is-lattice-hom
        {ğ“¤} {ğ“¤'} {A : Type ğ“¤} {B : Type ğ“¤'}
        (L : Lattice A) (M : Lattice B) (f : A â†’ B) : Type (ğ“¤ âŠ” ğ“¤') where
  private
    module A = Lattice L
    module B = Lattice M
  field
    pres-âˆ¨ : {x y : A} â†’ f (x A.âˆ¨ y) ï¼ f x B.âˆ¨ f y
    pres-âˆ§ : {x y : A} â†’ f (x A.âˆ§ y) ï¼ f x B.âˆ§ f y
    pres-0 : f A.0l ï¼ B.0l
    pres-1 : f A.1l ï¼ B.1l

is-lattice-algebra : {ğ“¤ ğ“¥ : Level} {A : Type ğ“¤} {B : Type ğ“¥} (L : Lattice A) (M : Lattice B) (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-lattice-algebra = is-lattice-hom

initial-lattice-algebra : {ğ“¤ : Level} {A : Type ğ“¤} (L : Lattice A) â†’ is-lattice-algebra L L id
initial-lattice-algebra L .is-lattice-hom.pres-âˆ¨ = refl
initial-lattice-algebra L .is-lattice-hom.pres-âˆ§ = refl
initial-lattice-algebra L .is-lattice-hom.pres-0 = refl
initial-lattice-algebra L .is-lattice-hom.pres-1 = refl
}
%```


\subtree[stt-004S]{
\title{Congruences}
\taxon{definition}
\p{An equivalence relation #{\sim} on a lattice #{L} is a congruence if it respects all lattice operations}

%```agda
\agda{
module Congruence where

record Equivalence {ğ“¤ ğ“¥} {A : Type ğ“¤} (_~_ : A â†’ A â†’ Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  field
    ~-is-prop : {x y : A} â†’ is-prop (x ~ y)
    reflexive : {x : A} â†’ x ~ x
    symmetric : {x y : A} â†’ x ~ y â†’ y ~ x
    transitive : {x y z : A} â†’ x ~ y â†’ y ~ z â†’ x ~ z

record LatticeCongruence {ğ“¤ ğ“¥} {A : Type ğ“¤} (L : Lattice A) (_~_ : A â†’ A â†’ Type ğ“¥) : Type (ğ“¤ âŠ” ğ“¥) where
  open Lattice L
  field
    ~-equivalence : Equivalence (_~_)
    ~-âˆ¨ : {a1 a2 b1 b2 : A} â†’ a1 ~ b1 â†’ a2 ~ b2 â†’ a1 âˆ¨ a2 ~ b1 âˆ¨ b2
    ~-âˆ§ : {a1 a2 b1 b2 : A} â†’ a1 ~ b1 â†’ a2 ~ b2 â†’ a1 âˆ§ a2 ~ b1 âˆ§ b2

  open Equivalence (~-equivalence) public

{-
module _ {ğ“¤} {ğ“¥} {A : Type ğ“¤} {L : Lattice A} where
  open Lattice L
  data âŸª_âŸ« (R : A â†’ A â†’ Type ğ“¥) : A â†’ A â†’ Type (ğ“¤ âŠ” ğ“¥) where
    âŸªâŸ«-inc  : {a b : A} â†’ R a b â†’ âŸª R âŸ« a b
    âŸªâŸ«-refl : {a : A} â†’ âŸª R âŸ« a a
    âŸªâŸ«-sym  : {a b : A} â†’ âŸª R âŸ« a b â†’ âŸª R âŸ« b a
    âŸªâŸ«-trans : {a b c : A} â†’ âŸª R âŸ« a b â†’ âŸª R âŸ« b c â†’ âŸª R âŸ« a c
    âŸªâŸ«-âˆ¨ : {a1 a2 b1 b2 : A} â†’ âŸª R âŸ« a1 b1 â†’ âŸª R âŸ« a2 b2 â†’ âŸª R âŸ« (a1 âˆ¨ a2) (b1 âˆ¨ b2)
    âŸªâŸ«-âˆ§ : {a1 a2 b1 b2 : A} â†’ âŸª R âŸ« a1 b1 â†’ âŸª R âŸ« a2 b2 â†’ âŸª R âŸ« (a1 âˆ§ a2) (b1 âˆ§ b2)

  âŸªâŸ«-congruence : {R : A â†’ A â†’ Type ğ“¥} â†’ LatticeCongruence L âŸª R âŸ«
  âŸªâŸ«-congruence = record
    { ~-equivalence = record
      { ~-is-prop = {!!}
      ; reflexive = âŸªâŸ«-refl
      ; symmetric = âŸªâŸ«-sym
      ; transitive = âŸªâŸ«-trans }
    ; ~-âˆ¨ = âŸªâŸ«-âˆ¨
    ; ~-âˆ§ = âŸªâŸ«-âˆ§ }
-}

}
%```
}

}

\subtree[stt-004U]{
\title{Examples}
\taxon{examples}
\p{The subobject/subtype classifier #{\mathrm{Prop}} has a canonical lattice structure on it, given by logical and and or}

%```agda
\agda{
}
%```
}

}
