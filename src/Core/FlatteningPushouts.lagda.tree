\date{2025-08-01}
\title{Flattening pushouts}
\taxon{Module}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.FlatteningPushouts where

open import Foundations.Prelude
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import Ergonomics.Representation
open import Ergonomics.Marker
}
%```

\subtree[stt-008D]{
\title{Flattening lemma for pushouts}
\taxon{Theorem}

\p{The flattening theorem essentially states that for a family #{P}
over a pushout #{A \times_C B}, the total type #{\tilde{P}} is
equivalent to the pushout of total types: #{\Sigma_A P
+_{\Sigma_C P} \Sigma_B P}.}

\proof{
\p{Given a span #{S : A \leftarrow B \rightarrow C} and a family #{P}
over the pushout of #{S}, we can define the total span #{\Sigma_{S}P}.
We first note that for some arbitrary type #{Q}, dependent cones over
#{S} at #{p \mapsto P(p) \to Q} are equivalent to cones over
#{\Sigma_{S} P} at #{Q} - this is analogous to [currying
functions](Foundations.PiProperties).  We then construct the following
square:
}

\quiver{
\begin{tikzcd}
	{\Pi_{p : A+^C B} Q^{P(p)}} && {Q^{\Sigma_{p : A+^CB} P(p)}} \\
	\\
	{\rm{cocone}^d(S,p \mapsto Q^{P(p)})} && {\rm{cocone}(\Sigma_S P,Q)}
	\arrow["{\rm{curry}}", from=1-1, to=1-3]
	\arrow["{\rm{cocone}^d}"', from=1-1, to=3-1]
	\arrow["{\rm{cocone}}", from=1-3, to=3-3]
	\arrow["{\rm{curry}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{Since, currying (functions or cocones) and the dependent cocone
map are equivalences, then so is the cocone map on the right.}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         (f : A â†’ B) (g : A â†’ C) where
  total-span : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
               â†’ Span _ _ _
  total-span P .Span.Centre = Î£ A (P âˆ˜ Î¹â‚‚ âˆ˜ g)
  total-span P .Span.Left = Î£ B (P âˆ˜ Î¹â‚)
  total-span P .Span.left (a , b) = (f a , tr P (sym (glue a)) b)
  total-span P .Span.Right = Î£ C (P âˆ˜ Î¹â‚‚)
  total-span P .Span.right = total-map-fst g

  total-cocone : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                 â†’ Cocone (total-span P) (Î£ (Pushout f g) P)
  total-cocone P .Cocone.p = total-map-fst Î¹â‚
  total-cocone P .Cocone.q = total-map-fst Î¹â‚‚
  total-cocone P .Cocone.filler (a , b)
    = Î£-pathâ†’ ( glue a , trâˆ™tr-sym' (glue a) b)

  total-is-pushout : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                     â†’ is-pushoutÏ‰ (total-span P) (total-cocone P)
  total-is-pushout P {ğ“ } {Q} = eqv where
    module S' = Span (total-span P)

    Q' : Pushout f g â†’ Type _
    Q' x = P x â†’ Q

    lem2 : âˆ€ {a b} (p : a ï¼ b) {x} {f : P a â†’ Q}
           â†’ (tr Q' p f) x ï¼ f (tr P (sym p) x)
    lem2 refl = refl

    curry-cocone
      : Cocone (total-span P) Q â†’ CoconeD _ pushout Q'
    curry-cocone (mk-cocone p q filler) = mk-coconeD (curry p) (curry q) Î»
      a â†’ funextâ†’ Î» b â†’ lem2 (glue a) âˆ™ curry filler a b

    H : Arrow-map (cocone-map _ (total-cocone P) {Q})
                  (coconeáµˆ-map (mk-span _ f g) pushout {Q'})
    H .Arrow-map.top = curry
    H .Arrow-map.bot = curry-cocone
    H .Arrow-map.comm h
      = ap (mk-coconeD (Î» a b â†’ h (Î¹â‚ a , b)) (Î» a b â†’ h (Î¹â‚‚ a , b)))
           (funextâ†’ Î» a â†’ J {a = Î¹â‚ (f a)} (Î» z G â†’
                 funextâ†’ (Î» b â†’ lem2 G âˆ™ ap h (Î£-pathâ†’ (G , trâˆ™tr-sym' G b)))
               ï¼ apáµˆ (curry h) G)
           funext-refl
           {Î¹â‚‚ (g a)} (glue a))

    curry-cocone-is-equiv : quasi-iso curry-cocone
    curry-cocone-is-equiv .fst (mk-coconeD p q filler)
      = mk-cocone (uncurry p) (uncurry q)
          Î» where (a , b) â†’ sym (lem2 (glue a)) âˆ™ happly (filler a) b
    curry-cocone-is-equiv .snd .fst (mk-cocone p q filler)
      = Cocone-pathâ†’ _  _ (funextâ†’ ~refl) (funextâ†’ ~refl)
          Î» a â†’ âˆ™-reflr _ âˆ™ sym'âˆ™ (lem2 (glue (fst a))) (filler a)
    curry-cocone-is-equiv .snd .snd (mk-coconeD p q filler)
      = ap (mk-coconeD p q) (funextâ†’ Î»
         a â†’   ap funextâ†’ (funextâ†’ (Î» b â†’ symâˆ™ (lem2 (glue a))
                                            (happly (filler a) b)))
             âˆ™ _â‰ƒ_.Î· funextâ‰ƒ (filler a))

    arr-eq : is-Arrow-equiv H
    arr-eq .fst = curry-is-equiv
    arr-eq .snd = is-equivâ†qiso curry-cocone-is-equiv

    eqv : is-equiv (cocone-map _ (total-cocone P))
    eqv = is-equivâ†Arrow-equivâ»Â¹ {F = H} arr-eq Pushout-is-pushoutÏ‰áµˆ
}
%```
}

\subtree[stt-008S]{
\title{Fibres of the cogap map}
\taxon{Corollary}

\p{As a consequence of the [flattening lemma](stt-008D), we can give a
nice characterisation of fibres of [cogap maps](stt-004G). }

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“œ}
                (C : Cocone S X) where
  open Span S

  Fibre-family : âˆ€ x â†’ Pushout left right â†’ Type ğ“œ
  Fibre-family x p = cogap C p ï¼ x

  cogap-fibre
    : âˆ€ x â†’ fibre (cogap C) x
    â‰ƒ Pushout (total-span _ _ (Fibre-family x) .Span.left)
              (total-span _ _ (Fibre-family x) .Span.right)
  cogap-fibre x = mkâ‰ƒ _
    (is-equivâ»Â¹
      (cogap-is-equivâ†is-pushout _
        (total-is-pushout _ _ (Fibre-family x))))
}
%```
}
