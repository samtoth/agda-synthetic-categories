\title{Leibniz Adjunction}
\taxon{Module}
\date{2026-02-18}
\author{fredrikbakke}

\import{stt-macros}

%```agda
\agda{
module Core.LeibnizAdjunction where

open import ufAxioms
open import Foundations.NullHomotopy global-funext

open import Foundations.Prelude
open import Foundations.TypeFamilies

open import Core.Arrow
open import Core.ArrowEquiv
open import Core.Join
open import Core.CanonicalPushouts
open import Core.PullbackPower
open import Core.PushoutProduct
open import Core.PushoutSums

open import Ergonomics.Extensionality
}
%```

\subtree{
\taxon{Definition}
\title{The pullback power of the pushout sum}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  (F@(A , B) : Fam ğ“¤1 ğ“¤2)
  (G@(X , Y) : DepFam ğ“¤3 ğ“¤4 F)
  (H@(U , V) : DepÂ²Fam ğ“¤5 ğ“¤6 F G)
  where

  Î Ì‚Î£Ì‚á¶  : Fam (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤5 âŠ” ğ“¤6)
            (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4 âŠ” ğ“¤6)
  Î Ì‚Î£Ì‚á¶  = Î Ì‚á¶  (Î£Ì‚á¶  F G) (Î£Ì‚áµˆá¶  F G H)

module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  {A : Type ğ“¤1}
  {B : Type ğ“¤2}
  (f : A â†’ B)
  {X : B â†’ Type ğ“¤3}
  {Y : B â†’ Type ğ“¤4}
  (g : (b : B) â†’ X b â†’ Y b)
  {U : (b : B) â†’ Y b â†’ Type ğ“¤5}
  {V : (b : B) â†’ Y b â†’ Type ğ“¤6}
  (h : (b : B) (y : Y b) â†’ U b y â†’ V b y)
  where

  Î Ì‚Î£Ì‚ : (((b , y) : Î£ B Y) â†’ U b y) â†’ Arr-dmap (Î£Ì‚ f g) (Î» (b , y) â†’ h b y)
  Î Ì‚Î£Ì‚ = Î Ì‚ (Î£Ì‚ f g) (Î» (b , y) â†’ h b y)

  Î Ì‚Î Ì‚ : ((b : B) (y : Y b) â†’ U b y) â†’ Arr-dmap f (Î» b â†’ Î Ì‚ (g b) (h b))
  Î Ì‚Î Ì‚ = Î Ì‚ f (Î» b â†’ Î Ì‚ (g b) (h b))
}
%```
}

\subtree{
\taxon{Theorem}
\title{The dependent Leibniz adjunction}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  (F@(A , B) : Fam ğ“¤1 ğ“¤2)
  (G@(X , Y) : DepFam ğ“¤3 ğ“¤4 F)
  (H@(U , V) : DepÂ²Fam ğ“¤5 ğ“¤6 F G)
  (let Î Î£ = Î Ì‚Î£Ì‚á¶  F G H)
  (let Î Â² = Î Ì‚Î Ì‚á¶  F G H)
  where

  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base : fst Î Î£ â†’ fst Î Â²
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .fst a .fst x = f (a , x)
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .fst a .snd x y = p (a , x) (Î¹â‚‚ y)
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .snd a b x .fst = p (a , x) (Î¹â‚ b)
  Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (f , p) .snd a b x .snd y = ap (p (a , x)) (sym (glue (b , y)))

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base : fst Î Â² â†’ fst Î Î£
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (f , p) .fst (a , x) = f a .fst x
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (f , p) .snd (a , x)
    = pushout-rec
        (mk-cocone
          (Î» b â†’ p a b x .fst)
          (Î» y â†’ f a .snd x y)
          (Î» (b , y) â†’ sym (p a b x .snd y)))

  Leibnizáµˆá¶ -base-section-cocone
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ Cocone (mk-span _ fst snd) (V (ax .fst) (ax .snd) (fp .fst ax))
  Leibnizáµˆá¶ -base-section-cocone (f , p) ax
    = mk-cocone
        (Î» b â†’ p ax (Î¹â‚ b))
        (Î» y â†’ p ax (Î¹â‚‚ y))
        (Î» (b , y) â†’ sym (ap (p ax) (sym (glue (b , y)))))

  Leibnizáµˆá¶ -base-section-coherence
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ fp .snd ax â—‚ glue ~âˆ™ ~refl â–¸ snd
    ~ ~refl â–¸ fst ~âˆ™ (Leibnizáµˆá¶ -base-section-cocone fp ax) .Cocone.filler
  Leibnizáµˆá¶ -base-section-coherence (f , p) ax (b , y)
    = âˆ™-reflr _
    âˆ™ sym (ap sym (ap-sym (p ax) (glue (b , y))) âˆ™ sym-sym)
    âˆ™ sym (âˆ™-refll _)

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-retraction
    : (fp : fst Î Î£) â†’ Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base fp) ï¼ fp
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-retraction (f , p)
    = Î£-pathâ†’ (refl , funextâ†’ Î» ax
              â†’ funextâ†’ Î» j
              â†’ (pushout-rec-unique (Leibnizáµˆá¶ -base-section-cocone (f , p) ax) (p ax)
                  ~refl
                  ~refl
                  (Leibnizáµˆá¶ -base-section-coherence (f , p) ax) ~â»Â¹) j)

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section-glue
    : (fq : fst Î Â²)
    â†’ (a : A) (b : B a) (x : X a) (y : Y a x)
    â†’ ap (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base fq .snd (a , x)) (sym (glue (b , y)))
    ï¼ fq .snd a b x .snd y
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section-glue (f , p) a b x y
    = ap-sym (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base (f , p) .snd (a , x)) (glue (b , y))
    âˆ™ ap sym (pushout-rec-apÎ² (b , y))
    âˆ™ sym-sym

  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section
    : (fq : fst Î Â²) â†’ Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base fq) ï¼ fq
  Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section (f , p)
    = Î£-pathâ†’
        ( refl
        , funextâ†’ Î» a â†’ funextâ†’ Î» b â†’ funextâ†’ Î» x
        â†’ Î£-pathâ†’ (refl
                  , funextâ†’ (Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section-glue (f , p) a b x)))

  Leibnizáµˆá¶ â‰…-base : fst Î Î£ â‰… fst Î Â²
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd = Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd-iso .fst = Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd-iso .snd .fst = Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-retraction
  Leibnizáµˆá¶ â‰…-base ._â‰…_.fwd-iso .snd .snd = Î Ì‚Î£Ì‚á¶ â†Î Ì‚Î Ì‚á¶ -base-is-section

  Leibnizáµˆá¶ â‰ƒ-base : fst Î Î£ â‰ƒ fst Î Â²
  Leibnizáµˆá¶ â‰ƒ-base = equivâ†qiso Leibnizáµˆá¶ â‰…-base

  Leibnizáµˆá¶ -family-null-homotopy-at-curry
    : (fp : fst Î Î£)
    â†’ (a : A)
    â†’ B a
    â†’ (x : X a)
    â†’ null-homotopy (fp .snd (a , x) âˆ˜ Î¹â‚‚)
  Leibnizáµˆá¶ -family-null-homotopy-at-curry (f , p) a b x .fst
    = p (a , x) (Î¹â‚ b)
  Leibnizáµˆá¶ -family-null-homotopy-at-curry (f , p) a b x .snd y
    = ap (p (a , x)) (sym (glue (b , y)))

  Leibnizáµˆá¶ -family-null-homotopy-at-uncurry
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ B (ax .fst)
    â†’ null-homotopy (fp .snd ax âˆ˜ Î¹â‚‚)
  Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b
    = Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a b x

  Leibnizáµˆá¶ -family-cod-uncurry
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ B (ax .fst) * Y (ax .fst) (ax .snd)
    â†’ V (ax .fst) (ax .snd) (fp .fst ax)
  Leibnizáµˆá¶ -family-cod-uncurry fp ax = fp .snd ax

  Leibnizáµˆá¶ -family-cod-uncurry-sym
    : (fp : fst Î Î£) (a : A) (x : X a) (b : B a) (y : Y a x)
    â†’ Leibnizáµˆá¶ -family-cod-uncurry fp (a , x) (Î¹â‚‚ y)
    ï¼ Leibnizáµˆá¶ -family-cod-uncurry fp (a , x) (Î¹â‚ b)
  Leibnizáµˆá¶ -family-cod-uncurry-sym fp a x b y
    = ap (Leibnizáµˆá¶ -family-cod-uncurry fp (a , x)) (sym (glue (b , y)))

  module _
    (fp : fst Î Î£) (a : A) (x : X a) (l : V a x (fp .fst (a , x)))
    where

    Leibnizáµˆá¶ -family-cod : B a * Y a x â†’ Type ğ“¤6
    Leibnizáµˆá¶ -family-cod j
      = Leibnizáµˆá¶ -family-cod-uncurry fp (a , x) j ï¼ l

    Leibnizáµˆá¶ â‰ƒ-family-cod-inner-over
      : (r : (y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y))
      â†’ (b : B a)
      â†’ (Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
          ((y : Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y)))
      â‰ƒ (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
    Leibnizáµˆá¶ â‰ƒ-family-cod-inner-over r b
      = (Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
          ((y : Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» t â†’ Î -ap-â‰ƒ (Î» y â†’ IdP-const-â‰ƒ (Leibnizáµˆá¶ -family-cod-uncurry fp (a , x)) (glue (b , y)) t (r y))) âŸ©
        (Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
          ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry-sym fp a x b y âˆ™ t ï¼ r y))
        â‰ƒâŸ¨ null-homotopy-pathâ‰ƒ {f = Leibnizáµˆá¶ -family-cod-uncurry fp (a , x) âˆ˜ Î¹â‚‚} (Leibnizáµˆá¶ -family-cod-uncurry-sym fp a x b) r eâ»Â¹ âŸ©
        (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
        â‰ƒâˆ

    Leibnizáµˆá¶ â‰ƒ-family-cod-inner
      : (r : (y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y))
      â†’ (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          (((b , y) : B a Ã— Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
      â‰ƒ ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
    Leibnizáµˆá¶ â‰ƒ-family-cod-inner r
      = (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          (((b , y) : B a Ã— Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» t â†’ curryâ‰ƒ) âŸ©
        (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          ((b : B a) (y : Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ (Î» b â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b))
                     (Î» b t â†’ (y : Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y))
                     eâ»Â¹ âŸ©
        ((b : B a)
          â†’ Î£[ t âˆ¶ Leibnizáµˆá¶ -family-cod (Î¹â‚ b) ]
            ((y : Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) t (r y)))
        â‰ƒâŸ¨ Î -ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-cod-inner-over r) âŸ©
        ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r))
        â‰ƒâˆ

    Leibnizáµˆá¶ â‰ƒ-family-cod-main
      : (((j : B a * Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry fp (a , x) j ï¼ l))
      â‰ƒ (Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry fp (a , x) (Î¹â‚‚ y) ï¼ l) ]
          ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r)))
    Leibnizáµˆá¶ â‰ƒ-family-cod-main
      = (((j : B a * Y a x) â†’ Leibnizáµˆá¶ -family-cod-uncurry fp (a , x) j ï¼ l))
        â‰ƒâŸ¨ Pushout-UPáµˆâ‰ƒ eâ»Â¹ âŸ©
        CoconeD (mk-span _ fst snd) pushout (Leibnizáµˆá¶ -family-cod)
        â‰ƒâŸ¨ coconeD-reprâ‰ƒ âŸ©
        (Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
          Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y)) ]
            (((b , y) : B a Ã— Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-comm âŸ©
        (Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y)) ]
          Î£[ t âˆ¶ ((b : B a) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚ b)) ]
            (((b , y) : B a Ã— Y a x) â†’ IdP (ap (Leibnizáµˆá¶ -family-cod) (glue (b , y))) (t b) (r y)))
        â‰ƒâŸ¨ Î£-ap-â‰ƒ Leibnizáµˆá¶ â‰ƒ-family-cod-inner âŸ©
        (Î£[ r âˆ¶ ((y : Y a x) â†’ Leibnizáµˆá¶ -family-cod (Î¹â‚‚ y)) ]
        ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r)))
        â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-cod-null-homotopy
    : (fp : fst Î Î£)
    â†’ (ax : Î£ A X)
    â†’ null-homotopy (fp .snd ax) â‰ƒ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax)
  Leibnizáµˆá¶ â‰ƒ-family-cod-null-homotopy fp (a , x)
    = null-homotopy (fp .snd (a , x))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-cod-main fp a x) âŸ©
      (Î£[ l âˆ¶ V a x (fp .fst (a , x)) ]
        Î£[ r âˆ¶ ((y : Y a x) â†’ fp .snd (a , x) (Î¹â‚‚ y) ï¼ l) ]
          ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ (l , r)))
      â‰ƒâŸ¨ Î£-assoc eâ»Â¹ âŸ©
      null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x))
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-currying-swap-arguments
    : (fp : fst Î Î£)
    â†’ (a : A)
    â†’ (m : (x : X a) â†’ null-homotopy (fp .snd (a , x) âˆ˜ Î¹â‚‚))
    â†’ (((x : X a) (b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ m x))
    â‰ƒ (((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a b ï¼ m))
  Leibnizáµˆá¶ â‰ƒ-family-currying-swap-arguments fp a m
    = (((x : X a) (b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ m x))
      â‰ƒâŸ¨ flipâ‰ƒ âŸ©
      ((b : B a) (x : X a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ m x)
      â‰ƒâŸ¨ Î -ap-â‰ƒ (Î» b â†’ funextâ‰ƒ eâ»Â¹) âŸ©
      ((b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a b ï¼ m)
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-currying-at
    : (fp : fst Î Î£)
    â†’ (a : A)
    â†’ ((x : X a) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x)))
    â‰ƒ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a)
  Leibnizáµˆá¶ â‰ƒ-family-currying-at fp a
    = ((x : X a) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x)))
      â‰ƒâŸ¨ Î£-Î -swapâ‰ƒ _ _ âŸ©
      (Î£[ g âˆ¶ ((x : X a) â†’ null-homotopy (fp .snd (a , x) âˆ˜ Î¹â‚‚)) ]
        ((x : X a) (b : B a) â†’ Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x) b ï¼ g x))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-currying-swap-arguments fp a) âŸ©
      null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a)
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family-currying
    : (fp : fst Î Î£)
    â†’ ((ax : Î£ A X) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax))
    â‰ƒ ((a : A) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a))
  Leibnizáµˆá¶ â‰ƒ-family-currying fp
    = ((ax : Î£ A X) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax))
      â‰ƒâŸ¨ curryâ‰ƒ âŸ©
      ((a : A) (x : X a) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp (a , x)))
      â‰ƒâŸ¨ Î -ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-currying-at fp) âŸ©
      ((a : A) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-curry fp a))
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ-family
    : (fp : fst Î Î£)
    â†’ snd Î Î£ fp â‰ƒ snd Î Â² (Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base fp)
  Leibnizáµˆá¶ â‰ƒ-family fp
    = snd Î Î£ fp
      â‰ƒâŸ¨ Î -ap-â‰ƒ (Leibnizáµˆá¶ â‰ƒ-family-cod-null-homotopy fp) âŸ©
      ((ax : Î£ A X) â†’ null-homotopy (Leibnizáµˆá¶ -family-null-homotopy-at-uncurry fp ax))
      â‰ƒâŸ¨ Leibnizáµˆá¶ â‰ƒ-family-currying fp âŸ©
      snd Î Â² (Î Ì‚Î Ì‚á¶ â†Î Ì‚Î£Ì‚á¶ -base fp)
      â‰ƒâˆ

  Leibnizáµˆá¶ â‰ƒ : Î Î£ â‰ƒá¶  Î Â²
  Leibnizáµˆá¶ â‰ƒ = Leibnizáµˆá¶ â‰ƒ-base , Leibnizáµˆá¶ â‰ƒ-family
}
%```
}

\subtree{
\taxon{Corollary}
\title{The nondependent Leibniz adjunction for families}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  (F : Fam ğ“¤1 ğ“¤2)
  (G : Fam ğ“¤3 ğ“¤4)
  (H : Fam ğ“¤5 ğ“¤6)
  where

  Leibnizá¶ â‰ƒ : âŸ¨(F â–¡á¶  G) ,á¶  H âŸ© â‰ƒá¶  âŸ¨ F ,á¶  âŸ¨ G ,á¶  H âŸ© âŸ©
  Leibnizá¶ â‰ƒ = Leibnizáµˆá¶ â‰ƒ F (Famâ†’DepFam F G) (Famâ†’DepÂ²Fam F G H)
}
%```
}

\subtree{
\taxon{Corollary}
\title{The dependent Leibniz adjunction for arrows}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  {A : Type ğ“¤1}
  {B : Type ğ“¤2}
  (f : A â†’ B)
  {X : B â†’ Type ğ“¤3}
  {Y : B â†’ Type ğ“¤4}
  (g : (b : B) â†’ X b â†’ Y b)
  {U : (b : B) â†’ Y b â†’ Type ğ“¤5}
  {V : (b : B) â†’ Y b â†’ Type ğ“¤6}
  (h : (b : B) (y : Y b) â†’ U b y â†’ V b y)
  (let h-uncurry = Î» (b , y) â†’ h b y)
  (let F = fibre-fam f)
  (let G = fibre-depfam g)
  (let H = fibre-depÂ²fam h)
  (let Î Ì‚Î£Ì‚á¶ -fibre-fam = Î Ì‚Î£Ì‚á¶  F G H)
  (let Î Ì‚Î Ì‚á¶ -fibre-fam = Î Ì‚Î Ì‚á¶  F G H)
  where

  Î Ì‚Î£Ì‚-bridgeâ‰ƒ
    : Arrow-equiv
        (Î Ì‚Î£Ì‚ f g h)
        (snd (unstraighten (snd Î Ì‚Î£Ì‚á¶ -fibre-fam)))
  Î Ì‚Î£Ì‚-bridgeâ‰ƒ
    = concat-Arrow-equiv
        (Î Ì‚-unstraighten-Arrow-equiv (Î£Ì‚ f g) h-uncurry)
        (unstraighten-Arrow-equivâ†â‰ƒá¶ 
          (Î Ì‚á¶ -unstraight-fibre-fam (Î£Ì‚ f g) h-uncurry)
          (Î Ì‚Î£Ì‚á¶ -fibre-fam)
          (Î Ì‚á¶ -ap-base-fam (fibre-depfam h-uncurry) (Î£Ì‚-unstraightenâ‰ƒá¶  f g .snd)))

  Î Ì‚Î Ì‚-bridgeâ‰ƒ
    : Arrow-equiv
        (Î Ì‚Î Ì‚ f g h)
        (snd (unstraighten (snd Î Ì‚Î Ì‚á¶ -fibre-fam)))
  Î Ì‚Î Ì‚-bridgeâ‰ƒ
    = concat-Arrow-equiv
        (Î Ì‚-unstraighten-Arrow-equiv f (Î» b â†’ Î Ì‚ (g b) (h b)))
        (unstraighten-Arrow-equivâ†â‰ƒá¶ 
          (Î Ì‚á¶ -unstraight-fibre-fam f (Î» b â†’ Î Ì‚ (g b) (h b)))
          (Î Ì‚Î Ì‚á¶ -fibre-fam)
          (Î Ì‚á¶ -ap-â‰ƒáµˆá¶ 
            (F)
            (fibre-depfam (Î» b â†’ Î Ì‚ (g b) (h b)))
            (Î Ì‚áµˆá¶  F G H)
            (Î» b â†’ Î Ì‚-fibre-famâ‰ƒÎ Ì‚á¶ -unstraight-fibre-fam (g b) (h b))))

  Leibnizáµˆâ‰ƒ : Arrow-equiv (Î Ì‚Î£Ì‚ f g h) (Î Ì‚Î Ì‚ f g h)
  Leibnizáµˆâ‰ƒ
    = concat-Arrow-equiv
        (Î Ì‚Î£Ì‚-bridgeâ‰ƒ)
        (concat-Arrow-equiv
          (unstraighten-Arrow-equivâ†â‰ƒá¶ 
            (Î Ì‚Î£Ì‚á¶ -fibre-fam)
            (Î Ì‚Î Ì‚á¶ -fibre-fam)
            (Leibnizáµˆá¶ â‰ƒ F G H))
          (inv-Arrow-equiv Î Ì‚Î Ì‚-bridgeâ‰ƒ))
}
%```
}

\subtree{
\taxon{Corollary}
\title{The nondependent Leibniz adjunction for arrows}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 ğ“¤5 ğ“¤6 : Level}
  {A : Type ğ“¤1} {B : Type ğ“¤2} (f : A â†’ B)
  {C : Type ğ“¤3} {D : Type ğ“¤4} (g : C â†’ D)
  {E : Type ğ“¤5} {F : Type ğ“¤6} (h : E â†’ F)
  where

  Leibnizâ‰ƒ : Arrow-equiv âŸ¨ (f â–¡ g) , h âŸ© âŸ¨ f , âŸ¨ g , h âŸ© âŸ©
  Leibnizâ‰ƒ = Leibnizáµˆâ‰ƒ f (Î» _ â†’ g) (Î» _ _ â†’ h)
}
%```
}
