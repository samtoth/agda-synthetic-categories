\date{2025-04-20}
\title{Slices of types}
\taxon{Module}

\import{stt-macros}

\p{
 If we fix a type A, we can consider the slice âˆ-category #{\mathcal{S}/A}
}

% ```agda
\agda{
module Core.Slice where

open import Foundations.Prelude
open import ufAxioms
open import Ergonomics.Extensionality
}
% ```

% ```agda
\agda{
Slice-map : âˆ€ {ğ“¤} {A : Type ğ“¤}
              {ğ“¥} {B : Type ğ“¥} (p : B â†’ A) {ğ“¦}
              {C : Type ğ“¦} (q : C â†’ A)
              â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Slice-map {B = B} p {C = C} q = Î£[ f âˆ¶ (B â†’ C) ] (q âˆ˜ f ~ p)

Slice-id : âˆ€ {ğ“¤} {A : Type ğ“¤}
             {ğ“¥} {B : Type ğ“¥}
             (p : B â†’ A)
             â†’ Slice-map p p
Slice-id p = id , ~refl

Slice-fibre : âˆ€ {ğ“¤} {A : Type ğ“¤}
              {ğ“¥} {B : Type ğ“¥} {p : B â†’ A}
              {ğ“¦} {C : Type ğ“¦} {q : C â†’ A}
              â†’ Slice-map p q â†’
              (âˆ€ a â†’ fibre p a â†’ fibre q a)
Slice-fibre (f , comm) a (b , fib) = (f b , comm b âˆ™ fib)

Slice-family : âˆ€ {ğ“¤} {A : Type ğ“¤}
                 {ğ“¥} {B : A â†’ Type ğ“¥}
                 {ğ“¦} {C : A â†’ Type ğ“¦}
               â†’ Slice-map (fst {B = B}) (fst {B = C})
               â†’ (âˆ€ a â†’ B a â†’ C a)
Slice-family {C = C} (f , comm) a b
  = tr C (comm (a , b)) (f (a , b) .snd)

Slice-fibre-is-equiv
  : âˆ€ {ğ“¤} {A : Type ğ“¤}
      {ğ“¥} {B : Type ğ“¥} {p : B â†’ A}
      {ğ“¦} {C : Type ğ“¦} {q : C â†’ A}
    â†’ is-equiv (Slice-fibre {p = p} {q = q})
Slice-fibre-is-equiv {p = p} {q = q} = is-equivâ†qiso (Î» where
  .fst fmap â†’ (Î» b â†’ fmap (p b) (b , refl) .fst)
              , Î» b â†’ fmap (p b) (b , refl) .snd
  .snd .fst f â†’ ext! (~refl , (Î» a â†’ âˆ™-reflr _))
  .snd .snd f â†’ ext! (Î» where .(p b) b refl â†’ refl , âˆ™-reflr _))
}
% ```

\subtree[stt-003D]{
\taxon{Theorem}
\title{Equivalence from fibrewise equivalence}

\p{Given a pair of maps #{p : A \to C}, #{q : B \to C}, and a map #{(f , h)} from #{p} to #{q} in the slice
category, then #{f} is an equivalence iff the induced map on fibres is an equivalence.}

\remark{\p{In \lbrack{}[[foundations.FibrewiseEquiv]]\rbrack{}, we showed the straightened
version of this theorem, with type families over a base.}}

\p{In fact, this is just a corollary of the theorem [[stt-0030]], by considering #{\textrm{fib}_{p}}
as a family over #{C}. The situation can be summarised as follows:}

\quiver{
\begin{tikzcd}
	& {\Sigma_{(c : C)}\textrm{fib}_p(c)} && {\Sigma_{(c : C)}\textrm{fib}_q(c)} \\
	A &&&& B \\
	\\
	&& C
	\arrow[from=1-2, to=1-4]
	\arrow["\sim", from=1-4, to=2-5]
	\arrow["\sim", from=2-1, to=1-2]
	\arrow["f", from=2-1, to=2-5]
	\arrow["p"', from=2-1, to=4-3]
	\arrow["q", from=2-5, to=4-3]
\end{tikzcd}
}


% ```agda
\agda{
is-equivâ†on-fibres : âˆ€ {ğ“¤} {C : Type ğ“¤}
                    {ğ“¥} {A : Type ğ“¥} {p : A â†’ C}
                    {ğ“¦} {B : Type ğ“¦} {q : B â†’ C}
                    â†’ (F@(f , h) : Slice-map p q)
                    â†’ (is-fibrewise-equiv (Slice-fibre {p = p} {q = q} F))
                    â†’ is-equiv f
is-equivâ†on-fibres {p = p} {q = q} (f , h) fw
  = 3-for-2' ((totalâ‰ƒtotal-fibre p) ._â‰ƒ_.has-is-eqv)
             (is-equiv-âˆ˜ ((totalâ‰ƒtotal-fibre q) ._â‰ƒ_.has-is-eqv)
                          (is-total-equivâ†is-fibrewise-equiv fw))

fibre-equivâ†is-equiv : âˆ€ {ğ“¤} {C : Type ğ“¤}
                    {ğ“¥} {A : Type ğ“¥} {p : A â†’ C}
                    {ğ“¦} {B : Type ğ“¦} {q : B â†’ C}
                    â†’ (F@(f , h) : Slice-map p q)
                    â†’ is-equiv f
                    â†’ (is-fibrewise-equiv (Slice-fibre {p = p} {q = q} F))
fibre-equivâ†is-equiv {p = p} {q = q} F@(f , h) feq
  = is-fibrewise-equivâ†is-total-equiv
     (3-for-2 {f = totalâ†total-fibre q}
       (totalâ‰ƒtotal-fibre q ._â‰ƒ_.has-is-eqv)
       (is-equiv-âˆ˜ feq ((totalâ‰ƒtotal-fibre p) ._â‰ƒ_.has-is-eqv)))
}
% ```
}

\subtree[stt-008J]{
\date{2025-08-02}
\title{Slice maps into embeddings}
\taxon{Theorem}

\p{Let #{f : A \to B} and #{g} be an [embedding](stt-008I) #{A'
\hookrightarrow B}. The type of slice maps #{f \to g} is a
proposition.}

\proof{
\p{Maps in the slice category are equivalent to fibrewise maps on the
fibres, but since #{g} is an embedding, it is a [propositional
map](Foundations.PropMapEmbedding).}
}

%```agda
\agda{
slice-embedding-is-prop
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {f : A â†’ C} {g : B â†’ C} â†’ is-embedding g
    â†’ is-prop (Slice-map f g)
slice-embedding-is-prop {f = f} {g = g} emb
  = is-propâ†equiv-to-prop
       (mkâ‰ƒ _ (is-equivâ»Â¹ (Slice-fibre-is-equiv {p = f} {q = g})))
       (is-prop-Î  (Î»
         a â†’ is-prop-Î  Î» _ â†’ is-prop-mapâ†is-embedding emb a))
}
%```
}
