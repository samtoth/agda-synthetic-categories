\date{2025-03-07}
\title{Pushouts}
\author{samueltoth}


\import{stt-macros}

% ```agda
\agda{
{-# OPTIONS --allow-unsolved-metas #-}
module foundations.Pushout where

open import foundations.universe
open import foundations.Functions
open import foundations.Identity
open import foundations.CoherentIsomorphism
open import foundations.QuasiIsomorphism
open import foundations.EquivSingleton
open import foundations.Singleton
open import foundations.Sigma
open import foundations.Homotopy
open import foundations.DependentIdentity
open import foundations.DependentHomotopy
open import foundations.SigmaPath
open import foundations.FunExt
}
% ```


\subtree[stt-0015]{
\taxon{definition}

\title{Spans}

\p{
    A span is a diagram of types: #{C \xleftarrow{f} A \xrightarrow{g} B}.
}

% ```agda
\agda{
record Span ğ“¤ ğ“¥ ğ“¦ : Type (lsuc (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)) where
  constructor mk-span
  field
    Centre : Type ğ“¤
    {Left} : Type ğ“¥
    left   : Centre â†’ Left
    {Right} : Type ğ“¦
    right : Centre â†’ Right
}
% ```

}

\subtree[stt-0016]{
 \taxon{definition}
 \title{cocone}
 \p{
  Given a span #{s : C \xleftarrow{f} A \xrightarrow{g} B}, and a type #{Q}, we define the type of #{Q}-cocones over #{s} to be the structure with:
   \ul{
     \li{A function #{i : C \to Q}}
     \li{A function #{j : B \to Q}}
     \li{A path #{i \circ f = j \circ g}}
}
}

% ```agda
\agda{
record Cocone  {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) {ğ“›} (Carrier : Type ğ“›)
        : Type (lsuc (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›))  where
  constructor mk-cocone
  open Span S
  field
    p       : Left â†’ Carrier
    q       : Right â†’ Carrier
    filler  : p âˆ˜ left ~ q âˆ˜ right 


record CoconeD {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
               {ğ“›} {Q : Type ğ“›} (cc : Cocone S Q)
               {ğ“œ} (P : Q â†’ Type ğ“œ) : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“› âŠ” ğ“œ) where
  constructor mk-coconeD
  open Span S
  open Cocone cc
  field
    p : (l : Left) â†’ P (p l) 
    q : (r : Right) â†’ P (q r)
    filler : HomotopyP (P â—‚ filler) (p âˆ˜ left) (q âˆ˜ right)

module _ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
               {ğ“›} {Q : Type ğ“›} {cc : Cocone S Q}
               {ğ“œ} {P : Q â†’ Type ğ“œ}  where
  open CoconeD
  open Span S
  module cc = Cocone cc


  record coconeáµˆ~ (a b : CoconeD S cc P) : Type (ğ“¤ âŠ” ğ“¦ âŠ” ğ“¥ âŠ” ğ“œ) where
    module a = CoconeD a
    module b = CoconeD b
    field
      p~ : a.p ~ b.p
      q~ : a.q ~ b.q
      filler~ : HomotopyP (Î» c â†’ apâ‚‚ (IdP ((P â—‚ cc.filler) c)) (p~ (left c)) (q~ (right c)))
                  a.filler
                  b.filler

  record coconeáµˆ-path (a b : CoconeD S cc P) : Type (ğ“¤ âŠ” ğ“¦ âŠ” ğ“¥ âŠ” ğ“œ) where
    module a = CoconeD a
    module b = CoconeD b
    field
      pï¼ : a.p ï¼ b.p
      qï¼ : a.q ï¼ b.q
      fillerï¼ : IdP (apâ‚‚ (HomotopyP (P â—‚ cc.filler)) (ap (_âˆ˜ left) pï¼) (ap (_âˆ˜ right) qï¼))
                    a.filler b.filler

  pathâ†cocone~ : FunExtGlobal â†’ âˆ€ {a b : CoconeD S cc P} â†’ coconeáµˆ~ a b â†’ coconeáµˆ-path a b
  pathâ†cocone~ fe record { p~ = p~ ; q~ = q~ ; filler~ = filler~ }
    = record { pï¼ = funextâ†’ fe p~ ; qï¼ = funextâ†’ fe q~ ; fillerï¼ = {!!} âˆ™ funextâ†’ fe filler~ } where open WithFunExt

  from-coconeáµˆ-path : âˆ€ {a b : CoconeD S cc P} â†’ coconeáµˆ-path a b â†’ a ï¼ b
  from-coconeáµˆ-path record { pï¼ = refl ; qï¼ = refl ; fillerï¼ = refl } = refl

  funext-coconeáµˆâ†’ : FunExtGlobal â†’ âˆ€ {a b : CoconeD S cc P} â†’ coconeáµˆ~ a b â†’ a ï¼ b
  funext-coconeáµˆâ†’ fe = from-coconeáµˆ-path âˆ˜ pathâ†cocone~ fe
}
% ```
}


\subtree[stt-0017]{
  \taxon{definition}
  \title{is-pushout}

  \p{
    Given a span of types #{C \xleftarrow{f} A \xrightarrow{g} B}, we say that a type #{D} is it's pushout if it is the universal cocone. In other words it fits universally into the following commutative diagram:
  }

  \quiver{
  \begin{tikzcd}
	A && B \\
	\\
	C && D \\
        &&& Q
	\arrow["g", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[bend left, from=1-3, to=4-4]
	\arrow[from=3-1, to=3-3]
	\arrow[bend right, from=3-1, to=4-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[dashed, from=3-3, to=4-4]
  \end{tikzcd}
  }

  \p{In the language of type theory, given a cocone #{C}, this can be encoded by requiring
     that the obvious map #{(C \to Q) \to \mathrm{Cocone(Q)}} given by precomposition
     is an equivalence.
  }


% ```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) where
  construct-cocone : âˆ€ {ğ“› ğ“œ} {C : Type ğ“›} (C-cc : Cocone S C)
                {Q : Type ğ“œ} â†’ (C â†’ Q) â†’ Cocone S Q
  construct-cocone C f = mk-cocone (f âˆ˜ p) (f âˆ˜ q) Î» a â†’ ap f (filler a) where open Cocone C

  is-pushout : âˆ€ {ğ“›} {C : Type ğ“›} â†’ Cocone S C â†’ Type _
  is-pushout {ğ“›} C = âˆ€ {Q : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›)} â†’ is-equiv (construct-cocone C {Q})

  is-pushoutÏ‰ : âˆ€ {ğ“›} {C : Type ğ“›} â†’ Cocone S C â†’ TypeÏ‰
  is-pushoutÏ‰ {ğ“›} C = âˆ€ {ğ“œ} {Q : Type ğ“œ} â†’ is-equiv (construct-cocone C {Q})
}
% ```
}

% ```agda
\agda{
  construct-coconeáµˆ : âˆ€ {ğ“› ğ“œ} {C : Type ğ“›} (C-cc : Cocone S C)
                      â†’ {Q : C â†’ Type ğ“œ}
                      â†’ ((c : C) â†’ Q c)
                      â†’ CoconeD S C-cc Q 
  construct-coconeáµˆ C f = mk-coconeD (f âˆ˜ p) (f âˆ˜ q) (apáµˆ f âˆ˜ filler) where open Cocone C

  is-pushoutáµˆ : âˆ€ {ğ“›} {C : Type ğ“›} â†’ Cocone S C â†’ Type _
  is-pushoutáµˆ {ğ“›} {C} Cc =  âˆ€ {Q : C â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›)} â†’ is-equiv (construct-coconeáµˆ Cc {Q})

  
  is-pushoutÏ‰áµˆ : âˆ€ {ğ“›} {C : Type ğ“›} â†’ Cocone S C â†’ TypeÏ‰
  is-pushoutÏ‰áµˆ {ğ“›} {C} Cc = âˆ€ {ğ“œ} {Q : C â†’ Type ğ“œ} â†’ is-equiv (construct-coconeáµˆ Cc {Q})
}
% ```

\subtree[stt-0018]{
\taxon{theorem}
\title{Uniqueness of pushouts}
\meta{assumes}{Univalence}

\p{Pushouts, like all universal constructions, are unique if they exist. We will show 
that the type of cocones that are pushouts is a subsingleton}

\proof{

% ```agda
\agda{
-- module _ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) where
--   pushouts-unique : âˆ€ {ğ“›} â†’ is-subsingleton (Î£[ X âˆ¶ Type ğ“› ] Î£[ C âˆ¶ Cocone S X ] is-pushout S C)
--   pushouts-unique = {!!}
}
% ```

}
}

% ```agda
\agda{
has-pushouts : âˆ€ ğ“¤ â†’ Type (lsuc ğ“¤)
has-pushouts ğ“¤ = âˆ€ (S : Span ğ“¤ ğ“¤ ğ“¤)
                  â†’ Î£[ P âˆ¶ Type ğ“¤ ] Î£[ C âˆ¶ Cocone S P ]
                       is-pushout S C

record Ind-Pushout {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) : TypeÏ‰ where
  open Span S public

  field
    Pushout : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
    cocone : Cocone S Pushout

  open Cocone cocone public renaming (p to Î¹â‚ ; q to Î¹â‚‚ ; filler to glue)

  open CoconeD

  field
    pushout-ind : âˆ€ {ğ“ } (Q : Pushout â†’ Type ğ“ ) â†’ CoconeD S cocone Q â†’ (x : Pushout) â†’ Q x

    pushout-indÎ²1 : âˆ€ {ğ“ } {Q : Pushout â†’ Type ğ“ } â†’ {c : CoconeD S cocone Q} â†’
                      âˆ€ x â†’ pushout-ind Q c (Î¹â‚ x) ï¼ c .p x

    pushout-indÎ²2 : âˆ€ {ğ“ } {Q : Pushout â†’ Type ğ“ } â†’ {c : CoconeD S cocone Q} â†’
                      âˆ€ x â†’ pushout-ind Q c (Î¹â‚‚ x) ï¼ c .q x

  field
    pushout-ind-apÎ² : âˆ€ {ğ“ } {Q : Pushout â†’ Type ğ“ } {c : CoconeD S cocone Q}
                      â†’ HomotopyP (Î» c â†’ apâ‚‚ (IdP (ap Q (glue c))) (pushout-indÎ²1 (left c)) (pushout-indÎ²2 (right c)))
                                  (apáµˆ (pushout-ind Q c) âˆ˜ glue) 
                                  (c .filler)
  Dependentâ†cocone : âˆ€ {ğ“ } {Q : Type ğ“ } â†’
                      Cocone S Q â†’ CoconeD S cocone Î» _ â†’ Q
  Dependentâ†cocone (mk-cocone p q eq) = mk-coconeD p q Î» c â†’ tr-constant (glue c) (p (left c)) âˆ™ eq c

  pushout-ind-equiv :  FunExtGlobal â†’ âˆ€ {ğ“ } {Q : Pushout â†’ Type ğ“ } 
                      â†’ is-equiv (pushout-ind Q)
  pushout-ind-equiv FE {Q = Q} = is-equivâ†qiso I where
    open WithFunExt

    I : quasi-iso (pushout-ind Q)
    I .fst = construct-coconeáµˆ S cocone 
    I .snd .fst C@(mk-coconeD p q eq) = funext-coconeáµˆâ†’ FE II where
       II : coconeáµˆ~ ((construct-coconeáµˆ S cocone âˆ˜ pushout-ind Q) C) C 
       II .coconeáµˆ~.p~ = pushout-indÎ²1
       II .coconeáµˆ~.q~ = pushout-indÎ²2
       II .coconeáµˆ~.filler~ = pushout-ind-apÎ²
    I .snd .snd f = funextâ†’ FE (pushout-ind (Î» z â†’ (pushout-ind Q âˆ˜ I .fst) f z ï¼ f z)
                               (mk-coconeD pushout-indÎ²1 pushout-indÎ²2 {!!})) 


  pushout-rec : âˆ€ {ğ“ } {Q : Type ğ“ } â†’ Cocone S Q â†’ Pushout â†’ Q
  pushout-rec {Q = Q} cc = pushout-ind (Î» _ â†’ Q) (mk-coconeD (cc .Cocone.p) (cc .Cocone.q)
                            Î» a â†’ tr-constant  (glue a) (cc .Cocone.p (left a)) âˆ™ cc .Cocone.filler a) 

  pushout-rec-equiv : FunExtGlobal â†’ âˆ€ {ğ“ } {Q : Type ğ“ } 
                      â†’ is-equiv (pushout-rec {Q = Q})
  pushout-rec-equiv fe = is-equivâ†qiso I where
    open WithFunExt

    I : quasi-iso pushout-rec
    I .fst = construct-cocone S cocone
    I .snd .fst = {!!}
    I .snd .snd f = funextâ†’ fe (pushout-ind (Î» z â†’ (pushout-rec âˆ˜ I .fst) f z ï¼ f z)
                            (mk-coconeD pushout-indÎ²1 pushout-indÎ²2 Î» a â†’ ?))



global-pushouts : TypeÏ‰
global-pushouts = âˆ€ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦) â†’ Ind-Pushout S

}
% ```
