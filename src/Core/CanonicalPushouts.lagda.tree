\date{2025-04-15}
\title{Properties of the canonical pushouts}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb Core.CanonicalPushouts \stopverb}

\import{stt-macros}

% ```agda
\agda{
module Core.CanonicalPushouts where

open import Foundations.Prelude
open import ufAxioms
open import Ergonomics.Extensionality
open import Ergonomics.Representation
}
% ```


\subtree[stt-002L]{
\taxon{theorem}
\title{Canonical pushouts are pushouts}

% ```agda
\agda{
Pushout-is-pushoutÏ‰ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                       {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                     â†’ is-pushoutÏ‰ (mk-span _ f g) pushout
Pushout-is-pushoutÏ‰ {f = f} {g} = is-equivâ†qiso iso where
  iso : quasi-iso (cocone-map (mk-span _ f g) pushout)
  iso .fst = pushout-rec
  iso .snd .fst f = ext! (pushout-ind _ Î» where
    .CoconeD.p _ â†’ refl
    .CoconeD.q _ â†’ refl
    .CoconeD.filler a â†’ IdP-funcâ†Square (glue a) refl refl
                         (Square-degen-hor _ _ (pushout-rec-apÎ² a)))
  iso .snd .snd (mk-cocone p q filler)
    = ap (mk-cocone p q) (ext! pushout-rec-apÎ²)


pushout-rec-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                       {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                       {ğ“ } {Q : Type ğ“ }
                      â†’ is-equiv (pushout-rec {f = f} {g} {Q = Q})
pushout-rec-is-equiv {Q = Q} = is-equivâ»Â¹ (Pushout-is-pushoutÏ‰)
}
% ```

}

\subtree[stt-004G]{
\taxon{definition}
\date{2025-05-17}
\title{The cogap map}
\meta{defines}{\startverb ["cogap"] \stopverb}

\p{
Analogously to pullbacks, we sometimes call pushout-rec the cogap map.
Given a cocone #{C} under a span #{S}, we can define a the
cogap-map from the pushout of #{S} and the apex of #{C}.
}

% ```agda
\agda{
cogap : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : A â†’ B} {g : A â†’ C}
        {ğ“œ} {D : Type ğ“œ}
      â†’ Cocone (mk-span A f g) D
      â†’ Pushout f g â†’ D
cogap = pushout-rec
}
% ```
}

\subtree[stt-007X]{
\date{2025-07-29}
\title{Pushouts via the cogap map}
\taxon{theorem}

\p{A cocone #{D} over #{B \xleftarrow{f} A \xrightarrow{g} C}
is a pushout iff the cogap map #{B +^A C \to D} is an equivalence.}

\proof{
\p{We would like to show for any #{Q}, that the cogap map i
construct the following triangle:}

\quiver{
\begin{tikzcd}
        {D \to Q} && {B +^A C \to Q} \\
	\\
	& {\textrm{Cocone}_S(Q)}
	\arrow["{\textrm{cogap}(D) \circ -}", from=1-1, to=1-3]
	\arrow["{\textrm{cocone-map}(D)}"'{pos=0.4}, from=1-1, to=3-2]
	\arrow["\sim", from=1-3, to=3-2]
\end{tikzcd}
}
}


%```agda
\agda{

is-pushoutâ†cogap : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                     {f : A â†’ B} {g : A â†’ C}
                     {ğ“œ} {D : Type ğ“œ}
                     (CD : Cocone (mk-span A f g) D)
                   â†’ is-equiv (cogap CD)
                   â†’ is-pushoutÏ‰ _ CD
is-pushoutâ†cogap CD = fwd where
    open Cocone CD

    H : âˆ€ {ğ“ } {Q : Type ğ“ }
        â†’ cocone-map _ CD ~ cocone-map _ pushout âˆ˜ postcomp Q (cogap CD)
    H f = ap (mk-cocone (f âˆ˜ p) (f âˆ˜ q)) (funextâ†’ (Î» a
      â†’ sym (  ap-âˆ˜ f (pushout-rec CD) (glue a)
             âˆ™ ap (ap f) (pushout-rec-apÎ² a))))


    fwd : is-equiv (cogap CD) â†’ is-pushoutÏ‰ _ CD
    fwd cogap-eq {_} {Q} = is-equiv~âˆ˜ H
               (Pushout-is-pushoutÏ‰ {Q = Q})
               (postcomp-equiv cogap-eq)
}
%```
}


\subtree[stt-007Y]{
\date{2025-07-29}
\title{Pushouts from pullbacks}
\taxon{theorem}
\p{A cocone #{D} over a span #{C \xleftarrow{f} A \xrightarrow{g} B}
is a pushout iff for all types #{Q}, the cone #{Q^A} over the cospan
#{Q^B \xrightarrow{f} Q^D \xleftarrow{g} Q^C} is a pullback.}

\proof{

\p{There is an equivalence between cocones at #{Q} over a span and
the pullback #{Q^X \times_{Q^A} Q^B}. We then construct the following
triangle which, via the [3 for 2](stt-003E) property, completes the
proof.}

\quiver{
\begin{tikzcd}
	& {Q^Y} \\
	{\rm{Cocone}} && {Q^X\times_{Q^A}Q^B}
	\arrow["{\rm{cocone-map}}"', from=1-2, to=2-1]
	\arrow["{\rm{gap}}", from=1-2, to=2-3]
	\arrow["\sim"', from=2-1, to=2-3]
\end{tikzcd}
}
}

%```agda
\agda{
unquoteDecl cocone-reprâ‰… cocone-reprâ‰ƒ
  = make-record-repr cocone-reprâ‰… cocone-reprâ‰ƒ (quote Cocone)

postcomp-coconeâ‰ƒpb
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {f : B â†’ A}
      {g : B â†’ C} {D : Type ğ“œ}
    â†’ Cocone (mk-span _ f g) D â‰ƒ Pullback (postcomp D g) (postcomp D f)
postcomp-coconeâ‰ƒpb {f = f} {g} {D}
  = Cocone (mk-span _ f g) D                â‰ƒâŸ¨ cocone-reprâ‰ƒ âŸ©
    (Î£[ f' âˆ¶ (_ â†’ D)] Î£[ g' âˆ¶ (_ â†’ D)] (f' âˆ˜ f ~ g' âˆ˜ g))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-ap-â‰ƒ (Î» e â†’ precomp-Î -â‰ƒ (Î» _ â†’ symâ‰ƒ) âˆ™â‰ƒ funextâ‰ƒ eâ»Â¹))âŸ©
    (Î£[ f' âˆ¶ (_ â†’ D)] Î£[ g' âˆ¶ (_ â†’ D)] (g' âˆ˜ g ï¼ f' âˆ˜ f))
      â‰ƒâŸ¨ Î£-comm âŸ©
    Pullback (postcomp D g) (postcomp D f) â‰ƒâˆ

postcomp-cospan : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                    {ğ“ } (Q : Type ğ“ )
                  â†’ Cospan (ğ“¤ âŠ” ğ“ ) (ğ“¦ âŠ” ğ“ ) (ğ“¥ âŠ” ğ“ )
postcomp-cospan (mk-span Centre l r) Q
  = mk-cospan (Centre â†’ Q) (postcomp Q r) (postcomp Q l)

postcomp-cone : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
                  {ğ“œ} {D : Type ğ“œ}
                  (C : Cocone S D)
                  {ğ“ } (Q : Type ğ“ )
                â†’ Cone (postcomp-cospan S Q) (D â†’ Q)
postcomp-cone (mk-cocone p q filler) Q
  = mk-cone  (postcomp Q q) (postcomp Q p) Î»
    f â†’ (funextâ†’ (f â—‚ sym âˆ˜ filler))

is-pushoutâ†postcomp-pullback
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {D : Type ğ“œ}
      (C : Cocone S D)
    â†’ (âˆ€ {ğ“ }(Q : Type ğ“ ) â†’ is-pullbackÏ‰ (postcomp-cospan S Q)
                                  (postcomp-cone C Q))
    â†’ is-pushoutÏ‰ S C
is-pushoutâ†postcomp-pullback C pb {Q = Q}
  = 3-for-2~ H
             (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv)
             (gap-is-equivâ†is-pullback (postcomp-cone C Q) (pb Q))
  where
    H : gap (postcomp-cone C Q) ~
         _â‰ƒ_.fwd postcomp-coconeâ‰ƒpb âˆ˜ cocone-map _ C
    H f = ap (Î» p â†’ _ , _ , p)
          (ap funextâ†’ (funextâ†’ (Î» a â†’ ap-sym f (Cocone.filler C a))))
}
%```
}
