\date{2025-11-17}
\title{Simplicial types}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

\subtree[stt-00AB]{
\taxon{Remark}
\p{This module, as almost all in \code{Synthetic.Categories} assumes a
type #{\Delta^1} with a distributive lattice structure, we
call this type the generic interval.}
}

%```agda
\agda{
open import Foundations.Prelude
open import Algebra.Lattice

module Synthetic.Categories.Simplicial
  {ğ“˜} (Î”Â¹ : Type ğ“˜) (I : Lattice Î”Â¹) (I-distr : is-distributive I)
  where

open import ufAxioms

open Lattice I renaming (0l to i0; 1l to i1)
import Algebra.Lattice.Instances.Polynomial as Poly
open Poly  hiding (L[x]; Î”Â²)
open is-distributive I-distr

private
  Î”Â² = Poly.Î”Â² I
  I[x] = Poly.L[x] I

open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Modalities.Instances.Truncation

open import Core.Join
open import Core.Arrow
open import Core.ArrowEquiv
open import Core.CanonicalPushouts
open import Core.PushoutEquiv
open import Core.FunctorialPushout
open import Core.SpanMap
open import Core.Orthogonal
open import Core.OrthogonalClosure
open import Core.FlatteningPushouts
open import Core.SubtypeEquiv

open import Ergonomics.Extensionality
open import Ergonomics.Auto

open import Synthetic.Cubes Î”Â¹ i0 i1
}
%```


\subtree[stt-00AC]{
\taxon{Definition}
\title{Simplicial types}

\p{If we don't assume that the interval is totally ordered, we can speak of
particular types which \em{'see'} the interval as totally ordered. This can be
made precise by asking for types which are [null](stt-005G) with respect to the
family of propositions #{(i \le j) \lor (j \le i)}.}

%```agda
\agda{
is-simplicial : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type (ğ“˜ âŠ” ğ“¤)
is-simplicial = is-null {I = Î”Â¹ Ã— Î”Â¹} Î» (i , j) â†’ (i â‰¤ j) * (j â‰¤ i)
}
%```



\p{By virtue of being defined in terms of nullification at a proposition, we know
that simplicial types form a lex [#{\Sigma}-closed](stt-006E)
[reflective subuniverse](stt-0065).}

%```agda
\agda{
Simplicial-SubU : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“˜)
Simplicial-SubU = Null-SubU (Î» ((i , j) : Î”Â¹ Ã— Î”Â¹) â†’ (i â‰¤ j) * (j â‰¤ i)) _

Simplicial-GSU : GSU (_âŠ” ğ“˜)
Simplicial-GSU = Null-GSU (Î» ((i , j) : Î”Â¹ Ã— Î”Â¹) â†’ (i â‰¤ j) * (j â‰¤ i))

Simplicial-is-globally-reflective
  : is-globally-reflective Simplicial-GSU
Simplicial-is-globally-reflective = Null-globally-reflective

module Simp where
  open GRSUInduction Simplicial-is-globally-reflective
                     Null-globally-Î£-closed public

  open GSU Simplicial-GSU public renaming (S-equiv to is-simplicialâ†equiv)

  open is-globally-reflective Simplicial-is-globally-reflective

  Î£-is-simplicial = Null-globally-Î£-closed

Î”Â²-â‰¤-rec : âˆ€ {ğ“¤} {A : Type ğ“¤} {i j} â†’ is-simplicial A
           â†’ (l : i â‰¤ j â†’ A) â†’ (r : j â‰¤ i â†’ A) â†’ (l âˆ˜ â‰¤â†ï¼ ~ r âˆ˜ â‰¥â†ï¼) â†’ A
Î”Â²-â‰¤-rec {i = i} {j} asimp l u eq
  = is-equiv.bwd (asimp (i , j)) (cogap (mk-cocone l u
      Î» where (p , q) â†’ ap l (is-prop-separated _ _ _ _)
                      âˆ™ eq (â‰¤-antisym p q)
                      âˆ™ ap u (is-prop-separated _ _ _ _)))

Î”Â²-â‰¤-rec! : âˆ€ {ğ“¤} {A : Type ğ“¤} i j â†’ is-simplicial A
            â†’ (l : â¦ƒ i â‰¤ j â¦„ â†’ A) â†’ (r : â¦ƒ j â‰¤ i â¦„ â†’ A)
            â†’ (âˆ€ (q : i ï¼ j) â†’ l â¦ƒ â‰¤â†ï¼ q â¦„ ï¼ r â¦ƒ â‰¥â†ï¼ q â¦„)
            â†’ A
Î”Â²-â‰¤-rec! i j simp l r eq = Î”Â²-â‰¤-rec simp (Î» p â†’ l â¦ƒ p â¦„) (Î» q â†’ r â¦ƒ q â¦„) eq
}
%```
}

\subtree[tot-000E]{
\title{Triangulated squares}
\taxon{Lemma}

\p{The following square is simplicial-cocartesian. I.e. precomposition at any
simplicial type gives a [cartesian square](stt-003V):}

\quiver{
\begin{tikzcd}
	{\Delta^1} && {\Delta^2} \\
	\\
	{\Delta^2} && {\square^2}
	\arrow["\delta", from=1-1, to=1-3]
	\arrow["\delta"', from=1-1, to=3-1]
	\arrow["{(x,y)\mapsto(y,x)}", from=1-3, to=3-3]
	\arrow["{(x,y)\mapsto(x,y)}"', from=3-1, to=3-3]
\end{tikzcd}
}

\proof{
\p{We have that for all #{(i,j) : \square }, #{(i \leq j * j \leq i) \perp A}.
   By closure of left ortgogonality under #{\Sigma}, this gives us
   #{\Sigma_{i,j}(i \leq j * j \leq i) \perp A}. But this sigma type is exactly
   the triangulated square.
}
}

%```agda
\agda{
â§… : Type ğ“˜
â§… = Pushout {B = Î”Â²} {C = Î”Â²} (Î¹-const I I-distr) (Î¹-const I I-distr)

Î”Â²-Î¹-upper : Î”Â² â†’ â–¡^ 2
Î”Â²-Î¹-upper (x , y) = (x , y)

Î”Â²-Î¹-lower : Î”Â² â†’ â–¡^ 2
Î”Â²-Î¹-lower (x , y) = (y , x)

â§…-square : Arrow-map (Î¹-const I I-distr) Î”Â²-Î¹-upper
â§…-square .Arrow-map.top = Î¹-const I I-distr
â§…-square .Arrow-map.bot = Î”Â²-Î¹-lower
â§…-square .Arrow-map.comm = ~refl

â§…-incl : â§… â†’ â–¡^ 2
â§…-incl = cogap-mapâ†square â§…-square

â§…-Sub : Subtype (â–¡^ 2) ğ“˜
â§…-Sub .Subtype.family (i , j) = (i â‰¤ j) * (j â‰¤ i)
â§…-Sub .Subtype.has-is-subtype (i , j) = *-is-prop â‰¤-is-prop â‰¤-is-prop

fibre-â§…-incl : âˆ€ x â†’ fibre â§…-incl x â‰ƒ x âˆˆ â§…-Sub
fibre-â§…-incl x@(i , j)
  = fibre â§…-incl x    â‰ƒâŸ¨ cogap-fibre _ x âŸ©
    Pushout _ _        â‰ƒâŸ¨ mkâ‰ƒ pushout-map pushout-map-is-eqv âŸ©
    Pushout fst snd   â‰ƒâŸ¨âŸ©
    (i â‰¤ j) * (j â‰¤ i) â‰ƒâˆ where
  open Span
  total-fibre-span : Span ğ“˜ ğ“˜ ğ“˜
  total-fibre-span = total-span _ _ (Fibre-family (Coconeâ†Arrow-map â§…-square .snd) x)

  intended-span : Span ğ“˜ ğ“˜ ğ“˜
  intended-span = mk-span ((i â‰¤ j) Ã— (j â‰¤ i)) fst snd

  span-map : Span-map _ _
  span-map .Span-map.hâ‚ (x , refl) = auto!
  span-map .Span-map.hâ‚‚ (x , refl) = (auto! , auto!)
  span-map .Span-map.hâ‚ƒ (x , refl) = auto!
  span-map .Span-map.H _ = is-prop-separated _ _ _ _
  span-map .Span-map.K _ = is-prop-separated _ _ _ _

  pushout-map : Pushout (total-fibre-span .left) (total-fibre-span .right)
              â†’ Pushout fst snd
  pushout-map = Pushout-functorial-span span-map

  inv-span-map : Span-map _ _
  inv-span-map .Span-map.hâ‚ ij = (j , i) â¦ƒ ij â¦„ , refl
  inv-span-map .Span-map.hâ‚‚ (p , q) = j , Ã—-pathâ†’ ((â‰¤-antisym q p) , refl)
  inv-span-map .Span-map.hâ‚ƒ ij = ((i , j) â¦ƒ ij â¦„ , refl)
  inv-span-map .Span-map.H (p , q) = Î£-pathâ†’ (Î”Â²-ext (refl , (â‰¤-antisym p q))
    , is-propâ†is-truncated (Trunc.Ã—âˆˆS car-is-set car-is-set _ _) _ _)
  inv-span-map .Span-map.K (p , q) = Î£-pathâ†’ ((Î”Â²-ext ((â‰¤-antisym p q) , refl))
    , is-propâ†is-truncated (Trunc.Ã—âˆˆS car-is-set car-is-set _ _) _ _)

  inverse-pushout-map
    : Pushout fst snd
    â†’ Pushout (total-fibre-span .left) (total-fibre-span .right)
  inverse-pushout-map = Pushout-functorial-span inv-span-map

  span-hom : Span-map-homotopy (compose-span-map inv-span-map span-map) id-span-map
  span-hom .fst (a , refl) = refl
  span-hom .snd .fst (a , refl) = Î£-pathâ†’ (refl
    , (is-propâ†is-truncated (Trunc.Ã—âˆˆS car-is-set car-is-set _ _) _ _))
  span-hom .snd .snd .fst (a , refl) = refl
  span-hom .snd .snd .snd .fst a
    = (is-propâ†is-truncated
        (Trunc.Î£-is-truncated Î”Â²-is-set
          (Î» a â†’ Trunc.Ã—âˆˆS
            (suc-is-truncated _ car-is-set)
            (suc-is-truncated _ car-is-set) _ _) _ _) _ _)
  span-hom .snd .snd .snd .snd a
    = is-propâ†is-truncated
        (Trunc.Î£-is-truncated Î”Â²-is-set
          (Î» b â†’ Trunc.Ã—âˆˆS
           (suc-is-truncated _ car-is-set)
           (suc-is-truncated _ car-is-set) _ _) _ _) _ _


  span-eq : compose-span-map inv-span-map span-map ï¼ id-span-map
  span-eq = Span-map-funextâ†’ span-hom

  abstract
   ret : retract-witness pushout-map inverse-pushout-map
   ret a = sym (happly
             (sym (ap Pushout-functorial-span span-eq âˆ™ Canonical-pushout-map-id)
               âˆ™ (Canonical-Pushout-map-compose inv-span-map span-map)) a)


  span-hom' : Span-map-homotopy (compose-span-map span-map inv-span-map) id-span-map
  span-hom' .fst = ~refl
  span-hom' .snd .fst (p , q)
    = Ã—-pathâ†’ (is-prop-separated _ _ _ _ , is-prop-separated _ _ _ _)
  span-hom' .snd .snd .fst = ~refl
  span-hom' .snd .snd .snd .fst a
    = is-propâ†is-truncated (suc-is-truncated _ car-is-set _ _ _ _) _ _
  span-hom' .snd .snd .snd .snd a
    = is-propâ†is-truncated (suc-is-truncated _ car-is-set _ _ _ _) _ _

  span-eq' : compose-span-map span-map inv-span-map ï¼ id-span-map
  span-eq' = Span-map-funextâ†’ span-hom'

  abstract
   sec : section-witness pushout-map inverse-pushout-map
   sec a = sym (happly
             (sym (ap Pushout-functorial-span span-eq' âˆ™ Canonical-pushout-map-id)
               âˆ™ (Canonical-Pushout-map-compose span-map inv-span-map)) a)

  pushout-map-is-eqv : is-equiv pushout-map
  pushout-map-is-eqv = is-equivâ†qiso (inverse-pushout-map , ret , sec)

open FromFibreSubtype â§…-Sub â§…-incl fibre-â§…-incl public renaming
  (equiv-to-subtype to â§…-as-subtype;
   incl-is-embedding to â§…-incl-is-embedding;
   pres-carr to â§…-pres-carrier;
   pres-carr' to â§…-pres-carrier')

simp-is-triangulated : âˆ€ {ğ“¤} {A : Type ğ“¤}
                     â†’ is-simplicial A â†’ is-local (Î» (_ : ğŸ™) â†’ â§…-incl) A
simp-is-triangulated {_}{A} simp tt
  = is-orthogonalâ‡”orthogonal-! .fst
      (left-orthogonal-equiv _ _ amap amap-is-eqv !
        (left-orthogonal-Î£ _ !
          (is-orthogonalâ‡”orthogonal-! .snd
          âˆ˜ (is-localâ†is-null simp)))) where
  amap : Arrow-map (total-map (Î» _ â†’ !)) â§…-incl
  amap .Arrow-map.top = _â‰ƒ_.bwd â§…-as-subtype
  amap .Arrow-map.bot = fst
  amap .Arrow-map.comm = â§…-pres-carrier' ~â»Â¹

  amap-is-eqv : is-Arrow-equiv amap
  amap-is-eqv .fst = is-equivâ»Â¹ (_â‰ƒ_.has-is-eqv â§…-as-subtype)
  amap-is-eqv .snd = singleton-fst-is-equiv (Î» _ â†’ ğŸ™-is-singleton)
}
%```
}
