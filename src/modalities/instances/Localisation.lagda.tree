\date{2025-06-17}
\title{Localisations}
\taxon{module}
\meta{module}{\startverb modalities.instances.Localisation \stopverb}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module modalities.instances.Localisation where

open import ufAxioms
open import axioms.FreeAlgInj
open import foundations.Prelude
open import core.Orthogonal
open import core.CanonicalPushouts
open import core.Codiagonal
open import core.CoSlice
open import core.Arrow
open import core.ArrowEquiv
open import ergonomics.notations.Orthogonality
open import modalities.HigherModality
open import modalities.Subuniverses
open core.Orthogonal.notation
}
%```

\subtree[stt-005F]{
\taxon{definition}
\title{Local types}

\p{Given a family of maps #{f_i : A_i \to B_i}, we say that a type
is #{f}-local if it is [orthogonal](stt-004O) to each map.}

%```agda
\agda{
is-local : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘} {A : I → Type 𝓤} {B : I → Type 𝓥}
               → (f : (i : I) → A i → B i)
               → Type 𝓦
               → Type (𝓘 ⊔ 𝓤 ⊔ 𝓥 ⊔ 𝓦)
is-local f A = ∀ i → orthogonal-type (f i) A

is-local-is-prop
  : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘} {A : I → Type 𝓤} {B : I → Type 𝓥}
      {f : (i : I) → A i → B i}
    → ∀ (A : Type 𝓦) → is-prop (is-local f A)
is-local-is-prop A = is-prop-Π λ i → is-equiv-is-prop
}
%```
}


\subtree[stt-005G]{
\taxon{definition}
\title{Null types}

\p{Given a family of types #{A_i}, we say a type #{X} is #{A} null if
it is right orthogonal to each #{A_i}. Or equivalently, if the
obvious maps #{X \to (A_i \to X)} are equivalences for each #{i}.}

%```agda
\agda{
is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} (A : I → Type 𝓤)
            → Type 𝓥 → Type (𝓘 ⊔ 𝓤 ⊔ 𝓥)
is-null A X = ∀ i → is-equiv (const X (A i))

is-null-is-prop
  : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} {A : I → Type 𝓤}
    → ∀ (X : Type 𝓥) → is-prop (is-null A X)
is-null-is-prop X = is-prop-Π λ a → is-equiv-is-prop
}
%```
}

\subtree[stt-005H]{
\taxon{theorem}
\title{Null types are #{!\rm{-local}}}

\p{A type is #{A_i}-null iff it is #{(! : A_i \to 1)\rm{-local}}.}

\proof{
\p{A type #{X} is #{!\rm{-local}} when the map #{- \circ\ ! : (1 \to X) \to (A_i \to X)}
is an equivalence.}
}

%```agda
\agda{
is-local←is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} {A : I → Type 𝓤}
                   → {X : Type 𝓥}
                   → is-null A X
                   → is-local (λ i → ! {A = A i}) X
is-local←is-null eq i = 3-for-2' (is-equiv⁻¹ unit-ev-is-equiv) (eq i)

is-null←is-local : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} {A : I → Type 𝓤}
                   → {X : Type 𝓥}
                   → is-local (λ i → ! {A = A i}) X
                   → is-null A X
is-null←is-local eq i = is-equiv-∘ (eq i) unit-const-is-equiv
}
%```
}

\subtree[stt-005K]{
\title{Nullfication at an pointed family}
\taxon{definition}

\p{The nullification of a pointed type can be constructed
using the [free algabraic injection](stt-005I)
higher inductive type. By definition, the free
algabraic injection already gives a section to
the precomposition map. Because any map #{A \to 1}
has a section, then the precomposition by this
map already has a retract, and so the type is not just
algabraicly #{A}-injective, but #{A}-null.}

%```agda
\agda{
Null∙ : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘} (A : I → Type 𝓤)
         (A∙ : Π _ A) (X : Type 𝓥)
       → Type 𝓥
Null∙ A _ X = Free-inj
               (λ i → ! {A = A i})
                X

Null∙-is-null : ∀ {𝓘 𝓤 𝓥} {I : Type 𝓘}
                 {A : I → Type 𝓤} (A∙ : Π _ A)
                 {X : Type 𝓥}
               → is-null A (Null∙ A A∙ X)
Null∙-is-null a = is-null←is-local I where
  I : is-local (λ _ → !) _
  I i = is-equiv←qiso λ where
    .fst → injector-Free-inj i .fst
    .snd .fst α → funext→ (λ _ → Free-inj.is-ext (α ∘ !) (a i))
    .snd .snd → injector-Free-inj i .snd
}
%```
}


\subtree[stt-005Z]{
\taxon{lemma}
\title{Locality via sections of the codiagonal}
\citet{rijkeMod2020}{2.13}

\p{Given maps #{f_i : A_i \to B_i}, a type #{X} is #{f\rm{-local}}
iff #{-\circ f_i} and #{-\circ \nabla_{f_i}} all have sections.}

%```agda
\agda{
is-local←sec←sec-∇
  : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘}
      {A : I → Type 𝓤} {B : I → Type 𝓥}
      {f : (i : I) → A i → B i}
      {X : Type 𝓦}
    → (∀ i → section (postcomp X (f i)))
    → (∀ i → section (postcomp X (∇ (f i))))
    → is-local f X
is-local←sec←sec-∇ sec sec∇ i
  = is-equiv←is-pathsplit
      (is-pathsplit←sec-diag
        (sec i)
        (sec←sec-Coslice-equiv'
          (Δ←∇ _ _)
          Δ←∇-is-equiv
          (sec∇ i)))


sec∇←is-local
  : ∀ {𝓘 𝓤 𝓥 𝓦} {I : Type 𝓘}
      {A : I → Type 𝓤} {B : I → Type 𝓥}
      {f : (i : I) → A i → B i}
      {X : Type 𝓦}
    → is-local f X
    → ∀ i → section (postcomp X (∇ (f i)))
sec∇←is-local loc i = sec←sec-Coslice-equiv
                        (Δ←∇ _ _)
                        Δ←∇-is-equiv
                        (sec-diag←is-pathsplit
                          (is-pathsplit←is-equiv (loc i)))
}
%```
}

\subtree[stt-005Y]{
\title{Localisation}
\taxon{definition}

\p{Unlike in the case of [nullification](stt-005K), we cannot
in general expect the family of functions against which we are
localising to all have sections. As such the [Free algabraicly injective](stt-005I)
type will not get us all the way to a localisation.}


\p{As explained in \citet{2.14}{rijkeMod2020}, even though the free algabraicly
#{f}-injective type is not a localisation, we can add some morphisms to the class
with which we localise against to make it so. By the observation in \ref{stt-005Z},
we need to add all maps of the form #{\nabla_{f_i}} to #{f}.}

%```agda
\agda{

module _ {𝓘 𝓤 𝓦 : Level} {I : Type 𝓘}
         {A : I → Type 𝓤} {B : I → Type 𝓤}
         where
  private
    A' : (f : ∀ i → A i → B i) → I ⊎ I → Type 𝓤
    A' f (left i) = A i
    A' f (right i) = Pushout (f i) (f i)

    B' : (f : ∀ i → A i → B i) → I ⊎ I → Type 𝓤
    B' f (left i)  = B i
    B' f (right i) = B i

    f' : (f : ∀ i → A i → B i) → (i : I ⊎ I) → A' f i → B' f i
    f' f (left i) = f i
    f' f (right i) = ∇ (f i)

  Loc : (f : ∀ i → A i → B i) → Type 𝓦 → Type 𝓦
  Loc f = Free-inj (f' f)

  Loc-is-local : ∀ {X : Type 𝓦}
                   {f : ∀ i → A i → B i}
                 → is-local f (Loc f X)
  Loc-is-local = is-local←sec←sec-∇
                   (λ i → injector-Free-inj (left i))
                   (λ i → injector-Free-inj (right i))
}
%```
}


%```agda
\agda{
postcomp-inj : ∀ {𝓘 𝓤 𝓥 𝓦 𝓜}
                   {I : Type 𝓘} {A : I → Type 𝓤}
                   {B : I → Type 𝓥}
                   {f : (i : I) → A i → B i}
                   (X : Type 𝓦) {Y : Type 𝓜}
                 → (Free-inj f X → Y)
                 → (X → Y)
postcomp-inj X {Y} = postcomp Y Free-inj.inc

Local-reflects : ∀ {𝓘 𝓤 𝓥 𝓦 𝓜}
                   {I : Type 𝓘} {A : I → Type 𝓤}
                   {B : I → Type 𝓥}
                 {f : (i : I) → A i → B i}
                 (X : Type 𝓦) {Y : Type 𝓜}
               → is-local f Y
               → is-equiv (postcomp-inj {f = f} X {Y})
Local-reflects {I = I} {A}{B}{f} X {Y} Y-loc
  = is-equiv←is-pathsplit ps where
  module Y {i} = is-equiv (Y-loc i)

  -- RHS (2.8) from RSS modalities
  lem : (g h : Free-inj f X → Y)
     (i : I)
     (g' : A i → Free-inj _ X)
     (q : g ∘ g' ~ h ∘ g') →
     postcomp Y (f i) (g ∘ Free-inj.ext g') ~
     postcomp Y (f i) (h ∘ Free-inj.ext g')
  lem g h i g' K =      g ◂ (Free-inj.is-ext g')
                     ~∙ K
                     ~∙ (h ◂ Free-inj.is-ext g' ~⁻¹)

  postwhisker : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                  (X : Type 𝓦) (f : A → B)
                → ∀ {g h : B → X} → (g ~ h)
                → g ∘ f ~ h ∘ f
  postwhisker X f = _▸ f

  amap : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
            {C : Type 𝓦}
           (f : A → B)
           (g h : B → C)
         → Arrow-map
              (ap (postcomp C f) {g} {h})
              (postwhisker C f {g} {h})
  amap _ _ _ .Arrow-map.top = happly
  amap _ _ _ .Arrow-map.bot = happly
  amap _ _ _ .Arrow-map.comm refl = refl

  amap-is-equiv : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                    {C : Type 𝓦}
                    {f : A → B}
                    {g h : B → C}
                  → is-Arrow-equiv (amap f g h)
  amap-is-equiv .fst = global-funext
  amap-is-equiv .snd = global-funext

  opaque
    Y▸-is-equiv : ∀ {i g h} → is-equiv (postwhisker Y (f i) {g} {h})
    Y▸-is-equiv {i} = is-equiv←Arrow-equiv {F = amap _ _ _}
                                   amap-is-equiv
                               (is-embedding←is-equiv (Y-loc i))


  module Y▸ {i g h} = is-equiv (Y▸-is-equiv {i} {g} {h})

  secAp : ∀ (g h : Free-inj f X → Y)
          → section (postwhisker Y Free-inj.inc {g} {h})
  secAp g h .fst H
    = Free-inj.ind (λ z → g z ＝ h z)
        H
        (λ f' (K : g ∘ f' ~ h ∘ f')
          → Y▸.bwd (lem g h _ f' K))
        λ f' (K : g ∘ f' ~ h ∘ f') a
          → IdP-func←Square
             (Free-inj.is-ext f' a)
             _
             (K a)
             (Square←brt＝l
               (ap g (Free-inj.is-ext f' a))
               {ap h (Free-inj.is-ext f' a)}
               {Y▸.bwd {g = g ∘ Free-inj.ext f'}
                       {h = h ∘ Free-inj.ext f'}
                       (lem g h _ f' K) (f _ a)}
               (sym (happly (Y▸.ε (lem g h _ f' K)) a)))
  secAp g h .snd K = refl

  ps : is-pathsplit (postcomp-inj X)
  -- The section for postcomp is easy
  ps .fst .fst g = Free-inj.ind
                     (λ _ → Y)
                     g
                     (λ _ → Y.bwd)
                     λ g' h a → tr-const (Free-inj.is-ext g' a)
                                ∙ happly (Y.ε h) a
  ps .fst .snd h = refl
  -- Proof for second part (section of ap) at page 2:34
  ps .snd g h = section←Arrow-equiv⁻¹ {F = amap _ _ _} amap-is-equiv (secAp g h)
}
%```

\subtree[stt-0065]{
\date{2025-06-21}
\title{Nullification is a [reflective subuniverse](stt-0041)}
\taxon{corollary}


%```agda
\agda{
Null∙-SubU
  : ∀ {𝓘 𝓤} {I : Type 𝓘}
      {A : I → Type 𝓤}
      (a∙ : ∀ i → A i)
    → SubU 𝓤 (𝓘 ⊔ 𝓤)
Null∙-SubU {A = A} A∙ .Subtype.family = is-null A
Null∙-SubU A∙ .Subtype.has-is-subtype = is-null-is-prop

Null∙-reflective
  : ∀ {𝓘 𝓤} {I : Type 𝓘}
      {A : I → Type 𝓤}
      (a∙ : ∀ i → A i)
    → is-reflective (Null∙-SubU a∙)
Null∙-reflective a .is-reflective.has-reflectors A .Reflector.○
  = Null∙ _ a A
Null∙-reflective a .is-reflective.has-reflectors A .Reflector.○∈S
  = Null∙-is-null a
Null∙-reflective a .is-reflective.has-reflectors A .Reflector.○-η
  = Free-inj.inc
Null∙-reflective a .is-reflective.has-reflectors A .Reflector.reflects
  cnull = Local-reflects _ (is-local←is-null cnull)
}
%```
}

\subtree[stt-006A]{
\date{2025-06-23}
\taxon{lemma}
\title{#{f} local maps are #{\nabla(f)} local}

%```agda
\agda{
is-local∇←is-local : ∀ {𝓤 𝓥 𝓦} {A : Type 𝓤} {B : Type 𝓥}
                 (f : A → B)
                 {X : Type 𝓦}
               → is-equiv (postcomp X f)
               → is-equiv (postcomp X (∇ f))
is-local∇←is-local f {X} eq = equiv←Coslice-equiv
                                (Δ←∇ f X)
                                Δ←∇-is-equiv
                                (diagonal-is-equiv eq)
}
%```
}

\subtree[stt-0066]{
\title{Localisation is a [reflective subuniverse](stt-0041)}

\p{Localisation at any family of maps forms a reflective subuniverse
which is not in general #{\Sigma}-closed.}

%```agda
\agda{
module _ {𝓘 𝓤 𝓦 : Level} {I : Type 𝓘}
         {A : I → Type 𝓤} {B : I → Type 𝓤}
         where
  open is-reflective
  open Reflector

  Local-SubU
    : (f : (i : I) → A i → B i)
      → SubU 𝓦 (𝓘 ⊔ 𝓤 ⊔ 𝓦)
  Local-SubU f = mk-subtype
                         {family = is-local f}
                         is-local-is-prop



  -- This is RSS lemma 2.7: Should extract to it's own tree probably

  Local-reflective
    : (f : (i : I) → A i → B i)
    → is-reflective (Local-SubU f)
  Local-reflective f .has-reflectors A .Reflector.○ = Loc f A
  Local-reflective f .has-reflectors A .○∈S = Loc-is-local
  Local-reflective f .has-reflectors A .○-η = Free-inj.inc
  Local-reflective f .has-reflectors A .reflects cloc
    = Local-reflects _ λ where
      (left i) → cloc i
      (right i) → is-local∇←is-local (f i) (cloc i)
}
%```
}
