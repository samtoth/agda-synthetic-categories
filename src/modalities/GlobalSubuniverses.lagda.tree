\date{2025-06-14}
\title{Global subuniverses}
\author{samueltoth}
\taxon{module}
\meta{module}{\startverb modalities.GlobalSubuniverses \stopverb}
\import{stt-macros}


\p{The developments in this module follow \citet{foundations.global-subuniverses}{agda-unimath}.}

%```agda
\agda{
module modalities.GlobalSubuniverses where

open import foundations.Prelude
open import modalities.Subuniverses
open import core.Postwhisker
open import core.PiSection
open import ergonomics.Extensionality
}
%```

\subtree[stt-007A]{
\title{Global subuniverses}

\p{A global subuniverse is a subuniverse for each #{\UU}
which is closed under equivalence. This second property
holds via univalence for a particular univalent universe
but doesn't follow automatically for equivalences between
types in different universes.}

% ```agda
\agda{
record GSU (Î± : Level â†’ Level) : TypeÏ‰ where
  constructor mk-GSU
  field
    S : âˆ€ {ğ“¤} â†’ SubU ğ“¤ (Î± ğ“¤)
    S-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
              â†’ A â‰ƒ B
              â†’ A âˆˆ S â†’ B âˆˆ S

SubUâ†global : âˆ€ {Î±} â†’ GSU Î± â†’  âˆ€ {ğ“¤} â†’ SubU ğ“¤ (Î± ğ“¤)
SubUâ†global (mk-GSU s _) = s

GSU-equiv : âˆ€ {Î± Î²} â†’ GSU Î± â†’ GSU Î² â†’ TypeÏ‰
GSU-equiv S K = âˆ€ {ğ“¤} â†’ Subtype-equiv (GSU.S S {ğ“¤}) (GSU.S K {ğ“¤})
}
%```
}

\subtree[stt-007B]{
\taxon{definition}
\title{Global reflectors}

\p{For a particular type #{A : \UU}, we say that #{(\circ A, \eta :
A \to \circ A)} is a global reflector for #{A} when postcomposition
by #{\eta} at modal types (of any universe) is an equivalence. This
equivalence gives us a recursion principal for #{\circ A}.}


%```agda
\agda{
record is-global-reflector {Î±} (GS : GSU Î±)
         {ğ“¤} (A : Type ğ“¤)
         (â—‹A : Type ğ“¤) (Î· : A â†’ â—‹A) : TypeÏ‰ where
  constructor mk-grfltor
  open GSU GS
  field
    â—‹âˆˆS : â—‹A âˆˆ S
    reflects : âˆ€ {ğ“¥} {Q : Type ğ“¥}
               â†’ Q âˆˆ S â†’ is-equiv (postcomp Q Î·)

  â—‹-rec : âˆ€ {ğ“¥} {Q : Type ğ“¥} â†’ Q âˆˆ S â†’ (A â†’ Q) â†’ (â—‹A â†’ Q)
  â—‹-rec cs = is-equiv.bwd (reflects cs)

  â—‹-rec-Î² : âˆ€ {ğ“¥} {Q : Type ğ“¥} (p : Q âˆˆ S) (f : A â†’ Q)
             â†’ â—‹-rec p f âˆ˜ Î· ~ f
  â—‹-rec-Î² p f a = happly (is-equiv.Îµ (reflects p) f) a

  module âˆˆSâ–¸Î· {ğ“¦} {C : Type ğ“¦} {g h} (CâˆˆS : C âˆˆ S)
    = is-equiv (postwhisker-is-equivâ†ap-compose {A = A} {g = g}{h}
                         (is-embeddingâ†is-equiv (reflects CâˆˆS)))

is-reflectorâ†global : âˆ€ {Î±} {GS : GSU Î±} {ğ“¤}
                        {A : Type ğ“¤} {â—‹A : Type ğ“¤} {Î· : A â†’ â—‹A}
                      â†’ is-global-reflector GS A â—‹A Î·
                      â†’ let open GSU GS in is-reflector S A â—‹A Î·
is-reflectorâ†global (mk-grfltor â—‹âˆˆS reflects)
  = mk-is-rfltor â—‹âˆˆS reflects

is-global-reflector-subtype-equiv
  : âˆ€ {Î± Î²} {S : GSU Î±} {K : GSU Î²}
      {ğ“¤} {A : Type ğ“¤} {â—‹A : Type ğ“¤}
      {Î· : A â†’ â—‹A}
    â†’ (GSU-equiv S K)
    â†’ is-global-reflector S A â—‹A Î·
    â†’ is-global-reflector K A â—‹A Î·
is-global-reflector-subtype-equiv {A = A} {â—‹A} {Î·} eq rfl = lem where
  open is-global-reflector rfl

  lem : is-global-reflector _ A â—‹A Î·
  lem .is-global-reflector.â—‹âˆˆS = eq _ .fst â—‹âˆˆS
  lem .is-global-reflector.reflects QK = reflects (eq _ .snd QK)
}
%```

\p{A global subuniverse is said to be reflective if we have all
reflectors.}

%```agda
\agda{
record is-globally-reflective {Î±} (GS : GSU Î±) : TypeÏ‰ where
  constructor mk-gReflectors
  open GSU GS
  field
    â—‹ : âˆ€ {ğ“¤} â†’ Type ğ“¤ â†’ Type ğ“¤
    Î· : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ â—‹ A
    has-is-reflector : âˆ€ {ğ“¤} {A : Type ğ“¤}
                       â†’ is-global-reflector GS A (â—‹ A) Î·

  module R {ğ“¤} {A} = is-global-reflector (has-is-reflector {ğ“¤} {A})
  open R public

  module â–¸Î· {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {g h}
    = is-equiv (postwhisker-is-equivâ†ap-compose {g = g}{h}
                 (is-embeddingâ†is-equiv
                   (reflects {A = B} (â—‹âˆˆS {ğ“¤}{A}))))

  reflector : âˆ€ {ğ“¤} (A : Type ğ“¤) â†’ Reflector S A
  reflector A = mk-rfltor (â—‹ A) Î·
                  (is-reflectorâ†global has-is-reflector)


is-reflectiveâ†global :  âˆ€ {Î±} {GS : GSU Î±} â†’ is-globally-reflective GS
                     â†’ âˆ€ {ğ“¤} â†’ is-reflective (SubUâ†global GS {ğ“¤})
is-reflectiveâ†global (mk-gReflectors â—‹ Î· has-is-reflector)
  = mk-reflective â—‹ Î· (is-reflectorâ†global has-is-reflector)


is-globally-reflective-subtype-equiv
  : âˆ€ {Î± Î²} {S : GSU Î±} {K : GSU Î²}
    â†’ GSU-equiv S K
    â†’ is-globally-reflective S
    â†’ is-globally-reflective K
is-globally-reflective-subtype-equiv {S = S} eq rfl
  = mk-gReflectors â—‹ Î·
     (is-global-reflector-subtype-equiv eq has-is-reflector)
  where open is-globally-reflective rfl
}
%```
}


\subtree[stt-007C]{
\taxon{definition}
\title{Sigma closed global reflective subuniverses}


%```agda
\agda{
is-globally-Î£-closed : âˆ€ {Î±} (GS : GSU Î±) â†’ TypeÏ‰
is-globally-Î£-closed (mk-GSU S _)
  = âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥}
    â†’ A âˆˆ S â†’ (âˆ€ a â†’ B a âˆˆ S)
    â†’ Î£ A B âˆˆ S

is-Î£-closedâ†globally : âˆ€ {Î±} (GS : GSU Î±)
                       â†’ is-globally-Î£-closed GS
                       â†’ âˆ€ {ğ“¤}
                       â†’ is-Î£-closed (SubUâ†global GS {ğ“¤})
is-Î£-closedâ†globally GS sc = sc

}
%```
}
\subtree[stt-007D]{
\taxon{theorem}
\title{Induction for sigma closed [GRSU](stt-007C)}

\p{When a global reflective subuniverse is closed under sigma types we
can extend the recursion principal in \ref{stt-007B} to an induction
prinicipal.}

\proof{ \p{Because #{S} is closed under #{\Sigma} types, we can use
the universal property of the reflector at #{A} to define a map
#{\bar{f} : \bigcirc A \to \Sigma_{(x : \bigcirc A)} \bigcirc P(x)}
just by it's action on #{\eta(x)} for #{x : A}. This map is given by
#{\eta(x) \mapsto (\eta(x), f(x))}.}

\p{To show that #{\bar{f}} is indeed a section, we first note that the
universal property of the reflector gives us #{\pi \bar{f} \eta \sim
\eta}.  Then because postcomposition by #{\eta} at a modal type is an
equivalence, [so is postwhiskering](stt-006I) by #{\eta} (assuming
funext), thus we can apply the inverse map to get a homotopy #{\pi
\bar{f} \sim \id}.}  }


%```agda
\agda{
module GRSUInduction {Î±} {GS : GSU Î±}
        (Sref : is-globally-reflective GS)
        (SÎ£ : is-globally-Î£-closed GS) where
  open GSU GS
  open is-globally-reflective Sref

  ind : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥} (PâˆˆS : âˆ€ a â†’ P a âˆˆ S)
        â†’ (Î  A (P âˆ˜ Î·)) â†’ Î  (â—‹ A) P
  ind {A = A} {P} ps f = Î â†section (f' , â–¸Î·.bwd secÎ·) module ind where
    f'' : A â†’ Î£ (â—‹ A) P
    f'' a = (Î· a , f a)

    f' : â—‹ A â†’ Î£ (â—‹ A) P
    f' = â—‹-rec (SÎ£ â—‹âˆˆS ps) f''

    secÎ· : fst âˆ˜ f' âˆ˜ Î· ~ Î·
    secÎ· = fst â—‚ â—‹-rec-Î² _ _

  ind-Î² : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥}
            (PâˆˆS : âˆ€ a â†’ P a âˆˆ S)
          â†’ (f : Î  A (P âˆ˜ Î·)) â†’ ind PâˆˆS f âˆ˜ Î· ~ f
  ind-Î² {A = A} {P} PS f a
    = tr P (â–¸Î·.bwd secÎ· (Î· a)) (snd (f' (Î· a)))
        ï¼âŸ¨ ap (Î» p â†’ tr P p (snd (f' (Î· a)))) (happly (â–¸Î·.Îµ secÎ·) a) âŸ©
      tr P (ap fst (â—‹-rec-Î² _ f'' a)) (snd (f' (Î· a)))
        ï¼âŸ¨ ap (Î» p â†’ coe p (snd (f' (Î· a)))) (sym (ap-âˆ˜ P fst _)) âŸ©
      tr (P âˆ˜ fst) (â—‹-rec-Î² _ f'' a) (snd (f' (Î· a)))
        ï¼âŸ¨ apáµˆ snd (â—‹-rec-Î² _ f'' a) âŸ©
      snd (f'' a)
        ï¼âŸ¨âŸ©
      f a âˆ       where open ind PS f


  ind-qiso : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥}
               (PS : âˆ€ a â†’ P a âˆˆ S)
             â†’ quasi-iso {A = (a : A) â†’ P (Î· a)} {B = (a : â—‹ A) â†’ P a}
                         (ind PS)
  ind-qiso PS .fst = _âˆ˜ Î·
  ind-qiso PS .snd .fst f = ext! (ind-Î² _ f)
  ind-qiso {A = A} {P} PS .snd .snd f = ext!
    (ind (Î» a â†’ is-modal-ï¼ (is-reflectiveâ†global Sref) (PS a))
         (ind-Î² _ (f âˆ˜ Î·)))

  ind-is-equiv : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {P : â—‹ A â†’ Type ğ“¥}
                   (PS : âˆ€ a â†’ P a âˆˆ S)
                 â†’ is-equiv {A = (a : A) â†’ P (Î· a)}
                            {B = (a : â—‹ A) â†’ P a}
                            (ind PS)
  ind-is-equiv = is-equivâ†qiso âˆ˜ ind-qiso
}
%```
}
