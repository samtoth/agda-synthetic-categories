\date{2025-02-20}
\title{Function types}
\taxon{Module}
\import{stt-macros}

% ```agda
\agda{
module Foundations.Functions where

open import Foundations.Universes
open import Foundations.Sigma
open import Foundations.Identity
open import Foundations.Singleton
}
% ```


% ```agda
\agda{
Î  : âˆ€ {ğ“¤ ğ“¥} (A : Type ğ“¤) (B : A â†’ Type ğ“¥) â†’ Type (ğ“¤ âŠ” ğ“¥)
Î  A B = (a : A) â†’ B a

id : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â†’ A
id a = a
{-# INLINE id #-}

ev : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} â†’ (a : A) â†’ Î  A B â†’ B a
ev a f = f a

const : âˆ€ {ğ“¤ ğ“¥} (A : Type ğ“¤) (B : Type ğ“¥) â†’ A â†’ B â†’ A
const _ _ a _ = a

infixr 40 _âˆ˜_
_âˆ˜_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {C : {a : A} â†’ B a â†’ Type ğ“¦}
      â†’ (f : {a : A} â†’ (b : B a) â†’ C b) â†’ (g : (a : A) â†’ B a) â†’ (a : A) â†’ C (g a)
f âˆ˜ g = Î» a â†’ f (g a)

happly : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a}
       â†’ f ï¼ g â†’ (a : A) â†’ f a ï¼ g a
happly refl a = refl

happlyáµ¢ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : {a : A} â†’ B a}
        â†’ Id ({a : A} â†’ B a) f g â†’ {a : A} â†’ f {a} ï¼ g {a}
happlyáµ¢ refl = refl

happly-sym : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : A â†’ Type ğ“¥} {f g : (a : A) â†’ B a}
             â†’ (p : f ï¼ g) â†’ (a : A) â†’ happly (sym p) ï¼ sym âˆ˜ happly p
happly-sym refl a = refl

}
% ```

\subtree[stt-003Y]{
\taxon{Definition}
\title{Explicit function composition}
\p{It is convenient to define post and pre composition functions
   that take the non-fixed type argument explicitly}

% TODO: Should pre/post comp switch????

% ```agda
\agda{
postcomp : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
             {ğ“¦} (C : Type ğ“¦) â†’ (f : A â†’ B)
           â†’ (B â†’ C) â†’ (A â†’ C)
postcomp C f = _âˆ˜ f

precomp : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
            {ğ“¦} (C : Type ğ“¦) â†’ (f : A â†’ B)
          â†’ (C â†’ A) â†’ (C â†’ B)
precomp C f = f âˆ˜_
}
% ```
}

\subtree[stt-0071]{
\title{Functoriality of function composition}
\taxon{Theorem}
\date{2025-07-13}
%```agda
\agda{
postcomp-âˆ˜ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
               {ğ“¦} (X : Type ğ“¦) (f : A â†’ B)
               {ğ“œ} {Q : Type ğ“œ} (g : Q â†’ A)
             â†’ âˆ€ h â†’ postcomp X (f âˆ˜ g) h ï¼ (postcomp X g âˆ˜ postcomp X f) h
postcomp-âˆ˜ X f g h = refl

precomp-âˆ˜ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
               {ğ“¦} (X : Type ğ“¦) (f : A â†’ B)
               {ğ“œ} {Q : Type ğ“œ} (g : Q â†’ A)
             â†’ âˆ€ h â†’ precomp X (f âˆ˜ g) h ï¼ (precomp X f âˆ˜ precomp X g) h
precomp-âˆ˜ X f g h = refl
}
%```
}


\subtree[stt-004M]{
\taxon{Definition}
\title{Dependent function composition}
\p{We can define a dependent version of [function postcomposition](stt-003Y),
that takes a family of types.}

% ```agda
\agda{
postcomp-Î  : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
             {ğ“¦} (C : B â†’ Type ğ“¦) â†’ (f : A â†’ B)
           â†’ (Î  B C) â†’ (Î  A (C âˆ˜ f))
postcomp-Î  C f = _âˆ˜ f

postcomp-Î -âˆ˜
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
      {ğ“œ} (X : C â†’ Type ğ“œ) (f : B â†’ C) (g : A â†’ B)
    â†’ âˆ€ h â†’ postcomp-Î  X (f âˆ˜ g) h ï¼ (postcomp-Î  (X âˆ˜ f) g âˆ˜ postcomp-Î  X f) h
postcomp-Î -âˆ˜ X f g h = refl

precomp-Î 
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
      (f : (i : I) â†’ A i â†’ B i)
    â†’ Î  I A â†’ Î  I B
precomp-Î  f g i = f i (g i)

precomp-Î áµ¢
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜} {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
      (f : {i : I} â†’ A i â†’ B i)
    â†’ (âˆ€ {i} â†’ A i) â†’ (âˆ€ {i} â†’ B i)
precomp-Î áµ¢ f x = f x
}
% ```
}

\subtree[stt-001F]{
\title{Functions are functors}

% ```agda
\agda{
ap-refl : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x : A} â†’ (f : A â†’ B) â†’ ap f (refl {a = x}) ï¼ refl
ap-refl f = refl


ap-sym : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤}{B : Type ğ“¥}  (f : A â†’ B) â†’ {x y : A} â†’ (p : x ï¼ y) â†’ ap f (sym p) ï¼ sym (ap f p)
ap-sym f refl = refl

ap-âˆ™ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y z : A} â†’ (f : A â†’ B) â†’ (p : x ï¼ y) â†’ (q : y ï¼ z) â†’ ap f (p âˆ™ q) ï¼ ap f p âˆ™ ap f q
ap-âˆ™ f refl p = refl

ap-âˆ™âˆ™ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y z w : A} â†’ (f : A â†’ B)
        â†’ (p : x ï¼ y) â†’ (q : y ï¼ z) â†’ (r : z ï¼ w)
        â†’ ap f (p âˆ™ q âˆ™ r) ï¼ ap f p âˆ™ ap f q âˆ™ ap f r
ap-âˆ™âˆ™ f refl q r = ap-âˆ™ f q r

ap-const : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y : A} {b}
           â†’ (p : x ï¼ y) â†’ ap (Î» _ â†’ b) p ï¼ refl {_}{B}
ap-const refl = refl

tr-const : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {x y : A}
           â†’ (p : x ï¼ y)
           â†’ {b : B}
           â†’ tr (Î» _ â†’ B) p b ï¼ b
tr-const refl = refl


ap-id : âˆ€ {ğ“¤} {A : Type ğ“¤} {x y : A} (p : x ï¼ y) â†’ ap id p ï¼ p
ap-id refl = refl

ap-âˆ˜ : âˆ€ {ğ“¤ ğ“¥ ğ“¦}  {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {x y : A}
          (f : B â†’ C) (g : A â†’ B) (p : x ï¼ y) â†’ ap (f âˆ˜ g) p ï¼ ap f (ap g p)
ap-âˆ˜ f g refl = refl

ap-âˆ˜âˆ˜ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}  {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {D : Type ğ“œ}
         {x y : A}
         (f : C â†’ D) (g : B â†’ C) (h : A â†’ B) (p : x ï¼ y)
       â†’ ap (f âˆ˜ g âˆ˜ h) p ï¼ ap f (ap g (ap h p))
ap-âˆ˜âˆ˜ f g h refl = refl

apâ‚‚ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {x y : A} {u v : B}
      â†’ (f : A â†’ B â†’ C) â†’ x ï¼ y â†’ u ï¼ v â†’ f x u ï¼ f y v
apâ‚‚ f refl refl = refl


apâ‚ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“›} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {D : Type ğ“›}
        {x y : A} {u v : B} {a b : C}
      â†’ (f : A â†’ B â†’ C â†’ D)
      â†’ x ï¼ y â†’ u ï¼ v â†’ a ï¼ b
      â†’ f x u a ï¼ f y v b
apâ‚ƒ f refl refl refl = refl

trâˆ˜ : âˆ€ {ğ“¤ ğ“¥ ğ“¦}  {A : Type ğ“¤} (P : A â†’ Type ğ“¥)
        {C : Type ğ“¦} (f : C â†’ A)
        {x y} (p : x ï¼ y) {b : P (f x)}
      â†’ tr (P âˆ˜ f) p b ï¼ tr P (ap f p) b
trâˆ˜ P f refl = refl
}
% ```

}

\subtree[stt-000M]{
\taxon{Definition}
\title{Fibres}

\p{Given a function #{f : A \to B}, we define the fibre of #{f} at #{b : B}, notated #{\fibre{f}{a}} to be the type
#{\Sigma_{a : A}{f(a) = b}}. }

\p{Note that this is subtly different to the preimage, as we can show that #{\Sigma_{(b : B)} \fibre{f}{b}} is equivalent to #{A} itself.}

% ```agda
\agda{

fibre : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ B â†’ Type (ğ“¤ âŠ” ğ“¥)
fibre f b = Î£ _ Î» a â†’ f a ï¼ b

total-fibre : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
total-fibre f = Î£ _ (fibre f)
}
% ```
}

\p{The fibre type gives us a useful tool for talking about properties of maps. Generally if we have a property of types for example being #{n}-connected, we reuse the same terminology on maps to mean all fibres of the map have the corresponding property.}


\subtree[stt-001G]{
\taxon{Definition}
\title{Propositional maps}

\p{We call a map propositional if the fibres are all sub-singletons. We will learn later that this is equivalent to the property of a map being an embedding.
This notion is a generalisation of injective set functions, infact if we - for a moment - imagine fibre to mean preimage, then a function of sets is injecte if each preimage is either empty or has a unique inhabitant.}

% ```agda
\agda{
is-prop-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-prop-map f = âˆ€ b â†’ is-prop (fibre f b)
}
% ```
}


\subtree[stt-001H]{
\taxon{Definition}
\title{Contractible maps}

\p{A map is said to be contractible if each of its fibres is a singleton (is contractible). We will see later that this is one of many notions of an equivalence of maps.}

\agda{
is-contr-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-contr-map f = âˆ€ b â†’ is-singleton (fibre f b)
}
% ```
}


\subtree[stt-001I]{
\taxon{Theorem}
\title{Contractible maps are propositional maps}

% ```agda
\agda{
is-prop-mapâ†is-contr-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
                         â†’ is-contr-map f â†’ is-prop-map f
is-prop-mapâ†is-contr-map ctr b = is-propâ†is-single (ctr b)
}
% ```
}

\subtree[stt-007O]{
\title{Logical equivalence}
\taxon{Definition}

\p{Given types #{P} and #{Q}, we say they are logically
equivalent when there are functions #{P \to Q} and #{Q \to P}.
We write #{P \iff Q} for the type of pairs #{(f : P \to Q,g : Q \to P)}.}

\remark{
Logical equivalence is also known as bi-implication as well as just equivalence.
We avoid bi-implication, but use equivalence when it is understood that the types
involved are [propositions](stt-0009).
}

%```agda
\agda{
infixl 29 _âˆ™â‡”_

_â‡”_ : âˆ€ {ğ“¤ ğ“¥} â†’ Type ğ“¤ â†’ Type ğ“¥ â†’ Type (ğ“¤ âŠ” ğ“¥)
P â‡” Q = (P â†’ Q) Ã— (Q â†’ P)

_âˆ™â‡”_ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
       â†’ A â‡” B â†’ B â‡” C â†’ A â‡” C
p âˆ™â‡” q = (q .fst âˆ˜ p .fst , p .snd âˆ˜ q .snd)

_â‡”â»Â¹ : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A â‡” B â†’ B â‡” A
(f , g) â‡”â»Â¹ = (g , f)

}
%```
}
