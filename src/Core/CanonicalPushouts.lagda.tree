\date{2025-04-15}
\title{Properties of the canonical pushouts}
\author{samueltoth}
\taxon{Module}

\import{stt-macros}

% ```agda
\agda{
module Core.CanonicalPushouts where

open import Foundations.Prelude
open import ufAxioms
open import Ergonomics.Extensionality
open import Ergonomics.Representation
}
% ```


\subtree[stt-002L]{
\taxon{Theorem}
\title{Canonical pushouts are pushouts}

% ```agda
\agda{
Pushout-is-pushoutÏ‰ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                       {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                     â†’ is-pushoutÏ‰ (mk-span _ f g) pushout
Pushout-is-pushoutÏ‰ {f = f} {g} = is-equivâ†qiso iso where
  iso : quasi-iso (cocone-map (mk-span _ f g) pushout)
  iso .fst = pushout-rec
  iso .snd .fst f = ext! (pushout-ind _ Î» where
    .CoconeD.p _ â†’ refl
    .CoconeD.q _ â†’ refl
    .CoconeD.filler a â†’ IdP-funcâ†Square (glue a) refl refl
                         (Square-degen-hor _ _ (pushout-rec-apÎ² a)))
  iso .snd .snd (mk-cocone p q filler)
    = ap (mk-cocone p q) (ext! pushout-rec-apÎ²)


pushout-rec-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                       {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                       {ğ“ } {Q : Type ğ“ }
                      â†’ is-equiv (pushout-rec {f = f} {g} {Q = Q})
pushout-rec-is-equiv {Q = Q} = is-equivâ»Â¹ (Pushout-is-pushoutÏ‰)

pushout-rec-unique
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
      {ğ“ } {Q : Type ğ“ }
      (C : Cocone (mk-span _ f g) Q)
      (F' : Pushout f g â†’ Q)
    â†’ let open Cocone C
      in (H : F' âˆ˜ Î¹â‚ ~ p)
      â†’  (K : F' âˆ˜ Î¹â‚‚ ~ q)
      â†’  (M : F' â—‚ glue ~âˆ™ K â–¸ g ~ H â–¸ f ~âˆ™ filler)
      â†’ F' ~ pushout-rec C
pushout-rec-unique {f = f} CC F' H K M
  = pushout-ind _
       (mk-coconeD H K
       Î» a â†’ IdP-funcâ†Square (glue a) _ _
               (mk-square
               (M a
               âˆ™ ap (H (f a) âˆ™_) (sym (pushout-rec-apÎ² a)))))

Pushout-UPâ‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                {ğ“ } {Q : Type ğ“ }
                â†’ (Pushout f g â†’ Q) â‰ƒ Cocone (mk-span A f g) Q
Pushout-UPâ‰ƒ = mkâ‰ƒ _ (is-equivâ»Â¹ pushout-rec-is-equiv)
}
% ```
}

\subtree[stt-008E]{
\title{Canonical pushouts satisfy the dependent universal property}
\taxon{Theorem}

%```agda
\agda{
Pushout-is-pushoutÏ‰áµˆ : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                         {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                       â†’ is-pushoutÏ‰áµˆ (mk-span A f g) pushout
Pushout-is-pushoutÏ‰áµˆ {f = f} {g} = is-equivâ†qiso iso where
  iso : quasi-iso (coconeáµˆ-map _ pushout)
  iso .fst = pushout-ind _
  iso .snd .fst h = funextâ†’ (pushout-ind _
    (mk-coconeD
      ~refl
      ~refl
      Î» a â†’ IdP-Î â†Square (glue a) (mk-square (âˆ™-reflr _ âˆ™ pushout-ind-apÎ² _))))
  iso .snd .snd (mk-coconeD p q filler)
    = ap (mk-coconeD p q) (funextâ†’ pushout-ind-apÎ²)

pushout-ind-is-equiv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
                         {C : Type ğ“¦} {f : A â†’ B} {g : A â†’ C}
                         {ğ“ } {Q : Pushout f g â†’ Type ğ“ }
                       â†’ is-equiv (pushout-ind {f = f} {g} Q)
pushout-ind-is-equiv = is-equivâ»Â¹ Pushout-is-pushoutÏ‰áµˆ
}
%```
}


\subtree[stt-004G]{
\taxon{Definition}
\date{2025-05-17}
\title{The cogap map}

\p{
Analogously to pullbacks, we sometimes call pushout-rec the cogap map.
Given a cocone #{C} under a span #{S}, we can define a the
cogap-map from the pushout of #{S} and the apex of #{C}.
}

% ```agda
\agda{
cogap : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
        {f : A â†’ B} {g : A â†’ C}
        {ğ“œ} {D : Type ğ“œ}
      â†’ Cocone (mk-span A f g) D
      â†’ Pushout f g â†’ D
cogap = pushout-rec
}
% ```
}

\subtree[stt-007X]{
\date{2025-07-29}
\title{Pushouts via the cogap map}
\taxon{Theorem}

\p{A cocone #{D} over #{B \xleftarrow{f} A \xrightarrow{g} C}
is a pushout iff the cogap map #{B +^A C \to D} is an equivalence.}

\proof{
\p{We would like to show for any #{Q}, that the cogap map i
construct the following triangle:}

\quiver{
\begin{tikzcd}
        {D \to Q} && {B +^A C \to Q} \\
	\\
	& {\textrm{Cocone}_S(Q)}
	\arrow["{\textrm{cogap}(D) \circ -}", from=1-1, to=1-3]
	\arrow["{\textrm{cocone-map}(D)}"'{pos=0.4}, from=1-1, to=3-2]
	\arrow["\sim", from=1-3, to=3-2]
\end{tikzcd}
}
}


%```agda
\agda{

module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         {f : A â†’ B} {g : A â†’ C} {ğ“œ} {D : Type ğ“œ}
         (CD : Cocone (mk-span A f g) D) where
  open Cocone CD

  private
    H : âˆ€ {ğ“ } {Q : Type ğ“ }
        â†’ cocone-map _ CD ~ cocone-map _ pushout âˆ˜ postcomp Q (cogap CD)
    H f = ap (mk-cocone (f âˆ˜ p) (f âˆ˜ q)) (funextâ†’ (Î» a
      â†’ sym (  ap-âˆ˜ f (pushout-rec CD) (glue a)
             âˆ™ ap (ap f) (pushout-rec-apÎ² a))))

  is-pushoutâ†cogap : is-equiv (cogap CD) â†’ is-pushoutÏ‰ _ CD
  is-pushoutâ†cogap cogap-eq {_} {Q}
    = is-equiv~âˆ˜ H
                 (Pushout-is-pushoutÏ‰ {Q = Q})
                 (postcomp-equiv cogap-eq)

  cogap-is-equivâ†is-pushout
    : is-pushoutÏ‰ _ CD â†’ is-equiv (cogap CD)
  cogap-is-equivâ†is-pushout po = is-equivâ†postcomp _
    Î» {_} {Q} â†’ 3-for-2~ H (Pushout-is-pushoutÏ‰ {Q = Q}) po
}
%```
}


\subtree[stt-007Y]{
\date{2025-07-29}
\title{Pushouts from pullbacks}
\taxon{Theorem}
\p{A cocone #{D} over a span #{C \xleftarrow{f} A \xrightarrow{g} B}
is a pushout iff for all types #{Q}, the cone #{Q^A} over the cospan
#{Q^B \xrightarrow{f} Q^D \xleftarrow{g} Q^C} is a pullback.}

\proof{

\p{There is an equivalence between cocones at #{Q} over a span and
the pullback #{Q^X \times_{Q^A} Q^B}. We then construct the following
triangle which, via the [3 for 2](stt-003E) property, completes the
proof.}

\quiver{
\begin{tikzcd}
	& {Q^Y} \\
	{\rm{Cocone}} && {Q^X\times_{Q^A}Q^B}
	\arrow["{\rm{cocone-map}}"', from=1-2, to=2-1]
	\arrow["{\rm{gap}}", from=1-2, to=2-3]
	\arrow["\sim"', from=2-1, to=2-3]
\end{tikzcd}
}
}

%```agda
\agda{
unquoteDecl cocone-reprâ‰… cocone-reprâ‰ƒ
  = make-record-repr cocone-reprâ‰… cocone-reprâ‰ƒ (quote Cocone)

unquoteDecl coconeD-reprâ‰… coconeD-reprâ‰ƒ
  = make-record-repr coconeD-reprâ‰… coconeD-reprâ‰ƒ (quote CoconeD)

unquoteDecl Span-reprâ‰… Span-reprâ‰ƒ
  = make-record-repr Span-reprâ‰… Span-reprâ‰ƒ (quote Span)

postcomp-coconeâ‰ƒpb
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
      {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {f : B â†’ A}
      {g : B â†’ C} {D : Type ğ“œ}
    â†’ Cocone (mk-span _ f g) D â‰ƒ Pullback (postcomp D g) (postcomp D f)
postcomp-coconeâ‰ƒpb {f = f} {g} {D}
  = Cocone (mk-span _ f g) D                â‰ƒâŸ¨ cocone-reprâ‰ƒ âŸ©
    (Î£[ f' âˆ¶ (_ â†’ D)] Î£[ g' âˆ¶ (_ â†’ D)] (f' âˆ˜ f ~ g' âˆ˜ g))
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-ap-â‰ƒ (Î» e â†’ precomp-Î -â‰ƒ (Î» _ â†’ symâ‰ƒ) âˆ™â‰ƒ funextâ‰ƒ eâ»Â¹))âŸ©
    (Î£[ f' âˆ¶ (_ â†’ D)] Î£[ g' âˆ¶ (_ â†’ D)] (g' âˆ˜ g ï¼ f' âˆ˜ f))
      â‰ƒâŸ¨ Î£-comm âŸ©
    Pullback (postcomp D g) (postcomp D f) â‰ƒâˆ

postcomp-cospan : âˆ€ {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                    {ğ“ } (Q : Type ğ“ )
                  â†’ Cospan (ğ“¤ âŠ” ğ“ ) (ğ“¦ âŠ” ğ“ ) (ğ“¥ âŠ” ğ“ )
postcomp-cospan (mk-span Centre l r) Q
  = mk-cospan (Centre â†’ Q) (postcomp Q r) (postcomp Q l)

postcomp-cone : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
                  {ğ“œ} {D : Type ğ“œ}
                  (C : Cocone S D)
                  {ğ“ } (Q : Type ğ“ )
                â†’ Cone (postcomp-cospan S Q) (D â†’ Q)
postcomp-cone (mk-cocone p q filler) Q
  = mk-cone  (postcomp Q q) (postcomp Q p) Î»
    f â†’ (funextâ†’ (f â—‚ sym âˆ˜ filler))

is-pushoutâ†postcomp-pullback
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {D : Type ğ“œ}
      (C : Cocone S D)
    â†’ (âˆ€ {ğ“ }(Q : Type ğ“ ) â†’ is-pullbackÏ‰ (postcomp-cospan S Q)
                                  (postcomp-cone C Q))
    â†’ is-pushoutÏ‰ S C
is-pushoutâ†postcomp-pullback C pb {Q = Q}
  = 3-for-2~ H
             (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv)
             (gap-is-equivâ†is-pullback (postcomp-cone C Q) (pb Q))
  module pushout-postcomp where
    H : gap (postcomp-cone C Q) ~
         _â‰ƒ_.fwd postcomp-coconeâ‰ƒpb âˆ˜ cocone-map _ C
    H f = ap (Î» p â†’ _ , _ , p)
          (ap funextâ†’ (funextâ†’ (Î» a â†’ ap-sym f (Cocone.filler C a))))


postcomp-pullbackâ†is-pushout
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {D : Type ğ“œ}
      (C : Cocone S D)
    â†’ is-pushoutÏ‰ S C
    â†’ âˆ€ {ğ“ }(Q : Type ğ“ )
    â†’ is-pullbackÏ‰ (postcomp-cospan S Q)
                   (postcomp-cone C Q)
postcomp-pullbackâ†is-pushout C pb Q
  = is-pullbackâ†gap (postcomp-cone C Q)
      (is-equiv~âˆ˜ H (postcomp-coconeâ‰ƒpb ._â‰ƒ_.has-is-eqv) pb) where
    H : gap (postcomp-cone C Q) ~
         _â‰ƒ_.fwd postcomp-coconeâ‰ƒpb âˆ˜ cocone-map _ C
    H f = ap (Î» p â†’ _ , _ , p)
          (ap funextâ†’ (funextâ†’ (Î» a â†’ ap-sym f (Cocone.filler C a))))
}
%```
}


\subtree[stt-0082]{
\date{2025-07-30}
\title{Pushout is commutative}
\taxon{Theorem}

\p{There is an equivalence #{A \times_C B \simeq B \times_C A}.}


%```agda
\agda{

pushout-flip : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                 {f : B â†’ A} {g : B â†’ C}
               â†’ Pushout f g â†’ Pushout g f
pushout-flip = pushout-rec (mk-cocone Î¹â‚‚ Î¹â‚ (sym âˆ˜ glue))

pushout-flip-inv : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                     {f : B â†’ A} {g : B â†’ C}
                   â†’ pushout-flip {f = f} {g} âˆ˜ pushout-flip ~ id
pushout-flip-inv = pushout-ind _ (mk-coconeD ~refl ~refl Î»
                 b â†’ IdP-funcâ†Square (glue b) _ _
                       (mk-square
                         (âˆ™-reflr _
                         âˆ™ ap-âˆ˜ pushout-flip pushout-flip (glue b)
                         âˆ™ ap (ap pushout-flip) (pushout-rec-apÎ² b)
                         âˆ™ ap-sym _ (glue b)
                         âˆ™ ap sym (pushout-rec-apÎ² b)
                         âˆ™ sym-sym
                         âˆ™ sym (ap-id (glue b)))))

pushout-comm : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
                 {f : B â†’ A} {g : B â†’ C}
               â†’ Pushout f g â‰ƒ Pushout g f
pushout-comm {f = f} {g = g} = mkâ‰ƒ _ cogap-is-equiv where
  po-cogap : Pushout f g â†’ Pushout g f
  po-cogap = pushout-flip

  cogap-is-equiv : is-equiv po-cogap
  cogap-is-equiv = is-equivâ†qiso ( pushout-flip
                                 , pushout-flip-inv
                                 , pushout-flip-inv)
}
%```
}

