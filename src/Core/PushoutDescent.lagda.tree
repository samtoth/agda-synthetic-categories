\date{2025-08-01}
\title{Descent for pushouts}
\taxon{module}
\meta{module}{Core.PushoutDescent}
\author{samueltoth}
\import{stt-macros}

%```agda
\agda{
module Core.PushoutDescent where

open import Foundations.Prelude
open import Ergonomics.Extensionality
open import ufAxioms
open import Core.CanonicalPushouts
open import Core.Arrow
open import Core.ArrowEquiv
open import Ergonomics.Representation
}
%```

\subtree[stt-008D]{
\title{Flattening lemma for pushouts}
\taxon{theorem}

\p{The flattening theorem essentially states that for a family #{P}
over a pushout #{A \times_C B}, the total type #{\tilde{P}} is
equivalent to the pushout of total types: #{\Sigma_A P
+_{\Sigma_C P} \Sigma_B P}.}

\proof{
\p{Given a span #{S : A \leftarrow B \rightarrow C} and a family #{P}
over the pushout of #{S}, we can define the total span #{\Sigma_{S}P}.
We first note that for some arbitrary type #{Q}, dependent cones over
#{S} at #{p \mapsto P(p) \to Q} are equivalent to cones over
#{\Sigma_{S} P} at #{Q} - this is analogous to [currying
functions](Foundations.PiProperties).  We then construct the following
square:
}

\quiver{
\begin{tikzcd}
	{\Pi_{p : A+^C B} Q^{P(p)}} && {Q^{\Sigma_{p : A+^CB} P(p)}} \\
	\\
	{\rm{cocone}^d(S,p \mapsto Q^{P(p)})} && {\rm{cocone}(\Sigma_S P,Q)}
	\arrow["{\rm{curry}}", from=1-1, to=1-3]
	\arrow["{\rm{cocone}^d}"', from=1-1, to=3-1]
	\arrow["{\rm{cocone}}", from=1-3, to=3-3]
	\arrow["{\rm{curry}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{Since, currying (functions or cocones) and the dependent cocone
map are equivalences, then so is the cocone map on the right.}

}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦}
         (f : A â†’ B) (g : A â†’ C) where
  total-span : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
               â†’ Span _ _ _
  total-span P .Span.Centre = Î£ A (P âˆ˜ Î¹â‚‚ âˆ˜ g)
  total-span P .Span.Left = Î£ B (P âˆ˜ Î¹â‚)
  total-span P .Span.left (a , b) = (f a , tr P (sym (glue a)) b)
  total-span P .Span.Right = Î£ C (P âˆ˜ Î¹â‚‚)
  total-span P .Span.right = total-map-fst g

  total-cocone : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                 â†’ Cocone (total-span P) (Î£ (Pushout f g) P)
  total-cocone P .Cocone.p = total-map-fst Î¹â‚
  total-cocone P .Cocone.q = total-map-fst Î¹â‚‚
  total-cocone P .Cocone.filler (a , b)
    = Î£-pathâ†’ ( glue a , trâˆ™tr-sym' (glue a) b)

  total-is-pushout : âˆ€ {ğ“œ} (P : Pushout f g â†’ Type ğ“œ)
                     â†’ is-pushoutÏ‰ (total-span P) (total-cocone P)
  total-is-pushout P {ğ“ } {Q} = eqv where
    module S' = Span (total-span P)

    Q' : Pushout f g â†’ Type _
    Q' x = P x â†’ Q

    lem2 : âˆ€ {a b} (p : a ï¼ b) {x} {f : P a â†’ Q}
           â†’ (tr Q' p f) x ï¼ f (tr P (sym p) x)
    lem2 refl = refl

    curry-cocone
      : Cocone (total-span P) Q â†’ CoconeD _ pushout Q'
    curry-cocone (mk-cocone p q filler) = mk-coconeD (curry p) (curry q) Î»
      a â†’ funextâ†’ Î» b â†’ lem2 (glue a) âˆ™ curry filler a b

    H : Arrow-map (cocone-map _ (total-cocone P) {Q})
                  (coconeáµˆ-map (mk-span _ f g) pushout {Q'})
    H .Arrow-map.top = curry
    H .Arrow-map.bot = curry-cocone
    H .Arrow-map.comm h
      = ap (mk-coconeD (Î» a b â†’ h (Î¹â‚ a , b)) (Î» a b â†’ h (Î¹â‚‚ a , b)))
           (funextâ†’ Î» a â†’ J {a = Î¹â‚ (f a)} (Î» z G â†’
                 funextâ†’ (Î» b â†’ lem2 G âˆ™ ap h (Î£-pathâ†’ (G , trâˆ™tr-sym' G b)))
               ï¼ apáµˆ (curry h) G)
           funext-refl
           {Î¹â‚‚ (g a)} (glue a))

    curry-cocone-is-equiv : quasi-iso curry-cocone
    curry-cocone-is-equiv .fst (mk-coconeD p q filler)
      = mk-cocone (uncurry p) (uncurry q)
          Î» where (a , b) â†’ sym (lem2 (glue a)) âˆ™ happly (filler a) b
    curry-cocone-is-equiv .snd .fst (mk-cocone p q filler)
      = Cocone-pathâ†’ _  _ (funextâ†’ ~refl) (funextâ†’ ~refl)
          Î» a â†’ âˆ™-reflr _ âˆ™ sym'âˆ™ (lem2 (glue (fst a))) (filler a)
    curry-cocone-is-equiv .snd .snd (mk-coconeD p q filler)
      = ap (mk-coconeD p q) (funextâ†’ Î»
         a â†’   ap funextâ†’ (funextâ†’ (Î» b â†’ symâˆ™ (lem2 (glue a))
                                            (happly (filler a) b)))
             âˆ™ _â‰ƒ_.Î· funextâ‰ƒ (filler a))

    arr-eq : is-Arrow-equiv H
    arr-eq .fst = curry-is-equiv
    arr-eq .snd = is-equivâ†qiso curry-cocone-is-equiv

    eqv : is-equiv (cocone-map _ (total-cocone P))
    eqv = is-equivâ†Arrow-equivâ»Â¹ {F = H} arr-eq Pushout-is-pushoutÏ‰áµˆ
}
%```
}


\p{Before introducing the main descent theorem, we need some auxiliary
definitions.}


\subtree[stt-008M]{
\date{2025-08-03}
\title{Maps of spans}
\taxon{theorem}

\p{A map between spans #{S} and #{S'} is a diagram as follows where
all the squares commute:}

\quiver{
\begin{tikzcd}
	A && S && B \\
	\\
	{A'} && {S'} && {B'}
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=1-1]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-3, to=3-3]
	\arrow[from=1-5, to=3-5]
	\arrow[from=3-3, to=3-1]
	\arrow[from=3-3, to=3-5]
\end{tikzcd}
}

\p{Equivalently, a span map is a pair of arrow maps between the
left and right maps of each span, together with a homotopy between
the two maps between the centre of the spans.}

%```agda
\agda{
record Span-map {ğ“¤ ğ“¥ ğ“¦} (S : Span ğ“¤ ğ“¥ ğ“¦)
                {ğ“¤' ğ“¥' ğ“¦'} (S' : Span ğ“¤' ğ“¥' ğ“¦')
                : Type (ğ“¤ âŠ” ğ“¤' âŠ” ğ“¥ âŠ” ğ“¥' âŠ” ğ“¦ âŠ” ğ“¦') where
   constructor mk-span-map
   module S = Span S
   module S' = Span S'
   field
     hâ‚ : S.Left â†’ S'.Left
     hâ‚‚ : S.Centre â†’ S'.Centre
     hâ‚ƒ : S.Right â†’ S'.Right
     H  : hâ‚ âˆ˜ S.left ~ S'.left âˆ˜ hâ‚‚
     K  : hâ‚ƒ âˆ˜ S.right ~ S'.right âˆ˜ hâ‚‚

   amap-lâ†“ : Arrow-map S.left S'.left
   amap-lâ†“ = mk-amap hâ‚‚ hâ‚ H

   amap-l : Arrow-map hâ‚‚ hâ‚
   amap-l = mk-amap S.left S'.left (H ~â»Â¹)

   amap-râ†“ : Arrow-map S.right S'.right
   amap-râ†“ = mk-amap hâ‚‚ hâ‚ƒ K

   amap-r : Arrow-map hâ‚‚ hâ‚ƒ
   amap-r = mk-amap S.right S'.right (K ~â»Â¹)
}
%```
}

\subtree[stt-008N]{
\date{2025-08-03}
\title{Cartesian maps of spans}
\taxon{definition}

\p{A map between spans is said to be cartesian when each square
is [cartesian](stt-003V) (i.e. a pullback square).}

%```agda
\agda{
is-cartesian-span-map
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {ğ“¤' ğ“¥' ğ“¦'} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
    â†’ Span-map S S' â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤' âŠ” ğ“¥' âŠ” ğ“¦')
is-cartesian-span-map F = is-cartesian amap-l Ã— is-cartesian amap-r
  where open Span-map F

is-cartesian-span-map-is-prop
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦}
      {ğ“¤' ğ“¥' ğ“¦'} {S' : Span ğ“¤' ğ“¥' ğ“¦'}
      {F : Span-map S S'}
    â†’ is-prop (is-cartesian-span-map F)
is-cartesian-span-map-is-prop
  = is-prop-Î£
      is-cartesian-is-prop
      (Î» _ â†’ is-cartesian-is-prop)

unquoteDecl Span-map-reprâ‰… Span-map-reprâ‰ƒ
  = make-record-repr Span-map-reprâ‰… Span-map-reprâ‰ƒ (quote Span-map)
}
%```
}


\subtree[stt-008O]{
\date{2025-08-03}
\title{Pulling back squares}
\taxon{construction}

\p{Given span #{S}, and a cocone over #{S} centred at #{X}, we can
\em{'pull this square back'} along any map #{X' \to X}, to obtain a
span #{S'}, a cocone over #{S'} at #{X'} as well as a cartesian map
of spans #{S' \to S}.
}

%```agda
\agda{
module SquarePB {ğ“¤ ğ“¥ ğ“¦ ğ“œ ğ“›} {S : Span ğ“¤ ğ“¥ ğ“¦} {X : Type ğ“œ}
                (C : Cocone S X) {X' : Type ğ“›} (f : X' â†’ X)
                where
  open Span S
  open Cocone C

  S' : Span (ğ“¤ âŠ” ğ“¥ âŠ” ğ“œ âŠ” ğ“›) (ğ“¥ âŠ” ğ“œ âŠ” ğ“›) (ğ“¦ âŠ” ğ“œ âŠ” ğ“›)
  S' .Span.Centre = Pullback {B = Pullback p f} fst left
  S' .Span.Left = Pullback p f
  S' .Span.left  = fst
  S' .Span.Right = Pullback q f
  S' .Span.right ((r , x , H) , c , K) = (right c  , x , sym (sym H âˆ™ ap p K âˆ™ filler c) )

  C' : Cocone S' X'
  C' .Cocone.p = pb.Ï€â‚‚ _ _
  C' .Cocone.q = pb.Ï€â‚‚ _ _
  C' .Cocone.filler _ = refl

  proj : Span-map S' S
  proj .Span-map.hâ‚ = pb.Ï€â‚ _ _
  proj .Span-map.hâ‚‚ = pb.Ï€â‚‚ _ _
  proj .Span-map.hâ‚ƒ = pb.Ï€â‚ q f
  proj .Span-map.H  = pb.filler _ _
  proj .Span-map.K _ = refl

  front-left : Arrow-map (pb.Ï€â‚ p f) f
  front-left = mk-amap (pb.Ï€â‚‚ p f) p (pb.filler p f)

  front-right : Arrow-map (pb.Ï€â‚ q f) f
  front-right = mk-amap (pb.Ï€â‚‚ q f) q (pb.filler _ _)

  front-right-is-cart : is-cartesian (front-right)
  front-right-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  front-left-is-cart : is-cartesian front-left
  front-left-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  amap-lâ†“-is-cart : is-cartesian (Span-map.amap-lâ†“ proj)
  amap-lâ†“-is-cart = is-cartesianâ†is-pullback _ pullback-is-pullback

  amap-l-is-cart : is-cartesian (Span-map.amap-l proj)
  amap-l-is-cart = rotate-is-cartesian _ amap-lâ†“-is-cart

  square~ : Arrow-map-path
              (paste-squares front-left (Span-map.amap-l proj))
              (paste-squares front-right (Span-map.amap-r proj))
  square~ .fst = ~refl
  square~ .snd .fst = filler
  square~ .snd .snd ((l , x' , H) , c , refl)
    = âˆ™-reflr _
    âˆ™ sym (ap (filler c âˆ™_) (âˆ™-symsym (sym H) (filler c))
          âˆ™ symâˆ™ (filler c) (sym (sym H))
          âˆ™ sym-sym)

  proj-is-cartesian : is-cartesian-span-map proj
  proj-is-cartesian .fst = amap-l-is-cart
  proj-is-cartesian .snd = 3-for-2-cartesian square~
    (compose-cartesian front-left-is-cart amap-l-is-cart)
    front-right-is-cart

}
%```
}

\subtree[stt-008Q]{
\title{Maps in #{\rm{Cart}(S)}}

%```agda
\agda{
record Cart {ğ“¤ ğ“¥ ğ“¦} (Sp : Span ğ“¤ ğ“¥ ğ“¦) ğ“œ
         : Type (lsuc (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ)) where
   constructor mk-cart
   field
     S' : Span (ğ“¤ âŠ” ğ“¥ âŠ” ğ“œ) (ğ“¥ âŠ” ğ“œ) (ğ“¦ âŠ” ğ“œ)
     proj : Span-map S' Sp
     has-is-cartesian : is-cartesian-span-map proj

   open Span S' public
   open Span-map proj public


unquoteDecl Cart-reprâ‰… Cart-reprâ‰ƒ
  = make-record-repr Cart-reprâ‰… Cart-reprâ‰ƒ (quote Cart)
}
%```

\p{Given a span #{S} and a pair of cartesian span maps #{S'} and #{S''}
over #{S}, we define the type of maps between #{S'} and #{S''}.
In other words we consider the full subcategory of the slice category
of #{\rm{Span}} consisting of [cartesian span maps](stt-008N).}

\quiver{
\begin{tikzcd}
	&&&& {B'} \\
	&&&&&&&& {B''} \\
	&& {S'} &&&& B \\
	&&&&&& {S''} \\
	{A'} &&&& S \\
	&&&& {A''} \\
	&& A
	\arrow[from=1-5, to=2-9]
	\arrow[from=1-5, to=3-7]
	\arrow[from=2-9, to=3-7]
	\arrow[from=3-3, to=1-5]
	\arrow[from=3-3, to=4-7]
	\arrow[from=3-3, to=5-1]
	\arrow[from=3-3, to=5-5]
	\arrow[from=4-7, to=2-9]
	\arrow[from=4-7, to=5-5]
	\arrow[from=4-7, to=6-5]
	\arrow[from=5-1, to=6-5]
	\arrow[from=5-1, to=7-3]
	\arrow[from=5-5, to=3-7]
	\arrow[from=5-5, to=7-3]
	\arrow[from=6-5, to=7-3]
\end{tikzcd}
}

%```agda
\agda{
module _ {ğ“¤ ğ“¥ ğ“¦} {S : Span ğ“¤ ğ“¥ ğ“¦} where
  Cart-pathâ†’ : âˆ€ {ğ“œ}
              â†’ {C C' : Cart S ğ“œ}
              â†’ (p : C .Cart.S' ï¼ C' .Cart.S')
              â†’ IdP (ap (Î» p â†’ Span-map p S) p)
                    (C .Cart.proj)
                    (C' .Cart.proj)
              â†’ C ï¼ C'
  Cart-pathâ†’ {C = C} {mk-cart S' proj cart} refl refl
    = ap (mk-cart S' proj) (is-cartesian-span-map-is-prop _ _)


  record Cart-map {ğ“œ ğ“} (S' : Cart S ğ“œ) (S'' : Cart S ğ“)
                  : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ âŠ” ğ“) where
    constructor mk-cart-map
    module S' = Cart S'
    module S'' = Cart S''
    field
      map : Span-map (S'.S') (S''.S')

    module map = Span-map map

    field
      hâ‚-comm : S'.hâ‚ ~ S''.hâ‚ âˆ˜ map.hâ‚
      hâ‚‚-comm : S'.hâ‚‚ ~ S''.hâ‚‚ âˆ˜ map.hâ‚‚
      hâ‚ƒ-comm : S'.hâ‚ƒ ~ S''.hâ‚ƒ âˆ˜ map.hâ‚ƒ

  Cart-map-is-equiv
    : âˆ€ {ğ“œ ğ“} {S' : Cart S ğ“œ} {S'' : Cart S ğ“}
      â†’ Cart-map {ğ“œ} {ğ“} S' S'' â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“œ âŠ” ğ“)
  Cart-map-is-equiv F = is-equiv map.hâ‚
                      Ã— is-equiv map.hâ‚‚
                      Ã— is-equiv map.hâ‚ƒ where
    open Cart-map F

  postulate
    Cart-uaâ†’ : âˆ€ {ğ“œ} {S' S'' : Cart S ğ“œ} (F : Cart-map {ğ“œ} {ğ“œ} S' S'')
               â†’ Cart-map-is-equiv F
               â†’ S' ï¼ S''
  -- Cart-uaâ†’ {ğ“œ} F (feq , geq , heq)
    -- = {!!}
    -- = Cart-pathâ†’ {ğ“œ = ğ“œ} {!!} {!!}
}
%```

\p{By the pullback pasting property the span map at the top is
cartesian when the two side maps are.}
}


\subtree[stt-008P]{
\title{Straightening cartesian span maps}
\taxon{lemma}
\citet{2.7}{rijke-2017}

\p{Given a span #{S}, we can define a map #{\rm{Cocone}(C,\UU) \to
\rm{Cart}(S)} - where #{\rm{Cart}(S)} is the type of spans #{S'}
together with a cartesian span map down into #{S}.}

%```agda
\agda{

module _ {ğ“¤ ğ“¥ ğ“¦} {Sp : Span ğ“¤ ğ“¥ ğ“¦}  where
  open Span Sp renaming (Centre to S;
                         left to f;
                         right to g;
                         Left to A;
                         Right to B) using ()


  cartâ†cocone : âˆ€ {ğ“œ} â†’ Cocone Sp (Type ğ“œ) â†’ Cart Sp ğ“œ
  cartâ†cocone cc = mk-cart span proj cart where
    open Cocone cc renaming (p to Pa; q to Pb)

    span : Span _ _ _
    span .Span.Centre = Î£[ apa âˆ¶ (Î£ A Pa) ] Î£[ s âˆ¶ S ] (fst apa ï¼ f s)
    span .Span.Left = Î£ A Pa
    span .Span.left ((.(f s) , pa) , s , refl) = (f s , pa)
    span .Span.Right = Î£ B Pb
    span .Span.right ((_ , pa) , s ,  refl) = (g s , coe (filler s) pa)

    proj : Span-map span Sp
    proj .Span-map.hâ‚ = fst
    proj .Span-map.hâ‚‚ (_ , s , _) = s
    proj .Span-map.hâ‚ƒ = fst
    proj .Span-map.H (s , a , refl) = refl
    proj .Span-map.K (s , a , refl) = refl

    H : âˆ€ s â†’ fib-Ï€â‚‚ fst f s ._â‰ƒ_.fwd
            ~ arrow-fibre (Span-map.amap-l proj) s
    H s ((((a , pa) , (s , refl)) , refl)) = refl

    lmap-eq : âˆ€ s â†’ fibre (pb.Ï€â‚‚ fst f) s â‰ƒ fibre fst (g s)
    lmap-eq s = fib-Ï€â‚‚ fst f s
             âˆ™â‰ƒ fibre-straighten Pa (f s)
             âˆ™â‰ƒ coeâ‰ƒ (filler s)
             âˆ™â‰ƒ fibre-straighten Pb (g s) eâ»Â¹

    K : âˆ€ s â†’ lmap-eq s ._â‰ƒ_.fwd
            ~ arrow-fibre (Span-map.amap-r proj) s
    K s ((((a , pa) , (s , refl)) , refl)) = refl

    cart : is-cartesian-span-map proj
    cart .fst s = homotopy-is-equiv (H s) (fib-Ï€â‚‚ fst f s ._â‰ƒ_.has-is-eqv)
    cart .snd s = homotopy-is-equiv (K s) (lmap-eq s ._â‰ƒ_.has-is-eqv)
}
%```

\p{If the types in the span all live in a univalent unvirse #{\UU},
then this map is an equivalence.}

\proof{
\p{The type #{\rm{Cart}(S)} consists of the data:}

\ul{
\li{A span #{A' \xleftarrow{f} S' \xrightarrow{g} B'}}
\li{Maps #{h_A}, #{h_S}, #{h_B}}
\li{Homotopies #{H} and #{K}, witnessing the two squares involved commute}
\li{Proofs #{p_f} and #{p_g} witnessing that the squares are cartesian}
}

\p{We first note that the tuples #{f, H, p_f} and #{g,K,p_g} are
equivalent to fibrewise equivalences
#{\Pi_{(x : S)} \rm{fib}_{h_s}(x) \simeq \rm{fib}_{h_A}(f(x))} (and
respectively for #{g}). We then also pass #{(A', h_A)}, #{(S', h_S)}
and #{(B',h_B)} accross the straightning/unstraitening equivalences.
Resulting in the following data:}

\ul{
\li{#{Q : S \to \UU}}
\li{#{P_A : A \to \UU}}
\li{#{P_B : B \to \UU}}
\li{#{\Pi_{(x : S)} Q(x) \simeq P_A(f(x))}}
\li{#{\Pi_{(x : S)} Q(x) \simeq P_B(g(x))}}
}

\p{Now, by univalence, the first and last data together are
contractible, and so this is equivalent to the #{S} cocones at #{\UU}.
All that remains is to show that the map underlying this equivalence
is homotopic to the map we had preveously constructed.}
}

%```agda
\agda{
module _ {ğ“¤} {Sp : Span ğ“¤ ğ“¤ ğ“¤}  where
  cartâ†cocone-is-equiv : is-equiv (cartâ†cocone {Sp = Sp} {ğ“¤})
  cartâ†cocone-is-equiv = {!!} where

    open Span Sp renaming (Centre to S;
                           left to f;
                           right to g;
                           Left to A;
                           Right to B) using ()

    bundle-map : âˆ€ {A B : Type ğ“¤} (f : A â†’ B)
                      â†’ Bundle A â†’ Bundle B â†’ Type ğ“¤
    bundle-map f (A' , pa) (B' , pb)
      = Î£[ f' âˆ¶ (A' â†’ B') ] (pb âˆ˜ f' ~ f âˆ˜ pa)

    amapâ†bmap : âˆ€ {A B : Type ğ“¤} (f : A â†’ B)
                      (A' : Bundle A) (B' : Bundle B)
                    â†’ bundle-map f A' B'
                    â†’ Arrow-map
                        (A' .snd)
                        (B' .snd)
    amapâ†bmap f (A' , pa) (B' , pb) (f' , H)
        = mk-amap f' f (H ~â»Â¹)

    is-cartesian-bmap
      : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
        â†’ bundle-map f A' B' â†’ Type ğ“¤
    is-cartesian-bmap {f = f} {(_ , pa)} {(_ , pb)} (f' , H)
      = is-cartesian {f = pa} {f' = pb} (mk-amap f' f (H ~â»Â¹))

    tofib : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
            â†’ (bundle-map f A' B')
            â‰ƒ (âˆ€ b â†’ fibre (A' .snd) b â†’ fibre (B' .snd) (f b))
    tofib {A} {B}{f} {(A' , pa)} {(B' , pb)}
      = equivâ†qiso (mk-iso to (from , ret , sec)) where
      to : _ â†’ _
      to F = arrow-fibre (amapâ†bmap _ _ _ F)

      from : _ â†’ _
      from feq = Î£-Î -swap {X = A'} (Î» _ â†’ B')
                          (Î» a fa â†’ pb fa ï¼ f (pa a))
                          (Î» x â†’ feq (pa x) (x , refl))

      ret : (a : bundle-map f _ (B' , pb)) â†’ (from âˆ˜ to) a ï¼ a
      ret (f , H) = Î£-pathâ†’ (refl , (funextâ†’ (Î» a â†’ âˆ™-reflr _ âˆ™ sym-sym)))

      sec : _
      sec f = funextâ†’ (Î» a â†’ funextâ†’ (Î» where
        (a , refl) â†’ Î£-pathâ†’ (refl , (âˆ™-reflr _ âˆ™ sym-sym))))

    tofibeq : âˆ€ {A B : Type ğ“¤} {f : A â†’ B} {A' : Bundle A} {B' : Bundle B}
            â†’ (Î£[ F âˆ¶ bundle-map f A' B' ] is-cartesian-bmap {f = f}{A'}{B'} F)
            â‰ƒ (âˆ€ b â†’ fibre (A' .snd) b â‰ƒ fibre (B' .snd) (f b))
    tofibeq {A}{B}{f}{(A' , pa)}{(B' , pb)}
      = Î£ (bundle-map f _ (B' , pb)) (is-cartesian-bmap {f = f}{_}{B' , pb})
          â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst tofib âŸ©
        (Î£[ f' âˆ¶ (âˆ€ b â†’ fibre pa b â†’ fibre pb (f b))] is-fibrewise-equiv f')
          â‰ƒâŸ¨ fibrewise-equivâ‰ƒ  âŸ©
        ((b : A) â†’ fibre pa b â‰ƒ fibre pb (f b)) â‰ƒâˆ

    strait-bundle
      : âˆ€ {A B} {f : A â†’ B} (A' : Bundle A)
      â†’ (Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map f A' B') (is-cartesian-bmap {f = f}{A'} {B'}))
      â‰ƒ (Î£[ Q âˆ¶ (B â†’ Type ğ“¤)] (âˆ€ a â†’ fibre (A' . snd) a ï¼ Q (f a)))
    strait-bundle {A}{B}{f} Ab@(A' , pa)
      = (Î£[ B' âˆ¶ (Bundle B) ]
          Î£ (bundle-map f Ab B') (is-cartesian-bmap {f = f}{Ab}{B'}))
          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» bun â†’ tofibeq) âŸ©
        (Î£[ B' âˆ¶ (Bundle B)] (âˆ€ a â†’ fibre pa a â‰ƒ fibre (B' .snd) (f a)))
          â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» Q â†’ âˆ€ a â†’ fibre pa a â‰ƒ Q (f a)} straightenâ‰ƒ âŸ©
        (Î£[ Q âˆ¶ (B â†’ Type ğ“¤)] ((a : A) â†’ fibre pa a â‰ƒ Q (f a)))
          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» Q â†’ precomp-Î -â‰ƒ (Î» c â†’ uaâ‰ƒ)) âŸ©
        Î£ (B â†’ Type ğ“¤) (Î» Q â†’ (a : A) â†’ fibre pa a ï¼ Q (f a)) â‰ƒâˆ

    shuffle : Cart Sp ğ“¤
            â‰ƒ (Î£[ S' âˆ¶ Bundle S ] (
                 (Î£[ A' âˆ¶ Bundle A ] Î£ (bundle-map f S' A') (is-cartesian-bmap {f = f}{S'} {A'}))
                 Ã—
                 (Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map g S' B') (is-cartesian-bmap {f = g}{S'}{B'}))))
    shuffle = mkâ‰ƒ map (is-equivâ†qiso map-qiso) where
      map : Cart Sp ğ“¤ â†’ _
      map (mk-cart
            (mk-span S' f' g')
            (mk-span-map hâ‚ hâ‚‚ hâ‚ƒ H K)
            (pf , pg))
        = (S' , hâ‚‚)
        , ((_ , hâ‚) , ((f' , H) , pf))
        , ((_ , hâ‚ƒ) , ((g' , K) , pg))

      bwd : _ â†’ Cart Sp ğ“¤
      bwd ((S' , hâ‚‚)
          , ((A' , hâ‚) , ((f' , H) , pf))
          , ((B' , hâ‚ƒ) , ((g' , K) , pg)))
          = mk-cart (mk-span S' f' g')
                    (mk-span-map hâ‚ hâ‚‚ hâ‚ƒ H K)
                    (pf , pg)

      map-qiso : quasi-iso map
      map-qiso .fst = bwd
      map-qiso .snd .fst = ~refl
      map-qiso .snd .snd = ~refl

    unshuffle
      : (Î£[ Q âˆ¶ (S â†’ Type ğ“¤)]
          ((Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] (Q ~ Pa âˆ˜ f))
           Ã—
          (Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] (Q ï¼ Pb âˆ˜ g))))
      â‰ƒ Cocone Sp (Type ğ“¤)
    unshuffle = mkâ‰ƒ map (is-equivâ†qiso qiso) where
      map : _ â†’ Cocone Sp (Type ğ“¤)
      map (_ , ((Pa , H) , (Pb , refl)))
        = mk-cocone Pa Pb (sym âˆ˜ H)

      unmap : Cocone Sp (Type ğ“¤) â†’ _
      unmap (mk-cocone p q filler)
        = q âˆ˜ g , ((p , sym âˆ˜ filler) , (q , refl))

      ret : retract-witness map unmap
      ret (S' , (Pb , H) , Pa , refl)
        = Î£-pathâ†’ (refl , Ã—-pathâ†’ ( Î£-pathâ†’ (refl
                                            , (funextâ†’ (Î» _ â†’ sym-sym)))
                                  , refl))

      qiso : quasi-iso map
      qiso .fst = unmap
      qiso .snd .fst = ret
      qiso .snd .snd (mk-cocone p q filler)
        = ap (mk-cocone p q) (funextâ†’ (Î» _ â†’ sym-sym))

    eqv : Cart Sp ğ“¤ â‰ƒ Cocone Sp (Type ğ“¤)
    eqv
      = Cart Sp ğ“¤
          â‰ƒâŸ¨ shuffle âŸ©
        (Î£[ S' âˆ¶ Bundle S ] (
          (Î£[ A' âˆ¶ Bundle A ] Î£ (bundle-map f S' A') (is-cartesian-bmap {f = f}{S'} {A'}))
            Ã—
          (Î£[ B' âˆ¶ Bundle B ] Î£ (bundle-map g S' B') (is-cartesian-bmap {f = g}{S'}{B'}))))
          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» S'
               â†’ strait-bundle S' Ã—â‰ƒ strait-bundle S') âŸ©
        (Î£[ S' âˆ¶ Bundle S ]
          ((Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] ((a : S) â†’ fibre (S' .snd) a ï¼ Pa (f a)))
            Ã—
          (Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] ((a : S) â†’ fibre (S' .snd) a ï¼ Pb (g a)))))
          â‰ƒâŸ¨ Î£-ap-â‰ƒ-fst {B = Î» Q â†’
                        (Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] ((a : S) â†’ Q a ï¼ Pa (f a)))
                          Ã—
                        (Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] ((a : S) â†’ Q a ï¼ Pb (g a)))} straightenâ‰ƒ âŸ©
        (Î£[ Q âˆ¶ (S â†’ Type ğ“¤)]
          ((Î£[ Pa âˆ¶ (A â†’ Type ğ“¤)] ((a : S) â†’ Q a ï¼ Pa (f a)))
           Ã—
          (Î£[ Pb âˆ¶ (B â†’ Type ğ“¤)] ((a : S) â†’ Q a ï¼ Pb (g a)))))
          â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-ap-â‰ƒ (Î» paH â†’ Î£-ap-â‰ƒ (Î» aâ‚ â†’ funextâ‰ƒ eâ»Â¹))) âŸ©
        Î£ (S â†’ Type ğ“¤)
         (Î» Q â†’
            Î£ (A â†’ Type ğ“¤) (Î» Pa â†’ Q ~ Pa âˆ˜ f) Ã—
            Î£ (B â†’ Type ğ“¤) (Î» Pb â†’ Q ï¼ Pb âˆ˜ g))
          â‰ƒâŸ¨ unshuffle âŸ©
        Cocone Sp (Type ğ“¤) â‰ƒâˆ

}
%```
}


\subtree[stt-008L]{
\date{2025-08-03}
\title{Descent for pushouts}
\taxon{theorem}

\p{In the following, let #{S} be a span and #{C} be a cocone over #{S}
centred at #{X}.}

\p{Descent for pushouts states that if this cocone is a pushout, then
the map that takes a type #{X'} and a map #{X' \to X} to a cartesian
map over #{S} is an equivalence.}


%```agda
\agda{
module _ {ğ“¤} {Sp : Span ğ“¤ ğ“¤ ğ“¤} {X : Type ğ“¤}
         (C : Cocone Sp X) (C-po : is-pushoutÏ‰ _ C) where

  cart-map : (Î£[ X' âˆ¶ Type ğ“¤ ] (X' â†’ X)) â†’ Cart Sp ğ“¤
  cart-map (X' , f) = mk-cart S' proj proj-is-cartesian where
    open SquarePB C f


  descent-pushout : is-equiv cart-map
  descent-pushout =  is-equivâ†Arrow-equiv {F = amap} amap-eqv (C-po)
    where

    cmap : âˆ€ (P : X â†’ Type ğ“¤)
           â†’ Cart-map {ğ“¤} {ğ“¤} {ğ“¤} {Sp} {ğ“¤} {ğ“¤}
                      ((cartâ†cocone âˆ˜ cocone-map Sp C) P)
                      ((cart-map âˆ˜ unstraighten) P)
    cmap P = mk-cart-map
      (mk-span-map (pbâ‰ƒ ._â‰ƒ_.fwd)
                   (centreâ‰ƒ ._â‰ƒ_.fwd)
                   (pbâ‰ƒ ._â‰ƒ_.fwd)
                   comm1 comm2)
      ~refl
      ~refl
      ~refl module cmap where
      open Span Sp renaming (Left to A; Right to B; Centre to S)
      open Cocone C

      pbâ‰ƒ : âˆ€ {ğ“ } {A : Type ğ“ } {f : A â†’ X}
              â†’ (Î£[ a âˆ¶ A ] P (f a)) â‰ƒ Pullback f (fst {B = P})
      pbâ‰ƒ {A = A} {f = p} = Î£-ap-â‰ƒ Î» a â†’
          (P (p a))
              â‰ƒâŸ¨ Î£-ï¼singl' eâ»Â¹ âŸ©
          (Î£[ x âˆ¶ X ] ((p a ï¼ x) Ã— P x))
              â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» aâ‚ â†’ Ã—-swap) âŸ©
          (Î£[ x âˆ¶ X ] Î£[ px âˆ¶ P x ] (p a ï¼ x))
            â‰ƒâŸ¨ Î£-assoc eâ»Â¹ âŸ©
          (Î£[ xp âˆ¶ Î£ X P ] (p a ï¼ fst xp)) â‰ƒâˆ

      centreâ‰ƒ :  (Î£[ apa âˆ¶ (Î£ A (P âˆ˜ p))  ] Î£[ s âˆ¶ S ] (fst apa ï¼ left s))
                â‰ƒ Pullback {B = Pullback p (fst {B = P})} (fst) (left)
      centreâ‰ƒ = Î£-ap-â‰ƒ-fst pbâ‰ƒ

      comm1 : _â‰ƒ_.fwd pbâ‰ƒ âˆ˜ Span.left ((cartâ†cocone âˆ˜ cocone-map Sp C) P .Cart.S') ~
               Span.left ((cart-map âˆ˜ unstraighten) P .Cart.S') âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ
      comm1 ((a , p) , s , refl) = refl

      comm2 : _â‰ƒ_.fwd pbâ‰ƒ âˆ˜ Span.right ((cartâ†cocone âˆ˜ cocone-map Sp C) P .Cart.S') ~
               Span.right ((cart-map âˆ˜ unstraighten) P .Cart.S') âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ
      comm2 ((a , p) , s , refl)
        = Î£-pathâ†’
           ( refl
           , Î£-pathâ†’ let p =  Î£-pathâ†’ ((sym (filler s)) , trâˆ™tr-sym (filler s) p)
             in ( p , IdP-funcâ†Square p _ _
               (sym
                 (Î£-path-ap-fst
                 âˆ™ sym (ap (_âˆ™ sym (filler s))
                           (ap-const p))))))

    cmap-is-equiv : âˆ€ (P : X â†’ Type ğ“¤)
                    â†’ Cart-map-is-equiv (cmap P)
    cmap-is-equiv P
      = ( pbâ‰ƒ P .has-is-eqv
        , centreâ‰ƒ P .has-is-eqv
        , pbâ‰ƒ P .has-is-eqv) where
      open cmap
      open _â‰ƒ_

    opaque
      commutes : âˆ€ (P : X â†’ Type ğ“¤)
               â†’ (cartâ†cocone âˆ˜ cocone-map Sp C) P ï¼ (cart-map âˆ˜ unstraighten) P
      commutes P = Cart-uaâ†’ (cmap P) (cmap-is-equiv P)

    amap : Arrow-map (cocone-map _ C) cart-map
    amap = mk-amap unstraighten cartâ†cocone {!commutes!}

    amap-eqv : is-Arrow-equiv amap
    amap-eqv .fst = is-equivâ»Â¹ straighten-is-equiv
    amap-eqv .snd = {!!}
}
%```
}
