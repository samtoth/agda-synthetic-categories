\title{Pushout sum}
\taxon{Module}
\date{2026-01-08}
\author{samueltoth}
\date{2026-02-19}
\author{fredrikbakke}

\import{stt-macros}

%```agda
\agda{
module Core.PushoutSum where

open import ufAxioms

open import Foundations.Prelude
open import Foundations.TypeFamily

open import Core.Arrow
open import Core.CanonicalPushouts
open import Core.FlatteningPushouts
open import Core.Join
open import Core.PushoutEquiv
open import Core.PushoutSumFamilies
open import Core.SpanMap
open import Foundations.TotalEquiv
}
%```


\subtree[fre-0021]{
\taxon{Construction}
\title{Pushout sums of arrows}


\p{
Given an [arrow](fre-0001) #{f : A â†’ B} and a dependent arrow over it
#{g : (b : B) â†’ X\,b â†’ Y\,b}, then we may form the \em{pushout}
#{\hat\Sigma_f g} as the cogap map in the square

\quiver{
\begin{tikzcd}
	((a : A) \times X(f\,a)) && ((a : A) \times Y(f\,a))\\
	& \bullet \\
	((b : B) \times X\,b) && ((b : B) \times Y\,b)
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow[from=1-3, to=2-2]
	\arrow[from=3-1, to=2-2]
	\arrow[dashed, from=2-2, to=3-3, "{\hat\Sigma_f g}"]
	\arrow[phantom, from=1-1, to=2-2, "\ulcorner" very near end]
\end{tikzcd}
}
}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4}
  {A : Type ğ“¤1} {B : Type ğ“¤2} (f : A â†’ B)
  {X : B â†’ Type ğ“¤3} {Y : B â†’ Type ğ“¤4} (g : (b : B) â†’ X b â†’ Y b) where

  Î£Ì‚-left : Î£ A (X âˆ˜ f) â†’ Î£ B X
  Î£Ì‚-left = total-map-fst f

  Î£Ì‚-top : Î£ A (X âˆ˜ f) â†’ Î£ A (Y âˆ˜ f)
  Î£Ì‚-top = total-map (Î» a â†’ g (f a))

  Î£Ì‚-right : Î£ A (Y âˆ˜ f) â†’ Î£ B Y
  Î£Ì‚-right = total-map-fst f

  Î£Ì‚-bot : Î£ B X â†’ Î£ B Y
  Î£Ì‚-bot = total-map g

  Î£Ì‚-square : Arrow-map Î£Ì‚-left Î£Ì‚-right
  Î£Ì‚-square = mk-amap Î£Ì‚-top Î£Ì‚-bot ~refl

  Î£Ì‚ : Pushout Î£Ì‚-left Î£Ì‚-top â†’ Î£ B Y
  Î£Ì‚ = cogap-mapâ†square Î£Ì‚-square
}
%```
}

\subtree[stt-00BS]{
\title{Pushout product}
\taxon{Definition}

\p{
The pushout product is, in a sense, dual to the [pullback power](stt-004D).
Given a pair of maps #{f : A \to B} and #{g : C \to D}, we construct a square of both
orders of mapping from #{A \times C} to #{B \times D}, one component
at a time. The pushout product, written #{f \hat{\otimes} g}, is the cogap
map of this square.
}

\p{
The pushout product is the nondependent case of the [pushout sum](fre-0021).
}

%```agda
\agda{
Product-hom
  : {ğ“¤ ğ“¥ ğ“¦ ğ“œ : Level}
    {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
    {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
  â†’ Arrow-map (f âŠ—1 C) (f âŠ—1 D)
Product-hom f g .Arrow-map.top = _ 1âŠ— g
Product-hom f g .Arrow-map.bot = _ 1âŠ— g
Product-hom f g .Arrow-map.comm = ~refl

pushout-product
  : {ğ“¤ ğ“¥ ğ“¦ ğ“œ : Level}
    {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
    {C : Type ğ“¦} {D : Type ğ“œ} (g : C â†’ D)
  â†’ Pushout (f âŠ—1 C) (A 1âŠ— g) â†’ B Ã— D
pushout-product f g = cogap (Coconeâ†Arrow-map (Product-hom f g) .snd)

infixl 41 _â–¡_
_â–¡_ = pushout-product
}
%```

\p{The pushout product of #{f} with #{g} is sometimes written #{f \hat\otimes g}.}
}


\subtree[fre-0022]{
\taxon{Lemma}
\title{Fibre characterisation of the pushout sum}

\p{
The fibres of #{\hat\Sigma_f g} are given as the fibrewise join of #{f} and #{g}.
Given a pair #{(b , y)} in the codomain of #{\hat\Sigma_f g} then we have

##{\fibre{\hat\Sigma_f g}{(b , y)} â‰ƒ \fibre{f}{b} * \fibre{g\,b}{y}.}
}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 : Level}
  {A : Type ğ“¤1} {B : Type ğ“¤2} (f : A â†’ B)
  {X : B â†’ Type ğ“¤3} {Y : B â†’ Type ğ“¤4} (g : (b : B) â†’ X b â†’ Y b) where

  Î£Ì‚-fibre-fam
    : Fam (ğ“¤2 âŠ” ğ“¤4) (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î£Ì‚-fibre-fam
    = Î£ B Y
    , fibre (Î£Ì‚ f g)

  Î£Ì‚á¶ -unstraight-fibre-fam
    : Fam (ğ“¤2 âŠ” ğ“¤4) (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î£Ì‚á¶ -unstraight-fibre-fam = Î£Ì‚á¶  (fibre-fam f) (fibre-depfam g)

  Î£Ì‚-fibre-family-over
    : (b : B) (y : Y b)
    â†’ Pushout (Î£Ì‚-left f g) (Î£Ì‚-top f g)
    â†’ Type (ğ“¤2 âŠ” ğ“¤4)
  Î£Ì‚-fibre-family-over b y p = (Î£Ì‚ f g p ï¼ (b , y))

  Î£Ì‚-fibre-total-span
    : (b : B) (y : Y b)
    â†’ Span (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4) (ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4) (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤4)
  Î£Ì‚-fibre-total-span b y
    = total-span (Î£Ì‚-left f g) (Î£Ì‚-top f g) (Î£Ì‚-fibre-family-over b y)

  Î£Ì‚-fibre-total-span-left
    : (b : B) â†’ Y b â†’ Type (ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î£Ì‚-fibre-total-span-left b y
    = Span.Left (Î£Ì‚-fibre-total-span b y)

  Î£Ì‚-fibre-total-span-right
    : (b : B) â†’ Y b â†’ Type (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤4)
  Î£Ì‚-fibre-total-span-right b y
    = Span.Right (Î£Ì‚-fibre-total-span b y)

  Î£Ì‚-fibre-total-span-centre
    : (b : B) â†’ Y b â†’ Type (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î£Ì‚-fibre-total-span-centre b y
    = Span.Centre (Î£Ì‚-fibre-total-span b y)

  Î£Ì‚-cogap-fibre-at
    : (b : B) (y : Y b)
    â†’ fibre (Î£Ì‚ f g) (b , y)
    â‰ƒ Pushout
        (Î£Ì‚-fibre-total-span b y .Span.left)
        (Î£Ì‚-fibre-total-span b y .Span.right)
  Î£Ì‚-cogap-fibre-at b y
    = cogap-fibre (Coconeâ†Arrow-map (Î£Ì‚-square f g) .snd) (b , y)

  fibre-Î£Ì‚-rightâ‰ƒfibre-base
    : (b : B) (y : Y b)
    â†’ fibre (Î£Ì‚-right f g) (b , y) â‰ƒ fibre f b
  fibre-Î£Ì‚-rightâ‰ƒfibre-base b y = fibre-total-map-fst f b y

  Î£Ì‚-fibre-total-span-centreâ‰ƒfibrewise-product
    : (b : B) (y : Y b)
    â†’ Î£Ì‚-fibre-total-span-centre b y â‰ƒ (fibre f b Ã— fibre (g b) y)
  Î£Ì‚-fibre-total-span-centreâ‰ƒfibrewise-product b y
    = fibre-map-Î£-over f g b y

  Î£Ì‚-fibre-span-equiv
    : (b : B) (y : Y b)
    â†’ Span-equiv
        (mk-span (fibre f b Ã— fibre (g b) y) snd fst)
        (mk-span
          (Î£Ì‚-fibre-total-span-centre b y)
          (Î£Ì‚-fibre-total-span b y .Span.left)
          (Î£Ì‚-fibre-total-span b y .Span.right))
  Î£Ì‚-fibre-span-equiv b y = span-equiv where
    Spanâ‚€ : Span _ _ _
    Spanâ‚€ = Î£Ì‚-fibre-total-span b y

    Centreâ‚€ : Type (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
    Centreâ‚€ = Spanâ‚€ .Span.Centre

    leftâ‚€ : Centreâ‚€ â†’ Î£Ì‚-fibre-total-span-left b y
    leftâ‚€ = Spanâ‚€ .Span.left

    rightâ‚€ : Centreâ‚€ â†’ Î£Ì‚-fibre-total-span-right b y
    rightâ‚€ = Spanâ‚€ .Span.right

    leftâ‰ƒ : Î£Ì‚-fibre-total-span-left b y â‰ƒ fibre (g b) y
    leftâ‰ƒ = fibre-total-map {f = g} {a = b} {b = y}

    rightâ‰ƒ : Î£Ì‚-fibre-total-span-right b y â‰ƒ fibre f b
    rightâ‰ƒ = fibre-Î£Ì‚-rightâ‰ƒfibre-base b y

    centreâ‰ƒ : Centreâ‚€ â‰ƒ (fibre f b Ã— fibre (g b) y)
    centreâ‰ƒ = Î£Ì‚-fibre-total-span-centreâ‰ƒfibrewise-product b y

    leftâ‚€~left'
      : _â‰ƒ_.bwd leftâ‰ƒ âˆ˜ snd âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ ~ leftâ‚€
    leftâ‚€~left' ((a , x) , p) = fibre-map-Î£-over-left f g b y a x p âˆ™ sym Î± where
      lâ‚€ : Î£Ì‚-fibre-total-span-left b y
      lâ‚€ = (f a , x) , p

      Î²
        : coe (ap (Î£Ì‚-fibre-family-over b y) (sym (glue (a , x)))) p
        ï¼ p
      Î²
        = IdP-const-coe (Î£Ì‚ f g) (sym (glue (a , x))) p
        âˆ™ ap (_âˆ™ p) (ap (ap (Î£Ì‚ f g)) (sym-sym {p = glue (a , x)}))
        âˆ™ ap (_âˆ™ p) (pushout-rec-apÎ² (a , x))
        âˆ™ âˆ™-refll p

      Î± : leftâ‚€ ((a , x) , p) ï¼ lâ‚€
      Î± = Î£-pathâ†’ (refl , Î²)

    rightâ‚€~right'
      : _â‰ƒ_.bwd rightâ‰ƒ âˆ˜ fst âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ ~ rightâ‚€
    rightâ‚€~right' t = _â‰ƒ_.Î· rightâ‰ƒ (rightâ‚€ t)

    left-comm
      : _â‰ƒ_.fwd leftâ‰ƒ âˆ˜ leftâ‚€ ~ snd âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ
    left-comm p
      = sym (ap (_â‰ƒ_.fwd leftâ‰ƒ) (leftâ‚€~left' p))
      âˆ™ _â‰ƒ_.Îµ leftâ‰ƒ (snd (_â‰ƒ_.fwd centreâ‰ƒ p))

    right-comm
      : _â‰ƒ_.fwd rightâ‰ƒ âˆ˜ rightâ‚€ ~ fst âˆ˜ _â‰ƒ_.fwd centreâ‰ƒ
    right-comm p
      = sym (ap (_â‰ƒ_.fwd rightâ‰ƒ) (rightâ‚€~right' p))
      âˆ™ _â‰ƒ_.Îµ rightâ‰ƒ (fst (_â‰ƒ_.fwd centreâ‰ƒ p))

    span-equiv
      : Span-equiv
          (mk-span (fibre f b Ã— fibre (g b) y) snd fst)
          (mk-span Centreâ‚€ leftâ‚€ rightâ‚€)
    span-equiv
      = Span-equivâ†inverse-components
          ( centreâ‰ƒ
          , leftâ‰ƒ
          , left-comm
          , rightâ‰ƒ
          , right-comm)

  Î£Ì‚-fibreâ‰ƒfibrewise-join
    : ((b , y) : Î£ B Y)
    â†’ fibre (Î£Ì‚ f g) (b , y) â‰ƒ fibre f b * fibre (g b) y
  Î£Ì‚-fibreâ‰ƒfibrewise-join (b , y)
    = fibre (Î£Ì‚ f g) (b , y)                  â‰ƒâŸ¨ Î£Ì‚-cogap-fibre-at b y âŸ©
      Pushout
        (Î£Ì‚-fibre-total-span b y .Span.left)
        (Î£Ì‚-fibre-total-span b y .Span.right) â‰ƒâŸ¨ Pushoutâ‰ƒâ†Span-equiv (Î£Ì‚-fibre-span-equiv b y) âˆ™â‰ƒ pushout-comm âŸ©
      (fibre f b * fibre (g b) y)            â‰ƒâˆ

  Î£Ì‚-unstraightenâ‰ƒá¶ 
    : Î£Ì‚-fibre-fam â‰ƒá¶  Î£Ì‚á¶ -unstraight-fibre-fam
  Î£Ì‚-unstraightenâ‰ƒá¶ 
    = idequiv
    , Î£Ì‚-fibreâ‰ƒfibrewise-join
}
%```
}

\subtree[fre-0024]{
\taxon{Theorem}
\title{The equivalence of unstraightened pushout sums}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 : Level}
  (F@(A , B) : Fam ğ“¤1 ğ“¤2)
  (G@(X , Y) : DepFam ğ“¤3 ğ“¤4 F)
  (let fáµ˜ = fst {A = A} {B = B})
  (let gáµ˜ = Î» a â†’ fst {A = X a} {B = Y a})
  (let Fáµ˜ = fibre-fam fáµ˜)
  (let Gáµ˜ = fibre-depfam gáµ˜)
  where

  Î£Ì‚á¶ -fibre-fam-unstraight
    : Fam (ğ“¤1 âŠ” ğ“¤3) (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤4)
  Î£Ì‚á¶ -fibre-fam-unstraight = Î£Ì‚á¶  Fáµ˜ G

  Î£Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ£Ì‚á¶ -fibre-fam-unstraight
    : Î£Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜ â‰ƒá¶  Î£Ì‚á¶ -fibre-fam-unstraight
  Î£Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ£Ì‚á¶ -fibre-fam-unstraight
    = Î£Ì‚á¶ -ap-â‰ƒáµˆá¶  Fáµ˜ Gáµ˜ G (Î» a â†’ (idequiv , fibre-straighten (Y a)))
}
%```
}

\subtree[fre-0026]{
\taxon{Theorem}
\title{The equivalence of straightened pushout sums}

%```agda
\agda{
module _
  {ğ“¤1 ğ“¤2 ğ“¤3 ğ“¤4 : Level}
  (F@(A , B) : Fam ğ“¤1 ğ“¤2)
  (G@(X , Y) : DepFam ğ“¤3 ğ“¤4 F)
  (let fáµ˜ = fst {A = A} {B = B})
  (let gáµ˜ = Î» a â†’ fst {A = X a} {B = Y a})
  (let Fáµ˜ = fibre-fam fáµ˜)
  (let Gáµ˜ = fibre-depfam gáµ˜)
  where

  Î£Ì‚-straight
    : Fam (ğ“¤1 âŠ” ğ“¤3) (ğ“¤1 âŠ” ğ“¤2 âŠ” ğ“¤3 âŠ” ğ“¤4)
  Î£Ì‚-straight = Î£Ì‚-fibre-fam fáµ˜ gáµ˜

  Î£Ì‚-straightâ‰ƒÎ£Ì‚á¶ -unstraight-fibre-fam
    : Î£Ì‚-straight â‰ƒá¶  Î£Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜
  Î£Ì‚-straightâ‰ƒÎ£Ì‚á¶ -unstraight-fibre-fam
    = Î£Ì‚-unstraightenâ‰ƒá¶  fáµ˜ gáµ˜

  Î£Ì‚á¶ -fibre-fam-unstraightâ‰ƒÎ£Ì‚á¶ 
    : Î£Ì‚á¶ -fibre-fam-unstraight F G â‰ƒá¶  Î£Ì‚á¶  F G
  Î£Ì‚á¶ -fibre-fam-unstraightâ‰ƒÎ£Ì‚á¶ 
    = Î£Ì‚á¶ -ap-base-fam G (fibre-straighten B)

  Î£Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ£Ì‚á¶ 
    : Î£Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜ â‰ƒá¶  Î£Ì‚á¶  F G
  Î£Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ£Ì‚á¶ 
    = concatâ‰ƒá¶ 
        (Î£Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜)
        (Î£Ì‚á¶ -fibre-fam-unstraight F G)
        (Î£Ì‚á¶  F G)
        (Î£Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ£Ì‚á¶ -fibre-fam-unstraight F G)
        (Î£Ì‚á¶ -fibre-fam-unstraightâ‰ƒÎ£Ì‚á¶ )

  Î£Ì‚-straightenâ‰ƒá¶  : Î£Ì‚-straight â‰ƒá¶  Î£Ì‚á¶  F G
  Î£Ì‚-straightenâ‰ƒá¶ 
    = concatâ‰ƒá¶ 
        (Î£Ì‚-straight)
        (Î£Ì‚á¶ -unstraight-fibre-fam fáµ˜ gáµ˜)
        (Î£Ì‚á¶  F G)
        (Î£Ì‚-straightâ‰ƒÎ£Ì‚á¶ -unstraight-fibre-fam)
        (Î£Ì‚á¶ -unstraight-fibre-famâ‰ƒÎ£Ì‚á¶ )
}
%```
}
