\date{2025-03-07}
\title{Pushouts}
\author{samueltoth}


\import{stt-macros}

% ```agda
\agda{
module foundations.Pushout where

open import foundations.universe
open import foundations.Functions
open import foundations.Identity
open import foundations.CoherentIsomorphism
open import foundations.EquivSingleton
open import foundations.Singleton
open import foundations.Sigma
}
% ```


\subtree[stt-0015]{
\taxon{definition}

\title{Spans}

\p{
    A span is a diagram of types: #{C \xleftarrow{f} A \xrightarrow{g} B}.
}

% ```agda
\agda{
record Span 𝓤 𝓥 𝓦 : Type (lsuc (𝓤 ⊔ 𝓥 ⊔ 𝓦)) where
  constructor mk-span
  field
    Centre : Type 𝓤
    {Left} : Type 𝓥
    left   : Centre → Left
    {Right} : Type 𝓦
    right : Centre → Right
}
% ```

}

\subtree[stt-0016]{
 \taxon{definition}
 \title{cocone}
 \p{
  Given a span #{s : C \xleftarrow{f} A \xrightarrow{g} B}, and a type #{Q}, we define the type of #{Q}-cocones over #{s} to be the structure with:
   \ul{
     \li{A function #{i : C \to Q}}
     \li{A function #{j : B \to Q}}
     \li{A path #{i \circ f = j \circ g}}
}
}

% ```agda
\agda{
record Cocone  {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) {𝓛} (Carrier : Type 𝓛)
        : Type (lsuc (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛))  where
  constructor mk-cocone
  open Span S
  field
    p       : Left → Carrier
    q       : Right → Carrier
    filler  : p ∘ left ＝ q ∘ right 
}
% ```
}


\subtree[stt-0017]{
  \taxon{definition}
  \title{is-pushout}

  \p{
    Given a span of types #{C \xleftarrow{f} A \xrightarrow{g} B}, we say that a type #{D} is it's pushout if it is the universal cocone. In other words it fits universally into the following commutative diagram:
  }

  \quiver{
  \begin{tikzcd}
	A && B \\
	\\
	C && D \\
        &&& Q
	\arrow["g", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[bend left, from=1-3, to=4-4]
	\arrow[from=3-1, to=3-3]
	\arrow[bend right, from=3-1, to=4-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
	\arrow[dashed, from=3-3, to=4-4]
  \end{tikzcd}
  }

  \p{In the language of type theory, given a cocone #{C}, this can be encoded by requiring
     that the obvious map #{(C \to Q) \to \mathrm{Cocone(Q)}} given by precomposition
     is an equivalence.
  }


% ```agda
\agda{
module _ {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) where
  construct-cocone : ∀ {𝓛 𝓜} {C : Type 𝓛} (C-cc : Cocone S C)
                {Q : Type 𝓜} → (C → Q) → Cocone S Q
  construct-cocone C f .Cocone.p = f ∘ p where open Cocone C
  construct-cocone C f .Cocone.q = f ∘ q where open Cocone C
  construct-cocone C f .Cocone.filler = ap (f ∘_) filler where open Cocone C

  is-pushout : ∀ {𝓛} {C : Type 𝓛} → Cocone S C → Type _
  is-pushout {𝓛} C = ∀ {Q : Type (𝓤 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓛)} → is-equiv (construct-cocone C {Q})
}
% ```
}


\subtree[stt-0018]{
\taxon{theorem}
\title{Uniqueness of pushouts}
\meta{assumes}{Univalence}

\p{Pushouts, like all universal constructions, are unique if they exist. We will show 
that the type of cocones that are pushouts is a subsingleton}

\proof{

% ```agda
\agda{
-- module _ {𝓤 𝓥 𝓦} (S : Span 𝓤 𝓥 𝓦) where
--   pushouts-unique : ∀ {𝓛} → is-subsingleton (Σ[ X ∶ Type 𝓛 ] Σ[ C ∶ Cocone S X ] is-pushout S C)
--   pushouts-unique = {!!}
}
% ```

}
}
