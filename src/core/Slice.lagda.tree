\date{2025-04-20}
\title{Slices of types}
\taxon{module}
\meta{module}{\startverb core.Slice \stopverb}

\import{stt-macros}

\p{
 If we fix a type A, we can consider the slice âˆ-category #{\mathcal{S}/A}
}

% ```agda
\agda{
module core.Slice where

open import foundations.Prelude
}
% ```

% ```agda
\agda{
Slice-map : âˆ€ {ğ“¤} {A : Type ğ“¤}
              {ğ“¥} {B : Type ğ“¥} (p : B â†’ A) {ğ“¦}
              {C : Type ğ“¦} (q : C â†’ A)
              â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦)
Slice-map {B = B} p {C = C} q = Î£[ f âˆ¶ (B â†’ C) ] (q âˆ˜ f ~ p)

Slice-id : âˆ€ {ğ“¤} {A : Type ğ“¤}
             {ğ“¥} {B : Type ğ“¥}
             (p : B â†’ A)
             â†’ Slice-map p p
Slice-id p = id , ~refl             
    
Slice-fibre : âˆ€ {ğ“¤} {A : Type ğ“¤}
              {ğ“¥} {B : Type ğ“¥} {p : B â†’ A}
              {ğ“¦} {C : Type ğ“¦} {q : C â†’ A}
              â†’ Slice-map p q â†’
              (âˆ€ a â†’ fibre p a â†’ fibre q a)
Slice-fibre (f , comm) a (b , fib) = (f b , comm b âˆ™ fib)
}
% ```

\subtree[stt-003D]{
\taxon{theorem}
\title{Equivalence from fibrewise equivalence}

\p{Given a pair of maps #{p : A \to C}, #{q : B \to C}, and a map #{(f , h)} from #{p} to #{q} in the slice
category, then #{f} is an equivalence iff the induced map on fibres is an equivalence.}

\remark{\p{In \lbrack{}[[foundations.FibrewiseEquiv]]\rbrack{}, we showed the straightened
version of this theorem, with type families over a base.}}

\p{In fact, this is just a corollary of the theorem [[stt-0030]], by considering #{\textrm{fib}_{p}}
as a family over #{C}.}

\todo{Find place for baseâ‰ƒtotal-fibres}

% ```agda
\agda{
baseâ†total-fibre : âˆ€ {ğ“¤} {B : Type ğ“¤}
                     {ğ“¥} {A : Type ğ“¥} (p : A â†’ B)
                   â†’ total-fibre p â†’ A
baseâ†total-fibre p (_ , a , _) = a

refl-fibre : âˆ€ {ğ“¤} {B : Type ğ“¤}
               {ğ“¥} {A : Type ğ“¥} (p : A â†’ B)
               â†’ A â†’ total-fibre  p
refl-fibre p a = (p a , a , refl)

baseâ‰ƒtotal-fibre : âˆ€ {ğ“¤} {B : Type ğ“¤}
                     {ğ“¥} {A : Type ğ“¥} (p : A â†’ B)
                   â†’ total-fibre p â‰ƒ A
baseâ‰ƒtotal-fibre {A = A} p = mkâ‰ƒ (baseâ†total-fibre p) (is-equivâ†qiso f-qiso) where

  f-qiso : quasi-iso (baseâ†total-fibre p)
  f-qiso .fst = refl-fibre p
  f-qiso .snd .fst (_ , a , refl) = refl
  f-qiso .snd .snd a = refl


equivâ†on-fibres : âˆ€ {ğ“¤} {C : Type ğ“¤}
                    {ğ“¥} {A : Type ğ“¥} {p : A â†’ C}
                    {ğ“¦} {B : Type ğ“¦} {q : B â†’ C}
                    â†’ (F@(f , h) : Slice-map p q)
                    â†’ (is-fibrewise-equiv (Slice-fibre {p = p} {q = q} F))
                    â†’ is-equiv f
equivâ†on-fibres {p = p} {q = q} (f , h) fw
  = 3-for-2~' (lemma {p = p} {q = q} (f , h))
              ((baseâ‰ƒtotal-fibre p) ._â‰ƒ_.has-is-eqv)
              (is-equiv-âˆ˜ ((baseâ‰ƒtotal-fibre q) ._â‰ƒ_.has-is-eqv)
                          (is-total-equivâ†is-fibrewise-equiv fw)) where        
  lemma : âˆ€ {ğ“¤} {C : Type ğ“¤}
            {ğ“¥} {A : Type ğ“¥} {p : A â†’ C}
            {ğ“¦} {B : Type ğ“¦} {q : B â†’ C}
            (F@(f , _) : Slice-map p q)
            â†’ baseâ†total-fibre q âˆ˜ total-map (Slice-fibre {p = p} {q = q} F)
               ~
             f âˆ˜ baseâ†total-fibre p
  lemma (f , h) a = refl
}
% ```

}
