\date{2025-05-07}
\title{Straightening/unstraightening}
\taxon{module}
\meta{module}{\startverb Foundations.Straightening \stopverb}

\import{stt-macros}

% ```agda
\agda{
module Foundations.Straightening where

open import Foundations.Universes
open import Foundations.Functions
open import Foundations.Sigma
open import Foundations.SigmaPath
open import Foundations.SigmaProperties
open import Foundations.Identity
open import Foundations.DependentIdentity
open import Foundations.QuasiIsomorphism
open import Foundations.CoherentIsomorphism
open import Foundations.Univalence
open import Foundations.FunExt
open import Foundations.FunextUnivalence
open import Foundations.EquivProp
}
% ```

\subtree[stt-003S]{
\taxon{theorem}
\title{Replacement by fibres}

\p{Given a map #{p : E \to B}, the type #{\Sigma_{b} \rm{fib}_{p}(b)}
is equivalent to the base type, #{B}. }

% ```agda
\agda{
base←total-fibre : ∀ {𝓤} {B : Type 𝓤}
                     {𝓥} {A : Type 𝓥} (p : A → B)
                   → total-fibre p → A
base←total-fibre p (_ , a , _) = a

refl-fibre : ∀ {𝓤} {B : Type 𝓤}
               {𝓥} {A : Type 𝓥} (p : A → B)
               → A → total-fibre  p
refl-fibre p a = (p a , a , refl)

base≃total-fibre : ∀ {𝓤} {B : Type 𝓤}
                     {𝓥} {A : Type 𝓥} (p : A → B)
                   → total-fibre p ≃ A
base≃total-fibre {A = A} p = mk≃ (base←total-fibre p) (is-equiv←qiso f-qiso) where
  f-qiso : quasi-iso (base←total-fibre p)
  f-qiso .fst = refl-fibre p
  f-qiso .snd .fst (_ , a , refl) = refl
  f-qiso .snd .snd a = refl
}
% ```

}

\subtree[stt-003Q]{
\title{Straightening}
\taxon{theroem}
\date{2025-08-06}

\p{Under the assumption of univalence, given a base type #{B}, we can
define an equivalence between types \em{over} #{B} (#{\Sigma_{E : \UU} E
\to B}) and type families #{B \to \UU}. The former type is said to be
the \em{unstraightened} version of the later - and
visa-versa. Sometimes, we also call the unstraightened perspective to
be called \em{fibred} and the staightened version \em{indexed}.  }

%```agda
\agda{
module WithUA {𝓤} (UU : is-univalent 𝓤)(FE : FunExt-global) where
  open WithLocalUnivalence UU
  open WithFunExt-global FE

  Bundle : Type 𝓤 → Type (lsuc 𝓤)
  Bundle B = Σ[ E ∶ Type 𝓤 ] (E → B)

  straighten : ∀ {B} → Bundle B → B → Type 𝓤
  straighten (E , p) = fibre p

  unstraighten : ∀ {B} → (B → Type 𝓤) → Bundle B
  unstraighten {B} P = (Σ _ P , fst)


  straighten-qiso : ∀ {B} → quasi-iso (straighten {B})
  straighten-qiso .fst = unstraighten
  straighten-qiso .snd .snd P
    = funext→ (λ b → ua (fibre-straighten P b))
  straighten-qiso .snd .fst (E , p)
    = Σ-path→
      ( ua (base≃total-fibre p)
      , tr-ap1 (ua (base≃total-fibre p)) fst ∙ ap (fst ∘_) (sym-coe-ua)
      )
    where
    tr-ap1 : ∀ {A A' B : Type 𝓤} (p : A ＝ A') f
             → tr (λ A → A → B) p f ＝ λ x → f (coe (sym p) x)
    tr-ap1 refl f = refl

    lem : ∀ {A} → idequiv e⁻¹ ＝ idequiv {𝓤} {A}
    lem = ≃-path→ FE refl

    ua-sym : ∀ {A B} {e : A ≃ B} → sym (ua e) ＝ ua (e e⁻¹)
    ua-sym = equiv-J (λ _ e → sym (ua e) ＝ ua (e e⁻¹))
                     (ap sym (ua-idequiv) ∙ sym (ap ua lem ∙ ua-idequiv))
                     _ _

    sym-coe-ua : ∀ {A B} → {e : A ≃ B} → coe (sym (ua e)) ＝ _≃_.bwd e
    sym-coe-ua {A} {e = e} = ≃-ind (λ _ e → coe (sym (ua e)) ＝ _≃_.bwd e)
                              (λ where .A refl → ap coe ua-sym ∙ coe-ua)
                               _ e

  straighten-is-equiv : ∀ {B} → is-equiv (straighten {B})
  straighten-is-equiv = is-equiv←qiso straighten-qiso

  straighten≃ : ∀ {B} → Bundle B ≃ (B → Type 𝓤)
  straighten≃ = mk≃ _ straighten-is-equiv
}
%```
}
