\date{2025-04-18}
\title{The categrory of maps of types}
\taxon{Module}
\import{stt-macros}

% ```agda
\agda{
{-# OPTIONS --lossy-unification #-}
module Core.Arrow where

open import Foundations.Prelude
open import ufAxioms
open import Ergonomics.Representation
open import Ergonomics.Marker
open import Ergonomics.Extensionality
open import Core.Slice
open import Core.CanonicalPushouts
}
% ```


\subtree[stt-0038]{
\taxon{Definition}
\title{Walking morphisms in #{\mathcal{S}\omega}}

% ```agda
\agda{
record Arrow : TypeÏ‰ where
  constructor mk-arr
  no-eta-equality
  field
    {ğ“¤ ğ“¥} : Level
    {dom} : Type ğ“¤
    {cod} : Type ğ“¥
    f : dom â†’ cod
}
% ```
}

\subtree[stt-003U]{
\taxon{Definition}
\title{Morphisms of arrows}


\p{Given a pair of arrows, we define a morphism between them to be
a commutative square, that is a pair of a maps and a homotopy witnessing
that the square commutes.
}

% ```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B)
         {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} (f' : C â†’ D) where
  record Arrow-map : Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›) where
    constructor mk-amap
    field
      top  : A â†’ C
      bot  : B â†’ D
      comm : bot âˆ˜ f ~ f' âˆ˜ top

  unquoteDecl Arrow-map-reprâ‰… Arrow-map-reprâ‰ƒ
    = make-record-repr Arrow-map-reprâ‰… Arrow-map-reprâ‰ƒ (quote Arrow-map)
}
% ```
}


\subtree[stt-004H]{
\taxon{Theorem}
\date{2025-05-17}
\title{A square is a pullback}

\p{The type #{\Hom(f,g)} is equivalent to the pullback of #{g \circ -} with
#{- \circ f}.}

%```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
         {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} {g : C â†’ D} where

  pullbackâ†arrow : Arrow-map f g â†’ Pullback (g âˆ˜_) (_âˆ˜ f)
  pullbackâ†arrow (mk-amap f g h) = f , g , sym (funextâ†’ h)

  pullbackâ†arrow' : Arrow-map f g â†’ Pullback (_âˆ˜ f) (g âˆ˜_)
  pullbackâ†arrow' (mk-amap f g h) = g , f , funextâ†’ h

  Arrowâ‰ƒpullback : Arrow-map f g â‰ƒ Pullback (g âˆ˜_) (_âˆ˜ f)
  Arrowâ‰ƒpullback
    = Arrow-map f g                      â‰ƒâŸ¨ Arrow-map-reprâ‰ƒ f g âŸ©
      Î£[ k âˆ¶ (A â†’ C) ]
       Î£[ h âˆ¶ (B â†’ D) ] (h âˆ˜ f ~ g âˆ˜ k)  â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» _
                                           â†’ Î£-ap-â‰ƒ Î» _
                                             â†’ (funextâ‰ƒ eâ»Â¹) âˆ™â‰ƒ symâ‰ƒ)  âŸ©
      Pullback (g âˆ˜_) (_âˆ˜ f) â‰ƒâˆ

  Arrowâ‰ƒpullback' : Arrow-map f g â‰ƒ Pullback (_âˆ˜ f) (g âˆ˜_)
  Arrowâ‰ƒpullback'
    = Arrow-map f g                      â‰ƒâŸ¨ Arrow-map-reprâ‰ƒ f g âŸ©
      Î£[ k âˆ¶ (A â†’ C) ]
       Î£[ h âˆ¶ (B â†’ D) ] (h âˆ˜ f ~ g âˆ˜ k)  â‰ƒâŸ¨ Î£-comm âŸ©
      Î£[ k âˆ¶ (B â†’ D) ]
       Î£[ h âˆ¶ (A â†’ C) ] (k âˆ˜ f ~ g âˆ˜ h)  â‰ƒâŸ¨  Î£-ap-â‰ƒ (Î» _
                                           â†’ Î£-ap-â‰ƒ Î» _
                                             â†’ (funextâ‰ƒ eâ»Â¹))  âŸ©
      Pullback (_âˆ˜ f) (g âˆ˜_) â‰ƒâˆ
}
%```
}

\subtree[stt-004I]{
\title{Characterising the path of arrow maps}
\taxon{Theorem}

%```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
         {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} {f' : C â†’ D} where

  Arrow-map-path : âˆ€ (G H : Arrow-map f f') â†’ Type _
  Arrow-map-path (mk-amap t b H) (mk-amap t' b' H')
    = Î£[ p âˆ¶ t ~ t' ] Î£[ q âˆ¶ b ~ b' ]
      (H ~âˆ™ (f' â—‚ p) ~ q â–¸ f ~âˆ™ H')

  Arrow-map-path-refl : {G : Arrow-map f f'} â†’ Arrow-map-path G G
  Arrow-map-path-refl = ~refl , ~refl , ~âˆ™-reflr _

  Arrow-map-path-is-Rppred : âˆ€ (G : Arrow-map f f')
                             â†’ Reflexive-ppred _ G _
  Arrow-map-path-is-Rppred G = (Arrow-map-path G) , Arrow-map-path-refl

  Arrow-map-pathâ†id : âˆ€ {G H : Arrow-map f f'} â†’ (G ï¼ H) â†’ Arrow-map-path G H
  Arrow-map-pathâ†id refl = Arrow-map-path-refl

  opaque
    Arrow-map-pathâ‰ƒ : âˆ€ (G H : Arrow-map f f') â†’ (G ï¼ H) â‰ƒ Arrow-map-path G H
    Arrow-map-pathâ‰ƒ G@(mk-amap t b h) H
      = mkâ‰ƒ Arrow-map-pathâ†id
            (fundamental-Id
              (Arrow-map-path G)
              (is-singleâ†equiv-to-single
                (Î£-ap-â‰ƒ-fst (Arrow-map-reprâ‰ƒ _ _ eâ»Â¹))
                (is-singleton-structureâ†parts (SingS-is-single t)
                  (t , ~refl)
                  (is-singleton-structureâ†parts (SingS-is-single b)
                    (b , ~refl)
                    (SingS-is-single Î» a â†’ h a âˆ™ refl))))
              (Î» _ â†’ Arrow-map-pathâ†id) H)

    Arrow-map-pathâ†’ : âˆ€ {G H : Arrow-map f f'} â†’ Arrow-map-path G H
                      â†’ (G ï¼ H)
    Arrow-map-pathâ†’ = _â‰ƒ_.bwd (Arrow-map-pathâ‰ƒ _ _)

    Arrow-map-pathâ†’-refl : âˆ€ {G : Arrow-map f f'}
                          â†’ Arrow-map-pathâ†’ (Arrow-map-path-refl {G = G}) ï¼ refl
    Arrow-map-pathâ†’-refl
      = unap-equiv (Arrow-map-pathâ‰ƒ _ _ ._â‰ƒ_.has-is-eqv)
                   (is-equiv.Îµ (Arrow-map-pathâ‰ƒ _ _ ._â‰ƒ_.has-is-eqv) _)
}
%```
}

\subtree[stt-003X]{
\taxon{Theorem}
\title{Arrows and squares form a category}

% ```agda
\agda{
id-square : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
            â†’ Arrow-map f f
id-square = mk-amap id id ~refl

module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
         {ğ“¤' ğ“¥'} {A' : Type ğ“¤'} {B' : Type ğ“¥'} {f' : A' â†’ B'}
        {ğ“¤'' ğ“¥''} {A'' : Type ğ“¤''} {B'' : Type ğ“¥''} {f'' : A'' â†’ B''} where
  paste-squares : Arrow-map f' f'' â†’ Arrow-map f f'
                  â†’ Arrow-map f f''
  paste-squares (mk-amap g' h' comm') (mk-amap g h comm)
    = mk-amap (g' âˆ˜ g) (h' âˆ˜ h) (h' â—‚ comm ~âˆ™ comm' â–¸ g)
}
% ```
}

\subtree[stt-003V]{
\taxon{Definition}
\title{Cartesian squares}

\p{Given a map of arrows #{f \to f'}, we can define a family of functions
from the fibre over #{f} to the fibre over #{f'}. If this map is a
fibrewise equivalence, then we say that the square is cartesian (or a pullback
square).
}

% ```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
         {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} {f' : C â†’ D} where
  arrow-fibre :  (gs : Arrow-map f f') â†’
                 âˆ€ (b : B)
                 â†’ fibre f b â†’ fibre f' (gs .Arrow-map.bot b)
  arrow-fibre (mk-amap g g' hom) b (a , p) = (g a , sym (hom a) âˆ™ ap g' p)

  is-cartesian : Arrow-map f f' â†’ Type (ğ“¤ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“›)
  is-cartesian a = is-fibrewise-equiv (arrow-fibre a)

  is-cartesian-is-prop
    : âˆ€ {F : Arrow-map f f'} â†’ is-prop (is-cartesian F)
  is-cartesian-is-prop
    = is-prop-Î  (Î» a â†’ is-equiv-is-prop)
}
% ```
}

\subtree[stt-003W]{
\taxon{Theorem}
\title{Horizontal composition of cartesian squares}

% ```agda
\agda{
module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
         {ğ“¤' ğ“¥'} {A' : Type ğ“¤'} {B' : Type ğ“¥'} {f' : A' â†’ B'}
        {ğ“¤'' ğ“¥''} {A'' : Type ğ“¤''} {B'' : Type ğ“¥''} {f'' : A'' â†’ B''} where


  arrow-fibre-âˆ˜
    : âˆ€ (F : Arrow-map f' f'') (G : Arrow-map f f')
      â†’ âˆ€ b
      â†’ arrow-fibre (paste-squares F G) b
      ~ arrow-fibre F (Arrow-map.bot G b) âˆ˜ arrow-fibre G b
  arrow-fibre-âˆ˜ F@(mk-amap f f' fcomm) G@(mk-amap g g' gcomm) b (a , p)
    = Î£-pathâ†’ (refl , lem) where
       lem : sym (ap f' (gcomm a) âˆ™ fcomm (g a)) âˆ™ ap (f' âˆ˜ g') p ï¼
              sym (fcomm (g a)) âˆ™ ap f' (sym (gcomm a) âˆ™ ap g' p)
       lem = âŒœ sym (ap f' (gcomm a) âˆ™ fcomm (g a)) âŒ âˆ™ ap (f' âˆ˜ g') p
               ï¼âŸ¨ ap! (âˆ™-symsym (ap f' (gcomm a)) _) âŸ©
             (sym (fcomm (g a)) âˆ™ âŒœ sym (ap f' (gcomm a)) âŒ) âˆ™ ap (f' âˆ˜ g') p
               ï¼âŸ¨ ap! (sym (ap-sym f' _)) âŸ©
             (sym (fcomm (g a)) âˆ™ ap f' (sym (gcomm a))) âˆ™ ap (f' âˆ˜ g') p
               ï¼âŸ¨ âˆ™-assoc (sym (fcomm (g a))) _ _ âŸ©
             sym (fcomm (g a)) âˆ™ ap f' (sym (gcomm a)) âˆ™ âŒœ ap (f' âˆ˜ g') p âŒ
               ï¼âŸ¨ ap! (ap-âˆ˜ f' g' p) âŸ©
             sym (fcomm (g a)) âˆ™ âŒœ ap f' (sym (gcomm a)) âˆ™ (ap f' (ap g' p)) âŒ
               ï¼âŸ¨ ap! (sym (ap-âˆ™ f' (sym _) (ap g' p))) âŸ©
             sym (fcomm (g a)) âˆ™ ap f' (sym (gcomm a) âˆ™ ap g' p) âˆ

  compose-cartesian :  âˆ€ {a : Arrow-map f' f''} {b : Arrow-map f f'}
                     â†’ (ae : is-cartesian a) â†’ (be : is-cartesian b)
                     â†’  is-cartesian (paste-squares a b)
  compose-cartesian {a} {b} ae be x
    = tr is-equiv (funextâ†’ (arrow-fibre-âˆ˜ a b x ~â»Â¹))
       (is-equiv-âˆ˜ {f = arrow-fibre a (b .Arrow-map.bot x)} {g = arrow-fibre b x}
         (ae (b .Arrow-map.bot x))
         (be x)) where
    module b = is-equiv (be x)
    module a = is-equiv (ae (b .Arrow-map.bot x))

    open Arrow-map

    II : (x : B) (fib : fibre f x) â†’
       sym (paste-squares a b .Arrow-map.comm (fib .fst)) âˆ™
         ap (paste-squares a b .Arrow-map.bot) (fib .snd)
        ï¼
       (arrow-fibre a (b .Arrow-map.bot x) âˆ˜ arrow-fibre b x)
         fib .snd
    II x (aa , p)
     = sym (paste-squares a b .comm aa) âˆ™ ap (paste-squares a b .bot) p
         ï¼âŸ¨âŸ©
       âŒœ sym (ap (a .bot) (b .comm aa) âˆ™ a .comm (b .top aa)) âŒ âˆ™ ap (a .bot âˆ˜ b .bot) p
         ï¼âŸ¨ ap! (âˆ™-symsym (ap (a .bot) (b .comm aa)) _) âŸ©
       (sym (a .comm (b .top aa)) âˆ™ sym (ap (a .bot) (b .comm aa))) âˆ™ ap (a .bot âˆ˜ b .bot) p
         ï¼âŸ¨ âˆ™-assoc (sym (a .comm (b .top aa))) _ (ap (a .bot âˆ˜ b .bot) p) âŸ©
       sym (a .comm (b .top aa)) âˆ™ âŒœ sym (ap (a .bot) (b .comm aa)) âŒ âˆ™ ap (a .bot âˆ˜ b .bot) p
         ï¼âŸ¨ ap! (sym (ap-sym (a .bot) _)) âŸ©
       sym (a .comm (b .top aa)) âˆ™ ap (a .bot) (sym (b .comm aa)) âˆ™ âŒœ ap (a .bot âˆ˜ b .bot) p âŒ
         ï¼âŸ¨ ap! (ap-âˆ˜ _ _ _) âŸ©
       sym (a .comm (b .top aa)) âˆ™ âŒœ ap (a .bot) (sym (b .comm aa)) âˆ™ ap (a .bot) (ap (b .bot) p) âŒ
         ï¼âŸ¨ ap! (sym (ap-âˆ™ (a .bot) (sym (b .comm aa)) _)) âŸ©
       sym (a .comm (b .top aa)) âˆ™ ap (a .bot) (sym (b .comm aa) âˆ™ ap (b .bot) p)
         ï¼âŸ¨âŸ©
       (arrow-fibre a (b .bot x) âˆ˜ arrow-fibre b x) (aa , p) .snd âˆ


  3-for-2-cartesian : âˆ€ {a : Arrow-map f' f''} {b : Arrow-map f f'}
                        {H : Arrow-map f f''}
                      â†’ Arrow-map-path H (paste-squares a b)
                      â†’ is-cartesian H
                      â†’ is-cartesian a
                      â†’ is-cartesian b
  3-for-2-cartesian {a = F@(mk-amap f f' fcomm)} {b = G@(mk-amap g g' gcomm)}
                    K abcart bcart b
    = 3-for-2~ (arrow-fibre-âˆ˜ F G b)
               (bcart (g' b))
               (tr is-cartesian (Arrow-map-pathâ†’ K) abcart b)
}
% ```
}

\subtree[stt-002Z]{
\taxon{Theorem}
\title{Arrow morphisms are squares}

\p{We now have (at least) three things that can be called squares. We give functions
to convert from arrow-map squares, to either cones over cospans or cocones over spans.}


% ```agda
\agda{
Coconeâ†Arrow-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
                  {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} {f' : C â†’ D}
                â†’ Arrow-map f f' â†’ Î£[ S âˆ¶  Span ğ“¤ ğ“¥ ğ“¦ ] Cocone S D
Coconeâ†Arrow-map {f = f} {f' = f'} (mk-amap g g' comm)
  = (mk-span _ f g) , mk-cocone g' f' comm

Arrow-mapâ†Cocone : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {S : Span ğ“¤ ğ“¥ ğ“¦} {D : Type ğ“œ}
                   â†’ (C : Cocone S D)
                   â†’ Arrow-map (Span.left S) (Cocone.q C)
Arrow-mapâ†Cocone {S = S} C = mk-amap S.right C.p C.filler where
  module S = Span S
  module C = Cocone C

Coneâ†Arrow-map : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
                  {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} {f' : C â†’ D}
                 â†’ Arrow-map f f' â†’ Î£[ S âˆ¶ Cospan ğ“› ğ“¥ ğ“¦ ] Cone S A
Coneâ†Arrow-map {f = f} {f' = f'} (mk-amap top bot comm)
  = (mk-cospan _ bot f') , mk-cone f top comm
}
% ```
}

\subtree[stt-004E]{
\taxon{Defition}

\title{(co)gap maps from squares}

% ```agda
\agda{
gap-mapâ†square : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
                   {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} {f' : C â†’ D}
                 â†’ (g : Arrow-map f f')
                 â†’ A â†’ Pullback (g .Arrow-map.bot) f'
gap-mapâ†square g = gap (Coneâ†Arrow-map g .snd)


cogap-mapâ†square : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
                   {ğ“¦ ğ“›} {C : Type ğ“¦} {D : Type ğ“›} {f' : C â†’ D}
                 â†’ (g : Arrow-map f f')
                 â†’ Pushout f (g .Arrow-map.top) â†’ D
cogap-mapâ†square g = cogap (Coconeâ†Arrow-map g .snd)
}
% ```
}


\subtree[stt-003C]{
\title{Pullback squares from cartesian arrow maps}
\taxon{Theorem}
\p{We show that a [cartesian](stt-003V) arrow map gives a pullback square.
 That is, a square is cartesian iff the corresponding cone is a pullback cone.}

\proof{
\p{Suppose we have a square:}

\quiver{
\begin{tikzcd}
	A && C \\
	\\
	B && D
	\arrow["g", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["{f'}", from=1-3, to=3-3]
	\arrow["{g'}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{such that the map #{\textrm{fib}_{g'}(a) \toeq \textrm{fib}_g(f'(a))} is
an equivalence. Then to verify it is a pullback, then we need
to show that the induced map #{A \to C \times_D B} is also an equivalence.}

\p{We can view both of these maps as living in a slice over #{C}, and a
by [[stt-003D]], a map in the slice is in equivalence iff if is an equivalence
on fibres.}

\quiver{
\begin{tikzcd}
	A && {B \times_D C} \\
	& B
	\arrow["{\textit{gap}}", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=2-2]
	\arrow["{\pi_1}", from=1-3, to=2-2]
\end{tikzcd}
}

\p{So we need to show #{\textrm{fib}_{f}(c) \to \textrm{fib}_{\pi_1}(c)} is
an equivalence. The fibre of the projection is equivalent to the fibre of
#{g} at #{f(c)}, and so by the [3-for-2](foundations.3for2) property of equivalences we
have that the square is a pullback.}

% ```agda
\agda{
is-pullbackâ†is-cartesian : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
  {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
  {C : Type ğ“¦} {D : Type ğ“œ} {f' : C â†’ D}
  â†’ (g : Arrow-map f f')
  â†’ is-cartesian g
  â†’ let (s , c) = Coneâ†Arrow-map g
  in is-pullbackÏ‰ s c
is-pullbackâ†is-cartesian {A = A} {B} {f = f} {C} {D} {f' = f'} G pbsq
  = is-pullbackâ†gap cone (is-equivâ†on-fibres slice-map slice-equiv) where
  cospan = Coneâ†Arrow-map G .fst
  cone = Coneâ†Arrow-map G .snd

  g : A â†’ C
  g = G .Arrow-map.top

  g' : B â†’ D
  g' = G .Arrow-map.bot

  open pb

  slice-map : Slice-map f Ï€â‚
  slice-map .fst = gap cone
  slice-map .snd = ~refl

  lem : {a = b : B} â†’
      arrow-fibre G b ~
      fib-Ï€â‚ g' f' b ._â‰ƒ_.fwd âˆ˜ Slice-fibre (gap cone , ~refl) b
  lem (a , refl) = Î£-pathâ†’ (refl , (âˆ™-reflr _))

  slice-equiv : is-fibrewise-equiv (Slice-fibre {q = Ï€â‚} (gap cone , ~refl))
  slice-equiv b = 3-for-2~ {f = fib-Ï€â‚ g' f' b ._â‰ƒ_.fwd}
                           lem
                           (fib-Ï€â‚ g' f' b ._â‰ƒ_.has-is-eqv)
                           (pbsq b)


is-cartesianâ†is-pullback : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
  {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
  {C : Type ğ“¦} {D : Type ğ“œ} {f' : C â†’ D}
  â†’ (g : Arrow-map f f')
  â†’ let (s , c) = Coneâ†Arrow-map g
  in is-pullbackÏ‰ s c
  â†’ is-cartesian g
is-cartesianâ†is-pullback {f = f} {f' = f'} g pb b
  = homotopy-is-equiv lem
                      (is-equiv-âˆ˜ (fib-Ï€â‚ bot f' b ._â‰ƒ_.has-is-eqv)
                                  (fibre-equivâ†is-equiv slice-map gap-is-equiv b )) where
  open Arrow-map g
  open pb

  cospan = Coneâ†Arrow-map g .fst
  cone = Coneâ†Arrow-map g .snd

  gap-is-equiv : is-equiv (gap (mk-cone f top comm))
  gap-is-equiv = gap-is-equivâ†is-pullback _ pb

  slice-map : Slice-map f Ï€â‚
  slice-map .fst = gap cone
  slice-map .snd = ~refl

  lem : fib-Ï€â‚ bot f' b ._â‰ƒ_.fwd âˆ˜
      Slice-fibre slice-map b
      ~ arrow-fibre g b
  lem (a , refl) = Î£-pathâ†’ (refl , sym (âˆ™-reflr _))


is-cartesianâ†gap-is-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
      {C : Type ğ“¦} {D : Type ğ“œ} {g : C â†’ D}
    â†’ (F : Arrow-map f g)
    â†’ is-equiv (gap (Coneâ†Arrow-map F .snd))
    â†’ is-cartesian F
is-cartesianâ†gap-is-equiv F gap
  = is-cartesianâ†is-pullback F (is-pullbackâ†gap _ gap)
}
% ```
}
}

\subtree[stt-003P]{
\taxon{Definition}
\title{Squares from pre/post-composition}

\p{Given a square of the form:}

\quiver{
\begin{tikzcd}
	A && C \\
	\\
	B && D
	\arrow["g", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["{f'}", from=1-3, to=3-3]
	\arrow["{g'}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{For all types #{Q}, we obtain squares:}

\quiver{
\begin{tikzcd}
	{Q \to A} && {Q \to C} \\
	\\
	{Q \to B} && {Q \to D}
	\arrow["{g \circ -}", from=1-1, to=1-3]
	\arrow["{f \circ -}"', from=1-1, to=3-1]
	\arrow["{f' \circ -}", from=1-3, to=3-3]
	\arrow["{g' \circ -}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{and}

\quiver{
\begin{tikzcd}
	{D \to Q} && {B \to Q} \\
	\\
	{C \to Q} && {A \to Q}
	\arrow["{- \circ g'}", from=1-1, to=1-3]
	\arrow["{- \circ f'}"', from=1-1, to=3-1]
	\arrow["{- \circ f'}", from=1-3, to=3-3]
	\arrow["{- \circ g}"', from=3-1, to=3-3]
\end{tikzcd}
}

% ```agda
\agda{
postcomp-square : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
  {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
  {C : Type ğ“¦} {D : Type ğ“œ} {f' : C â†’ D}
  (g : Arrow-map f f')
  â†’ âˆ€ {ğ“›} (C : Type ğ“›) â†’ Arrow-map (postcomp C f') (postcomp C f)
postcomp-square (mk-amap top bot p) C
 = mk-amap (_âˆ˜ bot) (_âˆ˜ top) Î» f â†’ funextâ†’ (f â—‚ (p ~â»Â¹))

precomp-square : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
  {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
  {C : Type ğ“¦} {D : Type ğ“œ} {f' : C â†’ D}
  (g : Arrow-map f f')
  â†’ âˆ€ {ğ“›} (C : Type ğ“›) â†’ Arrow-map (precomp C f) (precomp C f')
precomp-square (mk-amap top bot p) C
  = mk-amap (top âˆ˜_) (bot âˆ˜_) Î» f â†’ funextâ†’ (p â–¸ f)
}
% ```
}

\remark{
\p{Precomposing squares gives the result of applying the functor
#{Hom(Q,H)} to the square. It is a well known result that this functor preserves
pullback Likewise, postcomposition is given by #{Hom(-,Q)}, and this functor turns
pushouts in to pullbacks.
}
}

\subtree[stt-003R]{
\title{Precomposition of cartesian squares}
\taxon{Theorem}

\p{Given a square of the following form:}

\quiver{
\begin{tikzcd}
	A && C \\
	\\
	B && D
	\arrow["g", from=1-1, to=1-3]
	\arrow["f"', from=1-1, to=3-1]
	\arrow["{f'}", from=1-3, to=3-3]
	\arrow["{g'}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{We show that the square obtained via precomposition
   is cartesian iff the original square is.
}

\proof{

\p{
First note that the type of cones on #{(Q \to B) \to (Q \to D) \leftarrow (Q \to C)}
is equivalent to the canonical pullback of #{B \to D \leftarrow C}. We can construct
the following triangle, and apply the three for two property for equivalences:
}

\quiver{
\begin{tikzcd}
	{(A \to Q)} &&& {(B \to Q)\times_{(C \to Q)} (D \to Q)} \\
	\\
	&& {\textrm{Cone}(f,g)}
	\arrow["{\textit{gap}}", from=1-1, to=1-4]
	\arrow["{\textrm{cone-map}}"', from=1-1, to=3-3]
	\arrow["\sim", from=1-4, to=3-3]
\end{tikzcd}
}

% ```agda
\agda{
unquoteDecl cone-reprâ‰… cone-reprâ‰ƒ
  = make-record-repr cone-reprâ‰… cone-reprâ‰ƒ (quote Cone)

precomp-coneâ‰ƒpb : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
  {A : Type ğ“¤} {B : Type ğ“¥}
  {C : Type ğ“¦} {f : A â†’ B}
  {g : C â†’ B} {D : Type ğ“œ}
  â†’ Cone (mk-cospan B f g) D â‰ƒ Pullback (precomp D f) (precomp D g)
precomp-coneâ‰ƒpb {f = f} {g = g} {D = D}
  = Cone (mk-cospan _ f g) D              â‰ƒâŸ¨ cone-reprâ‰ƒ âŸ©
    Î£[ f' âˆ¶ (D â†’ _) ] Î£[ g' âˆ¶ (D â†’ _) ]
        (precomp D f f' ~ precomp D g g') â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» f' â†’ Î£-ap-â‰ƒ (Î» g' â†’ funextâ‰ƒ eâ»Â¹)) âŸ©
    Pullback (precomp D f) (precomp D g)  â‰ƒâˆ


precomp-cartesian : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ}
  {A : Type ğ“¤} {B : Type ğ“¥} {f : A â†’ B}
  {C : Type ğ“¦} {D : Type ğ“œ} {f' : C â†’ D}
  (g : Arrow-map f f')
  â†’ is-cartesian g
  â†’ âˆ€ {ğ“›} {C : Type ğ“›}
  â†’ is-cartesian
        (precomp-square g C)
precomp-cartesian {A = A} {f = f} {f' = f'} G@(mk-amap g g' H) eq {_} {C}
  = is-cartesianâ†is-pullback _
      (is-pullbackâ†gap (cnâˆ˜ C)
                       (3-for-2
                         {f = _â‰ƒ_.bwd precomp-coneâ‰ƒpb}
                         {g = gap (cnâˆ˜ C)}
                         (_â‰ƒ_.has-is-eqv (precomp-coneâ‰ƒpb eâ»Â¹))
                         (cn-is-pb .is-pullbackÏ‰.has-is-pb C))) where
  cs : Cospan _ _ _
  cs = Coneâ†Arrow-map G .fst

  cn : Cone cs _
  cn = Coneâ†Arrow-map G .snd

  csâˆ˜ : âˆ€ {ğ“ } (Q : Type ğ“ ) â†’ Cospan _ _ _
  csâˆ˜ {ğ“ } Q = Coneâ†Arrow-map (precomp-square G Q) .fst

  cnâˆ˜ : âˆ€ {ğ“ } (Q : Type ğ“ ) â†’ Cone (csâˆ˜ Q) _
  cnâˆ˜ {ğ“ } Q = Coneâ†Arrow-map (precomp-square G Q) .snd

  cn-is-pb : is-pullbackÏ‰ cs cn
  cn-is-pb = is-pullbackâ†is-cartesian G eq

  map : âˆ€ {ğ“ } {Q : Type ğ“ } â†’ (Q â†’ A) â†’ Cone cs Q
  map {_} {Q} = _â‰ƒ_.bwd precomp-coneâ‰ƒpb  âˆ˜ gap (cnâˆ˜ Q)
}
% ```
}
}

%```agda
\agda{
rotate-square : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
                  {C : Type ğ“¦} {D : Type ğ“œ}
                  {f : A â†’ B} {g : C â†’ D}
                â†’ (F : Arrow-map f g)
                â†’ Arrow-map (F .Arrow-map.top) (F .Arrow-map.bot)
rotate-square {f = f} {g = g} F
  = mk-amap f g (F .Arrow-map.comm ~â»Â¹)

rotate-is-cartesian
  : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥}
      {C : Type ğ“¦} {D : Type ğ“œ}
      {f : A â†’ B} {g : C â†’ D}
      (F : Arrow-map f g)
    â†’ is-cartesian F
    â†’ is-cartesian (rotate-square F)
rotate-is-cartesian {f = f} {g} F@(mk-amap top bot comm) fcart
  = is-cartesianâ†gap-is-equiv _
        (is-equiv-âˆ˜ (pullback-swap ._â‰ƒ_.has-is-eqv)
                    (gap-is-equivâ†is-pullback _
                      (is-pullbackâ†is-cartesian _ fcart)))
}
%```

\subtree[stt-00BX]{
\title{The fibre of maps as a cartesian square}
\taxon{Example}

%```agda
\agda{
fibre-square : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) b
             â†’ Arrow-map (! {A = fibre f b}) f
fibre-square f b .Arrow-map.top = fst
fibre-square f b .Arrow-map.bot = const _ ğŸ™ b
fibre-square f b .Arrow-map.comm (x , p) = sym p


fibre-square-is-cartesian : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} (f : A â†’ B) b
                            â†’ is-cartesian (fibre-square f b)
fibre-square-is-cartesian f b = is-cartesianâ†gap-is-equiv _ eq where
  map : fibre f b â†’ Pullback (const _ ğŸ™ b) f
  map (x , p) = (tt , x , sym p)

  eq : is-equiv map
  eq = is-equivâ†qiso ((Î» (_ , x , p) â†’ (x , sym p))
                     , (Î» where (_ , refl) â†’ refl)
                     , Î» where (_ , _ , refl) â†’ refl)
}
%```
}

\subtree[stt-00BR]{
\title{Total squares}
\taxon{Construction}

\p{Given a family of squares, we can define the total square by taking the
sum types and total maps between them.}

%```agda
\agda{
total-square
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ ğ“œ} {I : Type ğ“˜}
      {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥} {f : (i : I) â†’ A i â†’ B i}
      {C : I â†’ Type ğ“¦} {D : I â†’ Type ğ“œ} {g : (i : I) â†’ C i â†’ D i}
    â†’ (F : (i : I) â†’ Arrow-map (f i) (g i))
    â†’ Arrow-map (total-map f) (total-map g)
total-square F .Arrow-map.top = total-map (Arrow-map.top âˆ˜ F)
total-square F .Arrow-map.bot = total-map (Arrow-map.bot âˆ˜ F)
total-square F .Arrow-map.comm (i , a)
  = Î£-pathâ†’ (refl , Arrow-map.comm (F i) a)
}
%```agda
}

\subtree[stt-00BY]{
\title{Dependent precomposition square}
\taxon{Construction}

\p{Given a family of squares #{F_i : f_i \to g_i}, we can form the product square
#{\Pi_i F_i : \Pi_i f_i \to \Pi_i g_i}}

%```agda
\agda{
Î -square
  : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ ğ“œ} {I : Type ğ“˜}
      {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥} {f : (i : I) â†’ A i â†’ B i}
      {C : I â†’ Type ğ“¦} {D : I â†’ Type ğ“œ} {g : (i : I) â†’ C i â†’ D i}
    â†’ (F : (i : I) â†’ Arrow-map (f i) (g i))
    â†’ Arrow-map (precomp-Î  f) (precomp-Î  g)
Î -square F .Arrow-map.top h i = Arrow-map.top (F i) (h i)
Î -square F .Arrow-map.bot h i = Arrow-map.bot (F i) (h i)
Î -square F .Arrow-map.comm h  = funextâ†’ (Î» a â†’ Arrow-map.comm (F a) (h a))
}
%```

\p{#{\Pi_i F_i} is cartesian iff each square #{F_i} is.}

\proof{

\p{We use 3-for-2 in the red triangle of the following diagram:}

\quiver{
\begin{tikzcd}[cramped]
	& {\Pi_i(B_i\times_{D_i}C_i)} \\
	{\Pi_i A_i} &&& {\Pi_iC_i} \\
	& {\Pi_iB_i\times_{\Pi_i D_i}\Pi_i c_i} \\
	\\
	{\Pi_iB_i} &&& {\Pi_iD_i}
	\arrow["\sim"{pos=0.3}, color={rgb,255:red,214;green,92;blue,92}, from=1-2, to=3-2]
	\arrow["{\Pi_i(\textrm{gap})}"{pos=0.3}, color={rgb,255:red,214;green,92;blue,92}, from=2-1, to=1-2]
	\arrow[from=2-1, to=2-4]
	\arrow[color={rgb,255:red,214;green,92;blue,92}, from=2-1, to=3-2]
	\arrow[from=2-1, to=5-1]
	\arrow[from=2-4, to=5-4]
	\arrow[from=3-2, to=2-4]
	\arrow[from=3-2, to=5-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=3-2, to=5-4]
	\arrow[from=5-1, to=5-4]
\end{tikzcd}
}
}

%```agda
\agda{
opaque
  Î -square-is-cartesian
    : âˆ€ {ğ“˜ ğ“¤ ğ“¥ ğ“¦ ğ“œ} {I : Type ğ“˜}
        {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥} {f : (i : I) â†’ A i â†’ B i}
        {C : I â†’ Type ğ“¦} {D : I â†’ Type ğ“œ} {g : (i : I) â†’ C i â†’ D i}
      â†’ (F : (i : I) â†’ Arrow-map (f i) (g i))
      â†’ (âˆ€ i â†’ is-cartesian (F i))
      â†’ is-cartesian (Î -square F)
  Î -square-is-cartesian {I = I} {g = g} F cart
    = is-cartesianâ†gap-is-equiv _ eq where
    curry-pb : Pullback (Arrow-map.bot (Î -square F)) (precomp-Î  g)
          â†’ Î  I (Î» z â†’ Pullback (Arrow-map.bot (F z)) (g z))
    curry-pb (f , g , H) i = (f i , g i , happly H i)

    curry-pb-qiso : quasi-iso curry-pb
    curry-pb-qiso .fst f = (pb.Ï€â‚ âˆ˜ f , pb.Ï€â‚‚ âˆ˜ f , funextâ†’ (pb.filler âˆ˜ f))
    curry-pb-qiso .snd .fst (f , g , p)
      = pullback-pathâ†’ (refl , refl , sym (funext.Î· p) âˆ™ sym (âˆ™-reflr _))
    curry-pb-qiso .snd .snd = ~refl

    eq : is-equiv (gap (Coneâ†Arrow-map (Î -square F) .snd))
    eq = (3-for-2~
            {f = curry-pb}
            {g = gap-mapâ†square (Î -square F)}
            {k = precomp-Î  (Î» i â†’ gap-mapâ†square (F i))}
            ~refl
            (is-equivâ†qiso curry-pb-qiso)
            (precomp-Î -equiv
              (Î» {i} â†’ gap-is-equivâ†is-pullback _
                (is-pullbackâ†is-cartesian _ (cart i)))))
}
%```
}
