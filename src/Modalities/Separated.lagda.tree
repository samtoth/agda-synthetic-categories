\date{2025-06-14}
\title{Separated types}
\author{samueltoth}
\taxon{Module}
\import{stt-macros}

%```agda
\agda{
module Modalities.Separated  where

open import Foundations.Prelude
open import ufAxioms
open import Modalities.Subuniverses
open import Modalities.GlobalSubuniverses
open import Modalities.Instances.Localisation
open import Core.Suspensions
open import Core.Arrow
open import Core.ArrowEquiv
open import Ergonomics.Universal
open import Ergonomics.PushoutUniv
}
%```


\subtree[stt-007E]{
\title{Separated types for a subuniverse}
\taxon{Definition}

\p{A type is separated if it's identity types are modal. This forms a
[(global)](stt-007A) [subuniverse](stt-003Z).}


%```agda
\agda{
is-separated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦) â†’ Type ğ“¤ â†’ Type (ğ“¤ âŠ” ğ“¦)
is-separated S A = âˆ€ (x y : A) â†’ (x ï¼ y) âˆˆ S

separated-SubU : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦) â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“¦)
separated-SubU S .Subtype.family = is-separated S
separated-SubU S .Subtype.has-is-subtype A
  = is-prop-Î  Î» x â†’ is-prop-Î  Î» y â†’ Subtype.has-is-subtype S (x ï¼ y)

equiv-separated : âˆ€ {Î±} (S : GSU Î±) {ğ“¤ ğ“¥} {A : Type ğ“¤}
                    {B : Type ğ“¥} (e : A â‰ƒ B)
                  â†’ is-separated (SubUâ†global S) A
                  â†’ is-separated (SubUâ†global S) B
equiv-separated S e sep x y
  = GSU.S-equiv S
       (embeddingâ‰ƒ (is-embeddingâ†is-equiv
                     (is-equivâ»Â¹ has-is-eqv)) x y)
       (sep (bwd x) (bwd y))
  where
    open _â‰ƒ_ e

separated-GSU : âˆ€ {Î±} (S : GSU Î±) â†’ GSU  (Î» ğ“¤ â†’ ğ“¤ âŠ” Î± ğ“¤)
separated-GSU S .GSU.S = separated-SubU (SubUâ†global S)
separated-GSU S .GSU.S-equiv = equiv-separated S


is-separated-SubU-equiv
  : âˆ€ {ğ“¤ ğ“¥ ğ“¥'} (S : SubU ğ“¤ ğ“¥) (K : SubU ğ“¤ ğ“¥')
      {A : Type ğ“¤}
    â†’ Subtype-equiv S K
    â†’ is-separated S A
    â†’ is-separated K A
is-separated-SubU-equiv _ _ eq sep a b = eq _ .fst (sep a b)
}
%```
}


\subtree[stt-007I]{
\title{Local types are separated}
\taxon{Theorem}

\p{Given a reflective subuniverse #{S},
the #{S}-modal types are also #{S}-separated.}

\todo{
Most of the separated stuff
requires the modified join construction which we don't have yet.
}

%```agda
\agda{
-- is-separatedâ†is-modal
--   : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
--       {A : Type ğ“¤}
--     â†’ A âˆˆ S
--     â†’ A âˆˆ separated-SubU S
-- is-separatedâ†is-modal S as x y
--   = {!!}
}
%```
}

\subtree[stt-007F]{
\title{Separated types and localisations}
\taxon{Theorem}

\p{Given a family of maps #{f_i : A_i \to B_i}, the separated
types with respect to localisation at #{f} are the #{\Sigma(f)}
local types. (Where #{\Sigma(-)} is the functorial action of
the suspension)}


\proof{
\p{We can construct the following commutative diagram:}
\quiver{
\begin{tikzcd}
	{\Sigma_{(x,y : X)} (x = y) ^ {B_i}} && {\Sigma_{(x,y:X)}(x=y)^{A_i}} \\
	\\
	{X^{\Sigma B_i}} && {X^{\Sigma A_i}}
	\arrow["{\textrm{total}((x=y)^f)}", from=1-1, to=1-3]
	\arrow["\sim"', from=1-1, to=3-1]
	\arrow["\sim", from=1-3, to=3-3]
	\arrow["{X^{\Sigma f}}"', from=3-1, to=3-3]
\end{tikzcd}
}

\p{It then follows that postcomposition by #{f} at #{x = y} is an
equivalence iff postcomposition by #{\Sigma(f)} is at #{X}.}
}

%```agda
\agda{
module _ {ğ“˜ ğ“¤ ğ“¥} {I : Type ğ“˜}
         {A : I â†’ Type ğ“¤} {B : I â†’ Type ğ“¥}
         (f : (i : I) â†’ A i â†’ B i) where

  private
    Î£f : (i : I) â†’ Susp (A i) â†’ Susp (B i)
    Î£f i = Susp-map (f i)

  is-separatedâ‡”is-Î£-local
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
    â†’ is-local Î£f X
    â‡” is-separated (Local-SubU f ğ“¤) X
  is-separatedâ‡”is-Î£-local {X = X}
    = ( (Î» loc x y i â†’ topmapâ‡”botmap-is-equiv i .snd (loc i) (x , y))
       , Î» sep i â†’ topmapâ‡”botmap-is-equiv i .fst Î» (x , y) â†’ sep x y i) where
    module _ i where
      topmap : âˆ€ (ab : X Ã— X)
          â†’ (B i â†’ ab .fst ï¼ ab .snd)
          â†’ (A i â†’ ab .fst ï¼ ab .snd)
      topmap (x , y) = postcomp (x ï¼ y) (f i)

      eqvl : (Î£[ ab âˆ¶ (X Ã— X)] (B i â†’ ab .fst ï¼ ab .snd))
           â‰ƒ (Susp (B i) â†’ X)
      eqvl = Î£-assoc âˆ™â‰ƒ (Susp-UPâ‰ƒ eâ»Â¹)

      eqvr : (Susp (A i) â†’ X)
           â‰ƒ (Î£[ ab âˆ¶ (X Ã— X)] (A i â†’ ab .fst ï¼ ab .snd))
      eqvr = Susp-UPâ‰ƒ âˆ™â‰ƒ Î£-assoc eâ»Â¹

      botmap : (Susp (B i) â†’ X) â†’ (Susp (A i) â†’ X)
      botmap = postcomp X (Î£f i)


      F : Arrow-map (total-map topmap) botmap
      F .Arrow-map.top = eqvl ._â‰ƒ_.fwd
      F .Arrow-map.bot = _â‰ƒ_.bwd eqvr
      F .Arrow-map.comm ((x , y) , H) = funextâ†’ (pushout-ind _
        (mk-coconeD
          ~refl
          ~refl
          Î» a â†’ IdP-funcâ†Square (glue a) refl refl
                 ( âˆ™-reflr _
                 âˆ™ pushout-rec-apÎ² a
                 âˆ™ sym (ap-âˆ˜
                        (pushout-rec (mk-cocone (Î» _ â†’ x) (Î» _ â†’ y) H))
                        (pushout-rec (mk-cocone Î¹â‚ Î¹â‚‚ (glue âˆ˜ f i)))
                        (glue a)
                        âˆ™ ap (ap _) (pushout-rec-apÎ² a)
                        âˆ™ pushout-rec-apÎ² (f i a)))))

      F-is-equiv : is-Arrow-equiv F
      F-is-equiv = ( eqvl ._â‰ƒ_.has-is-eqv
                   , is-equivâ»Â¹ (eqvr ._â‰ƒ_.has-is-eqv))

      topmapâ‡”botmap-is-equiv
        : is-fibrewise-equiv topmap â‡” is-equiv botmap
      topmapâ‡”botmap-is-equiv
        =    (fibrewiseâ‡”total-is-equiv â‡”â»Â¹)
          âˆ™â‡” topâ‡”bot-is-equivâ†Arrow-equiv F F-is-equiv

  is-separatedâ†is-Î£-local
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
    â†’ is-local Î£f X
    â†’ is-separated (Local-SubU f ğ“¤) X
  is-separatedâ†is-Î£-local = is-separatedâ‡”is-Î£-local .fst

  is-Î£-localâ†is-separated
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
    â†’ is-separated (Local-SubU f ğ“¤) X
    â†’ is-local Î£f X
  is-Î£-localâ†is-separated = is-separatedâ‡”is-Î£-local .snd
}
%```

\p{Becuase #{\Sigma(-)} [preserves](stt-007J) the unit type, we can
easily derive that #{A}-null separated types are #{\Sigma A}-null.}

%```agda
\agda{
module _ {ğ“˜ ğ“¤} {I : Type ğ“˜} (A : I â†’ Type ğ“¤) where
  is-separatedâ†is-Î£-null
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
      â†’ is-null (Susp âˆ˜ A) X
      â†’ is-separated (Null-SubU A ğ“¤) X
  is-separatedâ†is-Î£-null null
    = is-separated-SubU-equiv (Local-SubU !A _) (Null-SubU A _)
        Nullâ‰ƒ!Local
        (is-separatedâ†is-Î£-local !A
          (is-local-equiv
            (Î» i â†’ Susp-!â»Â¹)
            (Î» _ â†’ Arrowâ»Â¹-is-equiv Susp-! Susp-!-is-equiv)
            (is-localâ†is-null null))) where
      !A : (i : I) â†’ A i â†’ ğŸ™
      !A i _ = tt

  is-Î£-nullâ†is-separated
    : âˆ€ {ğ“¤} {X : Type ğ“¤}
      â†’ is-separated (Null-SubU A ğ“¤) X
      â†’ is-null (Susp âˆ˜ A) X
  is-Î£-nullâ†is-separated sep
    = is-nullâ†is-local
       (is-local-equiv
         (Î» _ â†’ Susp-!)
         (Î» _ â†’ Susp-!-is-equiv)
         (is-Î£-localâ†is-separated
           (Î» _ _ â†’ tt)
           (is-separated-SubU-equiv
             (Null-SubU A _)
             (Local-SubU (Î» i _ â†’ tt) _)
             (_â‡”â»Â¹ âˆ˜ Nullâ‰ƒ!Local)
             sep)))
}
%```
}

\subtree[stt-007H]{
\title{Iterated separation}
\taxon{Definition}

\p{Because the separated types give a (reflective) subuniverse for
each (reflective) subuniverse, we can consider the result of
repeatedly applying separation.
}

%```agda
\agda{
is-n-separated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                 â†’ (n : â„•) â†’ Type ğ“¤
                 â†’ Type (ğ“¤ âŠ” ğ“¦)
is-n-separated {ğ“¤} S zero A = ULift ğ“¤ (A âˆˆ S)
is-n-separated S (suc n) A
  = âˆ€ (x y : A) â†’ is-n-separated S n (x ï¼ y)


mk-is-separated : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                 â†’ (n : â„•) (A : Type ğ“¤)
                 â†’ is-n-separated (separated-SubU S) n A
                 â†’ is-n-separated S (suc n) A
mk-is-separated S zero A (mk-lift sep) x y = mk-lift (sep x y)
mk-is-separated S (suc n) A sep a b
  = mk-is-separated S n (a ï¼ b) (sep a b)


is-n-separated-is-prop
  : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
      (n : â„•) (A : Type ğ“¤)
    â†’ is-prop (is-n-separated S n A)
is-n-separated-is-prop S zero A
  = is-prop-ULift (S .Subtype.has-is-subtype A)
is-n-separated-is-prop S (suc n) A
  = is-prop-Î  Î»
     a â†’ is-prop-Î  Î»
       b â†’ is-n-separated-is-prop S n (a ï¼ b)

n-separated-SubU : âˆ€ {ğ“¤ ğ“¦} (S : SubU ğ“¤ ğ“¦)
                   â†’ (n : â„•) â†’ SubU ğ“¤ (ğ“¤ âŠ” ğ“¦)
n-separated-SubU S n .Subtype.family = is-n-separated S n
n-separated-SubU S n .Subtype.has-is-subtype
  = is-n-separated-is-prop S n

equiv-n-separated
  : âˆ€ {ğ“¤ ğ“¥ Î±} (S : GSU Î±)
      (n : â„•)
      {A : Type ğ“¤} {B : Type ğ“¥}
    â†’ A â‰ƒ B
    â†’ is-n-separated (SubUâ†global S) n A
    â†’ is-n-separated (SubUâ†global S) n B
equiv-n-separated S zero eq (mk-lift sep)
  = mk-lift (S .GSU.S-equiv eq sep)
equiv-n-separated S (suc n) eq sep b b'
  = equiv-n-separated S n
      (mkâ‰ƒ _ (is-embeddingâ†is-equiv
                 (is-equivâ»Â¹ has-is-eqv)) eâ»Â¹)
      (sep (bwd b) (bwd b')) where open _â‰ƒ_ eq


n-separated-GSU : âˆ€ {Î±} (S : GSU Î±)
                  â†’ (n : â„•) â†’ GSU (Î» ğ“¤ â†’ ğ“¤ âŠ” Î± ğ“¤)
n-separated-GSU S n .GSU.S = n-separated-SubU (SubUâ†global S) n
n-separated-GSU S n .GSU.S-equiv = equiv-n-separated S n
}
%```
}
