\date{2025-04-18}
\title{Joins}
\author{samueltoth}
\taxon{Module}

\import{stt-macros}


% ```agda
\agda{
module Core.Join where

open import Foundations.Prelude
open import ufAxioms
open import Core.Suspensions
open import Core.Arrow
open import Core.CocartesianSquare
open import Core.CanonicalPushouts
open import Core.PushoutEquiv
open import Ergonomics.Universal
open import Ergonomics.PushoutUniv
open import Ergonomics.Auto
open import Ergonomics.Extensionality
open import Ergonomics.Marker

}
% ```


\subtree[stt-002S]{
\taxon{Definition}
\title{Joins of types}

\p{The join of types #{A} and #{B}, written #{A * B} is
the pushout of the span
#{A \xleftarrow{\pi_1} A \times B \xrightarrow{pi_2} B}}

\quiver{
\begin{tikzcd}
	{A \times B} && A \\
	\\
	B && {A * B}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-1, to=3-1]
	\arrow[from=1-3, to=3-3]
	\arrow[from=3-1, to=3-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=180}, draw=none, from=3-3, to=1-1]
\end{tikzcd}
}

% ```agda
\agda{
infixl 25 _*_

_*_ : âˆ€ {ğ“¤ ğ“¥} â†’ Type ğ“¤ â†’ Type ğ“¥ â†’ Type (ğ“¤ âŠ” ğ“¥)
A * B = Pushout {A = A Ã— B} fst snd
}
% ```

}


\subtree[stt-002V]{
\title{Singleton joins}

\p{The join of a singleton with any type is also a singleton}

\proof{
\p{This follows from the fact that [pushing an equivalence out gives
an equivalence](stt-0080).}
}

% ```agda
\agda{
*-comm : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥} â†’ A * B â‰ƒ B * A
*-comm {A = A} {B} = pushout-comm âˆ™â‰ƒ (Pushout-adjust-equiv Ã—-swap)


*-single' : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
            â†’ is-singleton B â†’ is-singleton (A * B)
*-single' {A = A} {B} sb
  = is-singleâ†equiv-to-single (mkâ‰ƒ _ Î¹â‚‚-is-equiv) sb where
  Î¹â‚‚-is-equiv : is-equiv {B = A * B} Î¹â‚‚
  Î¹â‚‚-is-equiv = dom-is-equivâ†cocartesian
                  (mk-amap snd Î¹â‚ glue)
                  (singleton-fst-is-equiv (Î» _ â†’ sb))
                  (is-cocartesianâ†is-pushout Pushout-is-pushoutÏ‰)

*-single : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
           â†’ is-singleton A â†’ is-singleton (A * B)
*-single sa
  = is-singleâ†equiv-to-single *-comm (*-single' sa)
}
% ```
}

\subtree[stt-002W]{
\taxon{Theorem}
\title{Joins of propositions}

\p{The universal property for joins of propositions says that
for propositions #{P} and #{Q}, to eliminate into a propositionÂ #{R},
it suffices to supply #{P \to R}, and #{Q \to R}}

\p{As an easy corollary, we have that the join of two propositions
is again a proposition.}

% ```agda
\agda{
*-prop-disj : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
              {Q : Type ğ“¦}
           â†’ is-prop A â†’ is-prop B
           â†’ is-prop Q
           â†’ (A * B â†’ Q) â†’ (A â†’ Q) Ã— (B â†’ Q)
*-prop-disj a b q f = (f âˆ˜ Î¹â‚ , f âˆ˜ Î¹â‚‚)


*-prop-disjâ‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦}
              {A : Type ğ“¤} {B : Type ğ“¥} {Q : Type ğ“¦}
           â†’ (pq : is-prop Q)
           â†’ (A * B â†’ Q) â‰ƒ ((A â†’ Q) Ã— (B â†’ Q))
*-prop-disjâ‰ƒ {A = A} {B} {Q} pq
 = (A * B â†’ Q)
      â‰ƒâŸ¨ Pushout-UPâ‰ƒ âŸ©
   Cocone (mk-span _ fst snd) Q
      â‰ƒâŸ¨ cocone-reprâ‰ƒ âŸ©
   Î£[ f âˆ¶ (A â†’ Q) ] Î£[ g âˆ¶ (B â†’ Q) ] (f âˆ˜ fst ~ g âˆ˜ snd)
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» f â†’ Î£-ap-â‰ƒ (Î» g â†’ curryâ‰ƒ)) âŸ©
   Î£[ f âˆ¶ (A â†’ Q) ] Î£[ g âˆ¶ (B â†’ Q) ] ((a : A) â†’ (b : B) â†’ f a ï¼ g b)
      â‰ƒâŸ¨ Î£-ap-â‰ƒ (Î» a â†’ Î£-singleton (Î» x â†’ is-singleton-Î  Î»
                     b â†’ is-singleton-Î  (Î»
                       c â†’ ï¼-singletonâ†is-prop pq _ _))) âŸ©
   ((A â†’ Q) Ã— (B â†’ Q)) â‰ƒâˆ

*-prop-UP : âˆ€ {ğ“¤ ğ“¥ ğ“¦} {A : Type ğ“¤} {B : Type ğ“¥}
              {Q : Type ğ“¦}
              (ap : is-prop A) (bp : is-prop B)
              (qp : is-prop Q)
            â†’ is-equiv (*-prop-disj ap bp qp)
*-prop-UP ap bp qp = *-prop-disjâ‰ƒ qp ._â‰ƒ_.has-is-eqv

opaque
  *-prop-rec
    : âˆ€ {ğ“¤ ğ“¥ ğ“¦}
        {A : Type ğ“¤} {B : Type ğ“¥} {Q : Type ğ“¦}
      â†’ (pq : is-prop Q)
      â†’ (A â†’ Q) â†’ (B â†’ Q) â†’ (A * B â†’ Q)
  *-prop-rec pq f g = _â‰ƒ_.bwd (*-prop-disjâ‰ƒ pq) (f , g)
{-#Â NOINLINE *-prop-rec #-}

*-is-prop : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} {B : Type ğ“¥}
            â†’ is-prop A â†’ is-prop B
            â†’ is-prop (A * B)
*-is-prop aprop bprop = is-propâ†is-single-if-inhabited
  (*-prop-rec is-single-is-prop
    (Î» a â†’ *-single (mk-singl a (aprop a)))
    (Î» b â†’ *-single' (mk-singl b (bprop b))))
}
% ```

}


\subtree[stt-009U]{
\title{Joins with the empty type}

\p{The join #{A * 0} for any type #{A} is equivalent to #{A}.}

\proof{The map #{A \times 0 \to 0} is an equivalence so by
\ref{stt-008O}, so must #{A \to A * 0}.}

%```agda
\agda{
*-âˆ… : âˆ€ {ğ“¤} {A : Type ğ“¤} â†’ A â‰ƒ âˆ… * A
*-âˆ… = mkâ‰ƒ Î¹â‚‚ (dom-is-equivâ†cocartesian (mk-amap snd Î¹â‚ glue)
             (Ã—-âˆ… ._â‰ƒ_.has-is-eqv) (is-cocartesianâ†is-pushout
                                     Pushout-is-pushoutÏ‰))
}
%```
}

\subtree[stt-009L]{
\title{Functoriality of the join}
\taxon{Theorem}

\p{The join operator on types defines a functor
#{\SS \times \SS \to \SS}. We define the action of #{*} on functions,
and show that it preserves equivalences.}

%```agda
\agda{
_*â‚_ : âˆ€ {ğ“¤ ğ“œ ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“œ}
         {B : Type ğ“¥} {B' : Type ğ“¦}
       â†’ (A â†’ A') â†’ (B â†’ B') â†’ A * B â†’ A' * B'
f *â‚ g = pushout-rec (mk-cocone (Î¹â‚ âˆ˜ f) (Î¹â‚‚ âˆ˜ g) (glue âˆ˜ (f âŠ— g)))

*â‚-is-equiv : âˆ€ {ğ“¤ ğ“œ ğ“¥ ğ“¦} {A : Type ğ“¤} {A' : Type ğ“œ}
                {B : Type ğ“¥} {B' : Type ğ“¦}
              â†’ {f : A â†’ A'} {g : B â†’ B'}
              â†’ is-equiv f â†’ is-equiv g
              â†’ is-equiv (f *â‚ g)
*â‚-is-equiv {A = A}{B = B}{f = f} {g} feq geq = is-equivâ†qiso iso where
  module f = is-equiv feq
  module g = is-equiv geq


  opaque
    sec : âˆ€ a â†’
        Square (ap ((f *â‚ g) âˆ˜ (f.bwd *â‚ g.bwd)) (glue a))
               (ap id (glue a))
               (((Î¹â‚ â—‚ f.Îµ) âˆ˜ fst) a)
               (((Î¹â‚‚ â—‚ g.Îµ) âˆ˜ snd) a)
    sec p@(a , b) = mk-square (
      âŒœ ap ((f *â‚ g) âˆ˜ (f.bwd *â‚ g.bwd)) (glue p) âŒ âˆ™ ((Î¹â‚‚ â—‚ g.Îµ) b)
                                    ï¼âŸ¨ ap! (ap-âˆ˜ _ _ (glue p)) âŸ©
      ap (f *â‚ g) âŒœ ap (f.bwd *â‚ g.bwd) (glue p) âŒ âˆ™ ((Î¹â‚‚ â—‚ g.Îµ) b)
                                    ï¼âŸ¨ ap! (pushout-rec-apÎ² p) âŸ©
      âŒœ ap (f *â‚ g) (glue (f.bwd a , g.bwd b)) âŒ âˆ™ ((Î¹â‚‚ â—‚ g.Îµ) b)
                                    ï¼âŸ¨ ap! (pushout-rec-apÎ² ((f.bwd âŠ— g.bwd) p)) âŸ©
      (glue âˆ˜ (f âŠ— g) âˆ˜ (f.bwd âŠ— g.bwd)) p âˆ™ (âŒœ Î¹â‚‚ â—‚ g.Îµ â–¸ snd âŒ) p
                                    ï¼âŸ¨ ap! ( sym (ap-âˆ˜ Î¹â‚‚ snd (Ã—-pathâ†’ (f.Îµ a , g.Îµ b))
                                            âˆ™ ap (ap Î¹â‚‚) Ã—-path-ap-snd)) âŸ©
      ((glue âˆ˜ (f âŠ— g) âˆ˜ (f.bwd âŠ— g.bwd)) ~âˆ™ (Î¹â‚‚ âˆ˜ snd â—‚ Ã—~ (f.Îµ , g.Îµ))) p
                                    ï¼âŸ¨âŸ©
      (glue ~âˆ˜ Ã—~ (f.Îµ , g.Îµ)) p    ï¼âŸ¨ switch-~âˆ˜ glue (Ã—~ (f.Îµ , g.Îµ)) p âŸ©
      (glue ~âˆ˜' Ã—~ (f.Îµ , g.Îµ)) p   ï¼âŸ¨ ap (_âˆ™ glue p) (ap-âˆ˜ Î¹â‚ fst (Ã—~ (f.Îµ , g.Îµ) p)) âŸ©
       ((Î¹â‚ â—‚ fst â—‚ Ã—~ (f.Îµ , g.Îµ)) ~âˆ™ glue) p
                                    ï¼âŸ¨ ap (Î» x â†’ (ap Î¹â‚ x) âˆ™ glue p) Ã—-path-ap-fst âŸ©
      ap Î¹â‚ (f.Îµ a) âˆ™ âŒœ glue p âŒ    ï¼âŸ¨ ap! (sym (ap-id (glue p))) âŸ©
      ap Î¹â‚ (f.Îµ a) âˆ™ ap id (glue p) âˆ)

    -- I wanted to generalise sec, and then give f.bwd and g.bwd
    -- but because is-equivâ»Â¹ goes via composing quasi-inverses it
    -- messes with the Îµ
    ret : âˆ€ a â†’
        Square (ap ((f.bwd *â‚ g.bwd) âˆ˜ (f *â‚ g)) (glue a))
               (ap id (glue a))
               (((Î¹â‚ â—‚ f.Î·) âˆ˜ fst) a)
               (((Î¹â‚‚ â—‚ g.Î·) âˆ˜ snd) a)
    ret p@(a , b) = mk-square (
        âŒœ ap ((f.bwd *â‚ g.bwd) âˆ˜ (f *â‚ g)) (glue p) âŒ âˆ™ ((Î¹â‚‚ â—‚ g.Î·) b)
                                      ï¼âŸ¨ ap! (ap-âˆ˜ _ _ (glue p)) âŸ©
        ap (f.bwd *â‚ g.bwd) âŒœ ap (f *â‚ g) (glue p) âŒ âˆ™ ((Î¹â‚‚ â—‚ g.Î·) b)
                                      ï¼âŸ¨ ap! (pushout-rec-apÎ² p) âŸ©
        âŒœ ap (f.bwd *â‚ g.bwd) (glue (f a , g b)) âŒ âˆ™ ((Î¹â‚‚ â—‚ g.Î·) b)
                                      ï¼âŸ¨ ap! (pushout-rec-apÎ² ((f âŠ— g) p)) âŸ©
        (glue âˆ˜ (f.bwd âŠ— g.bwd) âˆ˜ (f âŠ— g)) p âˆ™ (âŒœ Î¹â‚‚ â—‚ g.Î· â–¸ snd âŒ) p
                                      ï¼âŸ¨ ap! ( sym (ap-âˆ˜ Î¹â‚‚ snd (Ã—-pathâ†’ (f.Î· a , g.Î· b))
                                              âˆ™ ap (ap Î¹â‚‚) Ã—-path-ap-snd)) âŸ©
        ((glue âˆ˜ (f.bwd âŠ— g.bwd) âˆ˜ (f âŠ— g)) ~âˆ™ (Î¹â‚‚ âˆ˜ snd â—‚ Ã—~ (f.Î· , g.Î·))) p
                                      ï¼âŸ¨âŸ©
        (glue ~âˆ˜ Ã—~ (f.Î· , g.Î·)) p    ï¼âŸ¨ switch-~âˆ˜ glue (Ã—~ (f.Î· , g.Î·)) p âŸ©
        (glue ~âˆ˜' Ã—~ (f.Î· , g.Î·)) p   ï¼âŸ¨ ap (_âˆ™ glue p) (ap-âˆ˜ Î¹â‚ fst (Ã—~ (f.Î· , g.Î·) p)) âŸ©
         ((Î¹â‚ â—‚ fst â—‚ Ã—~ (f.Î· , g.Î·)) ~âˆ™ glue) p
                                      ï¼âŸ¨ ap (Î» x â†’ (ap Î¹â‚ x) âˆ™ glue p) Ã—-path-ap-fst âŸ©
        ap Î¹â‚ (f.Î· a) âˆ™ âŒœ glue p âŒ    ï¼âŸ¨ ap! (sym (ap-id (glue p))) âŸ©
        ap Î¹â‚ (f.Î· a) âˆ™ ap id (glue p) âˆ)

  iso : quasi-iso (f *â‚ g)
  iso .fst = f.bwd *â‚ g.bwd
  iso .snd .fst = pushout-ind _ (mk-coconeD (Î¹â‚ â—‚ f.Î·) (Î¹â‚‚ â—‚ g.Î·)
                    Î» a â†’ IdP-funcâ†Square
                           {f = (f.bwd *â‚ g.bwd) âˆ˜ (f *â‚ g)}
                           {id} (glue a)
                           (ap Î¹â‚ (f.Î· (fst a))) ((Î¹â‚‚ â—‚ g.Î·) (snd a))
                           (ret a))
  iso .snd .snd = pushout-ind _ (mk-coconeD (Î¹â‚ â—‚ f.Îµ) (Î¹â‚‚ â—‚ g.Îµ)
                   (Î» a â†’  IdP-funcâ†Square {f = (f *â‚ g) âˆ˜ (f.bwd *â‚ g.bwd)} {id}
                               (glue a) _ _
                               (sec a)))

*-â‰ƒ : âˆ€ {ğ“¤ ğ“¥ ğ“¦ ğ“œ} {A : Type ğ“¤} {B : Type ğ“¥} {C : Type ğ“¦} {D : Type ğ“œ}
      â†’ A â‰ƒ C â†’ B â‰ƒ D â†’ A * B â‰ƒ C * D
*-â‰ƒ (mkâ‰ƒ l le) (mkâ‰ƒ r re)
  = mkâ‰ƒ (l *â‚ r) (*â‚-is-equiv le re)
}
%```
}
