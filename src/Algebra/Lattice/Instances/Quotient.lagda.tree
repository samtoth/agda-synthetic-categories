\title{Quotients of a lattice}
\taxon{Module}
\author{markwilliams}
\date{2025-10-24}
\import{stt-macros}

%```agda
\agda{
{-# OPTIONS --lossy-unification #-}

open import Foundations.Prelude
open import ufAxioms
open import Core.Coequalisers

open import Modalities.Instances.Truncation
open import Algebra.Lattice

open import Ergonomics.Universal
open import Ergonomics.Extensionality

module Algebra.Lattice.Instances.Quotient where


is-reflexive : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (R : A â†’ A â†’ Type ğ“¥) â†’ Type (ğ“¤ âŠ” ğ“¥)
is-reflexive R = âˆ€ x â†’ R x x

equiv-classes : âˆ€ {ğ“¤ ğ“¥} {A : Type ğ“¤} (R : A â†’ A â†’ Type ğ“¥) â†’ Type (ğ“¤ âŠ” ğ“¥)
equiv-classes {A = A} R = Î£ A (Î» x â†’ Î£ A (R x))

_/_ : âˆ€ {ğ“¤ ğ“¥} (A : Type ğ“¤) (R : A â†’ A â†’ Type ğ“¥) â†’ Type (ğ“¤ âŠ” ğ“¥)
X / R = Trunc 2 (Coeq {A = equiv-classes R} (fst) (fst âˆ˜ snd))

module _ {ğ“¤ ğ“¥} {A : Type ğ“¤} {R : A â†’ A â†’ Type ğ“¥} where
  Î¹-quot : A â†’ A / R
  Î¹-quot a = Trunc.Î· (Î¹-coeq a)

  quot : (x : equiv-classes R ) â†’ Î¹-quot (fst x) ï¼ Î¹-quot (fst (snd x))
  quot = ap Trunc.Î· âˆ˜ glue-coeq

  glue-quot : {x y : A} (r : R x y) â†’ Î¹-quot x ï¼ Î¹-quot y
  glue-quot {x} {y} r = quot (x , (y , r))

  Quot-elim : âˆ€ {ğ“¦} {B : A / R  â†’ Type ğ“¦}
            â†’ â¦ƒ âˆ€ { x } â†’ Is-truncated 2 (B x) â¦„
            â†’ (f : âˆ€ x â†’ B (Î¹-quot x))
            â†’ (âˆ€ a â†’ IdP (ap B (quot a)) (f (fst a)) (f (fst (snd a)))  )
            â†’ âˆ€ x â†’ B x
  Quot-elim {B = B} f p =
    Trunc.ind (Î» _ â†’ trunc!) (coeq-ind (f , Î» a â†’
                             ap (Î» h â†’ coe  h (f (fst a)))
                             ((ap-âˆ˜ B Trunc.Î· ) (glue-coeq a))  âˆ™  p a))
  Quot-rec : âˆ€ {ğ“¦} {B : Type ğ“¦}
           â†’ â¦ƒ Is-truncated 2 B â¦„
           â†’ (f : A â†’ B)
           â†’ (âˆ€ (x : equiv-classes R) â†’ f (fst x) ï¼ f (fst (snd x)))
           â†’ A / R â†’ B
  Quot-rec f p = Trunc.ind (Î» _ â†’ trunc!) (coeq-rec (f , p))

  Quot-recâ‚‚ : âˆ€ {ğ“¦} {B : Type ğ“¦}
           â†’ â¦ƒ Is-truncated 2 B â¦„
           â†’ (f : A â†’ A â†’ B)
           â†’ (âˆ€ (x : equiv-classes R) y â†’ f (fst x) y ï¼ f (fst (snd x)) y)
           â†’ (âˆ€ x (y : equiv-classes R)  â†’ f x (fst y) ï¼ f x (fst (snd y)))
           â†’ A / R â†’ A / R â†’ B
  Quot-recâ‚‚ f p q  = Trunc.ind (Î» _ â†’ trunc!)
                       Î» x â†’ Trunc.ind (Î» _ â†’ trunc!)
                         Î» y â†’ coeq-recâ‚‚ f p q
                                         (Î» _ _ â†’  (is-setâ†is-truncated trunc! _ _) _ _)  x y


module _ {ğ“¤ ğ“¥} (A : Type ğ“¤) {L : Lattice A} (R : A â†’ A â†’ Type ğ“¥) {C : LatticeCongruence L R} where
  open Lattice L
  open LatticeCongruence C

  QuotLattice :  Lattice (A / R)
  QuotLattice .Lattice.0l = Î¹-quot 0l
  QuotLattice .Lattice.1l = Î¹-quot 1l
  QuotLattice .Lattice._âˆ§_ = Quot-recâ‚‚ (Î» x y â†’ Î¹-quot (x âˆ§ y))
                                       (Î» where (x , (y , r)) z â†’ glue-quot (~-âˆ§ r reflexive))
                                       (Î» where x (y , (z , r)) â†’ glue-quot (~-âˆ§ reflexive r))
  QuotLattice .Lattice._âˆ¨_ =  Quot-recâ‚‚ (Î» x y â†’ Î¹-quot (x âˆ¨ y))
                                        (Î» where (x , (y , r)) z â†’ glue-quot (~-âˆ¨ r reflexive))
                                        (Î» where x (y , (z , r)) â†’ glue-quot (~-âˆ¨ reflexive r))
 

  QuotLattice .Lattice.str-is-lattice .is-lattice.car-is-set = trunc!
  QuotLattice .Lattice.str-is-lattice .is-lattice.âˆ§-assoc {x} {y} {z} =  {!!}
  QuotLattice .Lattice.str-is-lattice .is-lattice.âˆ¨-assoc = {!!}
  QuotLattice .Lattice.str-is-lattice .is-lattice.âˆ§-comm = {!!}
  QuotLattice .Lattice.str-is-lattice .is-lattice.âˆ¨-comm = {!!}
  QuotLattice .Lattice.str-is-lattice .is-lattice.âˆ¨-âˆ§-abs = {!!}
  QuotLattice .Lattice.str-is-lattice .is-lattice.âˆ§-âˆ¨-abs = {!!}
  QuotLattice .Lattice.str-is-lattice .is-lattice.0-bottom = {!!}
  QuotLattice .Lattice.str-is-lattice .is-lattice.1-top = {!!}

}
%```
